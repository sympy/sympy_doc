
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solveset &#8212; SymPy 1.7.dev documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/solvers/solveset.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Stats" href="../stats.html" />
    <link rel="prev" title="Solvers" href="solvers.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../stats.html" title="Stats"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="solvers.html" title="Solvers"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">SymPy Modules Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solveset</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="solveset">
<span id="id1"></span><h1>Solveset<a class="headerlink" href="#solveset" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sympy.solvers.solveset"></span><p>This is the official documentation of the <code class="docutils literal notranslate"><span class="pre">solveset</span></code> module in solvers.
It contains the frequently asked questions about our new module to solve
equations.</p>
<div class="section" id="what-s-wrong-with-solve">
<h2>What’s wrong with solve():<a class="headerlink" href="#what-s-wrong-with-solve" title="Permalink to this headline">¶</a></h2>
<p>SymPy already has a pretty powerful <code class="docutils literal notranslate"><span class="pre">solve</span></code> function. But it has a lot of major
issues</p>
<ol class="arabic simple">
<li><p>It doesn’t have a consistent output for various types of solutions
It needs to return a lot of types of solutions consistently:</p>
<ul class="simple">
<li><p>Single solution : <span class="math notranslate nohighlight">\(x = 1\)</span></p></li>
<li><p>Multiple solutions: <span class="math notranslate nohighlight">\(x^2 = 1\)</span></p></li>
<li><p>No Solution: <span class="math notranslate nohighlight">\(x^2 + 1 = 0 ; x \in \mathbb{R}\)</span></p></li>
<li><p>Interval of solution: <span class="math notranslate nohighlight">\(\lfloor x \rfloor = 0\)</span></p></li>
<li><p>Infinitely many solutions: <span class="math notranslate nohighlight">\(sin(x) = 0\)</span></p></li>
<li><p>Multivariate functions with point solutions: <span class="math notranslate nohighlight">\(x^2 + y^2 = 0\)</span></p></li>
<li><p>Multivariate functions with non-point solution: <span class="math notranslate nohighlight">\(x^2 + y^2 = 1\)</span></p></li>
<li><p>System of equations: <span class="math notranslate nohighlight">\(x + y = 1\)</span> and <span class="math notranslate nohighlight">\(x - y = 0\)</span></p></li>
<li><p>Relational: <span class="math notranslate nohighlight">\(x &gt; 0\)</span></p></li>
<li><p>And the most important case: “We don’t Know”</p></li>
</ul>
</li>
<li><p>The input API is also a mess, there are a lot of parameters. Many of them
are not needed and they make it hard for the user and the developers to
work on solvers.</p></li>
<li><p>There are cases like finding the maxima and minima of function using
critical points where it is important to know if it has returned all the
solutions. <code class="docutils literal notranslate"><span class="pre">solve</span></code> does not guarantee this.</p></li>
</ol>
</div>
<div class="section" id="why-solveset">
<h2>Why Solveset?<a class="headerlink" href="#why-solveset" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">solveset</span></code> has a cleaner input and output interface: <code class="docutils literal notranslate"><span class="pre">solveset</span></code> returns
a set object and a set object takes care of all types of output. For
cases where it doesn’t “know” all the solutions a <code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> with a partial
solution is returned. For input it only takes the equation, the variables
to solve for and the optional argument <code class="docutils literal notranslate"><span class="pre">domain</span></code> over which the equation is to
be solved.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">solveset</span></code> can return infinitely many solutions. For example solving for
<span class="math notranslate nohighlight">\(\sin{(x)} = 0\)</span> returns <span class="math notranslate nohighlight">\(\{2 n \pi | n \in \mathbb{Z}\} \cup \{2 n \pi + \pi | n \in \mathbb{Z}\}\)</span>,
whereas <code class="docutils literal notranslate"><span class="pre">solve</span></code> only returns <span class="math notranslate nohighlight">\([0, \pi]\)</span>.</p></li>
<li><p>There is a clear code level and interface level separation between solvers
for equations in the complex domain and the real domain. For example
solving <span class="math notranslate nohighlight">\(e^x = 1\)</span> when <span class="math notranslate nohighlight">\(x\)</span> is to be solved in the complex domain, returns
the set of all solutions, that is <span class="math notranslate nohighlight">\(\{2 n i \pi | n \in \mathbb{Z}\}\)</span>, whereas
if <span class="math notranslate nohighlight">\(x\)</span> is to be solved in the real domain then only <span class="math notranslate nohighlight">\(\{0\}\)</span> is returned.</p></li>
</ul>
</div>
<div class="section" id="why-do-we-use-sets-as-an-output-type">
<h2>Why do we use Sets as an output type?<a class="headerlink" href="#why-do-we-use-sets-as-an-output-type" title="Permalink to this headline">¶</a></h2>
<p>SymPy has a well developed sets module, which can represent most of the set
containers in Mathematics such as:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">FiniteSet</span></code></p>
<p>Represents a finite set of discrete numbers.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Interval</span></code></p>
<p>Represents a real interval as a set.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ProductSet</span></code></p>
<p>Represents a Cartesian product of sets.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ImageSet</span></code></p>
<p>Represents the image of a set under a mathematical function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ImageSet</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="n">ImageSet</span><span class="p">(</span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Naturals</span><span class="p">)</span>  <span class="c1"># {x**2 for x in N}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="ow">in</span> <span class="n">squares</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ComplexRegion</span></code></p>
<p>Represents the set of all complex numbers in a region in the Argand plane.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code></p>
<p>Represents the set of elements, which satisfies a given condition.</p>
</li>
</ul>
</div></blockquote>
<p>Also, the predefined set classes such as:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Naturals</span></code> <span class="math notranslate nohighlight">\(\mathbb{N}\)</span></p>
<p>Represents the natural numbers (or counting numbers), which are all
positive integers starting from 1.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Naturals0</span></code> <span class="math notranslate nohighlight">\(\mathbb{N_0}\)</span></p>
<p>Represents the whole numbers, which are all the non-negative integers,
inclusive of 0.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Integers</span></code> <span class="math notranslate nohighlight">\(\mathbb{Z}\)</span></p>
<p>Represents all integers: positive, negative and zero.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Reals</span></code> <span class="math notranslate nohighlight">\(\mathbb{R}\)</span></p>
<p>Represents the set of all real numbers.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">Complexes</span></code> <span class="math notranslate nohighlight">\(\mathbb{C}\)</span></p>
<p>Represents the set of all complex numbers.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">EmptySet</span></code> <span class="math notranslate nohighlight">\(\phi\)</span></p>
<p>Represents the empty set.</p>
</li>
</ul>
<p>The above six sets are available as Singletons, like <code class="docutils literal notranslate"><span class="pre">S.Integers</span></code>.</p>
</div></blockquote>
<p>It is capable of most of the set operations in mathematics:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Union</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Intersection</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Complement</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SymmetricDifference</span></code></p></li>
</ul>
</div></blockquote>
<p>The main reason for using sets as output to solvers is that it can consistently
represent many types of solutions. For the single variable case it can represent:</p>
<blockquote>
<div><ul class="simple">
<li><p>No solution (by the empty set).</p></li>
<li><p>Finitely many solutions (by <code class="docutils literal notranslate"><span class="pre">FiniteSet</span></code>).</p></li>
<li><p>Infinitely many solutions, both countably and uncountably infinite solutions
(using the <code class="docutils literal notranslate"><span class="pre">ImageSet</span></code> module).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Interval</span></code></p></li>
<li><p>There can also be bizarre solutions to equations like the set of rational
numbers.</p></li>
</ul>
</div></blockquote>
<p>No other Python object (list, dictionary, generator, Python sets) provides the
flexibility of mathematical sets which our sets module tries to emulate. The
second reason to use sets is that they are close to the entities which
mathematicians deal with and it makes it easier to reason about them.  Set
objects conform to Pythonic conventions when possible, i.e., <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span></code> and
<code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">A</span></code> both work when they can be computed. Another advantage of using
objects closer to mathematical entities is that the user won’t have to “learn”
our representation and she can have her expectations transferred from her
mathematical experience.</p>
<p>For the multivariate case we represent solutions as a set of points in a
n-dimensional space and a point is represented by a <code class="docutils literal notranslate"><span class="pre">FiniteSet</span></code> of ordered
tuples, which is a point in <span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span> or <span class="math notranslate nohighlight">\(\mathbb{C}^n\)</span>.</p>
<p>Please note that, the general <code class="docutils literal notranslate"><span class="pre">FiniteSet</span></code> is unordered, but a <code class="docutils literal notranslate"><span class="pre">FiniteSet</span></code>
with a tuple as its only argument becomes ordered, since a tuple is ordered.
So the order in the tuple is mapped to a pre-defined order of variables
while returning solutions.</p>
<p>For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">FiniteSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FiniteSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Unordered</span>
<span class="go">FiniteSet(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FiniteSet</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># Ordered</span>
<span class="go">FiniteSet((1, 2, 3))</span>
</pre></div>
</div>
<p>Why not use dicts as output?</p>
<blockquote>
<div><p>Dictionary are easy to deal with programmatically but mathematically they are
not very precise and use of them can quickly lead to inconsistency and a lot
of confusion. For example:</p>
<ul>
<li><p>There are a lot of cases where we don’t know the complete solution and we
may like to output a partial solution, consider the equation <span class="math notranslate nohighlight">\(fg = 0\)</span>. The
solution of this equation is the union of the solution of the following
two equations: <span class="math notranslate nohighlight">\(f = 0\)</span>, <span class="math notranslate nohighlight">\(g = 0\)</span>. Let’s say that we are able to solve
<span class="math notranslate nohighlight">\(f = 0\)</span> but solving <span class="math notranslate nohighlight">\(g = 0\)</span> isn’t supported yet. In this case we cannot
represent partial solution of the given equation <span class="math notranslate nohighlight">\(fg = 0\)</span> using dicts.
This problem is solved with sets using a <code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> object:</p>
<p><span class="math notranslate nohighlight">\(sol_f \cup \{x | x ∊ \mathbb{R} ∧ g = 0\}\)</span>, where <span class="math notranslate nohighlight">\(sol_f\)</span> is the solution
of the equation <span class="math notranslate nohighlight">\(f = 0\)</span>.</p>
</li>
<li><p>Using a dict may lead to surprising results like:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">solve(Eq(x**2,</span> <span class="pre">1),</span> <span class="pre">x)</span> <span class="pre">!=</span> <span class="pre">solve(Eq(y**2,</span> <span class="pre">1),</span> <span class="pre">y)</span></code></p>
<p>Mathematically, this doesn’t make sense. Using <code class="docutils literal notranslate"><span class="pre">FiniteSet</span></code> here
solves the problem.</p>
</li>
</ul>
</li>
<li><p>It also cannot represent solutions for equations like <span class="math notranslate nohighlight">\(|x| &lt; 1\)</span>, which is
a disk of radius 1 in the Argand Plane. This problem is solved using
complex sets implemented as <code class="docutils literal notranslate"><span class="pre">ComplexRegion</span></code>.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="input-api-of-solveset">
<h2>Input API of <code class="docutils literal notranslate"><span class="pre">solveset</span></code><a class="headerlink" href="#input-api-of-solveset" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">solveset</span></code> has a cleaner input API, unlike <code class="docutils literal notranslate"><span class="pre">solve</span></code>. It takes a maximum
of three arguments:</p>
<p><code class="docutils literal notranslate"><span class="pre">solveset(equation,</span> <span class="pre">variable=None,</span> <span class="pre">domain=S.Complexes)</span></code></p>
<ul>
<li><p>Equation(s)</p>
<p>The equation(s) to solve.</p>
</li>
<li><p>Variable(s)</p>
<p>The variable(s) for which the equation is to be solved.</p>
</li>
<li><p>Domain</p>
<p>The domain in which the equation is to be solved.</p>
</li>
</ul>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">solveset</span></code> removes the <code class="docutils literal notranslate"><span class="pre">flags</span></code> argument of <code class="docutils literal notranslate"><span class="pre">solve</span></code>, which had made
the input API messy and output API inconsistent.</p>
</div></blockquote>
</div>
<div class="section" id="what-is-this-domain-argument-about">
<h2>What is this domain argument about?<a class="headerlink" href="#what-is-this-domain-argument-about" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset is designed to be independent of the assumptions on the
variable being solved for and instead, uses the <code class="docutils literal notranslate"><span class="pre">domain</span></code> argument to
decide the solver to dispatch the equation to, namely <code class="docutils literal notranslate"><span class="pre">solveset_real</span></code>
or <code class="docutils literal notranslate"><span class="pre">solveset_complex</span></code>. It’s unlike the old <code class="docutils literal notranslate"><span class="pre">solve</span></code> which considers the
assumption on the variable.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solveset</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># domain=S.Complexes is default</span>
<span class="go">FiniteSet(I, -I)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">EmptySet</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="what-are-the-general-methods-employed-by-solveset-to-solve-an-equation">
<h2>What are the general methods employed by solveset to solve an equation?<a class="headerlink" href="#what-are-the-general-methods-employed-by-solveset-to-solve-an-equation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset uses various methods to solve an equation, here is a brief overview
of the methodology:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">domain</span></code> argument is first considered to know the domain in which
the user is interested to get the solution.</p></li>
<li><p>If the given function is a relational (<code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>), and
the domain is real, then <code class="docutils literal notranslate"><span class="pre">solve_univariate_inequality</span></code> and solutions are
returned. Solving for complex solutions of inequalities, like <span class="math notranslate nohighlight">\(x^2 &lt; 0\)</span>
is not yet supported.</p></li>
<li><p>Based on the <code class="docutils literal notranslate"><span class="pre">domain</span></code>, the equation is dispatched to one of the two
functions <code class="docutils literal notranslate"><span class="pre">solveset_real</span></code> or <code class="docutils literal notranslate"><span class="pre">solveset_complex</span></code>, which solves the
given equation in the complex or real domain, respectively.</p></li>
<li><p>If the given expression is a product of two or more functions,
like say <span class="math notranslate nohighlight">\(gh = 0\)</span>, then the solution to the given equation is the Union
of the solution of the equations <span class="math notranslate nohighlight">\(g = 0\)</span> and <span class="math notranslate nohighlight">\(h = 0\)</span>, if and only if both
<span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> are finite for a finite input. So, the solution is built up
recursively.</p></li>
<li><p>If the function is trigonometric or hyperbolic, the function
<code class="docutils literal notranslate"><span class="pre">_solve_real_trig</span></code> is called, which solves it by converting it to complex
exponential form.</p></li>
<li><p>The function is now checked if there is any instance of a <code class="docutils literal notranslate"><span class="pre">Piecewise</span></code>
expression, if it is, then it’s converted to explicit expression and
set pairs and then solved recursively.</p></li>
<li><p>The respective solver now tries to invert the equation using the routines
<code class="docutils literal notranslate"><span class="pre">invert_real</span></code> and <code class="docutils literal notranslate"><span class="pre">invert_complex</span></code>. These routines are based on the
concept of mathematical inverse (though not exactly). It reduces the
real/complex valued equation <span class="math notranslate nohighlight">\(f(x) = y\)</span> to a set of equations:
<span class="math notranslate nohighlight">\(\{g(x)  = h_1(y), g(x) = h_2(y), ..., g(x) = h_n(y) \}\)</span> where <span class="math notranslate nohighlight">\(g(x)\)</span> is a
simpler function than <span class="math notranslate nohighlight">\(f(x)\)</span>. There is some work needed to be done in
this to find invert of more complex expressions.</p></li>
<li><p>After the invert, the equations are checked for radical or Abs (Modulus),
then the method <code class="docutils literal notranslate"><span class="pre">_solve_radical</span></code> tries to simplify the radical, by
removing it using techniques like squaring, cubing etc, and <code class="docutils literal notranslate"><span class="pre">_solve_abs</span></code>
solves nested Modulus by considering the positive and negative variants,
iteratively.</p></li>
<li><p>If none of the above method is successful, then methods of polynomial is
used as follows:</p>
<ul>
<li><p>The method to solve the rational function, <code class="docutils literal notranslate"><span class="pre">_solve_as_rational</span></code>, is
called.  Based on the domain, the respective poly solver
<code class="docutils literal notranslate"><span class="pre">_solve_as_poly_real</span></code> or <code class="docutils literal notranslate"><span class="pre">_solve_as_poly_complex</span></code> is called to solve
<code class="docutils literal notranslate"><span class="pre">f</span></code> as a polynomial.</p></li>
<li><p>The underlying method <code class="docutils literal notranslate"><span class="pre">_solve_as_poly</span></code> solves the equation using
polynomial techniques if it’s already a polynomial equation or, with
a change of variables, can be made so.</p></li>
</ul>
</li>
<li><p>The final solution set returned by <code class="docutils literal notranslate"><span class="pre">solveset</span></code> is the intersection of the
set of solutions found above and the input domain.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-do-we-manipulate-and-return-an-infinite-solution">
<h2>How do we manipulate and return an infinite solution?<a class="headerlink" href="#how-do-we-manipulate-and-return-an-infinite-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><p>In the real domain, we use our <code class="docutils literal notranslate"><span class="pre">ImageSet</span></code> class in the sets module to
return infinite solutions. <code class="docutils literal notranslate"><span class="pre">ImageSet</span></code> is an image of a set under
a mathematical function. For example, to represent the solution
of the equation <span class="math notranslate nohighlight">\(\sin{(x)} = 0\)</span>, we can use the <code class="docutils literal notranslate"><span class="pre">ImageSet</span></code> as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ImageSet</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ImageSet</span><span class="p">(</span><span class="n">Lambda</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Integers</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{2⋅n⋅π | n ∊ ℤ}</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">n</span></code> is a dummy variable. It is basically the image of the
set of integers under the function <span class="math notranslate nohighlight">\(2\pi n\)</span>.</p>
</li>
<li><p>In the complex domain, we use complex sets, which are implemented as the
<code class="docutils literal notranslate"><span class="pre">ComplexRegion</span></code> class in the sets module, to represent infinite
solution in the Argand plane. For example to represent the solution
of the equation <span class="math notranslate nohighlight">\(|z| = 1\)</span>, which is a unit circle, we can use
the <code class="docutils literal notranslate"><span class="pre">ComplexRegion</span></code> as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ComplexRegion</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ComplexRegion</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">),</span> <span class="n">polar</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{r⋅(ⅈ⋅sin(θ) + cos(θ)) | r, θ ∊ {1} × [0, 2⋅π)}</span>
</pre></div>
</div>
<p>Where the <code class="docutils literal notranslate"><span class="pre">FiniteSet</span></code> in the <code class="docutils literal notranslate"><span class="pre">ProductSet</span></code> is the range of the value
of <span class="math notranslate nohighlight">\(r\)</span>, which is the radius of the circle and the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> is the range
of <span class="math notranslate nohighlight">\(\theta\)</span>, the angle from the <span class="math notranslate nohighlight">\(x\)</span> axis representing a unit circle in the
Argand plane.</p>
<p>Note: We also have non-polar form notation for representing solution
in rectangular form. For example, to represent first two quadrants in the
Argand plane, we can write the <code class="docutils literal notranslate"><span class="pre">ComplexRegion</span></code> as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ComplexRegion</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ComplexRegion</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span><span class="o">*</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">)),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{x + y⋅ⅈ | x, y ∊ (-∞, ∞) × [0, ∞)}</span>
</pre></div>
</div>
<p>where the Intervals are the range of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> for the set of complex
numbers <span class="math notranslate nohighlight">\(x + iy\)</span>.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution">
<h2>How does <code class="docutils literal notranslate"><span class="pre">solveset</span></code> ensure that it is not returning any wrong solution?<a class="headerlink" href="#how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solvers in a Computer Algebra System are based on heuristic algorithms,
so it’s usually very hard to ensure 100% percent correctness, in every
possible case. However there are still a lot of cases where we can ensure
correctness. Solveset tries to verify correctness wherever it can. For
example:</p>
<p>Consider the equation <span class="math notranslate nohighlight">\(|x| = n\)</span>. A naive method to solve this equation
would return <code class="docutils literal notranslate"><span class="pre">{-n,</span> <span class="pre">n}</span></code> as its solution, which is not correct since
<code class="docutils literal notranslate"><span class="pre">{-n,</span> <span class="pre">n}</span></code> can be its solution if and only if <code class="docutils literal notranslate"><span class="pre">n</span></code> is positive.
Solveset returns this information as well to ensure correctness.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{x | x ∊ {-n, n} ∧ (n ∈ [0, ∞))}</span>
</pre></div>
</div>
<p>Though, there still a lot of work needs to be done in this regard.</p>
</div></blockquote>
</div>
<div class="section" id="search-based-solver-and-step-by-step-solution">
<h2>Search based solver and step-by-step solution<a class="headerlink" href="#search-based-solver-and-step-by-step-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Note: This is under Development.</p>
<p>After the introduction of <a class="reference internal" href="../sets.html#sympy.sets.conditionset.ConditionSet" title="sympy.sets.conditionset.ConditionSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">ConditionSet</span></code></a>, the
solving of equations can be seen as set transformations. Here is an abstract
view of the things we can do to solve equations.</p>
<ul class="simple">
<li><p>Apply various set transformations on the given set.</p></li>
<li><p>Define a metric of the usability of solutions, or a notion of some
solutions being better than others.</p></li>
<li><p>Different transformations would be the nodes of a tree.</p></li>
<li><p>Suitable searching techniques could be applied to get the best solution.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> gives us the ability to represent unevaluated equations and
inequalities in forms like <span class="math notranslate nohighlight">\(\{x|f(x)=0; x \in S\}\)</span> and <span class="math notranslate nohighlight">\(\{x|f(x)&gt;0; x \in S\}\)</span>
but a more powerful thing about <code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> is that it allows us to write
the intermediate steps as set to set transformation. Some of the transformations
are:</p>
<ul class="simple">
<li><p>Composition: <span class="math notranslate nohighlight">\(\{x|f(g(x))=0;x \in S\} \Rightarrow \{x|g(x)=y; x \in S, y \in \{z|f(z)=0; z \in S\}\}\)</span></p></li>
<li><dl class="simple">
<dt>Polynomial Solver: <span class="math notranslate nohighlight">\(\{x | P(x) = 0;x \in S\} \Rightarrow  \{x_1,x_2, ... ,x_n\} \cap S\)</span>,</dt><dd><p>where <span class="math notranslate nohighlight">\(x_i\)</span> are roots of <span class="math notranslate nohighlight">\(P(x)\)</span>.</p>
</dd>
</dl>
</li>
<li><p>Invert solver: <span class="math notranslate nohighlight">\(\{x|f(x)=0;x \in S\} \Rightarrow  \{g(0)| \text{ all g such that } f(g(x)) = x\}\)</span></p></li>
<li><dl class="simple">
<dt>logcombine: <span class="math notranslate nohighlight">\(\{x| \log(f(x)) + \log(g(x));x \in S\}\)</span></dt><dd><p><span class="math notranslate nohighlight">\(\Rightarrow  \{x| \log(f(x).g(x)); x \in S\} \text{ if } f(x) &gt; 0 \text{ and } g(x) &gt; 0\)</span>
<span class="math notranslate nohighlight">\(\Rightarrow  \{x| \log(f(x)) + \log(g(x));x \in S\} \text{ otherwise}\)</span></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>product solve: <span class="math notranslate nohighlight">\(\{x|f(x)g(x)=0; x \in S\}\)</span></dt><dd><p><span class="math notranslate nohighlight">\(\Rightarrow  \{x|f(x)=0; x \in S\} U \{x|g(x)=0; x \in S\}\)</span>
<span class="math notranslate nohighlight">\(\text{ given } f(x) \text{ and } g(x) \text{ are bounded.}\)</span>
<span class="math notranslate nohighlight">\(\Rightarrow  \{x|f(x)g(x)=0; x \in S\}, \text{ otherwise}\)</span></p>
</dd>
</dl>
</li>
</ul>
<p>Since the output type is same as the input type any composition of these
transformations is also a valid transformation. And our aim is to find
the right sequence of compositions (given the atoms) which transforms
the given condition set to a set which is not a condition set i.e.,
FiniteSet, Interval, Set of Integers and their Union, Intersection,
Complement or ImageSet. We can assign a cost function to each set,
such that, the more desirable that form of set is to us, the less the value
of the cost function. This way our problem is now reduced to finding the path
from the initial ConditionSet to the lowest valued set on a graph where
the atomic transformations forms the edges.</p>
</div></blockquote>
</div>
<div class="section" id="how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known">
<h2>How do we deal with cases where only some of the solutions are known?<a class="headerlink" href="#how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Creating a universal equation solver, which can solve each and every equation
we encounter in mathematics is an ideal case for solvers in a Computer
Algebra System. When cases which are not solved or can only be solved
incompletely, a <code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> is used and acts as an unevaluated solveset
object.</p>
<p>Note that, mathematically, finding a complete set of solutions for an
equation is undecidable. See <a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">Richardson’s theorem</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> is basically a Set of elements which satisfy a given
condition. For example, to represent the solutions of the equation in
the real domain:</p>
<div class="math notranslate nohighlight">
\[(x^2 - 4)(\sin(x) + x)\]</div>
<p>We can represent it as:</p>
<p><span class="math notranslate nohighlight">\(\{-2, 2\} ∪ \{x | x \in \mathbb{R} ∧ x + \sin(x) = 0\}\)</span></p>
</div></blockquote>
</div>
<div class="section" id="what-will-you-do-with-the-old-solve">
<h2>What will you do with the old solve?<a class="headerlink" href="#what-will-you-do-with-the-old-solve" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There are still a few things <code class="docutils literal notranslate"><span class="pre">solveset</span></code> can’t do, which the old <code class="docutils literal notranslate"><span class="pre">solve</span></code>
can, such as solving non linear multivariate &amp; LambertW type equations.
Hence, it’s not yet a perfect replacement for old <code class="docutils literal notranslate"><span class="pre">solve</span></code>. The ultimate
goal is to:</p>
<ul class="simple">
<li><p>Replace <code class="docutils literal notranslate"><span class="pre">solve</span></code> with <code class="docutils literal notranslate"><span class="pre">solveset</span></code> once solveset is at least as powerful as
<code class="docutils literal notranslate"><span class="pre">solve</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">solveset</span></code> does everything that <code class="docutils literal notranslate"><span class="pre">solve</span></code> can do
currently, and</p></li>
<li><p>eventually rename <code class="docutils literal notranslate"><span class="pre">solveset</span></code> to <code class="docutils literal notranslate"><span class="pre">solve</span></code>.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-are-symbolic-parameters-handled-in-solveset">
<h2>How are symbolic parameters handled in solveset?<a class="headerlink" href="#how-are-symbolic-parameters-handled-in-solveset" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset is in its initial phase of development, so the symbolic parameters
aren’t handled well for all the cases, but some work has been done in this
regard to depict our ideology towards symbolic parameters. As an example,
consider the solving of <span class="math notranslate nohighlight">\(|x| = n\)</span> for real <span class="math notranslate nohighlight">\(x\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is a symbolic
parameter. Solveset returns the value of <span class="math notranslate nohighlight">\(x\)</span> considering the domain of the
symbolic parameter <span class="math notranslate nohighlight">\(n\)</span> as well:</p>
<div class="math notranslate nohighlight">
\[([0, \infty) \cap \{n\}) \cup ((-\infty, 0] \cap \{-n\}).\]</div>
<p>This simply means <span class="math notranslate nohighlight">\(n\)</span> is the solution only when it belongs to the
<code class="docutils literal notranslate"><span class="pre">Interval</span></code> <span class="math notranslate nohighlight">\([0, \infty)\)</span> and <span class="math notranslate nohighlight">\(-n\)</span> is the solution only when <span class="math notranslate nohighlight">\(-n\)</span> belongs to
the <code class="docutils literal notranslate"><span class="pre">Interval</span></code> <span class="math notranslate nohighlight">\((- \infty, 0]\)</span>.</p>
<p>There are other cases to address too, like solving <span class="math notranslate nohighlight">\(2^x + (a - 2)\)</span> for <span class="math notranslate nohighlight">\(x\)</span>
where <span class="math notranslate nohighlight">\(a\)</span> is a symbolic parameter.  As of now, It returns the solution as an
intersection with <span class="math notranslate nohighlight">\(\mathbb{R}\)</span>, which is trivial, as it doesn’t reveal the
domain of <span class="math notranslate nohighlight">\(a\)</span> in the solution.</p>
<p>Recently, we have also implemented a function to find the domain of the
expression in a FiniteSet (Intersection with the interval) in which it is
not-empty. It is a useful addition for dealing with symbolic parameters.
For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">not_empty_in</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_empty_in</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Interval(0, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_empty_in</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Union(Interval(1, 2), Interval(-sqrt(2), -1))</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2015-Ideas#solvers">https://github.com/sympy/sympy/wiki/GSoC-2015-Ideas#solvers</a></p>
</dd>
<dt class="label" id="id3"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers">https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers</a></p>
</dd>
<dt class="label" id="id4"><span class="brackets">3</span></dt>
<dd><p><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2015-Application-AMiT-Kumar--Solvers-:-Extending-Solveset">https://github.com/sympy/sympy/wiki/GSoC-2015-Application-AMiT-Kumar–Solvers-:-Extending-Solveset</a></p>
</dd>
<dt class="label" id="id5"><span class="brackets">5</span></dt>
<dd><p><a class="reference external" href="http://iamit.in/blog/">http://iamit.in/blog/</a></p>
</dd>
<dt class="label" id="id6"><span class="brackets">6</span></dt>
<dd><p><a class="reference external" href="https://github.com/sympy/sympy/pull/2948">https://github.com/sympy/sympy/pull/2948</a> : Action Plan for improving solvers.</p>
</dd>
<dt class="label" id="id7"><span class="brackets">7</span></dt>
<dd><p><a class="reference external" href="https://github.com/sympy/sympy/issues/6659">https://github.com/sympy/sympy/issues/6659</a> : <code class="docutils literal notranslate"><span class="pre">solve()</span></code> is a giant mess</p>
</dd>
<dt class="label" id="id8"><span class="brackets">8</span></dt>
<dd><p><a class="reference external" href="https://github.com/sympy/sympy/pull/7523">https://github.com/sympy/sympy/pull/7523</a> : <code class="docutils literal notranslate"><span class="pre">solveset</span></code> PR</p>
</dd>
<dt class="label" id="id9"><span class="brackets">9</span></dt>
<dd><p><a class="reference external" href="https://groups.google.com/forum/#!topic/sympy/-SIbX0AFL3Q">https://groups.google.com/forum/#!topic/sympy/-SIbX0AFL3Q</a></p>
</dd>
<dt class="label" id="id10"><span class="brackets">10</span></dt>
<dd><p><a class="reference external" href="https://github.com/sympy/sympy/pull/9696">https://github.com/sympy/sympy/pull/9696</a></p>
</dd>
<dt class="label" id="id11"><span class="brackets">11</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">https://en.wikipedia.org/wiki/Richardson%27s_theorem</a></p>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="solveset-module-reference">
<h2>Solveset Module Reference<a class="headerlink" href="#solveset-module-reference" title="Permalink to this headline">¶</a></h2>
<p>Use <a class="reference internal" href="#sympy.solvers.solveset.solveset" title="sympy.solvers.solveset.solveset"><code class="xref py py-func docutils literal notranslate"><span class="pre">solveset()</span></code></a> to solve equations or expressions (assumed to be equal to 0) for a single variable.
Solving an equation like <span class="math notranslate nohighlight">\(x^2 == 1\)</span> can be done as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">FiniteSet(-1, 1)</span>
</pre></div>
</div>
<p>Or one may manually rewrite the equation as an expression equal to 0:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">FiniteSet(-1, 1)</span>
</pre></div>
</div>
<p>The first argument for <a class="reference internal" href="#sympy.solvers.solveset.solveset" title="sympy.solvers.solveset.solveset"><code class="xref py py-func docutils literal notranslate"><span class="pre">solveset()</span></code></a> is an expression (equal to zero) or an equation and the second argument
is the symbol that we want to solve the equation for.</p>
<dl class="py function">
<dt id="sympy.solvers.solveset.solveset">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">solveset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">S.Complexes</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L1949-L2119"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a given inequality or equation with set as output</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> : Expr or a relational.</p>
<blockquote>
<div><p>The target equation or inequality</p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable for which the equation is solved</p>
</div></blockquote>
<p><strong>domain</strong> : Set</p>
<blockquote>
<div><p>The domain over which the equation is solved</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Set</p>
<blockquote>
<div><p>A set of values for <span class="math notranslate nohighlight">\(symbol\)</span> for which <span class="math notranslate nohighlight">\(f\)</span> is True or is equal to
zero. An <span class="math notranslate nohighlight">\(EmptySet\)</span> is returned if <span class="math notranslate nohighlight">\(f\)</span> is False or nonzero.
A <span class="math notranslate nohighlight">\(ConditionSet\)</span> is returned as unsolved object if algorithms
to evaluate complete solution are not yet implemented.</p>
</div></blockquote>
<p><span class="math notranslate nohighlight">\(solveset\)</span> claims to be complete in the solution set that it returns.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>The algorithms to solve inequalities in complex domain  are
not yet implemented.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote>
<div><p>The input is not valid.</p>
</div></blockquote>
<p><strong>RuntimeError</strong></p>
<blockquote>
<div><p>It is a bug, please report to the github issue tracker.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Python interprets 0 and 1 as False and True, respectively, but
in this function they refer to solutions of an expression. So 0 and 1
return the Domain and EmptySet, respectively, while True and False
return the opposite (as they are assumed to be solutions of relational
expressions).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">solveset</span><span class="p">,</span> <span class="n">solveset_real</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The default domain is complex. Not specifying a domain will lead
to the solving of the equation in the complex domain (and this
is not affected by the assumptions on the symbol):</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{2*n*I*pi | n in Integers}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{2*n*I*pi | n in Integers}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>If you want to use <span class="math notranslate nohighlight">\(solveset\)</span> to solve the equation in the
real domain, provide a real domain. (Using <code class="docutils literal notranslate"><span class="pre">solveset_real</span></code>
does this automatically.)</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">FiniteSet(0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">FiniteSet(0)</span>
</pre></div>
</div>
<p>The solution is unaffected by assumptions on the symbol:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">{-2, 2}</span>
</pre></div>
</div>
<p>When a conditionSet is returned, symbols with assumptions that
would alter the set are replaced with more generic symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">imaginary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">ConditionSet(_R, Eq(_R**2 + _R*sin(_R) - 1, 0), Reals)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Inequalities can be solved over the real domain only. Use of a complex
domain leads to a NotImplementedError.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">Interval.open(0, oo)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sympy.solvers.solveset.solveset_real" title="sympy.solvers.solveset.solveset_real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solveset_real</span></code></a></dt><dd><p>solver for real domain</p>
</dd>
<dt><a class="reference internal" href="#sympy.solvers.solveset.solveset_complex" title="sympy.solvers.solveset.solveset_complex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solveset_complex</span></code></a></dt><dd><p>solver for complex domain</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset.solveset_real">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">solveset_real</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L2122-L2123"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset.solveset_complex">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">solveset_complex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L2126-L2127"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset.invert_real">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">invert_real</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f_x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">Reals</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L190-L195"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.invert_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts a real-valued function. Same as _invert, but sets
the domain to <code class="docutils literal notranslate"><span class="pre">S.Reals</span></code> before inverting.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset.invert_complex">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">invert_complex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f_x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">domain</span><span class="o">=</span><span class="default_value">S.Complexes</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L109-L184"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.invert_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the complex valued equation <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">y</span></code> to a set of equations
<code class="docutils literal notranslate"><span class="pre">{g(x)</span> <span class="pre">=</span> <span class="pre">h_1(y),</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_n(y)</span> <span class="pre">}</span></code> where <code class="docutils literal notranslate"><span class="pre">g(x)</span></code> is
a simpler function than <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>.  The return value is a tuple <code class="docutils literal notranslate"><span class="pre">(g(x),</span>
<span class="pre">set_h)</span></code>, where <code class="docutils literal notranslate"><span class="pre">g(x)</span></code> is a function of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">set_h</span></code> is
the set of function <code class="docutils literal notranslate"><span class="pre">{h_1(y),</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">h_n(y)}</span></code>.
Here, <code class="docutils literal notranslate"><span class="pre">y</span></code> is not necessarily a symbol.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">set_h</span></code> contains the functions, along with the information
about the domain in which they are valid, through set
operations. For instance, if <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">Abs(x)</span> <span class="pre">-</span> <span class="pre">n</span></code> is inverted
in the real domain, then <code class="docutils literal notranslate"><span class="pre">set_h</span></code> is not simply
<span class="math notranslate nohighlight">\({-n, n}\)</span> as the nature of <span class="math notranslate nohighlight">\(n\)</span> is unknown; rather, it is:
<span class="math notranslate nohighlight">\(Intersection([0, oo) {n}) U Intersection((-oo, 0], {-n})\)</span></p>
<p>By default, the complex domain is used which means that inverting even
seemingly simple functions like <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code> will give very different
results from those obtained in the real domain.
(In the case of <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code>, the inversion via <code class="docutils literal notranslate"><span class="pre">log</span></code> is multi-valued
in the complex domain, having infinitely many branches.)</p>
<p>If you are working with real values only (or you are not sure which
function to use) you should probably set the domain to
<code class="docutils literal notranslate"><span class="pre">S.Reals</span></code> (or use <span class="math notranslate nohighlight">\(invert\_real\)</span> which does that automatically).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">invert_complex</span><span class="p">,</span> <span class="n">invert_real</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span>
</pre></div>
</div>
<p>When does exp(x) == y?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, ImageSet(Lambda(_n, I*(2*_n*pi + arg(y)) + log(Abs(y))), Integers))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, Intersection(FiniteSet(log(y)), Reals))</span>
</pre></div>
</div>
<p>When does exp(x) == 1?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, ImageSet(Lambda(_n, 2*_n*I*pi), Integers))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, FiniteSet(0))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.solveset.invert_real" title="sympy.solvers.solveset.invert_real"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert_real</span></code></a>, <a class="reference internal" href="#sympy.solvers.solveset.invert_complex" title="sympy.solvers.solveset.invert_complex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">invert_complex</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset.domain_check">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">domain_check</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span></em>, <em class="sig-param"><span class="n">p</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L397-L430"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.domain_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns False if point p is infinite or any subexpression of f
is infinite or becomes so after replacing symbol with p. If none of
these conditions is met then True will be returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">domain_check</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The function relies on the assumption that the original form
of the equation has not been changed by automatic simplification.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># x/x is automatically simplified to 1</span>
<span class="go">True</span>
</pre></div>
</div>
<ul class="simple">
<li><p>To deal with automatic evaluations use evaluate=False:</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset.solvify">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">solvify</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span></em>, <em class="sig-param"><span class="n">domain</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L2180-L2258"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solvify" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an equation using solveset and returns the solution in accordance
with the <span class="math notranslate nohighlight">\(solve\)</span> output API.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>We classify the output based on the type of solution returned by <span class="math notranslate nohighlight">\(solveset\)</span>.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>A ConditionSet is the input.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Solution    |    Output</p>
<p>FiniteSet   | list</p>
<p>ImageSet,   | list (if <span class="math notranslate nohighlight">\(f\)</span> is periodic)
Union       |</p>
<p>EmptySet    | empty list</p>
<p>Others      | None</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">solvify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">9</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">[-3, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">[pi/2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">tan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">[0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Complexes</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solvify</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">[0]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="linear-eq-to-matrix">
<h2>linear_eq_to_matrix<a class="headerlink" href="#linear-eq-to-matrix" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sympy.solvers.solveset.linear_eq_to_matrix">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">linear_eq_to_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">equations</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">symbols</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L2340-L2453"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.linear_eq_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a given System of Equations into Matrix form.
Here <span class="math notranslate nohighlight">\(equations\)</span> must be a linear system of equations in
<span class="math notranslate nohighlight">\(symbols\)</span>. Element M[i, j] corresponds to the coefficient
of the jth symbol in the ith equation.</p>
<p>The Matrix form corresponds to the augmented matrix form.
For example:</p>
<div class="math notranslate nohighlight">
\[4x + 2y + 3z  = 1\]</div>
<div class="math notranslate nohighlight">
\[3x +  y +  z  = -6\]</div>
<div class="math notranslate nohighlight">
\[2x + 4y + 9z  = 2\]</div>
<p>This system would return <span class="math notranslate nohighlight">\(A\)</span> &amp; <span class="math notranslate nohighlight">\(b\)</span> as given below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="p">[</span> <span class="mi">4</span>  <span class="mi">2</span>  <span class="mi">3</span> <span class="p">]</span>          <span class="p">[</span> <span class="mi">1</span> <span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">3</span>  <span class="mi">1</span>  <span class="mi">1</span> <span class="p">]</span>   <span class="n">b</span>  <span class="o">=</span>   <span class="p">[</span><span class="o">-</span><span class="mi">6</span> <span class="p">]</span>
    <span class="p">[</span> <span class="mi">2</span>  <span class="mi">4</span>  <span class="mi">9</span> <span class="p">]</span>          <span class="p">[</span> <span class="mi">2</span> <span class="p">]</span>
</pre></div>
</div>
<p>The only simplification performed is to convert
<span class="math notranslate nohighlight">\(Eq(a, b) -&gt; a - b\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NonlinearError</strong></p>
<blockquote>
<div><p>The equations contain a nonlinear term.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote>
<div><p>The symbols are not given or are not unique.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">linear_eq_to_matrix</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;c, x, y, z&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The coefficients (numerical or symbolic) of the symbols will
be returned as matrices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[c,  0, 1],</span>
<span class="go">[0,  1, 1],</span>
<span class="go">[1, -1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[c + 1],</span>
<span class="go">[    0],</span>
<span class="go">[    0]])</span>
</pre></div>
</div>
<p>This routine does not simplify expressions and will raise an error
if nonlinearity is encountered:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NonlinearError</span>:
<span class="go">The term (x**2 - 3*x)/(x - 3) is nonlinear in {x, y}</span>
</pre></div>
</div>
<p>Simplifying these equations will discard the removable singularity
in the first, reveal the linear structure of the second:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eqns</span><span class="p">]</span>
<span class="go">[x - 3, x + y - 4]</span>
</pre></div>
</div>
<p>Any such simplification needed to eliminate nonlinear terms must
be done before calling this routine.</p>
</dd></dl>

</div>
<div class="section" id="linsolve">
<h2>linsolve<a class="headerlink" href="#linsolve" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sympy.solvers.solveset.linsolve">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">linsolve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">system</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">symbols</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L2456-L2703"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.linsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve system of N linear equations with M variables; both
underdetermined and overdetermined systems are supported.
The possible number of solutions is zero, one or infinite.
Zero solutions throws a ValueError, whereas infinite
solutions are represented parametrically in terms of the given
symbols. For unique solution a FiniteSet of ordered tuples
is returned.</p>
<p>All Standard input formats are supported:
For the given set of Equations, the respective input types
are given below:</p>
<div class="math notranslate nohighlight">
\[3x + 2y -   z = 1\]</div>
<div class="math notranslate nohighlight">
\[2x - 2y + 4z = -2\]</div>
<div class="math notranslate nohighlight">
\[2x -   y + 2z = 0\]</div>
<ul class="simple">
<li><p>Augmented Matrix Form, <span class="math notranslate nohighlight">\(system\)</span> given below:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>         <span class="p">[</span><span class="mi">3</span>   <span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>  <span class="mi">1</span><span class="p">]</span>
<span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">2</span>   <span class="mi">4</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
         <span class="p">[</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">2</span>  <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>List Of Equations Form</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]\)</span></p>
<ul class="simple">
<li><p>Input A &amp; b Matrix Form (from Ax = b) are given as below:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="p">[</span><span class="mi">3</span>   <span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>         <span class="p">[</span>  <span class="mi">1</span> <span class="p">]</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">2</span>   <span class="mi">4</span> <span class="p">]</span>    <span class="n">b</span> <span class="o">=</span>  <span class="p">[</span> <span class="o">-</span><span class="mi">2</span> <span class="p">]</span>
    <span class="p">[</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>   <span class="mi">2</span> <span class="p">]</span>         <span class="p">[</span>  <span class="mi">0</span> <span class="p">]</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(system = (A, b)\)</span></p>
<p>Symbols can always be passed but are actually only needed
when 1) a system of equations is being passed and 2) the
system is passed as an underdetermined matrix and one wants
to control the name of the free variables in the result.
An error is raised if no symbols are used for case 1, but if
no symbols are provided for case 2, internally generated symbols
will be provided. When providing symbols for case 2, there should
be at least as many symbols are there are columns in matrix A.</p>
<p>The algorithm used here is Gauss-Jordan elimination, which
results, after elimination, in a row echelon form matrix.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A FiniteSet containing an ordered tuple of values for the</p>
<p>unknowns for which the <span class="math notranslate nohighlight">\(system\)</span> has a solution. (Wrapping</p>
<p>the tuple in FiniteSet is used to maintain a consistent</p>
<p>output format throughout solveset.)</p>
<p>Returns EmptySet, if the linear system is inconsistent.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong></p>
<blockquote>
<div><p>The input is not valid.
The symbols are not given.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">linsolve</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x, y, z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1, 2,  3],</span>
<span class="go">[4, 5,  6],</span>
<span class="go">[7, 8, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[3],</span>
<span class="go">[6],</span>
<span class="go">[9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">FiniteSet((-1, 2, 0))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Parametric Solution: In case the system is underdetermined, the
function will return a parametric solution in terms of the given
symbols. Those that are free will be returned unchanged. e.g. in
the system below, <span class="math notranslate nohighlight">\(z\)</span> is returned as the solution for variable z;
it can take on any value.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">FiniteSet((z - 1, 2 - 2*z, z))</span>
</pre></div>
</div>
<p>If no symbols are given, internally generated symbols will be used.
The <span class="math notranslate nohighlight">\(tau0\)</span> in the 3rd position indicates (as before) that the 3rd
variable – whatever it’s named – can take on any value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
<span class="go">FiniteSet((tau0 - 1, 2 - 2*tau0, tau0))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>List of Equations as input</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Eqns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">Eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">FiniteSet((1, -2, -2))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Augmented Matrix as input</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span>
<span class="go">Matrix([</span>
<span class="go">[2, 1,  3, 1],</span>
<span class="go">[2, 6,  8, 3],</span>
<span class="go">[6, 8, 18, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">FiniteSet((3/10, 2/5, 0))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Solve for symbolic coefficients</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a, b, c, d, e, f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">f</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">FiniteSet(((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d)))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>A degenerate system returns solution as set of given
symbols.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">FiniteSet((x, y))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>For an empty system linsolve returns empty set</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">([],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">EmptySet</span>
</pre></div>
</div>
<ul class="simple">
<li><p>An error is raised if, after expansion, any nonlinearity
is detected:</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">([</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">FiniteSet((1, 1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NonlinearError</span>:
<span class="go">nonlinear term encountered: x**2</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nonlinsolve">
<h2>nonlinsolve<a class="headerlink" href="#nonlinsolve" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sympy.solvers.solveset.nonlinsolve">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">nonlinsolve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">system</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">symbols</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L3319-L3531"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.nonlinsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve system of N non linear equations with M variables, which means both
under and overdetermined systems are supported. Positive dimensional
system is also supported (A system with infinitely many solutions is said
to be positive-dimensional). In Positive dimensional system solution will
be dependent on at least one symbol. Returns both real solution
and complex solution(If system have). The possible number of solutions
is zero, one or infinite.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>system</strong> : list of equations</p>
<blockquote>
<div><p>The target system of equations</p>
</div></blockquote>
<p><strong>symbols</strong> : list of Symbols</p>
<blockquote>
<div><p>symbols should be given as a sequence eg. list</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A FiniteSet of ordered tuple of values of <span class="math notranslate nohighlight">\(symbols\)</span> for which the <span class="math notranslate nohighlight">\(system\)</span></p>
<p>has solution. Order of values in the tuple is same as symbols present in</p>
<p>the parameter <span class="math notranslate nohighlight">\(symbols\)</span>.</p>
<p>Please note that general FiniteSet is unordered, the solution returned</p>
<p>here is not simply a FiniteSet of solutions, rather it is a FiniteSet of</p>
<p>ordered tuple, i.e. the first &amp; only argument to FiniteSet is a tuple of</p>
<p>solutions, which is ordered, &amp; hence the returned solution is ordered.</p>
<p>Also note that solution could also have been returned as an ordered tuple,</p>
<p>FiniteSet is just a wrapper <span class="math notranslate nohighlight">\({}\)</span> around the tuple. It has no other</p>
<p>significance except for the fact it is just used to maintain a consistent</p>
<p>output format throughout the solveset.</p>
<p>For the given set of Equations, the respective input types</p>
<p>are given below:</p>
<div class="math notranslate nohighlight">
\[x*y - 1 = 0\]</div>
<div class="math notranslate nohighlight">
\[4*x**2 + y**2 - 5 = 0\]</div>
<p><span class="math notranslate nohighlight">\(system  = [x*y - 1, 4*x**2 + y**2 - 5]\)</span></p>
<p><span class="math notranslate nohighlight">\(symbols = [x, y]\)</span></p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong></p>
<blockquote>
<div><p>The input is not valid.
The symbols are not given.</p>
</div></blockquote>
<p><strong>AttributeError</strong></p>
<blockquote>
<div><p>The input symbols are not <span class="math notranslate nohighlight">\(Symbol\)</span> type.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">nonlinsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">FiniteSet((-1, -1), (-1/2, -2), (1/2, 2), (1, 1))</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>Positive dimensional system and complements:</p></li>
</ol>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.polys.polytools</span> <span class="kn">import</span> <span class="n">is_zero_dimensional</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a, b, c, d&#39;</span><span class="p">,</span> <span class="n">extended_real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq1</span> <span class="o">=</span>  <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">d</span><span class="o">*</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq3</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">d</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq4</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">,</span> <span class="n">eq3</span><span class="p">,</span> <span class="n">eq4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_zero_dimensional</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">nonlinsolve</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">  -1       1               1      -1</span>
<span class="go">{(---, -d, -, {d} \ {0}), (-, -d, ---, {d} \ {0})}</span>
<span class="go">   d       d               d       d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">FiniteSet((2 - y, y))</span>
</pre></div>
</div>
<p>2. If some of the equations are non-polynomial then <span class="math notranslate nohighlight">\(nonlinsolve\)</span>
will call the <span class="math notranslate nohighlight">\(substitution\)</span> function and return real and complex solutions,
if present.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">FiniteSet((ImageSet(Lambda(_n, 2*_n*I*pi + log(sin(2))), Integers), 2),</span>
<span class="go">        (ImageSet(Lambda(_n, I*(2*_n*pi + pi) + log(sin(2))), Integers), -2))</span>
</pre></div>
</div>
<p>3. If system is non-linear polynomial and zero-dimensional then it
returns both solution (real and complex solutions, if present) using
<span class="math notranslate nohighlight">\(solve_poly_system\)</span>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">FiniteSet((-2, -1), (2, 1), (-sqrt(2)*I, sqrt(2)*I), (sqrt(2)*I, -sqrt(2)*I))</span>
</pre></div>
</div>
<p>4. <span class="math notranslate nohighlight">\(nonlinsolve\)</span> can solve some linear (zero or positive dimensional)
system (because it uses the <span class="math notranslate nohighlight">\(groebner\)</span> function to get the
groebner basis and then uses the <span class="math notranslate nohighlight">\(substitution\)</span> function basis as the
new <span class="math notranslate nohighlight">\(system\)</span>). But it is not recommended to solve linear system using
<span class="math notranslate nohighlight">\(nonlinsolve\)</span>, because <span class="math notranslate nohighlight">\(linsolve\)</span> is better for general linear systems.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span><span class="n">z</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">9</span> <span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">FiniteSet((3*z - 5, 4 - z, z))</span>
</pre></div>
</div>
<p>5. System having polynomial equations and only real solution is
solved using <span class="math notranslate nohighlight">\(solve_poly_system\)</span>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">((</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="go">FiniteSet((191/20, -3*sqrt(391)/20), (191/20, 3*sqrt(391)/20))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="go">FiniteSet((1, 2), (1 - sqrt(5), 2 + sqrt(5)), (1 + sqrt(5), 2 - sqrt(5)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nonlinsolve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">/</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="go">FiniteSet((2, 1), (2 - sqrt(5), 1 + sqrt(5)), (2 + sqrt(5), 1 - sqrt(5)))</span>
</pre></div>
</div>
<p>6. It is better to use symbols instead of Trigonometric Function or
Function (e.g. replace <span class="math notranslate nohighlight">\(sin(x)\)</span> with symbol, replace <span class="math notranslate nohighlight">\(f(x)\)</span> with symbol
and so on. Get soln from <span class="math notranslate nohighlight">\(nonlinsolve\)</span> and then using <span class="math notranslate nohighlight">\(solveset\)</span> get
the value of <span class="math notranslate nohighlight">\(x\)</span>)</p>
<p class="rubric">How Nonlinsolve Is Better Than Old Solver <span class="math notranslate nohighlight">\(_solve_system\)</span> :</p>
<p>1. A positive dimensional system solver : nonlinsolve can return
solution for positive dimensional system. It finds the
Groebner Basis of the positive dimensional system(calling it as
basis) then we can start solving equation(having least number of
variable first in the basis) using solveset and substituting that
solved solutions into other equation(of basis) to get solution in
terms of minimum variables. Here the important thing is how we
are substituting the known values and in which equations.</p>
<p>2. Real and Complex both solutions : nonlinsolve returns both real
and complex solution. If all the equations in the system are polynomial
then using <span class="math notranslate nohighlight">\(solve_poly_system\)</span> both real and complex solution is returned.
If all the equations in the system are not polynomial equation then goes to
<span class="math notranslate nohighlight">\(substitution\)</span> method with this polynomial and non polynomial equation(s),
to solve for unsolved variables. Here to solve for particular variable
solveset_real and solveset_complex is used. For both real and complex
solution function <span class="math notranslate nohighlight">\(_solve_using_know_values\)</span> is used inside <span class="math notranslate nohighlight">\(substitution\)</span>
function.(<span class="math notranslate nohighlight">\(substitution\)</span> function will be called when there is any non
polynomial equation(s) is present). When solution is valid then add its
general solution in the final result.</p>
<p>3. Complement and Intersection will be added if any : nonlinsolve maintains
dict for complements and Intersections. If solveset find complements or/and
Intersection with any Interval or set during the execution of
<span class="math notranslate nohighlight">\(substitution\)</span> function ,then complement or/and Intersection for that
variable is added before returning final solution.</p>
</dd></dl>

</div>
<div class="section" id="transolve">
<h2>transolve<a class="headerlink" href="#transolve" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sympy.solvers.solveset._transolve">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">_transolve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span></em>, <em class="sig-param"><span class="n">domain</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L1734-L1946"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset._transolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to solve transcendental equations. It is a helper to
<code class="docutils literal notranslate"><span class="pre">solveset</span></code> and should be used internally. <code class="docutils literal notranslate"><span class="pre">_transolve</span></code>
currently supports the following class of equations:</p>
<blockquote>
<div><ul class="simple">
<li><p>Exponential equations</p></li>
<li><p>Logarithmic equations</p></li>
</ul>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> : Any transcendental equation that needs to be solved.</p>
<blockquote>
<div><p>This needs to be an expression, which is assumed
to be equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</div></blockquote>
<p><strong>symbol</strong> : The variable for which the equation is solved.</p>
<blockquote>
<div><p>This needs to be of class <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>.</p>
</div></blockquote>
<p><strong>domain</strong> : A set over which the equation is solved.</p>
<blockquote>
<div><p>This needs to be of class <code class="docutils literal notranslate"><span class="pre">Set</span></code>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Set</p>
<blockquote>
<div><p>A set of values for <code class="docutils literal notranslate"><span class="pre">symbol</span></code> for which <code class="docutils literal notranslate"><span class="pre">f</span></code> is equal to
zero. An <code class="docutils literal notranslate"><span class="pre">EmptySet</span></code> is returned if <code class="docutils literal notranslate"><span class="pre">f</span></code> does not have solutions
in respective domain. A <code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> is returned as unsolved
object if algorithms to evaluate complete solution are not
yet implemented.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">How To Use <code class="docutils literal notranslate"><span class="pre">_transolve</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">_transolve</span></code> should not be used as an independent function, because
it assumes that the equation (<code class="docutils literal notranslate"><span class="pre">f</span></code>) and the <code class="docutils literal notranslate"><span class="pre">symbol</span></code> comes from
<code class="docutils literal notranslate"><span class="pre">solveset</span></code> and might have undergone a few modification(s).
To use <code class="docutils literal notranslate"><span class="pre">_transolve</span></code> as an independent function the equation (<code class="docutils literal notranslate"><span class="pre">f</span></code>)
and the <code class="docutils literal notranslate"><span class="pre">symbol</span></code> should be passed as they would have been by
<code class="docutils literal notranslate"><span class="pre">solveset</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">_transolve</span> <span class="k">as</span> <span class="n">transolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solvers</span> <span class="kn">import</span> <span class="n">_tsolve</span> <span class="k">as</span> <span class="n">tsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># assumption added</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transolve</span><span class="p">(</span><span class="mi">5</span><span class="o">**</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">FiniteSet(-(log(3) + 3*log(5))/(-log(5) + 2*log(3)))</span>
</pre></div>
</div>
<p class="rubric">How <code class="docutils literal notranslate"><span class="pre">_transolve</span></code> Works</p>
<p><code class="docutils literal notranslate"><span class="pre">_transolve</span></code> uses two types of helper functions to solve equations
of a particular class:</p>
<p>Identifying helpers: To determine whether a given equation
belongs to a certain class of equation or not. Returns either
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Solving helpers: Once an equation is identified, a corresponding
helper either solves the equation or returns a form of the equation
that <code class="docutils literal notranslate"><span class="pre">solveset</span></code> might better be able to handle.</p>
<ul class="simple">
<li><p>Philosophy behind the module</p></li>
</ul>
<p>The purpose of <code class="docutils literal notranslate"><span class="pre">_transolve</span></code> is to take equations which are not
already polynomial in their generator(s) and to either recast them
as such through a valid transformation or to solve them outright.
A pair of helper functions for each class of supported
transcendental functions are employed for this purpose. One
identifies the transcendental form of an equation and the other
either solves it or recasts it into a tractable form that can be
solved by  <code class="docutils literal notranslate"><span class="pre">solveset</span></code>.
For example, an equation in the form <span class="math notranslate nohighlight">\(ab^{f(x)} - cd^{g(x)} = 0\)</span>
can be transformed to
<span class="math notranslate nohighlight">\(\log(a) + f(x)\log(b) - \log(c) - g(x)\log(d) = 0\)</span>
(under certain assumptions) and this can be solved with <code class="docutils literal notranslate"><span class="pre">solveset</span></code>
if <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(g(x)\)</span> are in polynomial form.</p>
<p class="rubric">How <code class="docutils literal notranslate"><span class="pre">_transolve</span></code> Is Better Than <code class="docutils literal notranslate"><span class="pre">_tsolve</span></code></p>
<ol class="arabic simple">
<li><p>Better output</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">_transolve</span></code> provides expressions in a more simplified form.</p>
<p>Consider a simple exponential equation</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="mi">3</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">transolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">    -3*log(2)</span>
<span class="go">{------------------}</span>
<span class="go"> -2*log(3) + log(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">tsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">     /   3     \</span>
<span class="go">     | --------|</span>
<span class="go">     | log(2/9)|</span>
<span class="go">[-log\2         /]</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Extensible</p></li>
</ol>
<p>The API of <code class="docutils literal notranslate"><span class="pre">_transolve</span></code> is designed such that it is easily
extensible, i.e. the code that solves a given class of
equations is encapsulated in a helper and not mixed in with
the code of <code class="docutils literal notranslate"><span class="pre">_transolve</span></code> itself.</p>
<ol class="arabic simple" start="3">
<li><p>Modular</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">_transolve</span></code> is designed to be modular i.e, for every class of
equation a separate helper for identification and solving is
implemented. This makes it easy to change or modify any of the
method implemented directly in the helpers without interfering
with the actual structure of the API.</p>
<ol class="arabic simple" start="4">
<li><p>Faster Computation</p></li>
</ol>
<p>Solving equation via <code class="docutils literal notranslate"><span class="pre">_transolve</span></code> is much faster as compared to
<code class="docutils literal notranslate"><span class="pre">_tsolve</span></code>. In <code class="docutils literal notranslate"><span class="pre">solve</span></code>, attempts are made computing every possibility
to get the solutions. This series of attempts makes solving a bit
slow. In <code class="docutils literal notranslate"><span class="pre">_transolve</span></code>, computation begins only after a particular
type of equation is identified.</p>
<p class="rubric">How To Add New Class Of Equations</p>
<p>Adding a new class of equation solver is a three-step procedure:</p>
<ul>
<li><p>Identify the type of the equations</p>
<p>Determine the type of the class of equations to which they belong:
it could be of <code class="docutils literal notranslate"><span class="pre">Add</span></code>, <code class="docutils literal notranslate"><span class="pre">Pow</span></code>, etc. types. Separate internal functions
are used for each type. Write identification and solving helpers
and use them from within the routine for the given type of equation
(after adding it, if necessary). Something like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_type</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="o">....</span>
    <span class="k">if</span> <span class="n">_is_exponential</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">new_eq</span> <span class="o">=</span> <span class="n">_solve_exponential</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="o">....</span>
<span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">add_type</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Define the identification helper.</p></li>
<li><p>Define the solving helper.</p></li>
</ul>
<p>Apart from this, a few other things needs to be taken care while
adding an equation solver:</p>
<ul class="simple">
<li><p>Naming conventions:
Name of the identification helper should be as
<code class="docutils literal notranslate"><span class="pre">_is_class</span></code> where class will be the name or abbreviation
of the class of equation. The solving helper will be named as
<code class="docutils literal notranslate"><span class="pre">_solve_class</span></code>.
For example: for exponential equations it becomes
<code class="docutils literal notranslate"><span class="pre">_is_exponential</span></code> and <code class="docutils literal notranslate"><span class="pre">_solve_expo</span></code>.</p></li>
<li><p>The identifying helpers should take two input parameters,
the equation to be checked and the variable for which a solution
is being sought, while solving helpers would require an additional
domain parameter.</p></li>
<li><p>Be sure to consider corner cases.</p></li>
<li><p>Add tests for each helper.</p></li>
<li><p>Add a docstring to your helper that describes the method
implemented.
The documentation of the helpers should identify:</p>
<ul>
<li><p>the purpose of the helper,</p></li>
<li><p>the method used to identify and solve the equation,</p></li>
<li><p>a proof of correctness</p></li>
<li><p>the return values of the helpers</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset._is_exponential">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">_is_exponential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L1538-L1584"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset._is_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if one or more terms contain <code class="docutils literal notranslate"><span class="pre">symbol</span></code> only in
exponents, else <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> : Expr</p>
<blockquote>
<div><p>The equation to be checked</p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable in which the equation is checked</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">_is_exponential</span> <span class="k">as</span> <span class="n">check</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Philosophy behind the helper</p></li>
</ul>
<p>The function extracts each term of the equation and checks if it is
of exponential form w.r.t <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset._solve_exponential">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">_solve_exponential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lhs</span></em>, <em class="sig-param"><span class="n">rhs</span></em>, <em class="sig-param"><span class="n">symbol</span></em>, <em class="sig-param"><span class="n">domain</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L1425-L1535"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset._solve_exponential" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for solving (supported) exponential equations.</p>
<p>Exponential equations are the sum of (currently) at most
two terms with one or both of them having a power with a
symbol-dependent exponent.</p>
<p>For example</p>
<div class="math notranslate nohighlight">
\[5^{2x + 3} - 5^{3x - 1}\]</div>
<div class="math notranslate nohighlight">
\[4^{5 - 9x} - e^{2 - x}\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lhs, rhs</strong> : Expr</p>
<blockquote>
<div><p>The exponential equation to be solved, <span class="math notranslate nohighlight">\(lhs = rhs\)</span></p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable in which the equation is solved</p>
</div></blockquote>
<p><strong>domain</strong> : Set</p>
<blockquote>
<div><p>A set over which the equation is solved.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A set of solutions satisfying the given equation.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> if the equation is unsolvable or</p>
<p>if the assumptions are not properly defined, in that case</p>
<p>a different style of <code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> is returned having the</p>
<p>solution(s) of the equation with the desired assumptions.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">_solve_exponential</span> <span class="k">as</span> <span class="n">solve_expo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_expo</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="o">**</span><span class="n">x</span> <span class="o">-</span> <span class="mi">5</span><span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>  <span class="c1"># not solvable</span>
<span class="go">ConditionSet(x, Eq(2**x + 3**x - 5**x, 0), Reals)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_expo</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>  <span class="c1"># solvable but incorrect assumptions</span>
<span class="go">ConditionSet(x, (a &gt; 0) &amp; (b &gt; 0), FiniteSet(0))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_expo</span><span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">FiniteSet(-3*log(2)/(-2*log(3) + log(2)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_expo</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span> <span class="o">-</span> <span class="mi">4</span><span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">FiniteSet(0)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Proof of correctness of the method</p></li>
</ul>
<p>The logarithm function is the inverse of the exponential function.
The defining relation between exponentiation and logarithm is:</p>
<div class="math notranslate nohighlight">
\[{\log_b x} = y \enspace if \enspace b^y = x\]</div>
<p>Therefore if we are given an equation with exponent terms, we can
convert every term to its corresponding logarithmic form. This is
achieved by taking logarithms and expanding the equation using
logarithmic identities so that it can easily be handled by <code class="docutils literal notranslate"><span class="pre">solveset</span></code>.</p>
<p>For example:</p>
<div class="math notranslate nohighlight">
\[3^{2x} = 2^{x + 3}\]</div>
<p>Taking log both sides will reduce the equation to</p>
<div class="math notranslate nohighlight">
\[(2x)\log(3) = (x + 3)\log(2)\]</div>
<p>This form can be easily handed by <code class="docutils literal notranslate"><span class="pre">solveset</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset._solve_logarithm">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">_solve_logarithm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lhs</span></em>, <em class="sig-param"><span class="n">rhs</span></em>, <em class="sig-param"><span class="n">symbol</span></em>, <em class="sig-param"><span class="n">domain</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L1587-L1673"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset._solve_logarithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to solve logarithmic equations which are reducible
to a single instance of <span class="math notranslate nohighlight">\(\log\)</span>.</p>
<p>Logarithmic equations are (currently) the equations that contains
<span class="math notranslate nohighlight">\(\log\)</span> terms which can be reduced to a single <span class="math notranslate nohighlight">\(\log\)</span> term or
a constant using various logarithmic identities.</p>
<p>For example:</p>
<div class="math notranslate nohighlight">
\[\log(x) + \log(x - 4)\]</div>
<p>can be reduced to:</p>
<div class="math notranslate nohighlight">
\[\log(x(x - 4))\]</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lhs, rhs</strong> : Expr</p>
<blockquote>
<div><p>The logarithmic equation to be solved, <span class="math notranslate nohighlight">\(lhs = rhs\)</span></p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable in which the equation is solved</p>
</div></blockquote>
<p><strong>domain</strong> : Set</p>
<blockquote>
<div><p>A set over which the equation is solved.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A set of solutions satisfying the given equation.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">ConditionSet</span></code> if the equation is unsolvable.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">_solve_logarithm</span> <span class="k">as</span> <span class="n">solve_log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_log</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">FiniteSet(sqrt(10), -sqrt(10))</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Proof of correctness</p></li>
</ul>
<p>A logarithm is another way to write exponent and is defined by</p>
<div class="math notranslate nohighlight">
\[{\log_b x} = y \enspace if \enspace b^y = x\]</div>
<p>When one side of the equation contains a single logarithm, the
equation can be solved by rewriting the equation as an equivalent
exponential equation as defined above. But if one side contains
more than one logarithm, we need to use the properties of logarithm
to condense it into a single logarithm.</p>
<p>Take for example</p>
<div class="math notranslate nohighlight">
\[\log(2x) - 15 = 0\]</div>
<p>contains single logarithm, therefore we can directly rewrite it to
exponential form as</p>
<div class="math notranslate nohighlight">
\[x = \frac{e^{15}}{2}\]</div>
<p>But if the equation has more than one logarithm as</p>
<div class="math notranslate nohighlight">
\[\log(x - 3) + \log(x + 3) = 0\]</div>
<p>we use logarithmic identities to convert it into a reduced form</p>
<p>Using,</p>
<div class="math notranslate nohighlight">
\[\log(a) + \log(b) = \log(ab)\]</div>
<p>the equation becomes,</p>
<div class="math notranslate nohighlight">
\[\log((x - 3)(x + 3))\]</div>
<p>This equation contains one logarithm and can be solved by rewriting
to exponents.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solveset._is_logarithmic">
<code class="sig-prename descclassname">sympy.solvers.solveset.</code><code class="sig-name descname">_is_logarithmic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solveset.py#L1676-L1731"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset._is_logarithmic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">True</span></code> if the equation is in the form
<span class="math notranslate nohighlight">\(a\log(f(x)) + b\log(g(x)) + ... + c\)</span> else <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f</strong> : Expr</p>
<blockquote>
<div><p>The equation to be checked</p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable in which the equation is checked</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the equation is logarithmic otherwise <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">_is_logarithmic</span> <span class="k">as</span> <span class="n">check</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">tan</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Philosophy behind the helper</p></li>
</ul>
<p>The function extracts each term and checks whether it is
logarithmic w.r.t <code class="docutils literal notranslate"><span class="pre">symbol</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="diophantine-equations-des">
<h2>Diophantine Equations (DEs)<a class="headerlink" href="#diophantine-equations-des" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="diophantine.html#diophantine-docs"><span class="std std-ref">Diophantine</span></a></p>
</div>
<div class="section" id="inequalities">
<h2>Inequalities<a class="headerlink" href="#inequalities" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="inequalities.html#inequality-docs"><span class="std std-ref">Inequality Solvers</span></a></p>
</div>
<div class="section" id="ordinary-differential-equations-odes">
<h2>Ordinary Differential equations (ODEs)<a class="headerlink" href="#ordinary-differential-equations-odes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="ode.html#ode-docs"><span class="std std-ref">ODE</span></a>.</p>
</div>
<div class="section" id="partial-differential-equations-pdes">
<h2>Partial Differential Equations (PDEs)<a class="headerlink" href="#partial-differential-equations-pdes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="pde.html#pde-docs"><span class="std std-ref">PDE</span></a>.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solveset</a><ul>
<li><a class="reference internal" href="#what-s-wrong-with-solve">What’s wrong with solve():</a></li>
<li><a class="reference internal" href="#why-solveset">Why Solveset?</a></li>
<li><a class="reference internal" href="#why-do-we-use-sets-as-an-output-type">Why do we use Sets as an output type?</a></li>
<li><a class="reference internal" href="#input-api-of-solveset">Input API of <code class="docutils literal notranslate"><span class="pre">solveset</span></code></a></li>
<li><a class="reference internal" href="#what-is-this-domain-argument-about">What is this domain argument about?</a></li>
<li><a class="reference internal" href="#what-are-the-general-methods-employed-by-solveset-to-solve-an-equation">What are the general methods employed by solveset to solve an equation?</a></li>
<li><a class="reference internal" href="#how-do-we-manipulate-and-return-an-infinite-solution">How do we manipulate and return an infinite solution?</a></li>
<li><a class="reference internal" href="#how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution">How does <code class="docutils literal notranslate"><span class="pre">solveset</span></code> ensure that it is not returning any wrong solution?</a></li>
<li><a class="reference internal" href="#search-based-solver-and-step-by-step-solution">Search based solver and step-by-step solution</a></li>
<li><a class="reference internal" href="#how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known">How do we deal with cases where only some of the solutions are known?</a></li>
<li><a class="reference internal" href="#what-will-you-do-with-the-old-solve">What will you do with the old solve?</a></li>
<li><a class="reference internal" href="#how-are-symbolic-parameters-handled-in-solveset">How are symbolic parameters handled in solveset?</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#solveset-module-reference">Solveset Module Reference</a></li>
<li><a class="reference internal" href="#linear-eq-to-matrix">linear_eq_to_matrix</a></li>
<li><a class="reference internal" href="#linsolve">linsolve</a></li>
<li><a class="reference internal" href="#nonlinsolve">nonlinsolve</a></li>
<li><a class="reference internal" href="#transolve">transolve</a></li>
<li><a class="reference internal" href="#diophantine-equations-des">Diophantine Equations (DEs)</a></li>
<li><a class="reference internal" href="#inequalities">Inequalities</a></li>
<li><a class="reference internal" href="#ordinary-differential-equations-odes">Ordinary Differential equations (ODEs)</a></li>
<li><a class="reference internal" href="#partial-differential-equations-pdes">Partial Differential Equations (PDEs)</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="solvers.html"
                        title="previous chapter">Solvers</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../stats.html"
                        title="next chapter">Stats</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/solvers/solveset.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../stats.html" title="Stats"
             >next</a> |</li>
        <li class="right" >
          <a href="solvers.html" title="Solvers"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solveset</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 SymPy Development Team.
      Last updated on Oct 01, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>