

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Geometric Algebra Module for Sympy &mdash; SymPy v0.7.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="top" title="SymPy v0.7.1 documentation" href="../../../index.html" />
    <link rel="up" title="SymPy Modules Reference" href="../../index.html" />
    <link rel="next" title="Extended LaTeXModule for Sympy" href="../latex_ex/latex_ex.html" />
    <link rel="prev" title="Geometry Module" href="../../geometry.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../latex_ex/latex_ex.html" title="Extended LaTeXModule for Sympy"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../../geometry.html" title="Geometry Module"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">SymPy v0.7.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" accesskey="U">SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="geometric-algebra-module-for-sympy">
<h1>Geometric Algebra Module for Sympy<a class="headerlink" href="#geometric-algebra-module-for-sympy" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Alan Bromborsky</td>
</tr>
</tbody>
</table>
<div class="math">
\[\begin{split}\newcommand{\bfrac}[2]{\displaystyle\frac{#1}{#2}}
\newcommand{\lp}{\left (}
\newcommand{\rp}{\right )}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\llt}{\left &lt;}
\newcommand{\rgt}{\right &gt;}
\newcommand{\abs}[1]{\left |{#1}\right | }
\newcommand{\pdiff}[2]{\bfrac{\partial {#1}}{\partial {#2}}}
\newcommand{\lbrc}{\left \{}
\newcommand{\rbrc}{\right \}}
\newcommand{\W}{\wedge}
\newcommand{\R}{\dagger}
\newcommand{\lbrk}{\left [}
\newcommand{\rbrk}{\right ]}
\newcommand{\proj}[2]{\llt {#1} \rgt_{#2}}
\newcommand{\bm}{\boldsymbol}\end{split}\]</div>
<div class="topic">
<p class="topic-title first">Abstract</p>
<p>This document describes the implementation of a geometric algebra module in
python  that utilizes the <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt> symbolic algebra library.  The   python
module <tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt> has been developed for coordinate free calculations using
the operations (geometric, outer, and inner products etc.) of geometric algebra.
The operations can be defined using a completely arbitrary metric defined
by the inner products of a set of arbitrary vectors or the metric  can be
restricted to enforce orthogonality and signature constraints on the set of
vectors.  In addition the module includes the geometric, outer (curl) and inner
(div) derivatives and the ability to define a curvilinear coordinate  system.
The module requires the numpy and the sympy modules.</p>
</div>
<div class="section" id="what-is-geometric-algebra">
<h2>What is Geometric Algebra?<a class="headerlink" href="#what-is-geometric-algebra" title="Permalink to this headline">¶</a></h2>
<p>Geometric algebra is the Clifford algebra of a real finite dimensional vector
space or the algebra that  results when a real finite dimensional vector space
is extended with a product of vectors (geometric product) that is associative,
left and right distributive, and yields a real number for the square (geometric
product) of any vector [Hestenes,Lasenby].  The elements of the geometric
algebra are called multivectors and consist of the linear combination of
scalars, vectros, and the geometric product of two or more vectors. The
additional axioms  for the geometric algebra are that for any vectors <span class="math">\(a\)</span>,
<span class="math">\(b\)</span>, and <span class="math">\(c\)</span> in the base vector space:</p>
<div class="math">
\[\begin{equation*}
\begin{array}{c}
a\lp bc \rp = \lp ab \rp c \\
a\lp b+c \rp = ab+ac \\
\lp a + b \rp c = ac+bc \\
aa = a^{2} \in \Re
\end{array}
\end{equation*}\]</div><p>By induction these also apply to any multivectors.</p>
<p>Several software packages for numerical geometric algebra calculations are
available from Doran-Lazenby group and the Dorst group. Symbolic packages for
Clifford algebra using orthongonal bases such as
<span class="math">\(e_{i}e_{j}+e_{j}e_{i} = 2\eta_{ij}\)</span>, where <span class="math">\(\eta_{ij}\)</span> is a numeric
array are available in Maple and Mathematica. The symbolic algebra module,
<tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt>, developed for python does not depend on an orthogonal basis
representation, but rather is generated from a set of <span class="math">\(n\)</span> arbitrary
symbolic vectors,  <span class="math">\(a_{1},a_{2},\dots,a_{n}\)</span> and a symbolic metric
tensor <span class="math">\(g_{ij} = a_{i}\cdot a_{j}\)</span>.</p>
<p>In order not to reinvent the wheel all scalar symbolic algebra is handled by the
python module  <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt>.</p>
<p>The basic geometic algebra operations will be implemented in python by defining
a multivector  class, MV, and overloading the python operators in Table
<a class="reference internal" href="#table1"><em>1</em></a> where <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt>  are any two multivectors (In the case of
<tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">^</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt>, and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> the operation is also defined if <tt class="docutils literal"><span class="pre">A</span></tt> or
<tt class="docutils literal"><span class="pre">B</span></tt> is a sympy symbol or a sympy real number).</p>
<table border="1" class="docutils" id="table1">
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><blockquote class="first last">
<div>Operation</div></blockquote>
</th>
<th class="head"><blockquote class="first last">
<div>Result</div></blockquote>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><blockquote class="first last">
<div><tt class="docutils literal"><span class="pre">A+B</span></tt></div></blockquote>
</td>
<td><blockquote class="first last">
<div>sum of multivectors</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div><tt class="docutils literal"><span class="pre">A-B</span></tt></div></blockquote>
</td>
<td><blockquote class="first last">
<div>difference of multivectors</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div><tt class="docutils literal"><span class="pre">A*B</span></tt></div></blockquote>
</td>
<td><blockquote class="first last">
<div>geometric product</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div><tt class="docutils literal"><span class="pre">A^B</span></tt></div></blockquote>
</td>
<td><blockquote class="first last">
<div>outer product of multivectors</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div><tt class="docutils literal"><span class="pre">A|B</span></tt></div></blockquote>
</td>
<td><blockquote class="first last">
<div>inner product of multivectors</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div><tt class="docutils literal"><span class="pre">A&lt;B</span></tt> or <tt class="docutils literal"><span class="pre">A&lt;&lt;B</span></tt></div></blockquote>
</td>
<td><blockquote class="first last">
<div>left contraction of multivectors</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div><tt class="docutils literal"><span class="pre">A&gt;B</span></tt> or <tt class="docutils literal"><span class="pre">A&gt;&gt;B</span></tt></div></blockquote>
</td>
<td><blockquote class="first last">
<div>right contraction of multivectors</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>Table <a class="reference internal" href="#table1"><em>1</em></a>. Multivector operations for symbolicGA</p>
<p>The option to use <tt class="docutils literal"><span class="pre">&lt;</span></tt> or <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> for left contraction and <tt class="docutils literal"><span class="pre">&gt;</span></tt> or <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> is given since the <tt class="docutils literal"><span class="pre">&lt;</span></tt> and
<tt class="docutils literal"><span class="pre">&gt;</span></tt> operators do not have r-forms (there are no <em>__rlt__()</em> and <em>__rlt__()</em> functions to overload) while
<tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> do have r-forms so that <em>x &lt;&lt; A</em> and <em>x &gt;&gt; A</em> are allowed where <em>x</em> is a scalar (symbol or integer)
and <em>A</em> is a multivector. With <tt class="docutils literal"><span class="pre">&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;</span></tt> we can only have mixed modes (scalars and multivectors) if the
multivector is the first operand.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Except for <tt class="docutils literal"><span class="pre">&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;</span></tt> all the multivector operators have r-forms so that as long as one of the
operands, left or right, is a multivector the other can be a multivector or a scalar (sympy symbol or integer).</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Note that the operator order precedence is determined by python and is not
neccessarily that used by  geometric algebra. It is <strong>absolutely essential</strong> to
use parenthesis in multivector
expressions containing <tt class="docutils literal"><span class="pre">^</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and/or <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt>.  As an example let
<tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> be any two multivectors. Then <tt class="docutils literal"><span class="pre">A</span> <span class="pre">+</span> <span class="pre">A*B</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">+(A*B)</span></tt>, but
<tt class="docutils literal"><span class="pre">A+A^B</span> <span class="pre">=</span> <span class="pre">(2*A)^B</span></tt> since in python the <tt class="docutils literal"><span class="pre">^</span></tt> operator has a lower precedence
than the &#8216;+&#8217; operator.  In geometric algebra the outer and inner products and
the left and right contractions have a higher precedence than the geometric
product and the geometric product has a higher precedence than addition and
subtraction.  In python the <tt class="docutils literal"><span class="pre">^</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>, <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> all have a lower
precedence than <tt class="docutils literal"><span class="pre">+</span></tt> and <tt class="docutils literal"><span class="pre">-</span></tt> while <tt class="docutils literal"><span class="pre">*</span></tt> has a higher precedence than
<tt class="docutils literal"><span class="pre">+</span></tt> and <tt class="docutils literal"><span class="pre">-</span></tt>.</p>
</div>
</div>
<div class="section" id="vector-basis-and-metric">
<span id="vbm"></span><h2>Vector Basis and Metric<a class="headerlink" href="#vector-basis-and-metric" title="Permalink to this headline">¶</a></h2>
<p>The two structures that define the <a class="reference internal" href="#MV" title="MV"><tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt></a> (multivector) class are the
symbolic basis vectors and the  symbolic metric.  The symbolic basis
vectors are input as a string with the symbol name separated by spaces.  For
example if we are calculating the geometric algebra of a system with three
vectors that we wish to denote as <tt class="docutils literal"><span class="pre">a0</span></tt>, <tt class="docutils literal"><span class="pre">a1</span></tt>, and <tt class="docutils literal"><span class="pre">a2</span></tt> we would define the
string variable:</p>
<p><tt class="docutils literal"><span class="pre">basis</span> <span class="pre">=</span> <span class="pre">'a0</span> <span class="pre">a1</span> <span class="pre">a2'</span></tt></p>
<p>that would be input into the multivector setup function.  The next step would be
to define the symbolic  metric for the geometric algebra of the basis we
have defined. The default metric is the most general and is the matrix of
the following symbols</p>
<div class="math" id="equation-1">
<span id="eq1"></span>\[\begin{equation*}
g = \lbrk
\begin{array}{ccc}
  a0**2 & (a0.a1)  & (a0.a2) \\
  (a0.a1) & a1**2  & (a1.a2) \\
  (a0.a2) & (a1.a2) & a2**2 \\
\end{array}
\rbrk
\end{equation*}\]</div><p>where each of the <span class="math">\(g_{ij}\)</span> is a symbol representing all of the dot
products of the basis vectors. Note that the symbols are named so that
<span class="math">\(g_{ij} = g_{ji}\)</span> since for the symbol function
<span class="math">\((a0.a1) \ne (a1.a0)\)</span>.</p>
<p>Note that the strings shown in equation <a class="reference internal" href="#eq1"><em>1</em></a> are only used when the values
of <span class="math">\(g_{ij}\)</span> are output (printed).   In the <tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt> module (library)
the <span class="math">\(g_{ij}\)</span> symbols are stored in a static member list of the multivector
class <a class="reference internal" href="#MV" title="MV"><tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt></a> as the double list <em>MV.metric</em> (<span class="math">\(g_{ij}\)</span> = <em>MV.metric[i][j]</em>).</p>
<p>The default definition of <span class="math">\(g\)</span> can be overwritten by specifying a string
that will define <span class="math">\(g\)</span>. As an example  consider a symbolic representation
for conformal geometry. Define for a basis</p>
<p><tt class="docutils literal"><span class="pre">basis</span> <span class="pre">=</span> <span class="pre">'a0</span> <span class="pre">a1</span> <span class="pre">a2</span> <span class="pre">n</span> <span class="pre">nbar'</span></tt></p>
<p>and for a metric</p>
<p><tt class="docutils literal"><span class="pre">metric</span> <span class="pre">=</span> <span class="pre">'#</span> <span class="pre">#</span> <span class="pre">#</span> <span class="pre">0</span> <span class="pre">0,</span> <span class="pre">#</span> <span class="pre">#</span> <span class="pre">#</span> <span class="pre">0</span> <span class="pre">0,</span> <span class="pre">#</span> <span class="pre">#</span> <span class="pre">#</span> <span class="pre">0</span> <span class="pre">0,</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">2,</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span> <span class="pre">2</span> <span class="pre">0'</span></tt></p>
<p>then calling <span class="math">\(MV.setup(basis,metric)\)</span> would initialize</p>
<div class="math">
\[\begin{equation*}
g = \lbrk
\begin{array}{ccccc}
  a0**2 & (a0.a1)  & (a0.a2) & 0 & 0\\
  (a0.a1) & a1**2  & (a1.a2) & 0 & 0\\
  (a0.a2) & (a1.a2) & a2**2 & 0 & 0 \\
  0 & 0 & 0 & 0 & 2 \\
  0 & 0 & 0 & 2 & 0
\end{array}
\rbrk
\end{equation*}\]</div><p>Here we have specified that <span class="math">\(n\)</span> and <span class="math">\(nbar\)</span> are orthonal to all the
<span class="math">\(a\)</span>&#8216;s, <span class="math">\(n**2 = nbar**2 = 0\)</span>, and <span class="math">\((n.nbar) = 2\)</span>. Using
<span class="math">\(\#\)</span> in the metric definition string just tells the program to use the
default symbol for that value.</p>
<p>When <tt class="docutils literal"><span class="pre">MV.setup</span></tt> is called multivector representations of the basis local to
the program are instantiated.  For our first example that means that the
symbolic vectors named <tt class="docutils literal"><span class="pre">a0</span></tt>, <tt class="docutils literal"><span class="pre">a1</span></tt>, and <tt class="docutils literal"><span class="pre">a2</span></tt> are created and made available
to the programmer for future calculations.</p>
<p>In addition to the basis vectors the <span class="math">\(g_{ij}\)</span> are also made available to
the programer with the following convention. If <tt class="docutils literal"><span class="pre">a0</span></tt> and <tt class="docutils literal"><span class="pre">a1</span></tt> are basis
vectors, then their dot products are denoted by  <tt class="docutils literal"><span class="pre">a0sq</span></tt>, <tt class="docutils literal"><span class="pre">a2sq</span></tt>, and
<tt class="docutils literal"><span class="pre">a0dota1</span></tt> for use as python program varibles. If you print  <tt class="docutils literal"><span class="pre">a0sq</span></tt> the
output would be <tt class="docutils literal"><span class="pre">a0**2</span></tt> and the output for <tt class="docutils literal"><span class="pre">a0dota1</span></tt> would be <tt class="docutils literal"><span class="pre">(a0.a1)</span></tt> as
shown in equation <a class="reference internal" href="#eq1"><em>1</em></a>.  If the default value are overridden the new
values are output by print.  For examle if <span class="math">\(g_{00} = 0\)</span> then &#8220;<tt class="docutils literal"><span class="pre">print</span>
<span class="pre">a0sq</span></tt>&#8221; would output &#8220;0.&#8221;</p>
<p>More generally, if <tt class="docutils literal"><span class="pre">metric</span></tt> is not a string, but a list of lists or a two
dimension numpy array, it is assumed that each element of <tt class="docutils literal"><span class="pre">metric</span></tt> is symbolic
variable so that the <span class="math">\(g_{ij}\)</span> could be defined as symbolic functions as
well as variables. For example instead of letting <span class="math">\(g_{01} = (a0.a1)\)</span> we
could have  <span class="math">\(g_{01} = cos(theta)\)</span> where we use a symbolic <span class="math">\(\cos\)</span>
function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Additionally <tt class="docutils literal"><span class="pre">MV.setup</span></tt> has an option for an othogonal basis where the signature
of the metric space is defined by a string.  For example if the signature of the
vector space is <span class="math">\((1,1,1)\)</span> (Euclidian 3-space) set</p>
<p><tt class="docutils literal"><span class="pre">metric</span> <span class="pre">=</span> <span class="pre">'[1,1,1]'</span></tt></p>
<p>Likewise if the signature is that of spacetime, <span class="math">\((1,-1,-1,-1)\)</span> then define</p>
<p class="last"><tt class="docutils literal"><span class="pre">metric</span> <span class="pre">=</span> <span class="pre">'[1,-1,-1,-1]'</span></tt>.</p>
</div>
</div>
<div class="section" id="representation-and-reduction-of-multivector-bases">
<h2>Representation and Reduction of Multivector Bases<a class="headerlink" href="#representation-and-reduction-of-multivector-bases" title="Permalink to this headline">¶</a></h2>
<p>In our symbolic geometric algebra we assume that all multivectors of interest to
us can be obtained from the symbolic basis vectors we have input, via the
different operations available to geometric algebra. The first problem we have
is representing the general multivector in terms terms of the basis vectors.  To
do this we  form the ordered geometric products of the basis vectors and develop
an internal representation of these  products in terms of python classes.  The
ordered geometric products are all multivectors of the form
<span class="math">\(a_{i_{1}}a_{i_{2}}\dots a_{i_{r}}\)</span> where <span class="math">\(i_{1}&lt;i_{2}&lt;\dots &lt;i_{r}\)</span>
and <span class="math">\(r \le n\)</span>. We call these multivectors bases and represent them
internally with the list of integers
<span class="math">\(\lbrk i_{1},i_{2},\dots,i_{r}\rbrk\)</span>. The bases are labeled, for the
purpose of output display, with strings that are concatenations of the strings
representing the basis vectors.  So that in our example  <tt class="docutils literal"><span class="pre">[1,2]</span></tt> would be
labeled with the string <tt class="docutils literal"><span class="pre">'a1a2'</span></tt> and represents the geometric product
<tt class="docutils literal"><span class="pre">a1*a2</span></tt>. Thus the list <tt class="docutils literal"><span class="pre">[0,1,2]</span></tt> represents <tt class="docutils literal"><span class="pre">a0*a1*a2</span></tt>.For our example the
complete set of bases and labels are shown in Table <a class="reference internal" href="#table2"><em>2</em></a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The empty list, <tt class="docutils literal"><span class="pre">[]</span></tt>, represents the scalar 1.</p>
</div>
<div class="highlight-python" id="table2"><div class="highlight"><pre><span class="n">MV</span><span class="o">.</span><span class="n">basislabel</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a0&#39;</span><span class="p">,</span> <span class="s">&#39;a1&#39;</span><span class="p">,</span> <span class="s">&#39;a2&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;a0a1&#39;</span><span class="p">,</span> <span class="s">&#39;a0a2&#39;</span><span class="p">,</span> <span class="s">&#39;a1a2&#39;</span><span class="p">],</span>
                 <span class="p">[</span><span class="s">&#39;a0a1a2&#39;</span><span class="p">]]</span>
<span class="n">MV</span><span class="o">.</span><span class="n">basis</span>      <span class="o">=</span> <span class="p">[[],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
                 <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]]</span>
</pre></div>
</div>
<p>Table <a class="reference internal" href="#table2"><em>2</em></a>. Multivector basis labels and internal basis representation.</p>
<p>Since there are <span class="math">\(2^{n}\)</span> bases and the number of bases with equal list
lengths is the same as for the  grade decomposition of a dimension <span class="math">\(n\)</span>
geometric algebra we will call the collections of bases of equal length
<tt class="docutils literal"><span class="pre">psuedogrades</span></tt>.</p>
<p>The critical operation in setting up the geometric algebra module is reducing
the geomertric product of any two bases to a linear combination of bases so that
we can calculate a multiplication table for the bases.   First we represent the
product as the concatenation of two base lists.  For example <tt class="docutils literal"><span class="pre">a1a2*a0a1</span></tt> is
represented by the list <tt class="docutils literal"><span class="pre">[1,2]+[0,1]</span> <span class="pre">=</span> <span class="pre">[1,2,0,1]</span></tt>. The representation of the
product is reduced via two operations, contraction and revision. The state of
the reduction is saved in two lists of equal length.  The first list contains
symbolic scale factors (symbol or numeric types) for the corresponding interger
list representing the product of  bases.  If we wish to reduce
<span class="math">\(\lbrk i_{1},\dots,i_{r}\rbrk\)</span> the starting point is the coefficient list
<span class="math">\(C = \lbrk 1 \rbrk\)</span> and the bases list
<span class="math">\(B = \lbrk \lbrk i_{1},\dots,i_{r}\rbrk \rbrk\)</span>.  We now operate  on each
element of the lists as follows:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">contraction</span></tt>: Consider a basis list <span class="math">\(B\)</span> with element
<span class="math">\(B[j] = \lbrk i_{1},\dots,i_{l},i_{l+1},\dots,i_{s}\rbrk\)</span> where
<span class="math">\(i_{l} = i_{l+1}\)</span>. Then the product of the <span class="math">\(l\)</span> and <span class="math">\(l+1\)</span> terms
result in a scalar and <span class="math">\(B[j]\)</span> is replaced by the new list representation
<span class="math">\(\lbrk i_{1},\dots,i_{l-1},i_{l+2},\dots,i_{r}\rbrk\)</span> which is of  psuedo
grade <span class="math">\(r-2\)</span> and <span class="math">\(C[j]\)</span> is replaced by the symbol
<span class="math">\(g_{i_{l}i_{l}}C[j]\)</span>.</li>
<li><tt class="docutils literal"><span class="pre">revision</span></tt>: Consider a basis list <span class="math">\(B\)</span> with element
<span class="math">\(B[j] = \lbrk i_{1},\dots,i_{l},i_{l+1},\dots,i_{s}\rbrk\)</span> where
<span class="math">\(i_{l} &gt; i_{l+1}\)</span>. Then the <span class="math">\(l\)</span> and <span class="math">\(l+1\)</span> elements must be
reversed to be put in normal order, but we have <span class="math">\(a_{i_{l}}a_{i_{l+1}} = 2g_{i_{l}i_{l+1}}-a_{i_{l+1}}a_{i_{l}}\)</span>
(From the geometric  algebra definition of the dot product of two vectors). Thus
we append the list representing the reduced element,
<span class="math">\(\lbrk i_{1},\dots,i_{l-1},i_{l+2},\dots,i_{s}\rbrk\)</span>, to the pseudo bases
list, <span class="math">\(B\)</span>, and append <span class="math">\(2g_{i{l}i_{l+1}}C[j]\)</span> to the coefficients
list, then  we replace <span class="math">\(B[j]\)</span> with
<span class="math">\(\lbrk i_{1},\dots,i_{l+1},i_{l},\dots,i_{s}\rbrk\)</span>  and <span class="math">\(C[j]\)</span> with
<span class="math">\(-C[j]\)</span>. Both lists are increased by one element if
<span class="math">\(g_{i_{l}i_{l+1}} \ne 0\)</span>.</li>
</ul>
<p>These processes are repeated untill every basis list in <span class="math">\(B\)</span> is in normal
(ascending) order with no repeated elements.  Then the coefficents of equivalent
bases are summed and the bases sorted according to psuedograde and ascending
order.  We now have a way of calculating the geometric product of any two bases
as a symbolic linear combination of all the bases with the coefficients
determined by <span class="math">\(g\)</span>. The base multiplication table for our simple example of
three vectors is given by (the coefficient of each psuedo base is enclosed with
{} for clarity):</p>
<div class="highlight-python"><pre>(1)(1) = 1
(1)(a0) = a0
(1)(a1) = a1
(1)(a2) = a2
(1)(a0a1) = a0a1
(1)(a0a2) = a0a2
(1)(a1a2) = a1a2
(1)(a0a1a2) = a0a1a2

(a0)(1) = a0
(a0)(a0) = {a0**2}1
(a0)(a1) = a0a1
(a0)(a2) = a0a2
(a0)(a0a1) = {a0**2}a1
(a0)(a0a2) = {a0**2}a2
(a0)(a1a2) = a0a1a2
(a0)(a0a1a2) = {a0**2}a1a2

(a1)(1) = a1
(a1)(a0) = {2*(a0.a1)}1-a0a1
(a1)(a1) = {a1**2}1
(a1)(a2) = a1a2
(a1)(a0a1) = {-a1**2}a0+{2*(a0.a1)}a1
(a1)(a0a2) = {2*(a0.a1)}a2-a0a1a2
(a1)(a1a2) = {a1**2}a2
(a1)(a0a1a2) = {-a1**2}a0a2+{2*(a0.a1)}a1a2

(a2)(1) = a2
(a2)(a0) = {2*(a0.a2)}1-a0a2
(a2)(a1) = {2*(a1.a2)}1-a1a2
(a2)(a2) = {a2**2}1
(a2)(a0a1) = {-2*(a1.a2)}a0+{2*(a0.a2)}a1+a0a1a2
(a2)(a0a2) = {-a2**2}a0+{2*(a0.a2)}a2
(a2)(a1a2) = {-a2**2}a1+{2*(a1.a2)}a2
(a2)(a0a1a2) = {a2**2}a0a1+{-2*(a1.a2)}a0a2+{2*(a0.a2)}a1a2

(a0a1)(1) = a0a1
(a0a1)(a0) = {2*(a0.a1)}a0+{-a0**2}a1
(a0a1)(a1) = {a1**2}a0
(a0a1)(a2) = a0a1a2
(a0a1)(a0a1) = {-a0**2*a1**2}1+{2*(a0.a1)}a0a1
(a0a1)(a0a2) = {2*(a0.a1)}a0a2+{-a0**2}a1a2
(a0a1)(a1a2) = {a1**2}a0a2
(a0a1)(a0a1a2) = {-a0**2*a1**2}a2+{2*(a0.a1)}a0a1a2

(a0a2)(1) = a0a2
(a0a2)(a0) = {2*(a0.a2)}a0+{-a0**2}a2
(a0a2)(a1) = {2*(a1.a2)}a0-a0a1a2
(a0a2)(a2) = {a2**2}a0
(a0a2)(a0a1) = {-2*a0**2*(a1.a2)}1+{2*(a0.a2)}a0a1+{a0**2}a1a2
(a0a2)(a0a2) = {-a0**2*a2**2}1+{2*(a0.a2)}a0a2
(a0a2)(a1a2) = {-a2**2}a0a1+{2*(a1.a2)}a0a2
(a0a2)(a0a1a2) = {a0**2*a2**2}a1+{-2*a0**2*(a1.a2)}a2+{2*(a0.a2)}a0a1a2

(a1a2)(1) = a1a2
(a1a2)(a0) = {2*(a0.a2)}a1+{-2*(a0.a1)}a2+a0a1a2
(a1a2)(a1) = {2*(a1.a2)}a1+{-a1**2}a2
(a1a2)(a2) = {a2**2}a1
(a1a2)(a0a1) = {2*a1**2*(a0.a2)-4*(a0.a1)*(a1.a2)}1+{2*(a1.a2)}a0a1+{-a1**2}a0a2
              +{2*(a0.a1)}a1a2
(a1a2)(a0a2) = {-2*a2**2*(a0.a1)}1+{a2**2}a0a1+{2*(a0.a2)}a1a2
(a1a2)(a1a2) = {-a1**2*a2**2}1+{2*(a1.a2)}a1a2
(a1a2)(a0a1a2) = {-a1**2*a2**2}a0+{2*a2**2*(a0.a1)}a1+{2*a1**2*(a0.a2)
                -4*(a0.a1)*(a1.a2)}a2+{2*(a1.a2)}a0a1a2

(a0a1a2)(1) = a0a1a2
(a0a1a2)(a0) = {2*(a0.a2)}a0a1+{-2*(a0.a1)}a0a2+{a0**2}a1a2
(a0a1a2)(a1) = {2*(a1.a2)}a0a1+{-a1**2}a0a2
(a0a1a2)(a2) = {a2**2}a0a1
(a0a1a2)(a0a1) = {2*a1**2*(a0.a2)-4*(a0.a1)*(a1.a2)}a0+{2*a0**2*(a1.a2)}a1
                +{-a0**2*a1**2}a2+{2*(a0.a1)}a0a1a2
(a0a1a2)(a0a2) = {-2*a2**2*(a0.a1)}a0+{a0**2*a2**2}a1+{2*(a0.a2)}a0a1a2
(a0a1a2)(a1a2) = {-a1**2*a2**2}a0+{2*(a1.a2)}a0a1a2
(a0a1a2)(a0a1a2) = {-a0**2*a1**2*a2**2}1+{2*a2**2*(a0.a1)}a0a1+{2*a1**2*(a0.a2)
                  -4*(a0.a1)*(a1.a2)}a0a2+{2*a0**2*(a1.a2)}a1a2</pre>
</div>
</div>
<div class="section" id="base-representation-of-multivectors">
<h2>Base Representation of Multivectors<a class="headerlink" href="#base-representation-of-multivectors" title="Permalink to this headline">¶</a></h2>
<p>In terms of the bases defined an arbitrary multivector can be represented as a
list of arrays  (we use the numpy python module to implement arrays).   If we
have <span class="math">\(n\)</span> basis vectors we initialize the list <tt class="docutils literal"><span class="pre">self.mv</span> <span class="pre">=</span> <span class="pre">[0,0,...,0]</span></tt>
with <span class="math">\(n+1\)</span> integers all zero.   Each zero is a placeholder for an array of
python objects (in this case the objects will be sympy  symbol objects). If
<tt class="docutils literal"><span class="pre">self.mv[r]</span> <span class="pre">=</span> <span class="pre">numpy.array([list</span> <span class="pre">of</span> <span class="pre">symbol</span> <span class="pre">objects])</span></tt> each entry in the
<tt class="docutils literal"><span class="pre">numpy.array</span></tt> will be a coefficient of the corresponding psuedo base.
<tt class="docutils literal"><span class="pre">self.mv[r]</span> <span class="pre">=</span> <span class="pre">0</span></tt> indicates that the coefficients of every base of psuedo grade
<span class="math">\(r\)</span> are 0.  The length of the array <tt class="docutils literal"><span class="pre">self.mv[r]</span></tt> is <span class="math">\(n \choose r\)</span>
the binomial coefficient. For example the psuedo basis vector <tt class="docutils literal"><span class="pre">a1</span></tt> would be
represented as a multivector by the list:</p>
<p><tt class="docutils literal"><span class="pre">a1.mv</span> <span class="pre">=</span> <span class="pre">[0,numpy.array([numeric(0),numeric(1),numeric(0)]),0,0]</span></tt></p>
<p>and <tt class="docutils literal"><span class="pre">a0a1a2</span></tt> by:</p>
<p><tt class="docutils literal"><span class="pre">a0a1a2.mv</span> <span class="pre">=</span> <span class="pre">[0,0,0,numpy.array([numeric(1)])]</span></tt></p>
<p>The array is stuffed with sympy numeric objects instead of python integers so
that we can perform symbolically manipulate sympy expressions that consist of
scalar algebraic symbols and exact rational numbers which sympy can also
represent.</p>
<p>The <tt class="docutils literal"><span class="pre">numpy.array</span></tt> is used because operations of addition, substraction, and
multiplication by an object are defined for the array if they are defined for
the objects making up the array, which they are by sympy.  We call this
representation a base type because the <tt class="docutils literal"><span class="pre">r</span></tt> index is not a grade index since
the bases we are using are not blades. In a blade representation the structure
would be identical, but the bases would be replaced by  blades and
<tt class="docutils literal"><span class="pre">self.mv[r]</span></tt> would represent the <tt class="docutils literal"><span class="pre">r</span></tt> grade components of the multivector.
The first use of the base representation is to store the results of the
multiplication tabel for the bases in the class variable <tt class="docutils literal"><span class="pre">MV.mtabel</span></tt>.  This
variable is a group of nested lists so that the geometric product of the
<tt class="docutils literal"><span class="pre">igrade</span></tt> and  <tt class="docutils literal"><span class="pre">ibase</span></tt> with the <tt class="docutils literal"><span class="pre">jgrade</span></tt> and <tt class="docutils literal"><span class="pre">jbase</span></tt> is
<tt class="docutils literal"><span class="pre">MV.mtabel[igrade][ibase][jgrade][jbase]</span></tt>.  We can then use this table to
calculate the geometric product of any two multivectors.</p>
</div>
<div class="section" id="blade-representation-of-multivectors">
<h2>Blade Representation of Multivectors<a class="headerlink" href="#blade-representation-of-multivectors" title="Permalink to this headline">¶</a></h2>
<p>Since we can now calculate the symbolic geometric product of any two
multivectors we can also calculate the blades corresponding to the product of
the symbolic basis vectors using the formula</p>
<div class="math">
\[\begin{equation*}
  A_{r}\W b = \half\lp A_{r}b-\lp -1 \rp^{r}bA_{r} \rp,
\end{equation*}\]</div><p>where <span class="math">\(A_{r}\)</span> is a multivector of grade <span class="math">\(r\)</span> and <span class="math">\(b\)</span> is a
vector.  For our example basis the result  is shown in Table <a class="reference internal" href="#table3"><em>3</em></a>.</p>
<div class="highlight-python" id="table3"><pre>1 = 1
a0 = a0
a1 = a1
a2 = a2
a0^a1 = {-(a0.a1)}1+a0a1
a0^a2 = {-(a0.a2)}1+a0a2
a1^a2 = {-(a1.a2)}1+a1a2
a0^a1^a2 = {-(a1.a2)}a0+{(a0.a2)}a1+{-(a0.a1)}a2+a0a1a2</pre>
</div>
<p>Table <a class="reference internal" href="#table3"><em>3</em></a>. Bases blades in terms of bases.</p>
<p>The important thing to notice about Table <a class="reference internal" href="#table3"><em>3</em></a> is that it is a
triagonal (lower triangular) system of equations so that using a simple back
substitution algorithym we can solve for the psuedo bases in terms of the blades
giving Table <a class="reference internal" href="#table4"><em>4</em></a>.</p>
<div class="highlight-python" id="table4"><pre>1 = 1
a0 = a0
a1 = a1
a2 = a2
a0a1 = {(a0.a1)}1+a0^a1
a0a2 = {(a0.a2)}1+a0^a2
a1a2 = {(a1.a2)}1+a1^a2
a0a1a2 = {(a1.a2)}a0+{-(a0.a2)}a1+{(a0.a1)}a2+a0^a1^a2</pre>
</div>
<p>Table <a class="reference internal" href="#table4"><em>4</em></a>. Bases in terms of basis blades.</p>
<p>Using Table <a class="reference internal" href="#table4"><em>4</em></a> and simple substitution we can convert from a base
multivector representation to a blade representation.  Likewise, using Table
<a class="reference internal" href="#table3"><em>3</em></a> we can convert from  blades to bases.</p>
<p>Using the blade representation it becomes simple to program functions that will
calculate the grade projection, reverse, even, and odd multivector functions.</p>
<p>Note that in the multivector class <tt class="docutils literal"><span class="pre">MV</span></tt> there is a class variable for each
instantiation, <tt class="docutils literal"><span class="pre">self.bladeflg</span></tt>, that is set to zero for a base representation
and 1 for a blade representation.  One needs to keep track of which
representation is in use since various multivector operations require conversion
from one representation to the other.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">When the geometric product of two multivectors is calculated the module looks to
see if either multivector is in blade representation.  If either is the result of
the geometric product is converted to a blade representation.  One result of this
is that if either of the multivectors is a simple vector (which is automatically a
blade) the result will be in a blade representation.  If <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are vectors
then the result <tt class="docutils literal"><span class="pre">a*b</span></tt> will be <tt class="docutils literal"><span class="pre">(a.b)+a^b</span></tt> or simply <tt class="docutils literal"><span class="pre">a^b</span></tt> if <tt class="docutils literal"><span class="pre">(a.b)</span> <span class="pre">=</span> <span class="pre">0</span></tt>.</p>
</div>
</div>
<div class="section" id="outer-and-inner-products-left-and-right-contractions">
<h2>Outer and Inner Products, Left and Right Contractions<a class="headerlink" href="#outer-and-inner-products-left-and-right-contractions" title="Permalink to this headline">¶</a></h2>
<p>In geometric algebra any general multivector <span class="math">\(A\)</span> can be decomposed into
pure grade  multivectors (a linear combination of blades of all the same order)
so that in a <span class="math">\(n\)</span>-dimensional vector space</p>
<div class="math">
\[\begin{equation*}
A = \sum_{r = 0}^{n}A_{r}
\end{equation*}\]</div><p>The geometric product of two pure grade multivectors <span class="math">\(A_{r}\)</span> and
<span class="math">\(B_{s}\)</span> has the form</p>
<div class="math">
\[\begin{equation*}
A_{r}B_{s} = \proj{A_{r}B_{s}}{\abs{r-s}}+\proj{A_{r}B_{s}}{\abs{r-s}+2}+\cdots+\proj{A_{r}B_{s}}{r+s}
\end{equation*}\]</div><p>where <span class="math">\(\proj{}{t}\)</span> projects the <span class="math">\(t\)</span> grade components of the
multivector argument.  The   inner and outer products of <span class="math">\(A_{r}\)</span> and
<span class="math">\(B_{s}\)</span> are then defined to be</p>
<div class="math">
\[\begin{equation*}
A_{r}\cdot B_{s} = \proj{A_{r}B_{s}}{\abs{r-s}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
A_{r}\wedge B_{s} = \proj{A_{r}B_{s}}{r+s}
\end{equation*}\]</div><p>and</p>
<div class="math">
\[\begin{equation*}
A\cdot B = \sum_{r,s}A_{r}\cdot B_{s}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
A\wedge B = \sum_{r,s}A_{r}\wedge B_{s}
\end{equation*}\]</div><p>Likewise the right (<span class="math">\(\lfloor\)</span>) and left (<span class="math">\(\rfloor\)</span>) contractions are defined as</p>
<div class="math">
\[\begin{equation*}
A_{r}\lfloor B_{s} = \left \{ \begin{array}{cc}
   \proj{A_{r}B_{s}}{r-s} &  r \ge s \\
             0            &  r < s \end{array} \right \}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
A_{r}\rfloor B_{s} = \left \{ \begin{array}{cc}
   \proj{A_{r}B_{s}}{s-r} &  s \ge r \\
             0            &  s < r \end{array} \right \}
\end{equation*}\]</div><p>and</p>
<div class="math">
\[\begin{equation*}
A\lfloor B = \sum_{r,s}A_{r}\lfloor B_{s}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
A\rfloor B = \sum_{r,s}A_{r}\rfloor B_{s}
\end{equation*}\]</div><p>The <tt class="docutils literal"><span class="pre">MV</span></tt> class function for the outer product of the multivectors <tt class="docutils literal"><span class="pre">mv1</span></tt> and
<tt class="docutils literal"><span class="pre">mv2</span></tt> is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">outer_product</span><span class="p">(</span><span class="n">mv1</span><span class="p">,</span><span class="n">mv2</span><span class="p">):</span>
     <span class="n">product</span> <span class="o">=</span> <span class="n">MV</span><span class="p">()</span>
     <span class="n">product</span><span class="o">.</span><span class="n">bladeflg</span> <span class="o">=</span> <span class="mi">1</span>
     <span class="n">mv1</span><span class="o">.</span><span class="n">convert_to_blades</span><span class="p">()</span>
     <span class="n">mv2</span><span class="o">.</span><span class="n">convert_to_blades</span><span class="p">()</span>
     <span class="k">for</span> <span class="n">igrade1</span> <span class="ow">in</span> <span class="n">MV</span><span class="o">.</span><span class="n">n1rg</span><span class="p">:</span>
         <span class="k">if</span> <span class="ow">not</span> <span class="n">isint</span><span class="p">(</span><span class="n">mv1</span><span class="o">.</span><span class="n">mv</span><span class="p">[</span><span class="n">igrade1</span><span class="p">]):</span>
             <span class="n">pg1</span> <span class="o">=</span> <span class="n">mv1</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">igrade1</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">igrade2</span> <span class="ow">in</span> <span class="n">MV</span><span class="o">.</span><span class="n">n1rg</span><span class="p">:</span>
                 <span class="n">igrade</span> <span class="o">=</span> <span class="n">igrade1</span><span class="o">+</span><span class="n">igrade2</span>
                 <span class="k">if</span> <span class="n">igrade</span> <span class="o">&lt;=</span> <span class="n">MV</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="n">isint</span><span class="p">(</span><span class="n">mv2</span><span class="o">.</span><span class="n">mv</span><span class="p">[</span><span class="n">igrade2</span><span class="p">]):</span>
                         <span class="n">pg2</span> <span class="o">=</span> <span class="n">mv2</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">igrade2</span><span class="p">)</span>
                         <span class="n">pg1pg2</span> <span class="o">=</span> <span class="n">pg1</span><span class="o">*</span><span class="n">pg2</span>
                         <span class="n">product</span><span class="o">.</span><span class="n">add_in_place</span><span class="p">(</span><span class="n">pg1pg2</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">igrade</span><span class="p">))</span>
     <span class="k">return</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
</pre></div>
</div>
<p>The steps for calculating the outer product are:</p>
<ol class="arabic simple">
<li>Convert <tt class="docutils literal"><span class="pre">mv1</span></tt> and <tt class="docutils literal"><span class="pre">mv2</span></tt> to blade representation if they are not already
in that form.</li>
<li>Project and loop through each grade <tt class="docutils literal"><span class="pre">mv1.mv[i1]</span></tt> and <tt class="docutils literal"><span class="pre">mv2.mv[i2]</span></tt>.</li>
<li>Calculate the geometric product <tt class="docutils literal"><span class="pre">pg1*pg2</span></tt>.</li>
<li>Project the <tt class="docutils literal"><span class="pre">i1+i2</span></tt> grade from <tt class="docutils literal"><span class="pre">pg1*pg2</span></tt>.</li>
<li>Accumulate the results for each pair of grades in the input multivectors.</li>
</ol>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In the  <tt class="docutils literal"><span class="pre">MV</span></tt> class we have overloaded the <tt class="docutils literal"><span class="pre">^</span></tt> operator to represent the outer
product so that instead of calling the outer product function we can write <tt class="docutils literal"><span class="pre">mv1^</span> <span class="pre">mv2</span></tt>.
Due to the precedence rules for python it is <strong>absolutely essential</strong> to enclose outer products
in parenthesis.</p>
</div>
<p>For the inner product of the multivectors <tt class="docutils literal"><span class="pre">mv1</span></tt> and <tt class="docutils literal"><span class="pre">mv2</span></tt> the <tt class="docutils literal"><span class="pre">MV</span></tt> class
function is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">inner_product</span><span class="p">(</span><span class="n">mv1</span><span class="p">,</span><span class="n">mv2</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s">&#39;s&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MV.inner_product(mv1,mv2) calculates the inner</span>

<span class="sd">    mode = &#39;s&#39; - symmetic (Doran &amp; Lasenby)</span>
<span class="sd">    mode = &#39;l&#39; - left contraction (Dorst)</span>
<span class="sd">    mode = &#39;r&#39; - right contraction (Dorst)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mv1</span><span class="p">,</span><span class="n">MV</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mv2</span><span class="p">,</span><span class="n">MV</span><span class="p">):</span>
        <span class="n">product</span> <span class="o">=</span> <span class="n">MV</span><span class="p">()</span>
        <span class="n">product</span><span class="o">.</span><span class="n">bladeflg</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">mv1</span><span class="o">.</span><span class="n">convert_to_blades</span><span class="p">()</span>
        <span class="n">mv2</span><span class="o">.</span><span class="n">convert_to_blades</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">igrade1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">n1</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mv1</span><span class="o">.</span><span class="n">mv</span><span class="p">[</span><span class="n">igrade1</span><span class="p">],</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">pg1</span> <span class="o">=</span> <span class="n">mv1</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">igrade1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">igrade2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MV</span><span class="o">.</span><span class="n">n1</span><span class="p">):</span>
                    <span class="n">igrade</span> <span class="o">=</span> <span class="n">igrade1</span><span class="o">-</span><span class="n">igrade2</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span><span class="p">:</span>
                        <span class="n">igrade</span> <span class="o">=</span> <span class="n">igrade</span><span class="o">.</span><span class="n">__abs__</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;l&#39;</span><span class="p">:</span>
                            <span class="n">igrade</span> <span class="o">=</span> <span class="o">-</span><span class="n">igrade</span>
                    <span class="k">if</span> <span class="n">igrade</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mv2</span><span class="o">.</span><span class="n">mv</span><span class="p">[</span><span class="n">igrade2</span><span class="p">],</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                            <span class="n">pg2</span> <span class="o">=</span> <span class="n">mv2</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">igrade2</span><span class="p">)</span>
                            <span class="n">pg1pg2</span> <span class="o">=</span> <span class="n">pg1</span><span class="o">*</span><span class="n">pg2</span>
                            <span class="n">product</span><span class="o">.</span><span class="n">add_in_place</span><span class="p">(</span><span class="n">pg1pg2</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">igrade</span><span class="p">))</span>
        <span class="k">return</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mv1</span><span class="p">,</span><span class="n">MV</span><span class="p">):</span>
                <span class="n">product</span> <span class="o">=</span> <span class="n">mv1</span><span class="o">.</span><span class="n">scalar_mul</span><span class="p">(</span><span class="n">mv2</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mv2</span><span class="p">,</span><span class="n">MV</span><span class="p">):</span>
                <span class="n">product</span> <span class="o">=</span> <span class="n">mv2</span><span class="o">.</span><span class="n">scalar_mul</span><span class="p">(</span><span class="n">mv1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">product</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
</pre></div>
</div>
<p>The inner product is calculated the same way as the outer product except that in
step 4, <tt class="docutils literal"><span class="pre">i1+i2</span></tt> is replaced by <tt class="docutils literal"><span class="pre">abs(i1-i2)</span></tt> or <tt class="docutils literal"><span class="pre">i1-i2</span></tt> for the right contraction or
<tt class="docutils literal"><span class="pre">i2-i1</span></tt> for the left contraction.  If <tt class="docutils literal"><span class="pre">i1-i2</span></tt> is less than zero there is no contribution
to the right contraction.  If <tt class="docutils literal"><span class="pre">i2-i1</span></tt> is less than zero there is no contribution to the
left contraction.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In the <tt class="docutils literal"><span class="pre">MV</span></tt> class we have overloaded the <tt class="docutils literal"><span class="pre">|</span></tt> operator for the inner product,
<tt class="docutils literal"><span class="pre">&gt;</span></tt> operator for the right contraction, and <tt class="docutils literal"><span class="pre">&lt;</span></tt> operator for the left contraction.
Instead of calling the inner product function we can write <tt class="docutils literal"><span class="pre">mv1|mv2</span></tt>, <tt class="docutils literal"><span class="pre">mv1&gt;mv2</span></tt>, or
<tt class="docutils literal"><span class="pre">mv1&lt;mv2</span></tt> respectively for the inner product, right contraction, or left contraction.
Again, due to the precedence rules for python it is <strong>absolutely essential</strong> to enclose inner
products and/or contractions in parenthesis.</p>
</div>
</div>
<div class="section" id="reverse-of-multivector">
<span id="reverse"></span><h2>Reverse of Multivector<a class="headerlink" href="#reverse-of-multivector" title="Permalink to this headline">¶</a></h2>
<p>If <span class="math">\(A\)</span> is the geometric product of <span class="math">\(r\)</span> vectors</p>
<div class="math">
\[\begin{equation*}
  A = a_{1}\dots a_{r}
\end{equation*}\]</div><p>then the reverse of <span class="math">\(A\)</span> designated <span class="math">\(A^{\R}\)</span> is defined by</p>
<div class="math">
\[\begin{equation*}
  A^{\R} \equiv a_{r}\dots a_{1}.
\end{equation*}\]</div><p>The reverse is simply the product with the order of terms reversed.  The reverse
of a sum of products is defined as the sum of the reverses so that for a general
multivector A we have</p>
<div class="math">
\[\begin{equation*}
  A^{\R} = \sum_{i=0}^{N} \proj{A}{i}^{\R}
\end{equation*}\]</div><p>but</p>
<div class="math" id="equation-2">
<span id="eq14"></span>\[\begin{equation*}
  \proj{A}{i}^{\R} = \lp -1\rp^{\frac{i\lp i-1\rp}{2}}\proj{A}{i}
\end{equation*}\]</div><p>which is proved by expanding the blade bases in terms of orthogonal vectors and
showing that equation <a class="reference internal" href="#eq14"><em>2</em></a> holds for the geometric product of orthogonal
vectors.</p>
<p>The reverse is important in the theory of rotations in <span class="math">\(n\)</span>-dimensions.  If
<span class="math">\(R\)</span> is the product of an even number of vectors and <span class="math">\(RR^{\R} = 1\)</span>
then <span class="math">\(RaR^{\R}\)</span> is a composition of rotations of the  vector <span class="math">\(a\)</span>.
If <span class="math">\(R\)</span> is the product of two vectors then the plane that <span class="math">\(R\)</span> defines
is the plane of the rotation.  That is to say that <span class="math">\(RaR^{\R}\)</span> rotates the
component of <span class="math">\(a\)</span> that is projected into the plane defined by <span class="math">\(a\)</span> and
<span class="math">\(b\)</span> where <span class="math">\(R=ab\)</span>.  <span class="math">\(R\)</span> may be written
<span class="math">\(R = e^{\frac{\theta}{2}U}\)</span>, where <span class="math">\(\theta\)</span> is the angle of rotation
and <span class="math">\(u\)</span> is a unit blade <span class="math">\(\lp u^{2} = \pm 1\rp\)</span> that defines the
plane of rotation.</p>
</div>
<div class="section" id="reciprocal-frames">
<span id="recframe"></span><h2>Reciprocal Frames<a class="headerlink" href="#reciprocal-frames" title="Permalink to this headline">¶</a></h2>
<p>If we have <span class="math">\(M\)</span> linearly independent vectors (a frame),
<span class="math">\(a_{1},\dots,a_{M}\)</span>, then the reciprocal frame is
<span class="math">\(a^{1},\dots,a^{M}\)</span> where <span class="math">\(a_{i}\cdot a^{j} = \delta_{i}^{j}\)</span>,
<span class="math">\(\delta_{i}^{j}\)</span> is the Kronecker delta (zero if <span class="math">\(i \ne j\)</span> and one
if <span class="math">\(i = j\)</span>). The reciprocal frame is constructed as follows:</p>
<div class="math">
\[\begin{equation*}
  E_{M} = a_{1}\W\dots\W a_{M}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
  E_{M}^{-1} = \bfrac{E_{M}}{E_{M}^{2}}
\end{equation*}\]</div><p>Then</p>
<div class="math">
\[\begin{equation*}
  a^{i} = \lp -1\rp^{i-1}\lp a_{1}\W\dots\W \breve{a}_{i} \W\dots\W a_{M}\rp E_{M}^{-1}
\end{equation*}\]</div><p>where <span class="math">\(\breve{a}_{i}\)</span> indicates that <span class="math">\(a_{i}\)</span> is to be deleted from
the product.  In the standard notation if a vector is denoted with a subscript
the reciprocal vector is denoted with a superscript. The multivector setup
function <tt class="docutils literal"><span class="pre">MV.setup(basis,metric,rframe)</span></tt> has the argument <tt class="docutils literal"><span class="pre">rframe</span></tt> with a
default value of <tt class="xref docutils literal"><span class="pre">False</span></tt>.  If it is set to <tt class="xref docutils literal"><span class="pre">True</span></tt> the reciprocal frame of
the basis vectors is  calculated. Additionaly there is the function
<tt class="docutils literal"><span class="pre">reciprocal_frame(vlst,names='')</span></tt> external to the <tt class="docutils literal"><span class="pre">MV</span></tt> class that will
calculate the reciprocal frame of a list, <tt class="docutils literal"><span class="pre">vlst</span></tt>, of vectors.  If the argument
<tt class="docutils literal"><span class="pre">names</span></tt> is set to a space delimited string of names for the vectors the
reciprocal vectors will be given these names.</p>
</div>
<div class="section" id="geometric-derivative">
<span id="deriv"></span><h2>Geometric Derivative<a class="headerlink" href="#geometric-derivative" title="Permalink to this headline">¶</a></h2>
<p>If <span class="math">\(F\)</span> is a multivector field that is a function of a vector
<span class="math">\(x = x^{i}\bm{\gamma}_{i}\)</span> (we are using the summation convention that
pairs of subscripts and superscripts are summed over the dimension of the vector
space) then the geometric derivative <span class="math">\(\nabla F\)</span> is given by (in this
section the summation convention is used):</p>
<div class="math">
\[\begin{equation*}
  \nabla F = \bm{\gamma}^{i}\bfrac{\partial F}{\partial x^{i}}
\end{equation*}\]</div><p>If <span class="math">\(F_{R}\)</span> is a grade-<span class="math">\(R\)</span> multivector and
<span class="math">\(F_{R} = F_{R}^{i_{1}\dots i_{R}}\bm{\gamma}_{i_{1}}\W\dots\W \bm{\gamma}_{i_{R}}\)</span>
then</p>
<div class="math">
\[\begin{equation*}
  \nabla F_{R} = \bfrac{\partial F_{R}^{i_{1}\dots i_{R}}}{\partial x^{j}}\bm{\gamma}^{j}\lp\bm{\gamma}_{i_{1}}\W
               \dots\W \bm{\gamma}_{i_{R}} \rp
\end{equation*}\]</div><p>Note that
<span class="math">\(\bm{\gamma}^{j}\lp\bm{\gamma}_{i_{1}}\W\dots\W \bm{\gamma}_{i_{R}} \rp\)</span>
can only contain grades <span class="math">\(R-1\)</span> and <span class="math">\(R+1\)</span> so that <span class="math">\(\nabla F_{R}\)</span>
also can only contain those grades. For a grade-<span class="math">\(R\)</span> multivector
<span class="math">\(F_{R}\)</span> the inner (div) and  outer (curl) derivatives are defined as</p>
<div class="math">
\[\begin{equation*}
\nabla\cdot F_{R} = \left < \nabla F_{R}\right >_{R-1}
\end{equation*}\]</div><p>and</p>
<div class="math">
\[\begin{equation*}
\nabla\W F_{R} = \left < \nabla F_{R}\right >_{R+1}
\end{equation*}\]</div><p>For a general multivector function <span class="math">\(F\)</span> the inner and outer derivatives are
just the sum of the inner and outer  dervatives of each grade of the multivector
function.</p>
<p>Curvilinear coordinates are derived from a vector function
<span class="math">\(x(\bm{\theta})\)</span> where
<span class="math">\(\bm{\theta} = \lp\theta_{1},\dots,\theta_{N}\rp\)</span> where the number of
coordinates is equal to the dimension of the  vector space.  In the case of
3-dimensional spherical coordinates <span class="math">\(\bm{\theta} = \lp r,\theta,\phi \rp\)</span>
and the coordinate generating function <span class="math">\(x(\bm{\theta})\)</span> is</p>
<div class="math">
\[\begin{equation*}
x =  r \cos\left({\phi}\right) \sin\left({\theta}\right){\bm{{\gamma}_{x}}}+ r \sin\left({\phi}\right) \sin\left({\theta}\right){\bm{{\gamma}_{y}}}+ r \cos\left({\theta}\right){\bm{{\gamma}_{z}}}
\end{equation*}\]</div><p>A coordinate frame is derived from <span class="math">\(x\)</span> by
<span class="math">\(\bm{e}_{i} = \pdiff{x}{\theta^{i}}\)</span>.  The following show the frame for
spherical coordinates.</p>
<div class="math">
\[\begin{equation*}
\bm{e}_{r} = \cos\left({\phi}\right) \sin\left({\theta}\right){\bm{{\gamma}_{x}}}+\sin\left({\phi}\right) \sin\left({\theta}\right){\bm{{\gamma}_{y}}}+\cos\left({\theta}\right){\bm{{\gamma}_{z}}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\bm{e}_{{\theta}} = \cos\left({\phi}\right) \cos\left({\theta}\right){\bm{{\gamma}_{x}}}+r \cos\left({\theta}\right) \sin\left({\phi}\right){\bm{{\gamma}_{y}}} - r \sin\left({\theta}\right){\bm{{\gamma}_{z}}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\bm{e}_{{\phi}} =  - r \sin\left({\phi}\right) \sin\left({\theta}\right){\bm{{\gamma}_{x}}}+r \cos\left({\phi}\right) \sin\left({\theta}\right){\bm{{\gamma}_{y}}}
\end{equation*}\]</div><p>The coordinate frame generated in this manner is not necessarily normalized so
define a normalized frame by</p>
<div class="math">
\[\begin{equation*}
\bm{\hat{e}}_{i} = \bfrac{\bm{e}_{i}}{\sqrt{\abs{\bm{e}_{i}^{2}}}} = \bfrac{\bm{e}_{i}}{\abs{\bm{e}_{i}}}
\end{equation*}\]</div><p>This works for all <span class="math">\(\bm{e}_{i}^{2} \neq 0\)</span> since we have defined
<span class="math">\(\abs{\bm{e}_{i}} = \sqrt{\abs{\bm{e}_{i}^{2}}}\)</span>.   For spherical
coordinates the normalized frame vectors are</p>
<div class="math">
\[\begin{equation*}
\bm{\hat{e}}_{r} =  \cos\left({\phi}\right) \sin\left({\theta}\right){\bm{{\gamma}_{x}}}+\sin\left({\phi}\right) \sin\left({\theta}\right){\bm{{\gamma}_{y}}}+\cos\left({\theta}\right){\bm{{\gamma}_{z}}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\bm{\hat{e}}_{{\theta}} = \cos\left({\phi}\right) \cos\left({\theta}\right){\bm{{\gamma}_{x}}}+\cos\left({\theta}\right) \sin\left({\phi}\right){\bm{{\gamma}_{y}}}- \sin\left({\theta}\right){\bm{{\gamma}_{z}}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\bm{\hat{e}}_{{\phi}} = - \sin\left({\phi}\right){\bm{{\gamma}_{x}}}+\cos\left({\phi}\right){\bm{{\gamma}_{y}}}
\end{equation*}\]</div><p>The geometric derivative in curvilinear coordinates is given by</p>
<div class="math">
\[\begin{align*}
  \nabla F_{R} & =  \bm{\gamma}^{i}\pdiff{}{x^{i}}\lp F_{R}^{i_{1}\dots i_{R}}
                   \bm{\hat{e}}_{i_{1}}\W\dots\W\bm{\hat{e}}_{i_{R}}\rp  \\
                 & =  \bm{e^{j}}\pdiff{}{\theta^{j}}\lp F_{R}^{i_{1}\dots i_{R}}
                   \bm{\hat{e}}_{i_{1}}\W\dots\W\bm{\hat{e}}_{i_{R}}\rp  \\
                 & =   \lp\pdiff{}{\theta^{j}} F_{R}^{i_{1}\dots i_{R}}\rp
                   \bm{e^{j}}\lp\bm{\hat{e}}_{i_{1}}\W\dots\W\bm{\hat{e}}_{i_{R}}\rp+
                   F_{R}^{i_{1}\dots i_{R}}\bm{e^{j}}
                   \pdiff{}{\theta^{j}}\lp\bm{\hat{e}}_{i_{1}}\W\dots\W\bm{\hat{e}}_{i_{R}}\rp \\
                 & =   \lp\pdiff{}{\theta^{j}} F_{R}^{i_{1}\dots i_{R}}\rp
                   \bm{e^{j}}\lp\bm{\hat{e}}_{i_{1}}\W\dots\W\bm{\hat{e}}_{i_{R}}\rp+
                   F_{R}^{i_{1}\dots i_{R}}C\lbrc \bm{\hat{e}}_{i_{1}}\W\dots\W\bm{\hat{e}}_{i_{R}}\rbrc
\end{align*}\]</div><p>where</p>
<div class="math">
\[\begin{equation*}
C\lbrc \bm{\hat{e}}_{i_{1}}\W\dots\W\bm{\hat{e}}_{i_{R}}\rbrc  = \bm{e^{j}}\pdiff{}{\theta^{j}}
                                                            \lp\bm{\hat{e}}_{i_{1}}\W\dots\W\bm{\hat{e}}_{i_{R}}\rp
\end{equation*}\]</div><p>are the connection multivectors for the curvilinear coordinate system. For a
spherical coordinate system they are</p>
<div class="math">
\[\begin{equation*}
C\lbrc\bm{\hat{e}}_{r}\rbrc =  \frac{2}{r}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\lbrc\bm{\hat{e}}_{\theta}\rbrc =  \frac{\cos\left({\theta}\right)}{r \sin\left({\theta}\right)}
                              +\frac{1}{r}\bm{\hat{e}}_{r}\W\bm{\hat{e}}_{\theta}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\lbrc\bm{\hat{e}}_{\phi}\rbrc = \frac{1}{r}{\bm{\bm{\hat{e}}_{r}}}\W\bm{\hat{e}}_{{\phi}}+ \frac{\cos\left({\theta}\right)}{r \sin\left({\theta}\right)}\bm{\hat{e}}_{{\theta}}\W\bm{\hat{e}}_{{\phi}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\lbrc\hat{e}_{r}\W\hat{e}_{\theta}\rbrc =  - \frac{\cos\left({\theta}\right)}{r \sin\left({\theta}\right)}
                                      \bm{\hat{e}}_{r}+\frac{1}{r}\bm{\hat{e}}_{{\theta}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\lbrc\bm{\hat{e}}_{r}\W\bm{\hat{e}}_{\phi}\rbrc = \frac{1}{r}\bm{\hat{e}}_{{\phi}}
                    - \frac{\cos\left({\theta}\right)}{r \sin\left({\theta}\right)}\bm{\hat{e}}_{r}\W\bm{\hat{e}}_{{\theta}}\W\bm{\hat{e}}_{{\phi}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\lbrc\bm{\hat{e}}_{\theta}\W\bm{\hat{e}}_{\phi}\rbrc =  \frac{2}{r}\bm{\hat{e}}_{r}\W
                                              \bm{\hat{e}}_{\theta}\W\bm{\hat{e}}_{\phi}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
C\lbrc\bm{\hat{e}}_r\W\bm{\hat{e}}_{\theta}\W\bm{\hat{e}}_{\phi}\rbrc = 0
\end{equation*}\]</div></div>
<div class="section" id="module-components">
<h2>Module Components<a class="headerlink" href="#module-components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="initializing-multivector-class">
<h3>Initializing Multivector Class<a class="headerlink" href="#initializing-multivector-class" title="Permalink to this headline">¶</a></h3>
<p>The multivector class is initialized with:</p>
<dl class="function">
<dt id="MV.setup">
<tt class="descclassname">MV.</tt><tt class="descname">setup</tt><big>(</big><em>basis</em>, <em>metric=''</em>, <em>rframe=False</em>, <em>coords=None</em>, <em>debug=False</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#MV.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>The <em>basis</em> and <em>metric</em> parameters were described in section <a class="reference internal" href="#vbm"><em>Vector Basis and Metric</em></a>. If
<em>rframe=True</em> the  reciprocal frame of the symbolic bases vectors is calculated.
If <em>debug=True</em> the data structure required to initialize the <a class="reference internal" href="#MV" title="MV"><tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt></a> class
are printer out. <em>coords</em> is a list of <tt class="xref py py-class docutils literal"><span class="pre">sympy</span></tt> symbols equal in length to
the number of basis vectors.  These symbols are used as the arguments of a
multivector field as a function of position and for calculating the derivatives
of a multivector field (if <em>coords</em> is defined then <em>rframe</em> is automatically
set equal to <em>True</em>). <em>offset</em> is an integer that is added to the multivector
coefficient index. For example if one wishes to start labeling vector coefficient
indexes at one instead of zero then set <em>offset=1</em>.  Additionally, <a class="reference internal" href="#MV.setup" title="MV.setup"><tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt></a>
calculates the pseudo scalar, <span class="math">\(I\)</span> and its inverse, <span class="math">\(I^{-1}\)</span> and makes
them available to the programmer as <em>MV.I</em> and <em>MV.Iinv</em>.</p>
</dd></dl>

<p>After <a class="reference internal" href="#MV.setup" title="MV.setup"><tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt></a> is run one can reinialize the <a class="reference internal" href="#MV" title="MV"><tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt></a> class with
curvilinear coordinates using:</p>
<dl class="function">
<dt id="MV.rebase">
<tt class="descclassname">MV.</tt><tt class="descname">rebase</tt><big>(</big><em>x</em>, <em>coords</em>, <em>base_name</em>, <em>debug=False</em>, <em>debug_level=0</em><big>)</big><a class="headerlink" href="#MV.rebase" title="Permalink to this definition">¶</a></dt>
<dd><p>A typical usage of <tt class="docutils literal"><span class="pre">MV.rebase</span></tt> for generating spherical curvilinear coordinate
is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;1 0 0,0 1 0,0 0 1&#39;</span>
<span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;gamma_x gamma_y gamma_z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
<span class="n">coords</span> <span class="o">=</span> <span class="n">make_symbols</span><span class="p">(</span><span class="s">&#39;r theta phi&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">gamma_z</span><span class="o">+</span><span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span>\
    <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">gamma_x</span><span class="o">+</span><span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">gamma_y</span><span class="p">))</span>
<span class="n">x</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="n">MV</span><span class="o">.</span><span class="n">rebase</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The input parameters for <tt class="docutils literal"><span class="pre">MV.rebase</span></tt> are</p>
</dd></dl>

<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">x</span></tt>: Vector function of coordinates (derivatives define curvilinear basis)</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">coords</span></tt>: List of sympy symbols for curvilinear coordinates</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">debug</span></tt>: If <tt class="xref docutils literal"><span class="pre">True</span></tt> printout (LaTeX) all quantities required for derivative calculation</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">debug_level</span></tt>: Set to 0,1,2, or 3 to stop curvilinear calculation before all quatities are
calculated.  This is done when debugging new curvilinear coordinate systems since simplification
of expressions is not sufficiently automated to insure success of process of any coordinate system
defined by vector function <tt class="docutils literal"><span class="pre">x</span></tt></p>
<p>To date <tt class="docutils literal"><span class="pre">MV.rebase</span></tt> works for cylindrical and spherical coordinate systems in
any number of dimensions  (until the execution time becomes too long).  To make
it work for these systems required creating some hacks for expression
simplification since both trigsimp and simplify were not general enough to
perform the required simplification.</p>
</li>
</ul>
<dl class="function">
<dt id="MV.set_str_format">
<tt class="descclassname">MV.</tt><tt class="descname">set_str_format</tt><big>(</big><em>str_mode=0</em><big>)</big><a class="headerlink" href="#MV.set_str_format" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">str_mode=0</span></tt> the string representation of the multivector contains no
newline characters (prints on one line).   If <tt class="docutils literal"><span class="pre">str_mode=1</span></tt> the string
representation of the multivector places a newline after each grade of the
multivector  (prints one grade per line).  If <tt class="docutils literal"><span class="pre">str_mode=2</span></tt> the string
representation of the multivector places a newline after each base of the
multivector  (prints one base per line). In both cases bases with zero
coefficients are not printed.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This function directly affects the way multivectors are printed with the
print command since it interacts with the <tt class="xref py py-func docutils literal"><span class="pre">__str__()</span></tt> function for the
multivector class which is used by the <tt class="docutils literal"><span class="pre">print</span></tt> command.</p>
<table border="1" class="last docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><blockquote class="first last">
<div><tt class="docutils literal"><span class="pre">str_mode</span></tt></div></blockquote>
</th>
<th class="head"><blockquote class="first last">
<div>Effect on print</div></blockquote>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><blockquote class="first last">
<div>0</div></blockquote>
</td>
<td>One multivector per line</td>
</tr>
<tr><td><blockquote class="first last">
<div>1</div></blockquote>
</td>
<td>One grade per line</td>
</tr>
<tr><td><blockquote class="first last">
<div>2</div></blockquote>
</td>
<td>One base per line</td>
</tr>
</tbody>
</table>
</div>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="instantiating-a-multivector">
<h3>Instantiating a Multivector<a class="headerlink" href="#instantiating-a-multivector" title="Permalink to this headline">¶</a></h3>
<p>Now that grades and bases have been described we can show all the ways that a
multivector can be instantiated. As an example assume that the multivector space
is initialized with <tt class="docutils literal"><span class="pre">MV.setup('e1</span> <span class="pre">e2</span> <span class="pre">e3')</span></tt>. Then the vectors <tt class="docutils literal"><span class="pre">e1</span></tt>, <tt class="docutils literal"><span class="pre">e2</span></tt>,
and <tt class="docutils literal"><span class="pre">e3</span></tt> are made available (broadcast) for use in the program .</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This is only true if the statement  <tt class="docutils literal"><span class="pre">set_main(sys.modules[__name__])</span></tt> appears
immediately after the <tt class="docutils literal"><span class="pre">from</span> <span class="pre">sympy.galgebra.GA</span> <span class="pre">import</span> <span class="pre">*</span></tt> statement.</p>
</div>
<p>So that  multivectors
could be instantiated with statements such as (<tt class="docutils literal"><span class="pre">a1</span></tt>, <tt class="docutils literal"><span class="pre">a2</span></tt>, and <tt class="docutils literal"><span class="pre">a3</span></tt> are
<tt class="docutils literal"><span class="pre">sympy</span></tt> symbols):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="n">a1</span><span class="o">*</span><span class="n">e1</span><span class="o">+</span><span class="n">a2</span><span class="o">*</span><span class="n">e2</span><span class="o">+</span><span class="n">a3</span><span class="o">*</span><span class="n">e3</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">e1</span><span class="o">*</span><span class="n">e2</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="o">|</span><span class="n">y</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">^</span><span class="n">y</span>
</pre></div>
</div>
<p>or with the multivector class constructor:</p>
<dl class="class">
<dt id="MV">
<em class="property">class </em><tt class="descname">MV</tt><big>(</big><em>value=''</em>, <em>mvtype=''</em>, <em>mvname=''</em>, <em>fct=False</em><big>)</big><a class="headerlink" href="#MV" title="Permalink to this definition">¶</a></dt>
<dd><p><em>mvname</em> is a  string that defines the name of the multivector for output
purposes. <em>value</em> and  <em>type</em> are defined by the following table and <em>fct</em> is a
switch that will convert the symbolic coefficients of a multivector to functions
if coordinate variables have been defined when <a class="reference internal" href="#MV.setup" title="MV.setup"><tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt></a> is called:</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="43%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><blockquote class="first last">
<div>mvtype</div></blockquote>
</th>
<th class="head"><blockquote class="first last">
<div>value</div></blockquote>
</th>
<th class="head"><blockquote class="first last">
<div>result</div></blockquote>
</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><blockquote class="first last">
<div>default</div></blockquote>
</td>
<td><blockquote class="first last">
<div>default</div></blockquote>
</td>
<td><blockquote class="first last">
<div>Zero multivector</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div>&#8216;basisvector&#8217;</div></blockquote>
</td>
<td><blockquote class="first last">
<div>int i</div></blockquote>
</td>
<td><blockquote class="first last">
<div><span class="math">\(\mbox{i}^{th}\)</span> basis vector</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div>&#8216;basisbivector&#8217;</div></blockquote>
</td>
<td><blockquote class="first last">
<div>int i</div></blockquote>
</td>
<td><blockquote class="first last">
<div><span class="math">\(\mbox{i}^{th}\)</span> basis bivector</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div>&#8216;scalar&#8217;</div></blockquote>
</td>
<td><blockquote class="first last">
<div>symbol x</div></blockquote>
</td>
<td><blockquote class="first last">
<div>symbolic scalar of value x</div></blockquote>
</td>
</tr>
<tr><td>&nbsp;</td>
<td><blockquote class="first last">
<div>string s</div></blockquote>
</td>
<td><blockquote class="first last">
<div>symbolic scalar of value Symbol(s)</div></blockquote>
</td>
</tr>
<tr><td>&nbsp;</td>
<td><blockquote class="first last">
<div>int i</div></blockquote>
</td>
<td><blockquote class="first last">
<div>sympy integer of value i</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div>&#8216;grade&#8217;</div></blockquote>
</td>
<td><blockquote class="first last">
<div>[int r, 1-D symbol array A]</div></blockquote>
</td>
<td><blockquote class="first last">
<div>X.grade(r) = A</div></blockquote>
</td>
</tr>
<tr><td>&nbsp;</td>
<td><blockquote class="first last">
<div>[int r, string s]</div></blockquote>
</td>
<td><blockquote class="first last">
<div>symbolic grade r multivector</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div>&#8216;vector&#8217;</div></blockquote>
</td>
<td><blockquote class="first last">
<div>1-D symbol array A</div></blockquote>
</td>
<td><blockquote class="first last">
<div>X.grade(1) = A</div></blockquote>
</td>
</tr>
<tr><td>&nbsp;</td>
<td><blockquote class="first last">
<div>string s</div></blockquote>
</td>
<td><blockquote class="first last">
<div>symbolic vector</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div>&#8216;grade2&#8217;</div></blockquote>
</td>
<td><blockquote class="first last">
<div>1-D symbol array A</div></blockquote>
</td>
<td><blockquote class="first last">
<div>X.grade(2) = A</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div>&#8216;pseudo&#8217;</div></blockquote>
</td>
<td><blockquote class="first last">
<div>symbol x</div></blockquote>
</td>
<td><blockquote class="first last">
<div>X.grade(n) = x</div></blockquote>
</td>
</tr>
<tr><td><blockquote class="first last">
<div>&#8216;spinor&#8217;</div></blockquote>
</td>
<td><blockquote class="first last">
<div>string s</div></blockquote>
</td>
<td><blockquote class="first last">
<div>symbolic even multivector</div></blockquote>
</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td><blockquote class="first last">
<div>default</div></blockquote>
</td>
<td><blockquote class="first last">
<div>string s</div></blockquote>
</td>
<td><blockquote class="first last">
<div>symbolic general multivector</div></blockquote>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>If the <em>value</em> argument has the option of being a string s then a general symbolic
multivector will be constructed constrained by the value of <em>mvtype</em>.  The string
s will be the base name of the multivector symbolic coefficients.  If <em>coords</em> is
not defined in <a class="reference internal" href="#MV.setup" title="MV.setup"><tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt></a> the indices of the multivector bases are appended to
the base name with a double underscore (superscript notation).  If <em>coords</em> is defined
the coordinate names will replace the indices in the coefficient names.  For example if
the base string is <em>A</em> and the  coordinates <em>(x,y,z)</em> then the
coefficients of a spinor in 3d space would be <em>A</em>, <em>A__xy</em>, <em>A__xz</em>, and <em>A__yz</em>.  If
the <tt class="xref py py-mod docutils literal"><span class="pre">latex_ex</span></tt> is used to print the multivector the coefficients would print as
<span class="math">\(A\)</span>, <span class="math">\(A^{xy}\)</span>, <span class="math">\(A^{xz}\)</span>, and <span class="math">\(A^{yz}\)</span>.</p>
<p>If the <em>fct</em> argrument of <a class="reference internal" href="#MV" title="MV"><tt class="xref py py-func docutils literal"><span class="pre">MV()</span></tt></a> is set to <em>True</em> and the <em>coords</em> argument in
<a class="reference internal" href="#MV.setup" title="MV.setup"><tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt></a> is defined the symbolic coefficients of the multivector are functions
of the coordinates.</p>
</dd></dl>

</div>
<div class="section" id="basic-multivector-class-functions">
<h3>Basic Multivector Class Functions<a class="headerlink" href="#basic-multivector-class-functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="__call__">
<tt class="descname">__call__</tt><big>(</big><em>self</em>, <em>igrade=0</em>, <em>ibase=0</em><big>)</big><a class="headerlink" href="#__call__" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">__call__</span></tt> returns the the <tt class="docutils literal"><span class="pre">igrade</span></tt>, <tt class="docutils literal"><span class="pre">ibase</span></tt> coefficient of the
multivector.  The defaults return the scalar component of the multivector.</p>
</dd></dl>

<dl class="function">
<dt id="convert_to_blades">
<tt class="descname">convert_to_blades</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#convert_to_blades" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert multivector from the base representation to the blade representation.
If multivector is already in blade representation nothing is done.</p>
</dd></dl>

<dl class="function">
<dt id="convert_from_blades">
<tt class="descname">convert_from_blades</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#convert_from_blades" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert multivector from the blade representation to the base representation.
If multivector is already in base representation nothing is done.</p>
</dd></dl>

<dl class="function">
<dt id="project">
<tt class="descname">project</tt><big>(</big><em>self</em>, <em>r</em><big>)</big><a class="headerlink" href="#project" title="Permalink to this definition">¶</a></dt>
<dd><p>If r is a integer return the grade-<span class="math">\(r\)</span> components of the multivector. If
r is a multivector return the grades of the multivector that correspond to the
non-zero grades of r. For example if one is projecting a general multivector and
r is a spinor, <tt class="docutils literal"><span class="pre">A.project(r)</span></tt> will return only the even grades of the multivector
A since a spinor only has even grades that are non-zero.</p>
</dd></dl>

<dl class="function">
<dt id="even">
<tt class="descname">even</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#even" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the even grade components of the multivector.</p>
</dd></dl>

<dl class="function">
<dt id="odd">
<tt class="descname">odd</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#odd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the odd grade components of the multivector.</p>
</dd></dl>

<dl class="function">
<dt id="rev">
<tt class="descname">rev</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#rev" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the reverse of the multivector.  See section <a class="reference internal" href="#reverse"><em>Reverse of Multivector</em></a>.</p>
</dd></dl>

<dl class="function">
<dt id="is_pure">
<tt class="descname">is_pure</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#is_pure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if multivector is pure grade (all grades but one are zero).</p>
</dd></dl>

<dl class="function">
<dt id="diff">
<tt class="descname">diff</tt><big>(</big><em>self</em>, <em>x</em><big>)</big><a class="headerlink" href="#diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the partial derivative of the multivector function with respect to
variable <span class="math">\(x\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="grad">
<tt class="descname">grad</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the geometric derivative of the multivector function.</p>
</dd></dl>

<dl class="function">
<dt id="grad_ext">
<tt class="descname">grad_ext</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#grad_ext" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the outer (curl) derivative of the multivector function. Equivalent to
<tt class="xref py py-func docutils literal"><span class="pre">curl()</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="grad_int">
<tt class="descname">grad_int</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#grad_int" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inner (div) derivative of the multivector function. Equivalent to
<tt class="xref py py-func docutils literal"><span class="pre">div()</span></tt>.</p>
</dd></dl>

<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If <em>A</em> is a vector field in three dimensions <span class="math">\(\nabla\cdot {\bf A}\)</span> = A.grad_int() = A.div(), but
<span class="math">\(\nabla\times {\bf A}\)</span> = -MV.I*A.grad_ext() = -MV.I*A.curl(). Note that grad_int() lowers the grade
of all blades by one grade and grad_ext() raises the grade of all blades by one.</p>
</div>
<dl class="function">
<dt id="set_coef">
<tt class="descname">set_coef</tt><big>(</big><em>self</em>, <em>grade</em>, <em>base</em>, <em>value</em><big>)</big><a class="headerlink" href="#set_coef" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the multivector coefficient of index <em>(grade,base)</em> to <em>value</em>.</p>
</dd></dl>

</div>
<div class="section" id="sympy-functions-applied-inplace-to-multivector-coefficients">
<h3>Sympy Functions Applied Inplace to Multivector Coefficients<a class="headerlink" href="#sympy-functions-applied-inplace-to-multivector-coefficients" title="Permalink to this headline">¶</a></h3>
<p>All the following fuctions belong to the <a class="reference internal" href="#MV" title="MV"><tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt></a> class and apply the
corresponding <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt> function to each component of a multivector.   All
these functions perform the operations inplace (<tt class="xref docutils literal"><span class="pre">None</span></tt> is returned)  on each
coefficient.  For example if you wished to simplify all the components of the
multivector <tt class="docutils literal"><span class="pre">A</span></tt> you would invoke <tt class="docutils literal"><span class="pre">A.simplify()</span></tt>.  The argument list for each
function is the same as for the corresponding <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt> function.   The only
function that differs in its action from the <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt> version is
<a class="reference internal" href="#trigsimp" title="trigsimp"><tt class="xref py py-func docutils literal"><span class="pre">trigsimp()</span></tt></a> in its case the function <tt class="docutils literal"><span class="pre">TrigSimp</span> <span class="pre">is</span> <span class="pre">applied</span></tt> (see
documentation on <a class="reference internal" href="#TrigSimp" title="TrigSimp"><tt class="xref py py-func docutils literal"><span class="pre">TrigSimp()</span></tt></a>).</p>
<dl class="function">
<dt id="collect">
<tt class="descname">collect</tt><big>(</big><em>self</em>, <em>lst</em><big>)</big><a class="headerlink" href="#collect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sqrfree">
<tt class="descname">sqrfree</tt><big>(</big><em>self</em>, <em>lst</em><big>)</big><a class="headerlink" href="#sqrfree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="subs">
<tt class="descname">subs</tt><big>(</big><em>self</em>, <em>*args</em><big>)</big><a class="headerlink" href="#subs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="simplify">
<tt class="descname">simplify</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#simplify" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="trigsimp">
<tt class="descname">trigsimp</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#trigsimp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="cancel">
<tt class="descname">cancel</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#cancel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="expand">
<tt class="descname">expand</tt><big>(</big><em>self</em><big>)</big><a class="headerlink" href="#expand" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="helper-functions">
<h3>Helper Functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h3>
<p>These are functions in <tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt>, but not in the multivector (<a class="reference internal" href="#MV" title="MV"><tt class="xref py py-class docutils literal"><span class="pre">MV</span></tt></a>)
class.</p>
<dl class="function">
<dt id="set_main">
<tt class="descname">set_main</tt><big>(</big><em>main_program</em><big>)</big><a class="headerlink" href="#set_main" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#set_main" title="set_main"><tt class="xref py py-func docutils literal"><span class="pre">set_main()</span></tt></a> passes the argument <em>main_program</em> from the main program to the
<tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt> module.  The argument must be <em>sys.modules[__name__]</em> and the
call should be placed immediately after <tt class="xref py py-mod docutils literal"><span class="pre">sys</span></tt> and <tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt> are
imported.  The purpose of this call is to allow <tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt> to broadcast to
the main program <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt>  variables and multivectors created by calls to
<tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt>. It is used by <a class="reference internal" href="#MV.setup" title="MV.setup"><tt class="xref py py-func docutils literal"><span class="pre">MV.setup()</span></tt></a> and <a class="reference internal" href="#make_symbols" title="make_symbols"><tt class="xref py py-func docutils literal"><span class="pre">make_symbols()</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="make_symbols">
<tt class="descname">make_symbols</tt><big>(</big><em>symnamelst</em><big>)</big><a class="headerlink" href="#make_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#make_symbols" title="make_symbols"><tt class="xref py py-func docutils literal"><span class="pre">make_symbols()</span></tt></a> creates a list of <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt> symbols with names defined
by the space delimited string <em>symnamelst</em>. In addition to returning the symbol
list the function broadcasts the named symbols to the main program.  For example
if you make the call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">syms</span> <span class="o">=</span> <span class="n">make_symbols</span><span class="p">(</span><span class="s">&#39;x y ab&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Not only will <em>syms</em> contain the symbols, but you can also directly use <em>x</em>,
<em>y</em>, and <em>ab</em> as symbols in your program.</p>
<blockquote>
<div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">You can only directly use <em>x</em>, <em>y</em>, and <em>ab</em> as symbols in your program if
the statement  <tt class="docutils literal"><span class="pre">set_main(sys.modules[__name__])</span></tt> appears immediately after
the <tt class="docutils literal"><span class="pre">from</span> <span class="pre">sympy.galgebra.GA</span> <span class="pre">import</span> <span class="pre">*</span></tt> statement.</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="set_names">
<tt class="descname">set_names</tt><big>(</big><em>var_lst</em>, <em>var_str</em><big>)</big><a class="headerlink" href="#set_names" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#set_names" title="set_names"><tt class="xref py py-func docutils literal"><span class="pre">set_names()</span></tt></a> allows one to name a list, <em>var_lst</em>, of multivectors enmass.
The names are in <em>var_str</em>, a blank separated string of names.  An error is
generated if the number of name is not equal to the length of <em>var_lst</em>.</p>
</dd></dl>

<dl class="function">
<dt id="reciprocal_frame">
<tt class="descname">reciprocal_frame</tt><big>(</big><em>vlst</em>, <em>names=''</em><big>)</big><a class="headerlink" href="#reciprocal_frame" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#reciprocal_frame" title="reciprocal_frame"><tt class="xref py py-func docutils literal"><span class="pre">reciprocal_frame()</span></tt></a> implements the proceedure described in section
<a class="reference internal" href="#recframe"><em>Reciprocal Frames</em></a>.  <em>vlst</em> is a list of independent vectors that you wish the
reciprocal frame calculated for. <em>names</em> is a blank separated string of names
for the reciprocal vectors if names are required by you application.  The
function returns a list containing the reciprocal vectors.</p>
</dd></dl>

<dl class="function">
<dt id="TrigSimp">
<tt class="descname">TrigSimp</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#TrigSimp" title="Permalink to this definition">¶</a></dt>
<dd><p>In general <tt class="xref py py-func docutils literal"><span class="pre">sympy.trigsimp()</span></tt> will not catch all the trigonometric
simplifications in an <tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt> expression.  Neither will <a class="reference internal" href="#TrigSimp" title="TrigSimp"><tt class="xref py py-func docutils literal"><span class="pre">TrigSimp()</span></tt></a>,
but it will catch a lot more of them. <a class="reference internal" href="#TrigSimp" title="TrigSimp"><tt class="xref py py-func docutils literal"><span class="pre">TrigSimp()</span></tt></a> is so simple it is show
below in its entirety.  All it does is apply  <tt class="xref py py-func docutils literal"><span class="pre">sympy.trigsimp()</span></tt> to the
expressions generated by <tt class="xref py py-func docutils literal"><span class="pre">sympy.cse()</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">TrigSimp</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">g</span><span class="p">)</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cse</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">trigsimp</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">sub</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">trigsimp</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="S">
<tt class="descname">S</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#S" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#S" title="S"><tt class="xref py py-func docutils literal"><span class="pre">S()</span></tt></a> instanciates a scaler multivector of value <em>x</em>, where <em>x</em> can be a
<tt class="xref py py-mod docutils literal"><span class="pre">sympy</span></tt> variable or integer.  This is just a shorthand method for
constructing scalar multivectors and can be used when there is any ambiguity
in a multivector expression as to whether a symbol or constant should be
treated as a scalar multivector or not.</p>
</dd></dl>

</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="algebra">
<h3>Algebra<a class="headerlink" href="#algebra" title="Permalink to this headline">¶</a></h3>
<p>The following examples of geometric algebra (not calculus) are all in the file
<strong class="program">testsymbolicGA.py</strong> which is included in the sympy distribution
examples  under the galbebra directory.  The section of code in the program for
each example  is show with the respective output following the code section.</p>
<div class="section" id="example-header">
<h4>Example Header<a class="headerlink" href="#example-header" title="Permalink to this headline">¶</a></h4>
<p>This is the header of <strong class="program">testsymbolicGA.py</strong> that allows access to the
required modules and also allow variables and certain multivectors to be
broadcast from the <tt class="xref py py-mod docutils literal"><span class="pre">GA</span></tt> module to the main program.</p>
<div class="highlight-python"><pre>import os,sys,sympy
from sympy.galgebra.GA import set_main, make_symbols, types, MV, ZERO, ONE, HALF
from sympy import collect
set_main(sys.modules[__name__])

def F(x):
        """
        Conformal Mapping Function
        """
        Fx = HALF*((x*x)*n+2*x-nbar)
        return(Fx)

def make_vector(a,n = 3):
        if type(a) == types.StringType:
                sym_str = ''
                for i in range(n):
                        sym_str += a+str(i)+' '
                sym_lst = make_symbols(sym_str)
                sym_lst.append(ZERO)
                sym_lst.append(ZERO)
                a = MV(sym_lst,'vector')
        return(F(a))

if __name__ == '__main__':
</pre>
</div>
</div>
<div class="section" id="basic-geometric-algebra-operations">
<h4>Basic Geometric Algebra Operations<a class="headerlink" href="#basic-geometric-algebra-operations" title="Permalink to this headline">¶</a></h4>
<p>Example of basic geometric algebra operation of geometric, outer, and inner
products.</p>
<div class="highlight-python"><pre>        MV.setup('a b c d e')
        MV.set_str_format(1)

        print 'e|(a^b) =',e|(a^b)
        print 'e|(a^b^c) =',e|(a^b^c)
        print 'a*(b^c)-b*(a^c)+c*(a^b) =',a*(b^c)-b*(a^c)+c*(a^b)
        print 'e|(a^b^c^d) =',e|(a^b^c^d)
        print -d*(a^b^c)+c*(a^b^d)-b*(a^c^d)+a*(b^c^d)

        print (a^b)|(c^d)

e|(a^b) = {-(b.e)}a
+{(a.e)}b

e|(a^b^c) = {(c.e)}a^b
+{-(b.e)}a^c
+{(a.e)}b^c

a*(b^c)-b*(a^c)+c*(a^b) = {3}a^b^c

e|(a^b^c^d) = {-(d.e)}a^b^c
+{(c.e)}a^b^d
+{-(b.e)}a^c^d
+{(a.e)}b^c^d

{4}a^b^c^d

{(a.d)*(b.c) - (a.c)*(b.d)}1
</pre>
</div>
</div>
<div class="section" id="examples-of-conformal-geometry">
<h4>Examples of Conformal Geometry<a class="headerlink" href="#examples-of-conformal-geometry" title="Permalink to this headline">¶</a></h4>
<p>Examples of comformal geometry [Lasenby,Chapter 10]. The examples show that
basic geometric entities (lines, circles, planes, and spheres) in three
dimensions can be represented by blades in a five dimensional (conformal) space.</p>
<div class="highlight-python"><pre>        print '\nExample: Conformal representations of circles, lines, spheres, and planes'

        metric = '1 0 0 0 0,0 1 0 0 0,0 0 1 0 0,0 0 0 0 2,0 0 0 2 0'

        MV.setup('e0 e1 e2 n nbar',metric,debug=0)
        MV.set_str_format(1)
        e = n+nbar
        #conformal representation of points

        A = make_vector(e0)    # point a = (1,0,0)  A = F(a)
        B = make_vector(e1)    # point b = (0,1,0)  B = F(b)
        C = make_vector(-1*e0) # point c = (-1,0,0) C = F(c)
        D = make_vector(e2)    # point d = (0,0,1)  D = F(d)
        X = make_vector('x',3)

        print 'a = e0, b = e1, c = -e0, and d = e2'
        print 'A = F(a) = 1/2*(a*a*n+2*a-nbar), etc.'
        print 'Circle through a, b, and c'
        print 'Circle: A^B^C^X = 0 =',(A^B^C^X)
        print 'Line through a and b'
        print 'Line  : A^B^n^X = 0 =',(A^B^n^X)
        print 'Sphere through a, b, c, and d'
        print 'Sphere: A^B^C^D^X = 0 =',(A^B^C^D^X)
        print 'Plane through a, b, and d'
        print 'Plane : A^B^n^D^X = 0 =',(A^B^n^D^X)

Example: Conformal representations of circles, lines, spheres, and planes
a = e0, b = e1, c = -e0, and d = e2
A = F(a) = 1/2*(a*a*n+2*a-nbar), etc.
Circle through a, b, and c
Circle: A^B^C^X = 0 = {-x2}e0^e1^e2^n
+{x2}e0^e1^e2^nbar
+{-1/2 + 1/2*x0**2 + 1/2*x1**2 + 1/2*x2**2}e0^e1^n^nbar

Line through a and b
Line  : A^B^n^X = 0 = {-x2}e0^e1^e2^n
+{-1/2 + x0/2 + x1/2}e0^e1^n^nbar
+{x2/2}e0^e2^n^nbar
+{-x2/2}e1^e2^n^nbar

Sphere through a, b, c, and d
Sphere: A^B^C^D^X = 0 = {1/2 - 1/2*x0**2 - 1/2*x1**2 - 1/2*x2**2}e0^e1^e2^n^nbar

Plane through a, b, and d
Plane : A^B^n^D^X = 0 = {1/2 - x0/2 - x1/2 - x2/2}e0^e1^e2^n^nbar

</pre>
</div>
</div>
<div class="section" id="calculation-of-reciprocal-frame">
<h4>Calculation of Reciprocal Frame<a class="headerlink" href="#calculation-of-reciprocal-frame" title="Permalink to this headline">¶</a></h4>
<p>Example shows the calculation of the reciprocal frame for three arbitrary
vectors and  verifies that the calculated reciprocal vectors have the correct
properties.</p>
<div class="highlight-python"><pre>        MV.setup('e1 e2 e3',metric)

        print 'Example: Reciprocal Frames e1, e2, and e3 unit vectors.\n\n'

        E = e1^e2^e3
        Esq = (E*E)()
        print 'E =',E
        print 'E^2 =',Esq
        Esq_inv = 1/Esq

        E1 = (e2^e3)*E
        E2 = (-1)*(e1^e3)*E
        E3 = (e1^e2)*E

        print 'E1 = (e2^e3)*E =',E1
        print 'E2 =-(e1^e3)*E =',E2
        print 'E3 = (e1^e2)*E =',E3

        w = (E1|e2)
        w.collect(MV.g)
        w = w().expand()
        print 'E1|e2 =',w

        w = (E1|e3)
        w.collect(MV.g)
        w = w().expand()
        print 'E1|e3 =',w

        w = (E2|e1)
        w.collect(MV.g)
        w = w().expand()
        print 'E2|e1 =',w

        w = (E2|e3)
        w.collect(MV.g)
        w = w().expand()
        print 'E2|e3 =',w

        w = (E3|e1)
        w.collect(MV.g)
        w = w().expand()
        print 'E3|e1 =',w

        w = (E3|e2)
        w.collect(MV.g)
        w = w().expand()
        print 'E3|e2 =',w

        w = (E1|e1)
        w = w().expand()
        Esq = Esq.expand()
        print '(E1|e1)/E^2 =',w/Esq

        w = (E2|e2)
        w = w().expand()
        print '(E2|e2)/E^2 =',w/Esq

        w = (E3|e3)
        w = w().expand()
        print '(E3|e3)/E^2 =',w/Esq

Example: Reciprocal Frames e1, e2, and e3 unit vectors.


E = e1^e2^e3
E^2 = -1 - 2*(e1.e2)*(e1.e3)*(e2.e3) + (e1.e2)**2 + (e1.e3)**2 + (e2.e3)**2
E1 = (e2^e3)*E = {-1 + (e2.e3)**2}e1+{(e1.e2) - (e1.e3)*(e2.e3)}e2+{(e1.e3) - (e1.e2)*(e2.e3)}e3
E2 =-(e1^e3)*E = {(e1.e2) - (e1.e3)*(e2.e3)}e1+{-1 + (e1.e3)**2}e2+{(e2.e3) - (e1.e2)*(e1.e3)}e3
E3 = (e1^e2)*E = {(e1.e3) - (e1.e2)*(e2.e3)}e1+{(e2.e3) - (e1.e2)*(e1.e3)}e2+{-1 + (e1.e2)**2}e3
E1|e2 = 0
E1|e3 = 0
E2|e1 = 0
E2|e3 = 0
E3|e1 = 0
E3|e2 = 0
(E1|e1)/E^2 = 1
(E2|e2)/E^2 = 1
(E3|e3)/E^2 = 1

</pre>
</div>
</div>
<div class="section" id="hyperbolic-geometry">
<h4>Hyperbolic Geometry<a class="headerlink" href="#hyperbolic-geometry" title="Permalink to this headline">¶</a></h4>
<p>Examples of calculation of distance in hyperbolic geometry [Lasenby,pp373-375].
This is a good example of the utility of not restricting the basis vector to be
orthogonal. Note that most of the calculation is simplifying a scalar
expression.</p>
<div class="highlight-python"><pre>        print 'Example: non-euclidian distance calculation'

        metric = '0 # #,# 0 #,# # 1'
        MV.setup('X Y e',metric)
        MV.set_str_format(1)
        L = X^Y^e
        B = L*e
        Bsq = (B*B)()
        print 'L = X^Y^e is a non-euclidian line'
        print 'B = L*e =',B
        BeBr =B*e*B.rev()
        print 'B*e*B.rev() =',BeBr
        print 'B^2 =',Bsq
        print 'L^2 =',(L*L)()
        make_symbols('s c Binv M S C alpha')
        Bhat = Binv*B # Normalize translation generator
        R = c+s*Bhat # Rotor R = exp(alpha*Bhat/2)
        print 's = sinh(alpha/2) and c = cosh(alpha/2)'
        print 'R = exp(alpha*B/(2*|B|)) =',R
        Z = R*X*R.rev()
        Z.expand()
        Z.collect([Binv,s,c,XdotY])
        print 'R*X*R.rev() =',Z
        W = Z|Y
        W.expand()
        W.collect([s*Binv])
        print '(R*X*rev(R)).Y =',W
        M = 1/Bsq
        W.subs(Binv**2,M)
        W.simplify()
        Bmag = sympy.sqrt(XdotY**2-2*XdotY*Xdote*Ydote)
        W.collect([Binv*c*s,XdotY])

        W.subs(2*XdotY**2-4*XdotY*Xdote*Ydote,2/(Binv**2))
        W.subs(2*c*s,S)
        W.subs(c**2,(C+1)/2)
        W.subs(s**2,(C-1)/2)
        W.simplify()
        W.subs(1/Binv,Bmag)
        W = W().expand()
        print '(R*X*R.rev()).Y =',W
        nl = '\n'

        Wd = collect(W,[C,S],exact=True,evaluate=False)
        print 'Wd =',Wd
        Wd_1 = Wd[ONE]
        Wd_C = Wd[C]
        Wd_S = Wd[S]
        print '|B| =',Bmag
        Wd_1 = Wd_1.subs(Bmag,1/Binv)
        Wd_C = Wd_C.subs(Bmag,1/Binv)
        Wd_S = Wd_S.subs(Bmag,1/Binv)
        print 'Wd[ONE] =',Wd_1
        print 'Wd[C] =',Wd_C
        print 'Wd[S] =',Wd_S


        lhs = Wd_1+Wd_C*C
        rhs = -Wd_S*S
        lhs = lhs**2
        rhs = rhs**2
        W = (lhs-rhs).expand()
        W = (W.subs(1/Binv**2,Bmag**2)).expand()
        print 'W =',W
        W = (W.subs(S**2,C**2-1)).expand()
        print 'W =',W
        W = collect(W,[C,C**2],evaluate=False)
        print 'W =',W
        
        a = W[C**2]
        b = W[C]
        c = W[ONE]

        print 'a =',a
        print 'b =',b
        print 'c =',c

        D = (b**2-4*a*c).expand()
        print 'Setting to 0 and solving for C gives:'
        print 'Descriminant D = b^2-4*a*c =',D
        C = (-b/(2*a)).expand()
        print 'C = cosh(alpha) = -b/(2*a) =',C

Example: non-euclidian distance calculation
L = X^Y^e is a non-euclidian line
B = L*e = X^Y
+{-(Y.e)}X^e
+{(X.e)}Y^e

B*e*B.rev() = {2*(X.Y)*(X.e)*(Y.e) - (X.Y)**2}e

B^2 = -2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2
L^2 = -2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2
s = sinh(alpha/2) and c = cosh(alpha/2)
R = exp(alpha*B/(2*|B|)) = {c}1
+{Binv*s}X^Y
+{-(Y.e)*Binv*s}X^e
+{(X.e)*Binv*s}Y^e

R*X*R.rev() = {Binv*(2*(X.Y)*c*s - 2*(X.e)*(Y.e)*c*s) + Binv**2*((X.Y)**2*s**2 
               - 2*(X.Y)*(X.e)*(Y.e)*s**2) + c**2}X
             +{2*Binv*c*s*(X.e)**2}Y
             +{Binv**2*(-2*(X.e)*(X.Y)**2*s**2 + 4*(X.Y)*(Y.e)*(X.e)**2*s**2)
               - 2*(X.Y)*(X.e)*Binv*c*s}e

(R*X*rev(R)).Y = {Binv*s*(-4*(X.Y)*(X.e)*(Y.e)*c + 2*c*(X.Y)**2) 
                 + Binv**2*s**2*(-4*(X.e)*(Y.e)*(X.Y)**2 +
                 4*(X.Y)*(X.e)**2*(Y.e)**2 + (X.Y)**3) + (X.Y)*c**2}1

(R*X*R.rev()).Y = S*(-2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2)**(1/2) 
                  + (X.Y)*Binv*C*(-2*(X.Y)*(X.e)*(Y.e) + 
                  (X.Y)**2)**(1/2) + (X.e)*(Y.e)*Binv*(-2*(X.Y)*(X.e)*(Y.e) 
                  + (X.Y)**2)**(1/2) - 
                  (X.e)*(Y.e)*Binv*C*(-2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2)**(1/2)
Wd = {1: (X.e)*(Y.e)*Binv*(-2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2)**(1/2),
      S: (-2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2)**(1/2),
      C: (X.Y)*Binv*(-2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2)**(1/2) - 
         (X.e)*(Y.e)*Binv*(-2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2)**(1/2)}
|B| = (-2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2)**(1/2)

Wd[ONE] = (X.e)*(Y.e)
Wd[C] = (X.Y) - (X.e)*(Y.e)
Wd[S] = 1/Binv

W = 2*(X.Y)*(X.e)*(Y.e)*C + (X.Y)**2*C**2 + (X.e)**2*(Y.e)**2 
    - (X.Y)**2*S**2 + (X.e)**2*(Y.e)**2*C**2 - 2*C*(X.e)**2*(Y.e)**2 
    - 2*(X.Y)*(X.e)*(Y.e)*C**2 + 2*(X.Y)*(X.e)*(Y.e)*S**2
W = -2*(X.Y)*(X.e)*(Y.e) + 2*(X.Y)*(X.e)*(Y.e)*C + (X.Y)**2 
    + (X.e)**2*(Y.e)**2 + (X.e)**2*(Y.e)**2*C**2 -
     2*C*(X.e)**2*(Y.e)**2
W = {1: -2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2 + (X.e)**2*(Y.e)**2,
     C**2: (X.e)**2*(Y.e)**2,
     C: 2*(X.Y)*(X.e)*(Y.e) - 2*(X.e)**2*(Y.e)**2}

a = (X.e)**2*(Y.e)**2
b = 2*(X.Y)*(X.e)*(Y.e) - 2*(X.e)**2*(Y.e)**2
c = -2*(X.Y)*(X.e)*(Y.e) + (X.Y)**2 + (X.e)**2*(Y.e)**2

Setting to 0 and solving for C gives:
Descriminant D = b^2-4*a*c = 0
C = cosh(alpha) = -b/(2*a) = 1 - (X.Y)/((X.e)*(Y.e))
</pre>
</div>
</div>
</div>
<div class="section" id="calculus">
<h3>Calculus<a class="headerlink" href="#calculus" title="Permalink to this headline">¶</a></h3>
<p>The calculus examples all use the extened LaTeXoutput module, <tt class="docutils literal"><span class="pre">latex_ex</span></tt>, for
clarity.</p>
<div class="section" id="maxwell-s-equations">
<h4>Maxwell&#8217;s Equations<a class="headerlink" href="#maxwell-s-equations" title="Permalink to this headline">¶</a></h4>
<p>In geometric calculus the equivalent of the electromagnetic tensor is
<span class="math">\(F = E\gamma_{0}+IB\gamma_{0}\)</span> where a spacetime vector is given by
<span class="math">\(x = x^{0}\gamma_{0}+x^{1}\gamma_{1}+x^{2}\gamma_{2}+x^{3}\gamma_{3}\)</span>
where <span class="math">\(x^{0} = ct\)</span>, the pseudoscalar
<span class="math">\(I = \gamma_{0}\gamma_{1}\gamma_{2}\gamma_{3}\)</span>, <span class="math">\(E\)</span> and <span class="math">\(B\)</span>
are four vectors where the time component is zero and the spatial components
equal to the electric and magnetic field  components.  Then Maxwell&#8217;s equations
can be all written as <span class="math">\(\nabla F = J\)</span> with <span class="math">\(J\)</span> the four current.
This example shows that this equations generates all of Maxwell&#8217;s equations
correctly  (in our units:math:<span class="math">\(c=1\)</span>) [Lasenby,pp229-231].</p>
<p><tt class="docutils literal"><span class="pre">Begin</span> <span class="pre">Program</span> <span class="pre">Maxwell.py</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.GA</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.latex_ex</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">set_main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">__name__</span><span class="p">])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    
    <span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;1  0  0  0,&#39;</span><span class="o">+</span>\
             <span class="s">&#39;0 -1  0  0,&#39;</span><span class="o">+</span>\
             <span class="s">&#39;0  0 -1  0,&#39;</span><span class="o">+</span>\
             <span class="s">&#39;0  0  0 -1&#39;</span>

    <span class="nb">vars</span> <span class="o">=</span> <span class="n">make_symbols</span><span class="p">(</span><span class="s">&#39;t x y z&#39;</span><span class="p">)</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;gamma_t gamma_x gamma_y gamma_z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="bp">True</span><span class="p">,</span><span class="nb">vars</span><span class="p">)</span>
    <span class="n">LatexPrinter</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;pseudo&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;$I$ Pseudo-Scalar&#39;</span>
    <span class="k">print</span> <span class="s">&#39;I =&#39;</span><span class="p">,</span><span class="n">I</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;E&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">B</span><span class="o">.</span><span class="n">set_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">E</span><span class="o">.</span><span class="n">set_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">*=</span> <span class="n">gamma_t</span>
    <span class="n">E</span> <span class="o">*=</span> <span class="n">gamma_t</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;J&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">E</span><span class="o">+</span><span class="n">I</span><span class="o">*</span><span class="n">B</span>
    <span class="k">print</span> <span class="s">&#39; &#39;</span>
    <span class="k">print</span> <span class="s">&#39;$B$ Magnetic Field Bi-Vector&#39;</span>
    <span class="k">print</span> <span class="s">&#39;B = Bvec gamma_0 =&#39;</span><span class="p">,</span><span class="n">B</span>
    <span class="k">print</span> <span class="s">&#39;$F$ Electric Field Bi-Vector&#39;</span>
    <span class="k">print</span> <span class="s">&#39;E = Evec gamma_0 =&#39;</span><span class="p">,</span><span class="n">E</span>
    <span class="k">print</span> <span class="s">&#39;$E+IB$ Electo-Magnetic Field Bi-Vector&#39;</span>
    <span class="k">print</span> <span class="s">&#39;F = E+IB =&#39;</span><span class="p">,</span><span class="n">F</span>
    <span class="k">print</span> <span class="s">&#39;$J$ Four Current&#39;</span>
    <span class="k">print</span> <span class="s">&#39;J =&#39;</span><span class="p">,</span><span class="n">J</span>
    <span class="n">gradF</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">grad</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;Geometric Derivative of Electo-Magnetic Field Bi-Vector&#39;</span>
    <span class="n">MV_format</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">nabla F =&#39;</span><span class="p">,</span><span class="n">gradF</span>
    <span class="k">print</span> <span class="s">&#39;All Maxwell Equations are&#39;</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">nabla F = J&#39;</span>
    <span class="k">print</span> <span class="s">&#39;Div $E$ and Curl $H$ Equations&#39;</span>
    <span class="k">print</span> <span class="s">&#39;&lt;</span><span class="se">\\</span><span class="s">nabla F&gt;_1 -J =&#39;</span><span class="p">,</span><span class="n">gradF</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">J</span><span class="p">,</span><span class="s">&#39; = 0&#39;</span>
    <span class="k">print</span> <span class="s">&#39;Curl $E$ and Div $B$ equations&#39;</span>
    <span class="k">print</span> <span class="s">&#39;&lt;</span><span class="se">\\</span><span class="s">nabla F&gt;_3 =&#39;</span><span class="p">,</span><span class="n">gradF</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span><span class="s">&#39; = 0&#39;</span>
    <span class="n">xdvi</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;Maxwell.tex&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">End</span> <span class="pre">Program</span> <span class="pre">Maxwell.py</span></tt></p>
<p><tt class="docutils literal"><span class="pre">Begin</span> <span class="pre">Program</span> <span class="pre">Output</span></tt></p>
<p><span class="math">\(I\)</span> Pseudo-Scalar</p>
<div class="math">
\[\begin{equation*}
I = {\gamma}_{t}{\gamma}_{x}{\gamma}_{y}{\gamma}_{z}
\end{equation*}\]</div><p><span class="math">\(B\)</span> Magnetic Field Bi-Vector</p>
<div class="math">
\[\begin{equation*}
B = - {B^{x}}{\gamma}_{t}{\gamma}_{x}- {B^{y}}{\gamma}_{t}{\gamma}_{y}- {B^{z}}{\gamma}_{t}{\gamma}_{z}
\end{equation*}\]</div><p><span class="math">\(F\)</span> Electric Field Bi-Vector</p>
<div class="math">
\[\begin{equation*}
E = - {E^{x}}{\gamma}_{t}{\gamma}_{x}- {E^{y}}{\gamma}_{t}{\gamma}_{y}- {E^{z}}{\gamma}_{t}{\gamma}_{z}
\end{equation*}\]</div><p><span class="math">\(E+IB\)</span> Electo-Magnetic Field Bi-Vector</p>
<div class="math">
\[\begin{equation*}
F = - {E^{x}}{\gamma}_{t}{\gamma}_{x}- {E^{y}}{\gamma}_{t}{\gamma}_{y}- {B^{z}}{\gamma}_{x}{\gamma}_{y}- {E^{z}}{\gamma}_{t}{\gamma}_{z}+ {B^{y}}{\gamma}_{x}{\gamma}_{z}- {B^{x}}{\gamma}_{y}{\gamma}_{z}
\end{equation*}\]</div><p><span class="math">\(J\)</span> Four Current</p>
<div class="math">
\[\begin{equation*}
J =  {J^{t}}{\gamma}_{t}+ {J^{x}}{\gamma}_{x}+ {J^{y}}{\gamma}_{y}+ {J^{z}}{\gamma}_{z}
\end{equation*}\]</div><p>Geometric Derivative of Electo-Magnetic Field Bi-Vector</p>
<div class="math">
\[\begin{align*}
\nabla F & =   \left(\partial_{z} {E^{z}} + \partial_{y} {E^{y}} + \partial_{x} {E^{x}}\right){\gamma}_{t} \\ & + \left(-\partial_{t} {E^{x}} + \partial_{y} {B^{z}} -\partial_{z} {B^{y}}\right){\gamma}_{x} \\ & + \left(\partial_{z} {B^{x}} -\partial_{t} {E^{y}} -\partial_{x} {B^{z}}\right){\gamma}_{y} \\ & + \left(-\partial_{y} {B^{x}} -\partial_{t} {E^{z}} + \partial_{x} {B^{y}}\right){\gamma}_{z} \\ & + \left(-\partial_{x} {E^{y}} -\partial_{t} {B^{z}} + \partial_{y} {E^{x}}\right){\gamma}_{t}{\gamma}_{x}{\gamma}_{y} \\ & + \left(-\partial_{x} {E^{z}} + \partial_{t} {B^{y}} + \partial_{z} {E^{x}}\right){\gamma}_{t}{\gamma}_{x}{\gamma}_{z} \\ & + \left(-\partial_{t} {B^{x}} -\partial_{y} {E^{z}} + \partial_{z} {E^{y}}\right){\gamma}_{t}{\gamma}_{y}{\gamma}_{z} \\ & + \left(\partial_{y} {B^{y}} + \partial_{z} {B^{z}} + \partial_{x} {B^{x}}\right){\gamma}_{x}{\gamma}_{y}{\gamma}_{z}\end{align*}\]</div><p>All Maxwell Equations are</p>
<div class="math">
\[\begin{equation*}
\nabla F = J
\end{equation*}\]</div><p>Div <span class="math">\(E\)</span> and Curl <span class="math">\(H\)</span> Equations</p>
<div class="math">
\[\begin{align*}
<\nabla F>_1 -J & =   \left(-{J^{t}} + \partial_{z} {E^{z}} + \partial_{y} {E^{y}} + \partial_{x} {E^{x}}\right){\gamma}_{t} \\ & + \left(-{J^{x}} -\partial_{t} {E^{x}} + \partial_{y} {B^{z}} -\partial_{z} {B^{y}}\right){\gamma}_{x} \\ & + \left(\partial_{z} {B^{x}} -\partial_{t} {E^{y}} -{J^{y}} -\partial_{x} {B^{z}}\right){\gamma}_{y} \\ & + \left(-\partial_{y} {B^{x}} -\partial_{t} {E^{z}} -{J^{z}} + \partial_{x} {B^{y}}\right){\gamma}_{z}\end{align*}\]</div><div class="math">
\[\begin{equation*}
  = 0
\end{equation*}\]</div><p>Curl <span class="math">\(E\)</span> and Div <span class="math">\(B\)</span> equations</p>
<div class="math">
\[\begin{align*}
<\nabla F>_3 & =   \left(-\partial_{x} {E^{y}} -\partial_{t} {B^{z}} + \partial_{y} {E^{x}}\right){\gamma}_{t}\W {\gamma}_{x}\W {\gamma}_{y} \\ & + \left(-\partial_{x} {E^{z}} + \partial_{t} {B^{y}} + \partial_{z} {E^{x}}\right){\gamma}_{t}\W {\gamma}_{x}\W {\gamma}_{z} \\ & + \left(-\partial_{t} {B^{x}} -\partial_{y} {E^{z}} + \partial_{z} {E^{y}}\right){\gamma}_{t}\W {\gamma}_{y}\W {\gamma}_{z} \\ & + \left(\partial_{y} {B^{y}} + \partial_{z} {B^{z}} + \partial_{x} {B^{x}}\right){\gamma}_{x}\W {\gamma}_{y}\W {\gamma}_{z}\end{align*}\]</div><div class="math">
\[\begin{equation*}
  = 0
\end{equation*}\]</div><p><tt class="docutils literal"><span class="pre">End</span> <span class="pre">Program</span> <span class="pre">Output</span></tt></p>
</div>
<div class="section" id="dirac-s-equation">
<h4>Dirac&#8217;s Equation<a class="headerlink" href="#dirac-s-equation" title="Permalink to this headline">¶</a></h4>
<p>The geometric algebra/calculus allows one to formulate the Dirac equation in
real terms (no <span class="math">\(\sqrt{-1}\)</span>).  Spinors  <span class="math">\(\lp\Psi\rp\)</span> are even
multivectors in space time (Minkowski space with signature (1,-1,-1,-1)) and the
Dirac equation becomes
<span class="math">\(\nabla \Psi I \sigma_{z}-eA\Psi = m\Psi\gamma_{t}\)</span>.  All the terms in the
real equation are explined  in Doran and Lasenby [Lasenby,pp281-283].</p>
<p><tt class="docutils literal"><span class="pre">Begin</span> <span class="pre">Program</span> <span class="pre">Dirac.py</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/local/bin/python</span>
<span class="c">#Dirac.py</span>

<span class="kn">from</span> <span class="nn">sympy.galgebra.GA</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.latex_ex</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">set_main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">__name__</span><span class="p">])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;1  0  0  0,&#39;</span><span class="o">+</span>\
             <span class="s">&#39;0 -1  0  0,&#39;</span><span class="o">+</span>\
             <span class="s">&#39;0  0 -1  0,&#39;</span><span class="o">+</span>\
             <span class="s">&#39;0  0  0 -1&#39;</span>

    <span class="nb">vars</span> <span class="o">=</span> <span class="n">make_symbols</span><span class="p">(</span><span class="s">&#39;t x y z&#39;</span><span class="p">)</span>
    <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;gamma_t gamma_x gamma_y gamma_z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="bp">True</span><span class="p">,</span><span class="nb">vars</span><span class="p">)</span>
    
    <span class="n">parms</span> <span class="o">=</span> <span class="n">make_symbols</span><span class="p">(</span><span class="s">&#39;m e&#39;</span><span class="p">)</span>
    <span class="n">Format</span><span class="p">(</span><span class="s">&#39;1 1 1 1&#39;</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span><span class="s">&#39;pseudo&#39;</span><span class="p">)</span>
    <span class="n">nvars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;psi&#39;</span><span class="p">,</span><span class="s">&#39;spinor&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>    
    <span class="n">sig_x</span> <span class="o">=</span> <span class="n">gamma_x</span><span class="o">*</span><span class="n">gamma_t</span>
    <span class="n">sig_y</span> <span class="o">=</span> <span class="n">gamma_y</span><span class="o">*</span><span class="n">gamma_t</span>
    <span class="n">sig_z</span> <span class="o">=</span> <span class="n">gamma_z</span><span class="o">*</span><span class="n">gamma_t</span>
    <span class="k">print</span> <span class="s">&#39;$A$ is 4-vector potential&#39;</span>
    <span class="k">print</span> <span class="n">A</span>
    <span class="k">print</span> <span class="s">r&#39;$\bm{\psi}$ is 8-component real spinor (even multi-vector)&#39;</span>
    <span class="k">print</span> <span class="n">psi</span>
    <span class="n">dirac_eq</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">grad</span><span class="p">()</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">sig_z</span><span class="o">-</span><span class="n">e</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">psi</span><span class="o">-</span><span class="n">m</span><span class="o">*</span><span class="n">psi</span><span class="o">*</span><span class="n">gamma_t</span>
    <span class="n">dirac_eq</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;Dirac equation in terms of real geometric algebra/calculus &#39;</span><span class="o">+</span>\
          <span class="s">r&#39;$\lp\nabla \bm{\psi} I \sigma_{z}-eA\bm{\psi} = m\bm{\psi}\gamma_{t}\rp$&#39;</span>
    <span class="k">print</span> <span class="s">&#39;Spin measured with respect to $z$ axis&#39;</span>
    <span class="n">Format</span><span class="p">(</span><span class="s">&#39;mv=3&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">r&#39;\nabla \bm{\psi} I \sigma_{z}-eA\bm{\psi}-m\bm{\psi}\gamma_{t} = &#39;</span><span class="p">,</span><span class="n">dirac_eq</span><span class="p">,</span><span class="s">&#39; = 0&#39;</span>
    <span class="n">xdvi</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;Dirac.tex&#39;</span><span class="p">)</span>
    
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">End</span> <span class="pre">Program</span> <span class="pre">Dirac.py</span></tt></p>
<p><tt class="docutils literal"><span class="pre">Begin</span> <span class="pre">Program</span> <span class="pre">Output</span></tt></p>
<p><span class="math">\(A\)</span> is 4-vector potential</p>
<div class="math">
\[\begin{equation*}
A =  {A^{t}}{\gamma}_{t}+ {A^{x}}{\gamma}_{x}+ {A^{y}}{\gamma}_{y}+ {A^{z}}{\gamma}_{z}
\end{equation*}\]</div><p><span class="math">\(\bm{\psi}\)</span> is 8-component real spinor (even multi-vector)</p>
<div class="math">
\[\begin{equation*}
{}\bm{{\psi}} =  {{\psi}}+ {{\psi}^{tx}}{\gamma}_{t}{\gamma}_{x}+ {{\psi}^{ty}}{\gamma}_{t}{\gamma}_{y}+ {{\psi}^{xy}}{\gamma}_{x}{\gamma}_{y}+ {{\psi}^{tz}}{\gamma}_{t}{\gamma}_{z}+ {{\psi}^{xz}}{\gamma}_{x}{\gamma}_{z}+ {{\psi}^{yz}}{\gamma}_{y}{\gamma}_{z}+ {{\psi}^{txyz}}{\gamma}_{t}{\gamma}_{x}{\gamma}_{y}{\gamma}_{z}
\end{equation*}\]</div><p>Dirac equation in terms of real geometric algebra/calculus
<span class="math">\(\lp\nabla \bm{\psi} I \sigma_{z}-eA\bm{\psi} = m\bm{\psi}\gamma_{t}\rp\)</span>
Spin measured with respect to <span class="math">\(z\)</span> axis</p>
<div class="math">
\[\begin{align*}
\nabla \bm{\psi} I \sigma_{z}-eA\bm{\psi}-m\bm{\psi}\gamma_{t} & =    \left(-e {A^{y}} {{\psi}^{ty}} -m {{\psi}} -\partial_{z} {{\psi}^{txyz}} -\partial_{y} {{\psi}^{tx}} -e {A^{z}} {{\psi}^{tz}} -e {A^{x}} {{\psi}^{tx}} + \partial_{x} {{\psi}^{ty}} -e {A^{t}} {{\psi}} + \partial_{t} {{\psi}^{xy}}\right){\gamma}_{t} \\ & + \left(-e {A^{y}} {{\psi}^{xy}} + \partial_{z} {{\psi}^{yz}} -e {A^{z}} {{\psi}^{xz}} -e {A^{t}} {{\psi}^{tx}} + m {{\psi}^{tx}} -\partial_{x} {{\psi}^{xy}} + \partial_{y} {{\psi}} -e {A^{x}} {{\psi}} -\partial_{t} {{\psi}^{ty}}\right){\gamma}_{x} \\ & + \left(-e {A^{y}} {{\psi}} + e {A^{x}} {{\psi}^{xy}} -e {A^{t}} {{\psi}^{ty}} -\partial_{x} {{\psi}} + \partial_{t} {{\psi}^{tx}} -\partial_{z} {{\psi}^{xz}} -e {A^{z}} {{\psi}^{yz}} + m {{\psi}^{ty}} -\partial_{y} {{\psi}^{xy}}\right){\gamma}_{y} \\ & + \left(-\partial_{z} {{\psi}^{xy}} + e {A^{x}} {{\psi}^{xz}} -e {A^{t}} {{\psi}^{tz}} -\partial_{x} {{\psi}^{yz}} + \partial_{y} {{\psi}^{xz}} + e {A^{y}} {{\psi}^{yz}} + \partial_{t} {{\psi}^{txyz}} + m {{\psi}^{tz}} -e {A^{z}} {{\psi}}\right){\gamma}_{z} \\ & + \left(\partial_{y} {{\psi}^{ty}} -e {A^{y}} {{\psi}^{tx}} + e {A^{x}} {{\psi}^{ty}} + \partial_{z} {{\psi}^{tz}} -e {A^{z}} {{\psi}^{txyz}} + \partial_{x} {{\psi}^{tx}} -e {A^{t}} {{\psi}^{xy}} -\partial_{t} {{\psi}} -m {{\psi}^{xy}}\right){\gamma}_{t}{\gamma}_{x}{\gamma}_{y} \\ & + \left(-\partial_{y} {{\psi}^{tz}} + \partial_{x} {{\psi}^{txyz}} -e {A^{t}} {{\psi}^{xz}} + e {A^{x}} {{\psi}^{tz}} + e {A^{y}} {{\psi}^{txyz}} + \partial_{z} {{\psi}^{ty}} -m {{\psi}^{xz}} -e {A^{z}} {{\psi}^{tx}} -\partial_{t} {{\psi}^{yz}}\right){\gamma}_{t}{\gamma}_{x}{\gamma}_{z} \\ & + \left(-e {A^{t}} {{\psi}^{yz}} -\partial_{z} {{\psi}^{tx}} + \partial_{x} {{\psi}^{tz}} -m {{\psi}^{yz}} + \partial_{y} {{\psi}^{txyz}} + \partial_{t} {{\psi}^{xz}} -e {A^{z}} {{\psi}^{ty}} -e {A^{x}} {{\psi}^{txyz}} + e {A^{y}} {{\psi}^{tz}}\right){\gamma}_{t}{\gamma}_{y}{\gamma}_{z} \\ & + \left(\partial_{z} {{\psi}} + e {A^{y}} {{\psi}^{xz}} + m {{\psi}^{txyz}} -\partial_{t} {{\psi}^{tz}} -\partial_{x} {{\psi}^{xz}} -e {A^{x}} {{\psi}^{yz}} -e {A^{t}} {{\psi}^{txyz}} -\partial_{y} {{\psi}^{yz}} -e {A^{z}} {{\psi}^{xy}}\right){\gamma}_{x}{\gamma}_{y}{\gamma}_{z}\end{align*}\]</div><div class="math">
\[\begin{equation*}
  = 0
\end{equation*}\]</div><p><tt class="docutils literal"><span class="pre">End</span> <span class="pre">Program</span> <span class="pre">Output</span></tt></p>
</div>
<div class="section" id="spherical-coordinates">
<h4>Spherical Coordinates<a class="headerlink" href="#spherical-coordinates" title="Permalink to this headline">¶</a></h4>
<p>Curvilinear coodinates are implemented as shown in section <a class="reference internal" href="#deriv"><em>Geometric Derivative</em></a>.  The
gradient of a scalar function and the divergence and curl of a vector function
(<span class="math">\(-I\lp\nabla\W A\rp\)</span> is the curl in three dimensions in the notation of
geometric algebra) to demonstrate the formulas derived in section <a class="reference internal" href="#deriv"><em>Geometric Derivative</em></a>.</p>
<p><tt class="docutils literal"><span class="pre">Begin</span> <span class="pre">Program</span> <span class="pre">coords.py</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usrlocal/bin/python</span>
<span class="c">#EandM.py</span>

<span class="kn">from</span> <span class="nn">sympy.galgebra.GA</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sympy.galgebra.latex_ex</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">import</span> <span class="nn">sympy</span><span class="o">,</span><span class="nn">numpy</span><span class="o">,</span><span class="nn">sys</span>

<span class="n">set_main</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">__name__</span><span class="p">])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">metric</span> <span class="o">=</span> <span class="s">&#39;1 0 0,&#39;</span><span class="o">+</span>\
             <span class="s">&#39;0 1 0,&#39;</span><span class="o">+</span>\
             <span class="s">&#39;0 0 1&#39;</span>

    <span class="n">MV</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="s">&#39;gamma_x gamma_y gamma_z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="p">,</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">Format</span><span class="p">(</span><span class="s">&#39;1 1 1 1&#39;</span><span class="p">)</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="n">make_symbols</span><span class="p">(</span><span class="s">&#39;r theta phi&#39;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">gamma_z</span><span class="o">+</span><span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span>\
        <span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">gamma_x</span><span class="o">+</span><span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">gamma_y</span><span class="p">))</span>
    <span class="n">x</span><span class="o">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>

    <span class="n">MV</span><span class="o">.</span><span class="n">rebase</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">coords</span><span class="p">,</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="bp">False</span><span class="p">)</span>

    <span class="c">#psi = MV.scalar_fct(&#39;psi&#39;)</span>
    <span class="n">psi</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;psi&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c">#psi.name = &#39;psi&#39;</span>
    <span class="n">dpsi</span> <span class="o">=</span> <span class="n">psi</span><span class="o">.</span><span class="n">grad</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;Gradient of Scalar Function $</span><span class="se">\\</span><span class="s">psi$&#39;</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">nabla</span><span class="se">\\</span><span class="s">psi =&#39;</span><span class="p">,</span><span class="n">dpsi</span>
    
    <span class="c">#A = MV.vector_fct(&#39;A&#39;)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">fct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c">#A.name = &#39;A&#39;</span>
    <span class="k">print</span> <span class="s">&#39;Div and Curl of Vector Function $A$&#39;</span>
    <span class="k">print</span> <span class="n">A</span>
        
    <span class="n">gradA</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">grad</span><span class="p">()</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">MV</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span><span class="s">&#39;pseudo&#39;</span><span class="p">)</span>
    <span class="n">divA</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">grad_int</span><span class="p">()</span>
    <span class="n">curlA</span> <span class="o">=</span> <span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">grad_ext</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">nabla </span><span class="se">\\</span><span class="s">cdot A =&#39;</span><span class="p">,</span><span class="n">divA</span>
    <span class="n">Format</span><span class="p">(</span><span class="s">&#39;mv=3&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;-I</span><span class="se">\\</span><span class="s">lp</span><span class="se">\\</span><span class="s">nabla </span><span class="se">\\</span><span class="s">W A</span><span class="se">\\</span><span class="s">rp =&#39;</span><span class="p">,</span><span class="n">curlA</span>
    
    <span class="n">xdvi</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;coords.tex&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">End</span> <span class="pre">Program</span> <span class="pre">coords.py</span></tt></p>
<p><tt class="docutils literal"><span class="pre">Begin</span> <span class="pre">Program</span> <span class="pre">Output</span></tt></p>
<p>Gradient of Scalar Function <span class="math">\(\psi\)</span></p>
<div class="math">
\[\begin{equation*}
\nabla\psi =  \partial_{r} {{\psi}}{}\bm{e}_{r}+\frac{1 \partial_{{\theta}} {{\psi}}}{r}{}\bm{e}_{{\theta}}+\frac{1 \partial_{{\phi}} {{\psi}}}{r \operatorname{sin}\left({\theta}\right)}{}\bm{e}_{{\phi}}
\end{equation*}\]</div><p>Div and Curl of Vector Function <span class="math">\(A\)</span></p>
<div class="math">
\[\begin{equation*}
A =  {A^{r}}{}\bm{e}_{r}+ {A^{{\theta}}}{}\bm{e}_{{\theta}}+ {A^{{\phi}}}{}\bm{e}_{{\phi}}
\end{equation*}\]</div><div class="math">
\[\begin{equation*}
\nabla \cdot A =  \left(\frac{{A^{{\theta}}} \operatorname{cos}\left({\theta}\right)}{r \operatorname{sin}\left({\theta}\right)} + 2 \frac{{A^{r}}}{r} + \partial_{r} {A^{r}} + \frac{\partial_{{\theta}} {A^{{\theta}}}}{r} + \frac{\partial_{{\phi}} {A^{{\phi}}}}{r \operatorname{sin}\left({\theta}\right)}\right)
\end{equation*}\]</div><div class="math">
\[\begin{align*}
-I\lp\nabla \W A\rp & =   \left(\frac{\partial_{{\theta}} {A^{{\phi}}}}{r} + \frac{{A^{{\phi}}} \operatorname{cos}\left({\theta}\right)}{r \operatorname{sin}\left({\theta}\right)} -\frac{\partial_{{\phi}} {A^{{\theta}}}}{r \operatorname{sin}\left({\theta}\right)}\right){}\bm{e}_{r} \\ & - \left(\frac{{A^{{\phi}}}}{r} + \partial_{r} {A^{{\phi}}} -\frac{\partial_{{\phi}} {A^{r}}}{r \operatorname{sin}\left({\theta}\right)}\right){}\bm{e}_{{\theta}} \\ & + \left(\frac{{A^{{\theta}}}}{r} + \partial_{r} {A^{{\theta}}} -\frac{\partial_{{\theta}} {A^{r}}}{r}\right){}\bm{e}_{{\phi}}\end{align*}\]</div><p><tt class="docutils literal"><span class="pre">End</span> <span class="pre">Program</span> <span class="pre">Output</span></tt></p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference external" href="http://geocalc.clas.asu.edu/html/CA_to_GC.html">Hestenes</a></dt>
<dd><tt class="docutils literal"><span class="pre">Clifford</span> <span class="pre">Algebra</span> <span class="pre">to</span> <span class="pre">Geometric</span> <span class="pre">Calculus</span></tt> by  D.Hestenes and G. Sobczyk, Kluwer
Academic Publishers, 1984.</dd>
<dt><a class="reference external" href="http://www.mrao.cam.ac.uk/~cjld1/pages/book.htm">Lasenby</a></dt>
<dd><tt class="docutils literal"><span class="pre">Geometric</span> <span class="pre">Algebra</span> <span class="pre">for</span> <span class="pre">Physicists</span></tt> by  C. Doran and A. Lasenby, Cambridge
University Press, 2003.</dd>
</dl>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Geometric Algebra Module for Sympy</a><ul>
<li><a class="reference internal" href="#what-is-geometric-algebra">What is Geometric Algebra?</a></li>
<li><a class="reference internal" href="#vector-basis-and-metric">Vector Basis and Metric</a></li>
<li><a class="reference internal" href="#representation-and-reduction-of-multivector-bases">Representation and Reduction of Multivector Bases</a></li>
<li><a class="reference internal" href="#base-representation-of-multivectors">Base Representation of Multivectors</a></li>
<li><a class="reference internal" href="#blade-representation-of-multivectors">Blade Representation of Multivectors</a></li>
<li><a class="reference internal" href="#outer-and-inner-products-left-and-right-contractions">Outer and Inner Products, Left and Right Contractions</a></li>
<li><a class="reference internal" href="#reverse-of-multivector">Reverse of Multivector</a></li>
<li><a class="reference internal" href="#reciprocal-frames">Reciprocal Frames</a></li>
<li><a class="reference internal" href="#geometric-derivative">Geometric Derivative</a></li>
<li><a class="reference internal" href="#module-components">Module Components</a><ul>
<li><a class="reference internal" href="#initializing-multivector-class">Initializing Multivector Class</a></li>
<li><a class="reference internal" href="#instantiating-a-multivector">Instantiating a Multivector</a></li>
<li><a class="reference internal" href="#basic-multivector-class-functions">Basic Multivector Class Functions</a></li>
<li><a class="reference internal" href="#sympy-functions-applied-inplace-to-multivector-coefficients">Sympy Functions Applied Inplace to Multivector Coefficients</a></li>
<li><a class="reference internal" href="#helper-functions">Helper Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#algebra">Algebra</a><ul>
<li><a class="reference internal" href="#example-header">Example Header</a></li>
<li><a class="reference internal" href="#basic-geometric-algebra-operations">Basic Geometric Algebra Operations</a></li>
<li><a class="reference internal" href="#examples-of-conformal-geometry">Examples of Conformal Geometry</a></li>
<li><a class="reference internal" href="#calculation-of-reciprocal-frame">Calculation of Reciprocal Frame</a></li>
<li><a class="reference internal" href="#hyperbolic-geometry">Hyperbolic Geometry</a></li>
</ul>
</li>
<li><a class="reference internal" href="#calculus">Calculus</a><ul>
<li><a class="reference internal" href="#maxwell-s-equations">Maxwell&#8217;s Equations</a></li>
<li><a class="reference internal" href="#dirac-s-equation">Dirac&#8217;s Equation</a></li>
<li><a class="reference internal" href="#spherical-coordinates">Spherical Coordinates</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../../geometry.html"
                        title="previous chapter">Geometry Module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../latex_ex/latex_ex.html"
                        title="next chapter">Extended LaTeXModule for Sympy</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../_sources/modules/galgebra/GA/GAsympy.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../latex_ex/latex_ex.html" title="Extended LaTeXModule for Sympy"
             >next</a> |</li>
        <li class="right" >
          <a href="../../geometry.html" title="Geometry Module"
             >previous</a> |</li>
        <li><a href="../../../index.html">SymPy v0.7.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, 2009, 2010, 2011 SymPy Development Team.
      Last updated on Jul 29, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>