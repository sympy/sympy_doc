

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Structural Details of Code Generation with Sympy &mdash; SymPy 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0 documentation" href="../index.html" />
    <link rel="up" title="SymPy Modules Reference" href="index.html" />
    <link rel="next" title="Numeric Computation" href="numeric-computation.html" />
    <link rel="prev" title="Numerical evaluation" href="evalf.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="numeric-computation.html" title="Numeric Computation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="evalf.html" title="Numerical evaluation"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">SymPy 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="structural-details-of-code-generation-with-sympy">
<span id="codegen-prose"></span><h1>Structural Details of Code Generation with Sympy<a class="headerlink" href="#structural-details-of-code-generation-with-sympy" title="Permalink to this headline">¶</a></h1>
<p>Several submodules in SymPy allow one to generate directly compilable and
executable code in a variety of different programming languages from Sympy
expressions. In addition, there are functions that generate Python importable
objects that can evaluate SymPy expressions very efficiently.</p>
<p>We will start with a brief introduction to the components that make up the code
generation capabilities of SymPy.</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>There are four main levels of abstractions:</p>
<div class="highlight-python"><pre>expression
   |
code printers
   |
code generators
   |
autowrap</pre>
</div>
<p><a class="reference internal" href="utilities/autowrap.html#module-sympy.utilities.autowrap" title="sympy.utilities.autowrap"><tt class="xref py py-mod docutils literal"><span class="pre">sympy.utilities.autowrap</span></tt></a> uses codegen, and codegen uses the code
printers. <a class="reference internal" href="utilities/autowrap.html#module-sympy.utilities.autowrap" title="sympy.utilities.autowrap"><tt class="xref py py-mod docutils literal"><span class="pre">sympy.utilities.autowrap</span></tt></a> does everything: it lets you go
from SymPy expression to numerical function in the same Python process in one
step. codegen is actual code generation, i.e., to compile and use later, or to
include in some larger project.</p>
<p>The code printers translate the SymPy objects into actual code, like <tt class="docutils literal"><span class="pre">abs(x)</span>
<span class="pre">-&gt;</span> <span class="pre">fabs(x)</span></tt> (for C).</p>
<p>The code printers don&#8217;t print optimal code in many cases. An example of this is
powers in C. <tt class="docutils literal"><span class="pre">x**2</span></tt> prints as <tt class="docutils literal"><span class="pre">pow(x,</span> <span class="pre">2)</span></tt> instead of <tt class="docutils literal"><span class="pre">x*x</span></tt>.  Other
optimizations (like mathematical simplifications) should happen before the code
printers.</p>
<p>Currently, <a class="reference internal" href="simplify/simplify.html#sympy.simplify.cse_main.cse" title="sympy.simplify.cse_main.cse"><tt class="xref py py-func docutils literal"><span class="pre">sympy.simplify.cse_main.cse()</span></tt></a> is not applied automatically anywhere in this
chain. It ideally happens at the codegen level, or somewhere above it.</p>
<p>We will iterate through the levels below.</p>
<p>The following three lines will be used to setup each example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">init_printing</span><span class="p">(</span><span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">beta</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">tau</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;f, g&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="code-printers-sympy-printing">
<h2>Code printers (sympy.printing)<a class="headerlink" href="#code-printers-sympy-printing" title="Permalink to this headline">¶</a></h2>
<p>This is where the meat of code generation is; the translation of SymPy
expressions to specific languages. Supported languages are C
(<a class="reference internal" href="printing.html#sympy.printing.ccode.ccode" title="sympy.printing.ccode.ccode"><tt class="xref py py-func docutils literal"><span class="pre">sympy.printing.ccode.ccode()</span></tt></a>), Fortran 95
(<a class="reference internal" href="printing.html#sympy.printing.fcode.fcode" title="sympy.printing.fcode.fcode"><tt class="xref py py-func docutils literal"><span class="pre">sympy.printing.fcode.fcode()</span></tt></a>), Javascript
(<a class="reference internal" href="printing.html#sympy.printing.jscode.jscode" title="sympy.printing.jscode.jscode"><tt class="xref py py-func docutils literal"><span class="pre">sympy.printing.jscode.jscode()</span></tt></a>), Julia
(<a class="reference internal" href="printing.html#sympy.printing.julia.julia_code" title="sympy.printing.julia.julia_code"><tt class="xref py py-func docutils literal"><span class="pre">sympy.printing.julia.julia_code()</span></tt></a>), Mathematica
(<a class="reference internal" href="printing.html#sympy.printing.mathematica.mathematica_code" title="sympy.printing.mathematica.mathematica_code"><tt class="xref py py-func docutils literal"><span class="pre">sympy.printing.mathematica.mathematica_code()</span></tt></a>), Octave/Matlab
(<a class="reference internal" href="printing.html#sympy.printing.octave.octave_code" title="sympy.printing.octave.octave_code"><tt class="xref py py-func docutils literal"><span class="pre">sympy.printing.octave.octave_code()</span></tt></a>), Python (print_python, which is
actually more like a lightweight version of codegen for Python, and
<a class="reference internal" href="printing.html#sympy.printing.lambdarepr.lambdarepr" title="sympy.printing.lambdarepr.lambdarepr"><tt class="xref py py-func docutils literal"><span class="pre">sympy.printing.lambdarepr.lambdarepr()</span></tt></a>, which supports many libraries
(like NumPy), and theano
(<a class="reference internal" href="printing.html#sympy.printing.theanocode.theano_function" title="sympy.printing.theanocode.theano_function"><tt class="xref py py-func docutils literal"><span class="pre">sympy.printing.theanocode.theano_function()</span></tt></a>). The code printers are
special cases of the other prints in SymPy (str printer, pretty printer, etc.).</p>
<p>An important distinction is that the code printer has to deal with assignments
(using the <a class="reference internal" href="printing.html#sympy.printing.codeprinter.Assignment" title="sympy.printing.codeprinter.Assignment"><tt class="xref py py-class docutils literal"><span class="pre">sympy.printing.codeprinter.Assignment</span></tt></a> object).This serves as
building blocks for the code printers and hence the <tt class="docutils literal"><span class="pre">codegen</span></tt> module.  An
example that shows the use of <tt class="docutils literal"><span class="pre">Assignment</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.printing.codeprinter</span> <span class="kn">import</span> <span class="n">Assignment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">known_mat</span> <span class="o">=</span> <span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Assignment</span><span class="p">(</span><span class="n">known_mat</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>
<span class="go">K := [x  y  z]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Assignment</span><span class="p">(</span><span class="n">known_mat</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">lhs</span>
<span class="go">K</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Assignment</span><span class="p">(</span><span class="n">known_mat</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">rhs</span>
<span class="go">[x  y  z]</span>
</pre></div>
</div>
<p>Here is a simple example of printing a C version of a SymPy expression:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">Z</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">    2</span>
<span class="go">-Z⋅e ⋅k</span>
<span class="go">────────</span>
<span class="go">  2⋅r</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ccode</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="go">-1.0L/2.0L*Z*pow(e, 2)*k/r</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ccode</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="s2">&quot;E&quot;</span><span class="p">)</span>
<span class="go">E = -1.0L/2.0L*Z*pow(e, 2)*k/r;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Piecewise</span></tt> expressions are converted into conditionals. If an <tt class="docutils literal"><span class="pre">assign_to</span></tt>
variable is provided an if statement is created, otherwise the ternary operator
is used. Note that if the <tt class="docutils literal"><span class="pre">Piecewise</span></tt> lacks a default term, represented by
<tt class="docutils literal"><span class="pre">(expr,</span> <span class="pre">True)</span></tt> then an error will be thrown.  This is to prevent generating
an expression that may not evaluate to anything. A use case for <tt class="docutils literal"><span class="pre">Piecewise</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">fcode</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">tau</span><span class="p">))</span>
<span class="go">      if (x &gt; 0) then</span>
<span class="go">         tau = x + 1</span>
<span class="go">      else</span>
<span class="go">         tau = x</span>
<span class="go">      end if</span>
</pre></div>
</div>
<p>The various printers also tend to support <tt class="docutils literal"><span class="pre">Indexed</span></tt> objects well. With
<tt class="docutils literal"><span class="pre">contract=True</span></tt> these expressions will be turned into loops, whereas
<tt class="docutils literal"><span class="pre">contract=False</span></tt> will just print the assignment expression that should be
looped over:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">len_y</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat_1</span> <span class="o">=</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;mat_1&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">len_y</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat_2</span> <span class="o">=</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;mat_2&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">len_y</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dy</span> <span class="o">=</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;Dy&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">len_y</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">len_y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Dy</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">mat_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat_1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">mat_2</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mat_2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">jscode</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="n">eq</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">contract</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">Dy[i] = (mat_1[i + 1] - mat_1[i])/(mat_2[i + 1] - mat_2[i]);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Res</span> <span class="o">=</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;Res&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">len_y</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="n">len_y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Res</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">mat_1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">mat_2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">jscode</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="n">eq</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">contract</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="go">for (var j=0; j&lt;5; j++){</span>
<span class="go">   Res[j] = 0;</span>
<span class="go">}</span>
<span class="go">for (var j=0; j&lt;5; j++){</span>
<span class="go">   for (var j=0; j&lt;5; j++){</span>
<span class="go">      Res[j] = Res[j] + mat_1[j]*mat_2[j];</span>
<span class="go">   }</span>
<span class="go">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">jscode</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="n">eq</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">contract</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">Res[j] = mat_1[j]*mat_2[j];</span>
</pre></div>
</div>
<p>Custom printing can be defined for certain types by passing a dictionary of
&#8220;type&#8221; : &#8220;function&#8221; to the <tt class="docutils literal"><span class="pre">user_functions</span></tt> kwarg. Alternatively, the
dictionary value can be a list of tuples i.e., <tt class="docutils literal"><span class="pre">[(argument_test,</span>
<span class="pre">cfunction_string)]</span></tt>. This can be used to call a custom Octave function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">custom_functions</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>  <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="s2">&quot;existing_octave_fcn&quot;</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="p">[(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">,</span> <span class="s2">&quot;my_mat_fcn&quot;</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">,</span> <span class="s2">&quot;my_fcn&quot;</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">octave_code</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span> <span class="n">user_functions</span><span class="o">=</span><span class="n">custom_functions</span><span class="p">)</span>
<span class="go">existing_octave_fcn(x) + my_fcn(x) + my_mat_fcn([1 x])</span>
</pre></div>
</div>
<p>An example of Mathematica code printer:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">x_</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">((</span><span class="n">t</span> <span class="o">-</span> <span class="n">n</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">/</span> <span class="p">((</span><span class="o">-</span><span class="n">T</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">            ⎛-T⋅n + t⎞</span>
<span class="go">T⋅x(T⋅n)⋅sin⎜────────⎟</span>
<span class="go">            ⎝   T    ⎠</span>
<span class="go">──────────────────────</span>
<span class="go">       -T⋅n + t</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">summation</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mathematica_code</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="go">T*x[-T]*Sin[(T + t)/T]/(T + t) + T*x[T]*Sin[(-T + t)/T]/(-T + t) + T*x[0]*Sin[</span>
<span class="go">t/T]/t</span>
</pre></div>
</div>
<p>We can go through a common expression in different languages we support and see
how it works:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;k, gamma_1, gamma_2, r, I, S&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">g1</span> <span class="o">*</span> <span class="n">g2</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">I</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">            ⎛     2       ⎞</span>
<span class="go">I⋅S⋅γ₁⋅γ₂⋅k⋅⎝3⋅cos (β) - 1⎠</span>
<span class="go">───────────────────────────</span>
<span class="go">              3</span>
<span class="go">             r</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">jscode</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="s2">&quot;H_is&quot;</span><span class="p">))</span>
<span class="go">H_is = I*S*gamma_1*gamma_2*k*(3*Math.pow(Math.cos(beta), 2) - 1)/Math.pow(r, 3);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">ccode</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="s2">&quot;H_is&quot;</span><span class="p">))</span>
<span class="go">H_is = I*S*gamma_1*gamma_2*k*(3*pow(cos(beta), 2) - 1)/pow(r, 3);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">fcode</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="s2">&quot;H_is&quot;</span><span class="p">))</span>
<span class="go">      H_is = I*S*gamma_1*gamma_2*k*(3*cos(beta)**2 - 1)/r**3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">julia_code</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="s2">&quot;H_is&quot;</span><span class="p">))</span>
<span class="go">H_is = I.*S.*gamma_1.*gamma_2.*k.*(3*cos(beta).^2 - 1)./r.^3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">octave_code</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assign_to</span><span class="o">=</span><span class="s2">&quot;H_is&quot;</span><span class="p">))</span>
<span class="go">H_is = I.*S.*gamma_1.*gamma_2.*k.*(3*cos(beta).^2 - 1)./r.^3;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mathematica_code</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
<span class="go">I*S*gamma_1*gamma_2*k*(3*Cos[beta]^2 - 1)/r^3</span>
</pre></div>
</div>
</div>
<div class="section" id="codegen-sympy-utilities-codegen">
<h2>Codegen (sympy.utilities.codegen)<a class="headerlink" href="#codegen-sympy-utilities-codegen" title="Permalink to this headline">¶</a></h2>
<p>This module deals with creating compilable code from SymPy expressions. This is
lower level than autowrap, as it doesn&#8217;t actually attempt to compile the code,
but higher level than the printers, as it generates compilable files (including
header files), rather than just code snippets.</p>
<p>The user friendly functions, here, are <tt class="docutils literal"><span class="pre">codegen</span></tt> and <tt class="docutils literal"><span class="pre">make_routine</span></tt>.
<tt class="docutils literal"><span class="pre">codegen</span></tt> takes a list of <tt class="docutils literal"><span class="pre">(variable,</span> <span class="pre">expression)</span></tt> pairs and a language (C,
F95, and Octave/Matlab are supported). It returns, as strings, a code file and
a header file (for relevant languages). The variables are created as functions
that return the value of the expression as output.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">codegen</span></tt> callable is not in the sympy namespace automatically,
to use it you must first import <tt class="docutils literal"><span class="pre">codegen</span></tt> from <tt class="docutils literal"><span class="pre">sympy.utilities.codegen</span></tt></p>
</div>
<p>For instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.codegen</span> <span class="kn">import</span> <span class="n">codegen</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">length</span><span class="p">,</span> <span class="n">breadth</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;length, breadth, height&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">c_name</span><span class="p">,</span> <span class="n">c_code</span><span class="p">),</span> <span class="p">(</span><span class="n">h_name</span><span class="p">,</span> <span class="n">c_header</span><span class="p">)]</span> <span class="o">=</span> \
<span class="gp">... </span><span class="n">codegen</span><span class="p">((</span><span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">*</span><span class="n">breadth</span><span class="o">*</span><span class="n">height</span><span class="p">),</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="n">header</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">c_name</span><span class="p">)</span>
<span class="go">test.c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">c_code</span><span class="p">)</span>
<span class="go">#include &quot;test.h&quot;</span>
<span class="go">#include &lt;math.h&gt;</span>
<span class="go">double volume(double breadth, double height, double length) {</span>
<span class="go">   double volume_result;</span>
<span class="go">   volume_result = breadth*height*length;</span>
<span class="go">   return volume_result;</span>
<span class="go">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">h_name</span><span class="p">)</span>
<span class="go">test.h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">c_header</span><span class="p">)</span>
<span class="go">#ifndef PROJECT__TEST__H</span>
<span class="go">#define PROJECT__TEST__H</span>
<span class="go">double volume(double breadth, double height, double length);</span>
<span class="go">#endif</span>
</pre></div>
</div>
<p>Various flags to <tt class="docutils literal"><span class="pre">codegen</span></tt> let you modify things. The project name for
preprocessor instructions can be varied using <tt class="docutils literal"><span class="pre">project</span></tt>. Variables listed as
global variables in arg <tt class="docutils literal"><span class="pre">global_vars</span></tt> will not show up as function arguments.</p>
<p><tt class="docutils literal"><span class="pre">language</span></tt> is a case-insensitive string that indicates the source code
language. Currently, <tt class="docutils literal"><span class="pre">C</span></tt>, <tt class="docutils literal"><span class="pre">F95</span></tt> and <tt class="docutils literal"><span class="pre">Octave</span></tt> are supported. <tt class="docutils literal"><span class="pre">Octave</span></tt>
generates code compatible with both Octave and Matlab.</p>
<p><tt class="docutils literal"><span class="pre">header</span></tt> when True, a header is written on top of each source file. <tt class="docutils literal"><span class="pre">empty</span></tt>
when True, empty lines are used to structure the code. With
<tt class="docutils literal"><span class="pre">argument_sequence</span></tt> a sequence of arguments for the routine can be defined in
a preferred order.</p>
<p><tt class="docutils literal"><span class="pre">prefix</span></tt> defines a prefix for the names of the files that contain the source
code.  If omitted, the name of the first name_expr tuple is used.</p>
<p><tt class="docutils literal"><span class="pre">to_files</span></tt> when True, the code will be written to one or more files with the
given prefix.</p>
<p>Here is an example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">f_name</span><span class="p">,</span> <span class="n">f_code</span><span class="p">),</span> <span class="n">header</span><span class="p">]</span> <span class="o">=</span> <span class="n">codegen</span><span class="p">((</span><span class="s2">&quot;volume&quot;</span><span class="p">,</span> <span class="n">length</span><span class="o">*</span><span class="n">breadth</span><span class="o">*</span><span class="n">height</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s2">&quot;F95&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">empty</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">argument_sequence</span><span class="o">=</span><span class="p">(</span><span class="n">breadth</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">global_vars</span><span class="o">=</span><span class="p">(</span><span class="n">height</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f_code</span><span class="p">)</span>
<span class="go">REAL*8 function volume(breadth, length)</span>
<span class="go">implicit none</span>
<span class="go">REAL*8, intent(in) :: breadth</span>
<span class="go">REAL*8, intent(in) :: length</span>
<span class="go">volume = breadth*height*length</span>
<span class="go">end function</span>
</pre></div>
</div>
<p>The method <tt class="docutils literal"><span class="pre">make_routine</span></tt> creates a <tt class="docutils literal"><span class="pre">Routine</span></tt> object, which represents an
evaluation routine for a set of expressions. This is only good for internal use
by the CodeGen objects, as an intermediate representation from SymPy expression
to generated code.  It is not recommended to make a <tt class="docutils literal"><span class="pre">Routine</span></tt> object
yourself. You should instead use <tt class="docutils literal"><span class="pre">make_routine</span></tt> method. <tt class="docutils literal"><span class="pre">make_routine</span></tt> in
turn calls the <tt class="docutils literal"><span class="pre">routine</span></tt> method of the CodeGen object depending upon the
language of choice. This creates the internal objects representing assignments
and so on, and creates the <tt class="docutils literal"><span class="pre">Routine</span></tt> class with them.</p>
<p>The various codegen objects such as <tt class="docutils literal"><span class="pre">Routine</span></tt> and <tt class="docutils literal"><span class="pre">Variable</span></tt> aren&#8217;t SymPy
objects (they don&#8217;t subclass from Basic).</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.codegen</span> <span class="kn">import</span> <span class="n">make_routine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.hydrogen</span> <span class="kn">import</span> <span class="n">R_nl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">R_nl</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">routine</span> <span class="o">=</span> <span class="n">make_routine</span><span class="p">(</span><span class="s1">&#39;my_routine&#39;</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">result_var</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">results</span><span class="p">]</span>   
<span class="go">[result₅₁₄₂₃₄₁₆₈₁₃₉₇₇₁₉₄₂₈]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">results</span><span class="p">]</span>
<span class="go">⎡                ___________                                           ⎤</span>
<span class="go">⎢          y    ╱ (-y + 2)!   -2⋅x                                     ⎥</span>
<span class="go">⎢4⋅√6⋅(4⋅x) ⋅  ╱  ───────── ⋅ℯ    ⋅assoc_laguerre(-y + 2, 2⋅y + 1, 4⋅x)⎥</span>
<span class="go">⎢            ╲╱    (y + 3)!                                            ⎥</span>
<span class="go">⎢──────────────────────────────────────────────────────────────────────⎥</span>
<span class="go">⎣                                  3                                   ⎦</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">arguments</span><span class="p">]</span>
<span class="go">[x, y]</span>
</pre></div>
</div>
<p>Another more complicated example with a mixture of specified and
automatically-assigned names.  Also has Matrix output:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">routine</span> <span class="o">=</span> <span class="n">make_routine</span><span class="p">(</span><span class="s1">&#39;fcn&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">r</span><span class="p">),</span> <span class="n">Matrix</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">result_var</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">results</span><span class="p">]</span>   
<span class="go">[result_5397460570204848505]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">results</span><span class="p">]</span>
<span class="go">[x⋅y]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">arguments</span><span class="p">]</span>   
<span class="go">[x, y, a, r, out_8598435338387848786]</span>
</pre></div>
</div>
<p>We can examine the various arguments more closely:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.codegen</span> <span class="kn">import</span> <span class="p">(</span><span class="n">InputArgument</span><span class="p">,</span> <span class="n">OutputArgument</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">InOutArgument</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">arguments</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">InputArgument</span><span class="p">)]</span>
<span class="go">[x, y]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">arguments</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">OutputArgument</span><span class="p">)]</span>  
<span class="go">[a, out_8598435338387848786]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">arguments</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">OutputArgument</span><span class="p">)]</span>
<span class="go">[1, [x  2]]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">arguments</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">InOutArgument</span><span class="p">)]</span>
<span class="go">[r]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">routine</span><span class="o">.</span><span class="n">arguments</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">InOutArgument</span><span class="p">)]</span>
<span class="go">[r + x]</span>
</pre></div>
</div>
<p>The full API reference can be viewed <a class="reference internal" href="utilities/codegen.html#codegen-api"><em>here</em></a>.</p>
</div>
<div class="section" id="autowrap">
<h2>Autowrap<a class="headerlink" href="#autowrap" title="Permalink to this headline">¶</a></h2>
<p>Autowrap automatically generates code, writes it to disk, compiles it, and
imports it into the current session. Main functions of this module are
<tt class="docutils literal"><span class="pre">autowrap</span></tt>, <tt class="docutils literal"><span class="pre">binary_function</span></tt>, and <tt class="docutils literal"><span class="pre">ufuncify</span></tt>.</p>
<p>It also automatically converts expressions containing <tt class="docutils literal"><span class="pre">Indexed</span></tt> objects into
summations. The classes IndexedBase, Indexed and Idx represent a matrix element
M[i, j]. See <a class="reference internal" href="tensor/index.html#tensor-module"><em>Tensor Module</em></a> for more on this.</p>
<p id="id1"><tt class="docutils literal"><span class="pre">autowrap</span></tt> creates a wrapper using f2py or Cython and creates a numerical function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">autowrap</span></tt> callable is not in the sympy namespace automatically,
to use it you must first import <tt class="docutils literal"><span class="pre">autowrap</span></tt> from <tt class="docutils literal"><span class="pre">sympy.utilities.autowrap</span></tt></p>
</div>
<p>The callable returned from autowrap() is a binary Python function, not a SymPy
object. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="kn">import</span> <span class="n">autowrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_func</span> <span class="o">=</span> <span class="n">autowrap</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    
<span class="go">-1.0</span>
</pre></div>
</div>
<p>The various flags available with autowrap() help to modify the services
provided by the method. The argument <tt class="docutils literal"><span class="pre">tempdir</span></tt> tells autowrap to compile the
code in a specific directory, and leave the files intact when finished. For
instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="kn">import</span> <span class="n">autowrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.qho_1d</span> <span class="kn">import</span> <span class="n">psi_n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_</span> <span class="o">=</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_</span> <span class="o">=</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">i</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qho</span> <span class="o">=</span> <span class="n">autowrap</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">y_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">psi_n</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">omega</span><span class="p">)),</span> <span class="n">tempdir</span><span class="o">=</span><span class="s1">&#39;/tmp&#39;</span><span class="p">)</span>  
</pre></div>
</div>
<p>Checking the Fortran source code in the directory specified reveals this:</p>
<div class="highlight-python"><pre>subroutine autofunc(m, omega, x, y)
implicit none
INTEGER*4, intent(in) :: m
REAL*8, intent(in) :: omega
REAL*8, intent(in), dimension(1:m) :: x
REAL*8, intent(out), dimension(1:m) :: y
INTEGER*4 :: i

REAL*8, parameter :: hbar = 1.05457162d-34
REAL*8, parameter :: pi = 3.14159265358979d0
do i = 1, m
   y(i) = (m*omega)**(1.0d0/4.0d0)*exp(-4.74126166983329d+33*m*omega*x(i &amp;
         )**2)/(hbar**(1.0d0/4.0d0)*pi**(1.0d0/4.0d0))
end do

end subroutine</pre>
</div>
<p>Using the argument <tt class="docutils literal"><span class="pre">args</span></tt> along with it changes argument sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">y_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">psi_n</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">omega</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qho</span> <span class="o">=</span> <span class="n">autowrap</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">tempdir</span><span class="o">=</span><span class="s1">&#39;/tmp&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">omega</span><span class="p">])</span>  
</pre></div>
</div>
<p>yields:</p>
<div class="highlight-python"><pre>subroutine autofunc(y, x, m, omega)
implicit none
INTEGER*4, intent(in) :: m
REAL*8, intent(in) :: omega
REAL*8, intent(out), dimension(1:m) :: y
REAL*8, intent(in), dimension(1:m) :: x
INTEGER*4 :: i

REAL*8, parameter :: hbar = 1.05457162d-34
REAL*8, parameter :: pi = 3.14159265358979d0
do i = 1, m
   y(i) = (m*omega)**(1.0d0/4.0d0)*exp(-4.74126166983329d+33*m*omega*x(i &amp;
         )**2)/(hbar**(1.0d0/4.0d0)*pi**(1.0d0/4.0d0))
end do

end subroutine</pre>
</div>
<p>The argument <tt class="docutils literal"><span class="pre">verbose</span></tt> is boolean, optional and if True, autowrap will not
mute the command line backends. This can be helpful for debugging.</p>
<p>The argument <tt class="docutils literal"><span class="pre">language</span></tt> and <tt class="docutils literal"><span class="pre">backend</span></tt> are used to change defaults:
<tt class="docutils literal"><span class="pre">Fortran</span></tt> and <tt class="docutils literal"><span class="pre">f2py</span></tt> to <tt class="docutils literal"><span class="pre">C</span></tt> and <tt class="docutils literal"><span class="pre">Cython</span></tt>. The argument helpers is used
to define auxiliary expressions needed for the main expression. If the main
expression needs to call a specialized function it should be put in the
<tt class="docutils literal"><span class="pre">helpers</span></tt> iterable. Autowrap will then make sure that the compiled main
expression can link to the helper routine. Items should be tuples with
<tt class="docutils literal"><span class="pre">(&lt;function_name&gt;,</span> <span class="pre">&lt;sympy_expression&gt;,</span> <span class="pre">&lt;arguments&gt;)</span></tt>. It is mandatory to
supply an argument sequence to helper routines.</p>
<p id="binary-function">Another method available at the <tt class="docutils literal"><span class="pre">autowrap</span></tt> level is <tt class="docutils literal"><span class="pre">binary_function</span></tt>. It
returns a sympy function. The advantage is that we can have very fast functions
as compared to SymPy speeds. This is because we will be using compiled
functions with Sympy attributes and methods. An illustration:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="kn">import</span> <span class="n">binary_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.hydrogen</span> <span class="kn">import</span> <span class="n">R_nl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psi_nl</span> <span class="o">=</span> <span class="n">R_nl</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">binary_function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">psi_nl</span><span class="p">)</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>  
<span class="go">0.766</span>
</pre></div>
</div>
<p id="ufuncify-method">While NumPy operations are very efficient for vectorized data but they
sometimes incur unnecessary costs when chained together.
Consider the following operation</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">get_numpy_array</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span>
</pre></div>
</div>
<p>The operators <tt class="docutils literal"><span class="pre">sin</span></tt> and <tt class="docutils literal"><span class="pre">/</span></tt> call routines that execute tight for loops in
<tt class="docutils literal"><span class="pre">C</span></tt>. The resulting computation looks something like this</p>
<div class="code c highlight-python"><pre>for(int i = 0; i &lt; n; i++)
{
    temp[i] = sin(x[i]);
}
for(int i = i; i &lt; n; i++)
{
    y[i] = temp[i] / x[i];
}</pre>
</div>
<p>This is slightly sub-optimal because</p>
<ol class="arabic simple">
<li>We allocate an extra <tt class="docutils literal"><span class="pre">temp</span></tt> array</li>
<li>We walk over <tt class="docutils literal"><span class="pre">x</span></tt> memory twice when once would have been sufficient</li>
</ol>
<p>A better solution would fuse both element-wise operations into a single for loop</p>
<div class="code c highlight-python"><pre>for(int i = i; i &lt; n; i++)
{
    y[i] = sin(x[i]) / x[i];
}</pre>
</div>
<p>Statically compiled projects like NumPy are unable to take advantage of such
optimizations. Fortunately, SymPy is able to generate efficient low-level C
or Fortran code. It can then depend on projects like <tt class="docutils literal"><span class="pre">Cython</span></tt> or <tt class="docutils literal"><span class="pre">f2py</span></tt> to
compile and reconnect that code back up to Python. Fortunately this process is
well automated and a SymPy user wishing to make use of this code generation
should call the <tt class="docutils literal"><span class="pre">ufuncify</span></tt> function.</p>
<p><tt class="docutils literal"><span class="pre">ufuncify</span></tt> is the third method available with Autowrap module. It basically
implies &#8216;Universal functions&#8217; and follows an ideology set by Numpy. The main
point of ufuncify as compared to autowrap is that it allows arrays as arguments
and can operate in an element-by-element fashion. The core operation done
element-wise is in accordance to Numpy&#8217;s array broadcasting rules. See <a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html">this</a> for more.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="kn">import</span> <span class="n">ufuncify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">ufuncify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">expr</span><span class="p">)</span> 
</pre></div>
</div>
<p>This function <tt class="docutils literal"><span class="pre">f</span></tt> consumes and returns a NumPy array. Generally <tt class="docutils literal"><span class="pre">ufuncify</span></tt>
performs at least as well as <tt class="docutils literal"><span class="pre">lambdify</span></tt>. If the expression is complicated
then <tt class="docutils literal"><span class="pre">ufuncify</span></tt> often significantly outperforms the NumPy backed solution.
Jensen has a good <a class="reference external" href="http://ojensen.wordpress.com/2010/08/10/fast-ufunc-ish-hydrogen-solutions/">blog post</a> on this topic.</p>
<p>Let us see an example for some quantitative analysis:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.hydrogen</span> <span class="kn">import</span> <span class="n">R_nl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">R_nl</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">                -2⋅x</span>
<span class="go">8⋅x⋅(-4⋅x + 4)⋅ℯ</span>
<span class="go">────────────────────</span>
<span class="go">         3</span>
</pre></div>
</div>
<p>The lambdify function translates SymPy expressions into Python functions,
leveraging a variety of numerical libraries. By default lambdify relies on
implementations in the <tt class="docutils literal"><span class="pre">math</span></tt> standard library. Naturally, Raw Python is
faster than Sympy. However it also supports <tt class="docutils literal"><span class="pre">mpmath</span></tt> and most notably,
<tt class="docutils literal"><span class="pre">numpy</span></tt>. Using the numpy library gives the generated function access to
powerful vectorized ufuncs that are backed by compiled C code.</p>
<p>Let us compare the speeds:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.autowrap</span> <span class="kn">import</span> <span class="n">ufuncify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="kn">import</span> <span class="n">lambdify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn_numpy</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>   
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn_fortran</span> <span class="o">=</span> <span class="n">ufuncify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">expr</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;f2py&#39;</span><span class="p">)</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">xx</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn_numpy</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>    
<span class="go">[ 0.          1.21306132  0.98101184  0.44626032  0.        ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fn_fortran</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>  
<span class="go">[ 0.          1.21306132  0.98101184  0.44626032  0.        ]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">timeit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;fn_numpy(xx)&#39;</span><span class="p">,</span> <span class="s1">&#39;from __main__ import fn_numpy, xx&#39;</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>    
<span class="go">0.18891601900395472</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;fn_fortran(xx)&#39;</span><span class="p">,</span> <span class="s1">&#39;from __main__ import fn_fortran, xx&#39;</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>    
<span class="go">0.004707066000264604</span>
</pre></div>
</div>
<p>The options available with ufuncify are more or less the same as those
available with <tt class="docutils literal"><span class="pre">autowrap</span></tt>.</p>
<p>There are other facilities available with Sympy to do efficient numeric
computation. See <a class="reference internal" href="numeric-computation.html#numeric-computation"><em>this</em></a> page for a comparison among them.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Structural Details of Code Generation with Sympy</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#code-printers-sympy-printing">Code printers (sympy.printing)</a></li>
<li><a class="reference internal" href="#codegen-sympy-utilities-codegen">Codegen (sympy.utilities.codegen)</a></li>
<li><a class="reference internal" href="#autowrap">Autowrap</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="evalf.html"
                        title="previous chapter">Numerical evaluation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="numeric-computation.html"
                        title="next chapter">Numeric Computation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/modules/codegen.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="numeric-computation.html" title="Numeric Computation"
             >next</a> |</li>
        <li class="right" >
          <a href="evalf.html" title="Numerical evaluation"
             >previous</a> |</li>
        <li><a href="../index.html">SymPy 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015 SymPy Development Team.
      Last updated on Mar 08, 2016.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>