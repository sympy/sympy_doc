
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iterables &#8212; SymPy 1.7.dev documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/utilities/iterables.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Lambdify" href="lambdify.html" />
    <link rel="prev" title="Enumerative" href="enumerative.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="lambdify.html" title="Lambdify"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="enumerative.html" title="Enumerative"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">Utilities</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Iterables</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="iterables">
<h1>Iterables<a class="headerlink" href="#iterables" title="Permalink to this headline">¶</a></h1>
<div class="section" id="cartes">
<h2>cartes<a class="headerlink" href="#cartes" title="Permalink to this headline">¶</a></h2>
<p>Returns the cartesian product of sequences as a generator.</p>
<dl>
<dt>Examples::</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">cartes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">cartes</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;ab&#39;</span><span class="p">))</span>
<span class="go">[(1, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;a&#39;), (3, &#39;b&#39;)]</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="variations">
<h2>variations<a class="headerlink" href="#variations" title="Permalink to this headline">¶</a></h2>
<p>variations(seq, n) Returns all the variations of the list of size n.</p>
<p>Has an optional third argument. Must be a boolean value and makes the method
return the variations with repetition if set to True, or the variations
without repetition if set to False.</p>
<dl>
<dt>Examples::</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">variations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">variations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">variations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="partitions">
<h2>partitions<a class="headerlink" href="#partitions" title="Permalink to this headline">¶</a></h2>
<p>Although the combinatorics module contains Partition and IntegerPartition
classes for investigation and manipulation of partitions, there are a few
functions to generate partitions that can be used as low-level tools for
routines:  <code class="docutils literal notranslate"><span class="pre">partitions</span></code> and <code class="docutils literal notranslate"><span class="pre">multiset_partitions</span></code>. The former gives
integer partitions, and the latter gives enumerated partitions of elements.
There is also a routine <code class="docutils literal notranslate"><span class="pre">kbins</span></code> that will give a variety of permutations
of partions.</p>
<p>partitions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">partitions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">2</span><span class="p">]</span>
<span class="go">[{1: 1, 6: 1}, {2: 1, 5: 1}, {3: 1, 4: 1}]</span>
</pre></div>
</div>
<p>multiset_partitions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">multiset_partitions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">multiset_partitions</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="go">[[[0, 1], [2]], [[0, 2], [1]], [[0], [1, 2]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">multiset_partitions</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">)]</span>
<span class="go">[[[1, 1, 1], [2]], [[1, 1, 2], [1]], [[1, 1], [1, 2]]]</span>
</pre></div>
</div>
<p>kbins:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">kbins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">rv</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">p</span><span class="p">]))</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">show</span><span class="p">(</span><span class="n">kbins</span><span class="p">(</span><span class="s2">&quot;ABCD&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[&#39;A,BCD&#39;, &#39;AB,CD&#39;, &#39;ABC,D&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">show</span><span class="p">(</span><span class="n">kbins</span><span class="p">(</span><span class="s2">&quot;ABC&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[&#39;A,BC&#39;, &#39;AB,C&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">show</span><span class="p">(</span><span class="n">kbins</span><span class="p">(</span><span class="s2">&quot;ABC&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># same as multiset_partitions</span>
<span class="go">[&#39;A,BC&#39;, &#39;AB,C&#39;, &#39;AC,B&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">show</span><span class="p">(</span><span class="n">kbins</span><span class="p">(</span><span class="s2">&quot;ABC&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[&#39;A,BC&#39;, &#39;A,CB&#39;,</span>
<span class="go"> &#39;B,AC&#39;, &#39;B,CA&#39;,</span>
<span class="go"> &#39;C,AB&#39;, &#39;C,BA&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">show</span><span class="p">(</span><span class="n">kbins</span><span class="p">(</span><span class="s2">&quot;ABC&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="mi">10</span><span class="p">))</span>
<span class="go">[&#39;A,BC&#39;, &#39;AB,C&#39;, &#39;AC,B&#39;,</span>
<span class="go"> &#39;B,AC&#39;, &#39;BC,A&#39;,</span>
<span class="go"> &#39;C,AB&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">show</span><span class="p">(</span><span class="n">kbins</span><span class="p">(</span><span class="s2">&quot;ABC&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="mi">11</span><span class="p">))</span>
<span class="go">[&#39;A,BC&#39;, &#39;A,CB&#39;, &#39;AB,C&#39;, &#39;AC,B&#39;,</span>
<span class="go"> &#39;B,AC&#39;, &#39;B,CA&#39;, &#39;BA,C&#39;, &#39;BC,A&#39;,</span>
<span class="go"> &#39;C,AB&#39;, &#39;C,BA&#39;, &#39;CA,B&#39;, &#39;CB,A&#39;]</span>
</pre></div>
</div>
<div class="section" id="module-sympy.utilities.iterables">
<span id="docstring"></span><h3>Docstring<a class="headerlink" href="#module-sympy.utilities.iterables" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.utilities.iterables.binary_partitions">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">binary_partitions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1986-L2041"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.binary_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the binary partition of n.</p>
<p>A binary partition consists only of numbers that are
powers of two. Each step reduces a <span class="math notranslate nohighlight">\(2^{k+1}\)</span> to <span class="math notranslate nohighlight">\(2^k\)</span> and
<span class="math notranslate nohighlight">\(2^k\)</span>. Thus 16 is converted to 8 and 8.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">binary_partitions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">binary_partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">[4, 1]</span>
<span class="go">[2, 2, 1]</span>
<span class="go">[2, 1, 1, 1]</span>
<span class="go">[1, 1, 1, 1, 1]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r831"><span class="brackets"><a class="fn-backref" href="#id1">R831</a></span></dt>
<dd><p>TAOCP 4, section 7.2.1.5, problem 64</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.bracelets">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">bracelets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2365-L2367"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.bracelets" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrapper to necklaces to return a free (unrestricted) necklace.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.capture">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">capture</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L705-L732"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.capture" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the printed output of func().</p>
<p><code class="docutils literal notranslate"><span class="pre">func</span></code> should be a function without arguments that produces output with
print statements.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">capture</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;hello world!&#39;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;hello&#39;</span> <span class="ow">in</span> <span class="n">capture</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="c1"># foo, not foo()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">capture</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">pprint</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">))</span>
<span class="go">&#39;2\n-\nx\n&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.common_prefix">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">common_prefix</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">seqs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L837-L860"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.common_prefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the subsequence that is a common start of sequences in <code class="docutils literal notranslate"><span class="pre">seqs</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">common_prefix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_prefix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_prefix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_prefix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">[1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_prefix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="go">[1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.common_suffix">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">common_suffix</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">seqs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L863-L890"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.common_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the subsequence that is a common ending of sequences in <code class="docutils literal notranslate"><span class="pre">seqs</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">common_suffix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_suffix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
<span class="go">[0, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_suffix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_suffix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_suffix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.connected_components">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">connected_components</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1168-L1236"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Connected components of an undirected graph or weakly connected components
of a directed graph.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>graph</strong> : tuple[list, list[tuple[T, T]]</p>
<blockquote>
<div><p>A tuple consisting of a list of vertices and a list of edges of
a graph whose connected components are to be found.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Given an undirected graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span> <span class="p">{</span>
    <span class="n">A</span> <span class="o">--</span> <span class="n">B</span>
    <span class="n">C</span> <span class="o">--</span> <span class="n">D</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can find the connected components using this function if we include
each edge in both directions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">connected_components</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">connected_components</span><span class="p">((</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">))</span>
<span class="go">[[&#39;A&#39;, &#39;B&#39;], [&#39;C&#39;, &#39;D&#39;]]</span>
</pre></div>
</div>
<p>The weakly connected components of a directed graph can found the same
way.</p>
<p class="rubric">Notes</p>
<p>The vertices of the graph must be hashable for the data structures used.
If the vertices are unhashable replace them with integer indices.</p>
<p>This function uses Tarjan’s algorithm to compute the connected components
in <span class="math notranslate nohighlight">\(O(|V|+|E|)\)</span> (linear) time.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.utilities.iterables.strongly_connected_components" title="sympy.utilities.iterables.strongly_connected_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.utilities.iterables.strongly_connected_components</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r832"><span class="brackets"><a class="fn-backref" href="#id2">R832</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory">https://en.wikipedia.org/wiki/Connected_component_(graph_theory</a>)</p>
</dd>
<dt class="label" id="r833"><span class="brackets"><a class="fn-backref" href="#id3">R833</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.dict_merge">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">dict_merge</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">dicts</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L827-L834"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.dict_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge dictionaries into a single dictionary.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.filter_symbols">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">filter_symbols</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterator</span></em>, <em class="sig-param"><span class="n">exclude</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L642-L664"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.filter_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Only yield elements from <span class="math notranslate nohighlight">\(iterator\)</span> that do not occur in <span class="math notranslate nohighlight">\(exclude\)</span>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iterator</strong> : iterable</p>
<p><strong>iterator to take elements from</strong></p>
<p><strong>exclude</strong> : iterable</p>
<p><strong>elements to exclude</strong></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>iterator</strong> : iterator</p>
<p>filtered iterator</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.flatten">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">flatten</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iterable</span></em>, <em class="sig-param"><span class="n">levels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cls</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L56-L117"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively denest iterable containers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">flatten</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flatten</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flatten</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flatten</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="go">[1, 2, 3, 4, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flatten</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
<span class="go">[1.0, 2, 1, None]</span>
</pre></div>
</div>
<p>If you want to denest only a specified number of levels of
nested containers, then set <code class="docutils literal notranslate"><span class="pre">levels</span></code> flag to the desired
number of levels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ls</span> <span class="o">=</span> <span class="p">[[(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">flatten</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[(-2, -1), (1, 2), (0, 0)]</span>
</pre></div>
</div>
<p>If cls argument is specified, it will only flatten instances of that
class, for example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Basic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyOp</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flatten</span><span class="p">([</span><span class="n">MyOp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">MyOp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))],</span> <span class="bp">cls</span><span class="o">=</span><span class="n">MyOp</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p>adapted from <a class="reference external" href="https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks">https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks</a></p>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.generate_bell">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">generate_bell</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2144-L2248"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.generate_bell" title="Permalink to this definition">¶</a></dt>
<dd><p>Return permutations of [0, 1, …, n - 1] such that each permutation
differs from the last by the exchange of a single pair of neighbors.
The <code class="docutils literal notranslate"><span class="pre">n!</span></code> permutations are returned as an iterator. In order to obtain
the next permutation from a random starting permutation, use the
<code class="docutils literal notranslate"><span class="pre">next_trotterjohnson</span></code> method of the Permutation class (which generates
the same sequence in a different manner).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">generate_bell</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">Matrix</span>
</pre></div>
</div>
<p>This is the sort of permutation used in the ringing of physical bells,
and does not produce permutations in lexicographical order. Rather, the
permutations differ from each other by exactly one inversion, and the
position at which the swapping occurs varies periodically in a simple
fashion. Consider the first few permutations of 4 elements generated
by <code class="docutils literal notranslate"><span class="pre">permutations</span></code> and <code class="docutils literal notranslate"><span class="pre">generate_bell</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)))[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[(0, 1, 2, 3), (0, 1, 3, 2), (0, 2, 1, 3), (0, 2, 3, 1), (0, 3, 1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">generate_bell</span><span class="p">(</span><span class="mi">4</span><span class="p">))[:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">[(0, 1, 2, 3), (0, 1, 3, 2), (0, 3, 1, 2), (3, 0, 1, 2), (3, 0, 2, 1)]</span>
</pre></div>
</div>
<p>Notice how the 2nd and 3rd lexicographical permutations have 3 elements
out of place whereas each “bell” permutation always has only two
elements out of place relative to the previous permutation (and so the
signature (+/-1) of a permutation is opposite of the signature of the
previous permutation).</p>
<p>How the position of inversion varies across the elements can be seen
by tracing out where the largest number appears in the permutations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">generate_bell</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">m</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">j</span> <span class="o">-</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)])</span>  <span class="c1"># make largest zero</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">print_nonzero</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="go">[XXX  XXXXXX  XXXXXX  XXX]</span>
<span class="go">[XX XX XXXX XX XXXX XX XX]</span>
<span class="go">[X XXXX XX XXXX XX XXXX X]</span>
<span class="go">[ XXXXXX  XXXXXX  XXXXXX ]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.next_trotterjohnson" title="sympy.combinatorics.permutations.Permutation.next_trotterjohnson"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.combinatorics.permutations.Permutation.next_trotterjohnson</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r834"><span class="brackets"><a class="fn-backref" href="#id4">R834</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Method_ringing">https://en.wikipedia.org/wiki/Method_ringing</a></p>
</dd>
<dt class="label" id="r835"><span class="brackets"><a class="fn-backref" href="#id5">R835</a></span></dt>
<dd><p><a class="reference external" href="https://stackoverflow.com/questions/4856615/recursive-permutation/4857018">https://stackoverflow.com/questions/4856615/recursive-permutation/4857018</a></p>
</dd>
<dt class="label" id="r836"><span class="brackets"><a class="fn-backref" href="#id6">R836</a></span></dt>
<dd><p><a class="reference external" href="http://programminggeeks.com/bell-algorithm-for-permutation/">http://programminggeeks.com/bell-algorithm-for-permutation/</a></p>
</dd>
<dt class="label" id="r837"><span class="brackets"><a class="fn-backref" href="#id7">R837</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm">https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm</a></p>
</dd>
<dt class="label" id="r838"><span class="brackets"><a class="fn-backref" href="#id8">R838</a></span></dt>
<dd><p>Generating involutions, derangements, and relatives by ECO
Vincent Vajnovszki, DMTCS vol 1 issue 12, 2010</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.generate_derangements">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">generate_derangements</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">perm</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2288-L2317"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.generate_derangements" title="Permalink to this definition">¶</a></dt>
<dd><p>Routine to generate unique derangements.</p>
<p>TODO: This will be rewritten to use the
ECO operator approach once the permutations
branch is in master.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">generate_derangements</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">generate_derangements</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[[1, 2, 0], [2, 0, 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">generate_derangements</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="go">[[1, 0, 3, 2], [1, 2, 3, 0], [1, 3, 0, 2], [2, 0, 3, 1],     [2, 3, 0, 1], [2, 3, 1, 0], [3, 0, 1, 2], [3, 2, 0, 1],     [3, 2, 1, 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">generate_derangements</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../functions/combinatorial.html#sympy.functions.combinatorial.factorials.subfactorial" title="sympy.functions.combinatorial.factorials.subfactorial"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.functions.combinatorial.factorials.subfactorial</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.generate_involutions">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">generate_involutions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2251-L2285"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.generate_involutions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates involutions.</p>
<p>An involution is a permutation that when multiplied
by itself equals the identity permutation. In this
implementation the involutions are generated using
Fixed Points.</p>
<p>Alternatively, an involution can be considered as
a permutation that does not contain any cycles with
a length that is greater than two.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">generate_involutions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">generate_involutions</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[(0, 1, 2), (0, 2, 1), (1, 0, 2), (2, 1, 0)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">generate_involutions</span><span class="p">(</span><span class="mi">4</span><span class="p">)))</span>
<span class="go">10</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r839"><span class="brackets"><a class="fn-backref" href="#id9">R839</a></span></dt>
<dd><p><a class="reference external" href="http://mathworld.wolfram.com/PermutationInvolution.html">http://mathworld.wolfram.com/PermutationInvolution.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.generate_oriented_forest">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">generate_oriented_forest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2370-L2413"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.generate_oriented_forest" title="Permalink to this definition">¶</a></dt>
<dd><p>This algorithm generates oriented forests.</p>
<p>An oriented graph is a directed graph having no symmetric pair of directed
edges. A forest is an acyclic graph, i.e., it has no cycles. A forest can
also be described as a disjoint union of trees, which are graphs in which
any two vertices are connected by exactly one simple path.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">generate_oriented_forest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">generate_oriented_forest</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">[[0, 1, 2, 3], [0, 1, 2, 2], [0, 1, 2, 1], [0, 1, 2, 0],     [0, 1, 1, 1], [0, 1, 1, 0], [0, 1, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0]]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r840"><span class="brackets"><a class="fn-backref" href="#id10">R840</a></span></dt>
<dd><p>T. Beyer and S.M. Hedetniemi: constant time generation of
rooted trees, SIAM J. Computing Vol. 9, No. 4, November 1980</p>
</dd>
<dt class="label" id="r841"><span class="brackets"><a class="fn-backref" href="#id11">R841</a></span></dt>
<dd><p><a class="reference external" href="https://stackoverflow.com/questions/1633833/oriented-forest-taocp-algorithm-in-python">https://stackoverflow.com/questions/1633833/oriented-forest-taocp-algorithm-in-python</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.group">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">multiple</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L189-L231"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.group" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits a sequence into a list of lists of equal, adjacent elements.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">group</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[[1, 1, 1], [2, 2], [3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">multiple</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(1, 3), (2, 2), (3, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">group</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">multiple</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[(1, 2), (3, 1), (2, 2), (1, 1)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.utilities.iterables.multiset" title="sympy.utilities.iterables.multiset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multiset</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.has_dups">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">has_dups</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2044-L2065"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.has_dups" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if there are any duplicate elements in <code class="docutils literal notranslate"><span class="pre">seq</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">has_dups</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Set</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">has_dups</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">has_dups</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">all</span><span class="p">(</span><span class="n">has_dups</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">set</span><span class="p">(),</span> <span class="n">Set</span><span class="p">(),</span> <span class="nb">dict</span><span class="p">(),</span> <span class="n">Dict</span><span class="p">()))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.has_variety">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">has_variety</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2068-L2087"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.has_variety" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if there are any different elements in <code class="docutils literal notranslate"><span class="pre">seq</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">has_variety</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">has_variety</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">has_variety</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.ibin">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">ibin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">bits</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">str</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L475-L544"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.ibin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of length <code class="docutils literal notranslate"><span class="pre">bits</span></code> corresponding to the binary value
of <code class="docutils literal notranslate"><span class="pre">n</span></code> with small bits to the right (last). If bits is omitted, the
length will be the number required to represent <code class="docutils literal notranslate"><span class="pre">n</span></code>. If the bits are
desired in reversed order, use the <code class="docutils literal notranslate"><span class="pre">[::-1]</span></code> slice of the returned list.</p>
<p>If a sequence of all bits-length lists starting from <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,...,</span> <span class="pre">0]</span></code>
through <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">1]</span></code> are desired, pass a non-integer for bits, e.g.
<code class="docutils literal notranslate"><span class="pre">'all'</span></code>.</p>
<p>If the bit <em>string</em> is desired pass <code class="docutils literal notranslate"><span class="pre">str=True</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">ibin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[0, 0, 1, 0]</span>
</pre></div>
</div>
<p>If all lists corresponding to 0 to 2**n - 1, pass a non-integer
for bits:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bits</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="go">(0, 1)</span>
<span class="go">(1, 0)</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
<p>If a bit string is desired of a given length, use str=True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">123</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bits</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;0001111011&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># small bits left</span>
<span class="go">&#39;1101111000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">ibin</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;011&#39;, &#39;100&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.interactive_traversal">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">interactive_traversal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L382-L472"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.interactive_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Traverse a tree asking a user which branch to choose.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.iproduct">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">iproduct</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">iterables</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L261-L299"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.iproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian product of iterables.</p>
<p>Generator of the cartesian product of iterables. This is analogous to
itertools.product except that it works with infinite iterables and will
yield any item from the infinite product eventually.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">iproduct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">iproduct</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="go">[(1, 3), (1, 4), (2, 3), (2, 4)]</span>
</pre></div>
</div>
<p>With an infinite iterator:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="p">,)</span> <span class="ow">in</span> <span class="n">iproduct</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Integers</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iproduct</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Integers</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Integers</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.product">itertools.product</a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.is_palindromic">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">is_palindromic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">i</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">j</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L20-L53"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.is_palindromic" title="Permalink to this definition">¶</a></dt>
<dd><p>return True if the sequence is the same from left to right as it
is from right to left in the whole sequence (default) or in the
Python slice <code class="docutils literal notranslate"><span class="pre">s[i:</span> <span class="pre">j]</span></code>; else False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">is_palindromic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_palindromic</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_palindromic</span><span class="p">(</span><span class="s1">&#39;abcbb&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_palindromic</span><span class="p">(</span><span class="s1">&#39;abcbb&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Normal Python slicing is performed in place so there is no need to
create a slice of the sequence for testing:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">is_palindromic</span><span class="p">(</span><span class="s1">&#39;abcbb&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_palindromic</span><span class="p">(</span><span class="s1">&#39;abcbb&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="../ntheory.html#sympy.ntheory.digits.is_palindromic" title="sympy.ntheory.digits.is_palindromic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.ntheory.digits.is_palindromic</span></code></a></dt><dd><p>tests integers</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.kbins">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">kbins</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">l</span></em>, <em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">ordered</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2531-L2654"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.kbins" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sequence <code class="docutils literal notranslate"><span class="pre">l</span></code> partitioned into <code class="docutils literal notranslate"><span class="pre">k</span></code> bins.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
</pre></div>
</div>
<p>The default is to give the items in the same order, but grouped
into k partitions without any reordering:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">kbins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">kbins</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">[[0], [1, 2, 3, 4]]</span>
<span class="go">[[0, 1], [2, 3, 4]]</span>
<span class="go">[[0, 1, 2], [3, 4]]</span>
<span class="go">[[0, 1, 2, 3], [4]]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ordered</span></code> flag is either None (to give the simple partition
of the elements) or is a 2 digit integer indicating whether the order of
the bins and the order of the items in the bins matters. Given:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">C</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">D</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>the following values for <code class="docutils literal notranslate"><span class="pre">ordered</span></code> have the shown meanings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">00</span> <span class="n">means</span> <span class="n">A</span> <span class="o">==</span> <span class="n">B</span> <span class="o">==</span> <span class="n">C</span> <span class="o">==</span> <span class="n">D</span>
<span class="mi">01</span> <span class="n">means</span> <span class="n">A</span> <span class="o">==</span> <span class="n">B</span>
<span class="mi">10</span> <span class="n">means</span> <span class="n">A</span> <span class="o">==</span> <span class="n">D</span>
<span class="mi">11</span> <span class="n">means</span> <span class="n">A</span> <span class="o">==</span> <span class="n">A</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ordered_flag</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ordered = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">ordered_flag</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">kbins</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="n">ordered_flag</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;     </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">p</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">ordered = None</span>
<span class="go">     [[0], [1, 2]]</span>
<span class="go">     [[0, 1], [2]]</span>
<span class="go">ordered = 0</span>
<span class="go">     [[0, 1], [2]]</span>
<span class="go">     [[0, 2], [1]]</span>
<span class="go">     [[0], [1, 2]]</span>
<span class="go">ordered = 1</span>
<span class="go">     [[0], [1, 2]]</span>
<span class="go">     [[0], [2, 1]]</span>
<span class="go">     [[1], [0, 2]]</span>
<span class="go">     [[1], [2, 0]]</span>
<span class="go">     [[2], [0, 1]]</span>
<span class="go">     [[2], [1, 0]]</span>
<span class="go">ordered = 10</span>
<span class="go">     [[0, 1], [2]]</span>
<span class="go">     [[2], [0, 1]]</span>
<span class="go">     [[0, 2], [1]]</span>
<span class="go">     [[1], [0, 2]]</span>
<span class="go">     [[0], [1, 2]]</span>
<span class="go">     [[1, 2], [0]]</span>
<span class="go">ordered = 11</span>
<span class="go">     [[0], [1, 2]]</span>
<span class="go">     [[0, 1], [2]]</span>
<span class="go">     [[0], [2, 1]]</span>
<span class="go">     [[0, 2], [1]]</span>
<span class="go">     [[1], [0, 2]]</span>
<span class="go">     [[1, 0], [2]]</span>
<span class="go">     [[1], [2, 0]]</span>
<span class="go">     [[1, 2], [0]]</span>
<span class="go">     [[2], [0, 1]]</span>
<span class="go">     [[2, 0], [1]]</span>
<span class="go">     [[2], [1, 0]]</span>
<span class="go">     [[2, 1], [0]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.utilities.iterables.partitions" title="sympy.utilities.iterables.partitions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partitions</span></code></a>, <a class="reference internal" href="#sympy.utilities.iterables.multiset_partitions" title="sympy.utilities.iterables.multiset_partitions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multiset_partitions</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.least_rotation">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">least_rotation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1277-L1314"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.least_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of steps of left rotation required to
obtain lexicographically minimal string/list/tuple, etc.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">least_rotation</span><span class="p">,</span> <span class="n">rotate_left</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">least_rotation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate_left</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span>
<span class="go">[1, 2, 3, 1, 5]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r842"><span class="brackets"><a class="fn-backref" href="#id12">R842</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation">https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.minlex">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">minlex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">directed</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">is_set</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">small</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2416-L2491"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.minlex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple representing the rotation of the sequence in which
the lexically smallest elements appear first, e.g. <span class="math notranslate nohighlight">\(cba -&gt;acb\)</span>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">directed</span></code> is False then the smaller of the sequence and the
reversed sequence is returned, e.g. <span class="math notranslate nohighlight">\(cba -&gt; abc\)</span>.</p>
<p>For more efficient processing, <code class="docutils literal notranslate"><span class="pre">is_set</span></code> can be set to True if there
are no duplicates in the sequence.</p>
<p>If the smallest element is known at the time of calling, it can be
passed as <code class="docutils literal notranslate"><span class="pre">small</span></code> and the calculation of the smallest element will
be omitted.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.combinatorics.polyhedron</span> <span class="kn">import</span> <span class="n">minlex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minlex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">(0, 1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minlex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">(0, 2, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minlex</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(0, 1, 2)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minlex</span><span class="p">(</span><span class="s1">&#39;11010011000&#39;</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;00011010011&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minlex</span><span class="p">(</span><span class="s1">&#39;11010011000&#39;</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&#39;00011001011&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.multiset">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">multiset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L302-L322"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.multiset" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the hashable sequence in multiset form with values being the
multiplicity of the item in the sequence.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">multiset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiset</span><span class="p">(</span><span class="s1">&#39;mississippi&#39;</span><span class="p">)</span>
<span class="go">{&#39;i&#39;: 4, &#39;m&#39;: 1, &#39;p&#39;: 2, &#39;s&#39;: 4}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.utilities.iterables.group" title="sympy.utilities.iterables.group"><code class="xref py py-obj docutils literal notranslate"><span class="pre">group</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.multiset_combinations">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">multiset_combinations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">g</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1317-L1370"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.multiset_combinations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique combinations of size <code class="docutils literal notranslate"><span class="pre">n</span></code> from multiset <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">multiset_combinations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>  <span class="n">multiset_combinations</span><span class="p">(</span><span class="s1">&#39;baby&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">[&#39;abb&#39;, &#39;aby&#39;, &#39;bby&#39;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
<p>The number of combinations depends on the number of letters; the
number of unique combinations depends on how the letters are
repeated.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="s1">&#39;abracadabra&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="s1">&#39;banana tree&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">(</span><span class="n">combinations</span><span class="p">,</span> <span class="n">s1</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="n">multiset_combinations</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
<span class="go">(165, 23)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span><span class="p">(</span><span class="n">combinations</span><span class="p">,</span> <span class="n">s2</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="n">multiset_combinations</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="go">(165, 54)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.multiset_partitions">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">multiset_partitions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">multiset</span></em>, <em class="sig-param"><span class="n">m</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1539-L1693"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.multiset_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique partitions of the given multiset (in list form).
If <code class="docutils literal notranslate"><span class="pre">m</span></code> is None, all multisets will be returned, otherwise only
partitions with <code class="docutils literal notranslate"><span class="pre">m</span></code> parts will be returned.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">multiset</span></code> is an integer, a range [0, 1, …, multiset - 1]
will be supplied.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">multiset_partitions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[[[1, 2, 3], [4]], [[1, 2, 4], [3]], [[1, 2], [3, 4]],</span>
<span class="go">[[1, 3, 4], [2]], [[1, 3], [2, 4]], [[1, 4], [2, 3]],</span>
<span class="go">[[1], [2, 3, 4]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">[[[1, 2, 3, 4]]]</span>
</pre></div>
</div>
<p>Only unique partitions are returned and these will be returned in a
canonical order regardless of the order of the input:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">==</span> <span class="n">ans</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="o">==</span>
<span class="gp">... </span> <span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="p">))))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If m is omitted then all partitions will be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[[[1, 1, 2]], [[1, 1], [2]], [[1, 2], [1]], [[1], [1], [2]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">))</span>
<span class="go">[[[1, 1, 1]], [[1], [1, 1]], [[1], [1], [1]]]</span>
</pre></div>
</div>
<p class="rubric">Counting</p>
<p>The number of partitions of a set is given by the bell number:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">bell</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">)))</span> <span class="o">==</span> <span class="n">bell</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">52</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The number of partitions of length k from a set of size n is given by the
Stirling Number of the 2nd kind:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.functions.combinatorial.numbers</span> <span class="kn">import</span> <span class="n">stirling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stirling</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">15</span>
<span class="go">True</span>
</pre></div>
</div>
<p>These comments on counting apply to <em>sets</em>, not multisets.</p>
<p class="rubric">Notes</p>
<p>When all the elements are the same in the multiset, the order
of the returned partitions is determined by the <code class="docutils literal notranslate"><span class="pre">partitions</span></code>
routine. If one is counting partitions then it is better to use
the <code class="docutils literal notranslate"><span class="pre">nT</span></code> function.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.utilities.iterables.partitions" title="sympy.utilities.iterables.partitions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partitions</span></code></a>, <a class="reference internal" href="../combinatorics/partitions.html#sympy.combinatorics.partitions.Partition" title="sympy.combinatorics.partitions.Partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.combinatorics.partitions.Partition</span></code></a>, <a class="reference internal" href="../combinatorics/partitions.html#sympy.combinatorics.partitions.IntegerPartition" title="sympy.combinatorics.partitions.IntegerPartition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.combinatorics.partitions.IntegerPartition</span></code></a>, <a class="reference internal" href="../functions/combinatorial.html#sympy.functions.combinatorial.numbers.nT" title="sympy.functions.combinatorial.numbers.nT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.functions.combinatorial.numbers.nT</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.multiset_permutations">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">multiset_permutations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">g</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1373-L1419"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.multiset_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the unique permutations of multiset <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">multiset_permutations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multiset_permutations</span><span class="p">(</span><span class="s1">&#39;aab&#39;</span><span class="p">)]</span>
<span class="go">[&#39;aab&#39;, &#39;aba&#39;, &#39;baa&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factorial</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;banana&#39;</span><span class="p">))</span>
<span class="go">720</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">multiset_permutations</span><span class="p">(</span><span class="s1">&#39;banana&#39;</span><span class="p">)))</span>
<span class="go">60</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.necklaces">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">necklaces</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">free</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2320-L2362"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.necklaces" title="Permalink to this definition">¶</a></dt>
<dd><p>A routine to generate necklaces that may (free=True) or may not
(free=False) be turned over to be viewed. The “necklaces” returned
are comprised of <code class="docutils literal notranslate"><span class="pre">n</span></code> integers (beads) with <code class="docutils literal notranslate"><span class="pre">k</span></code> different
values (colors). Only unique necklaces are returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">necklaces</span><span class="p">,</span> <span class="n">bracelets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>The “unrestricted necklace” is sometimes also referred to as a
“bracelet” (an object that can be turned over, a sequence that can
be reversed) and the term “necklace” is used to imply a sequence
that cannot be reversed. So ACB == ABC for a bracelet (rotate and
reverse) while the two are different for a necklace since rotation
alone cannot make the two sequences the same.</p>
<p>(mnemonic: Bracelets can be viewed Backwards, but Not Necklaces.)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="n">show</span><span class="p">(</span><span class="s1">&#39;ABC&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bracelets</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="n">show</span><span class="p">(</span><span class="s1">&#39;ABC&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">necklaces</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">{&#39;ACB&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">necklaces</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(0, 0, 0, 0), (0, 0, 0, 1), (0, 0, 1, 1),</span>
<span class="go"> (0, 1, 0, 1), (0, 1, 1, 1), (1, 1, 1, 1)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">show</span><span class="p">(</span><span class="s1">&#39;.o&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bracelets</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>
<span class="go">[&#39;....&#39;, &#39;...o&#39;, &#39;..oo&#39;, &#39;.o.o&#39;, &#39;.ooo&#39;, &#39;oooo&#39;]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r843"><span class="brackets"><a class="fn-backref" href="#id13">R843</a></span></dt>
<dd><p><a class="reference external" href="http://mathworld.wolfram.com/Necklace.html">http://mathworld.wolfram.com/Necklace.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.numbered_symbols">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">numbered_symbols</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">'x'</span></em>, <em class="sig-param"><span class="n">cls</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">exclude</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">assumptions</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L666-L702"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.numbered_symbols" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an infinite stream of Symbols consisting of a prefix and
increasing subscripts provided that they do not occur in <code class="docutils literal notranslate"><span class="pre">exclude</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>prefix</strong> : str, optional</p>
<blockquote>
<div><p>The prefix to use. By default, this function will generate symbols of
the form “x0”, “x1”, etc.</p>
</div></blockquote>
<p><strong>cls</strong> : class, optional</p>
<blockquote>
<div><p>The class to use. By default, it uses <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>, but you can also use <code class="docutils literal notranslate"><span class="pre">Wild</span></code> or <code class="docutils literal notranslate"><span class="pre">Dummy</span></code>.</p>
</div></blockquote>
<p><strong>start</strong> : int, optional</p>
<blockquote>
<div><p>The start number.  By default, it is 0.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>sym</strong> : Symbol</p>
<blockquote>
<div><p>The subscripted symbols.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.ordered_partitions">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">ordered_partitions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">m</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1850-L1983"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.ordered_partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates ordered partitions of integer <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>m</strong> : integer (default None)</p>
<blockquote>
<div><p>The default value gives partitions of all sizes else only
those with size m. In addition, if <code class="docutils literal notranslate"><span class="pre">m</span></code> is not None then
partitions are generated <em>in place</em> (see examples).</p>
</div></blockquote>
<p><strong>sort</strong> : bool (default True)</p>
<blockquote>
<div><p>Controls whether partitions are
returned in sorted order when <code class="docutils literal notranslate"><span class="pre">m</span></code> is not None; when False,
the partitions are returned as fast as possible with elements
sorted, but when m|n the partitions will not be in
ascending lexicographical order.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">ordered_partitions</span>
</pre></div>
</div>
<p>All partitions of 5 in ascending lexicographical:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ordered_partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[1, 1, 1, 1, 1]</span>
<span class="go">[1, 1, 1, 2]</span>
<span class="go">[1, 1, 3]</span>
<span class="go">[1, 2, 2]</span>
<span class="go">[1, 4]</span>
<span class="go">[2, 3]</span>
<span class="go">[5]</span>
</pre></div>
</div>
<p>Only partitions of 5 with two parts:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ordered_partitions</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[1, 4]</span>
<span class="go">[2, 3]</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">m</span></code> is given, a given list objects will be used more than
once for speed reasons so you will not see the correct partitions
unless you make a copy of each as it is generated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ordered_partitions</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">[[1, 1, 1], [1, 1, 1], [1, 1, 1], [2, 2, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ordered_partitions</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="go">[[1, 1, 5], [1, 2, 4], [1, 3, 3], [2, 2, 3]]</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">n</span></code> is a multiple of <code class="docutils literal notranslate"><span class="pre">m</span></code>, the elements are still sorted
but the partitions themselves will be <em>unordered</em> if sort is False;
the default is to return them in ascending lexicographical order.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ordered_partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[1, 5]</span>
<span class="go">[2, 4]</span>
<span class="go">[3, 3]</span>
</pre></div>
</div>
<p>But if speed is more important than ordering, sort can be set to
False:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ordered_partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">[1, 5]</span>
<span class="go">[3, 3]</span>
<span class="go">[2, 4]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r844"><span class="brackets"><a class="fn-backref" href="#id14">R844</a></span></dt>
<dd><p>Generating Integer Partitions, [online],
Available: <a class="reference external" href="https://jeromekelleher.net/generating-integer-partitions.html">https://jeromekelleher.net/generating-integer-partitions.html</a></p>
</dd>
<dt class="label" id="r845"><span class="brackets"><a class="fn-backref" href="#id15">R845</a></span></dt>
<dd><p>Jerome Kelleher and Barry O’Sullivan, “Generating All
Partitions: A Comparison Of Two Encodings”, [online],
Available: <a class="reference external" href="https://arxiv.org/pdf/0909.2331v2.pdf">https://arxiv.org/pdf/0909.2331v2.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.partitions">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">partitions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">m</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1696-L1847"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.partitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all partitions of positive integer, n.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>m</strong> : integer (default gives partitions of all sizes)</p>
<blockquote>
<div><p>limits number of parts in partition (mnemonic: m, maximum parts)</p>
</div></blockquote>
<p><strong>k</strong> : integer (default gives partitions number from 1 through n)</p>
<blockquote>
<div><p>limits the numbers that are kept in the partition (mnemonic: k, keys)</p>
</div></blockquote>
<p><strong>size</strong> : bool (default False, only partition is returned)</p>
<blockquote>
<div><p>when <code class="docutils literal notranslate"><span class="pre">True</span></code> then (M, P) is returned where M is the sum of the
multiplicities and P is the generated partition.</p>
</div></blockquote>
<p><strong>Each partition is represented as a dictionary, mapping an integer</strong></p>
<p><strong>to the number of copies of that integer in the partition.  For example,</strong></p>
<p><strong>the first partition of 4 returned is {4: 1}, “4: one of them”.</strong></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">partitions</span>
</pre></div>
</div>
<p>The numbers appearing in the partition (the key of the returned dict)
are limited with k:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">{2: 3}</span>
<span class="go">{1: 2, 2: 2}</span>
<span class="go">{1: 4, 2: 1}</span>
<span class="go">{1: 6}</span>
</pre></div>
</div>
<p>The maximum number of parts in the partition (the sum of the values in
the returned dict) are limited with m (default value, None, gives
partitions from 1 through n):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>  
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">{6: 1}</span>
<span class="go">{1: 1, 5: 1}</span>
<span class="go">{2: 1, 4: 1}</span>
<span class="go">{3: 2}</span>
</pre></div>
</div>
<p>Note that the _same_ dictionary object is returned each time.
This is for speed:  generating each partition goes quickly,
taking constant time, independent of n.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span>
<span class="go">[{1: 6}, {1: 6}, {1: 6}, {1: 6}]</span>
</pre></div>
</div>
<p>If you want to build a list of the returned dictionaries then
make a copy of them:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span>  
<span class="go">[{2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">M</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span> <span class="k">for</span> <span class="n">M</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>  
<span class="go">[(3, {2: 3}), (4, {1: 2, 2: 2}), (5, {1: 4, 2: 1}), (6, {1: 6})]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../combinatorics/partitions.html#sympy.combinatorics.partitions.Partition" title="sympy.combinatorics.partitions.Partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.combinatorics.partitions.Partition</span></code></a>, <a class="reference internal" href="../combinatorics/partitions.html#sympy.combinatorics.partitions.IntegerPartition" title="sympy.combinatorics.partitions.IntegerPartition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.combinatorics.partitions.IntegerPartition</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r846"><span class="brackets"><a class="fn-backref" href="#id16">R846</a></span></dt>
<dd><p>modified from Tim Peter’s version to allow for k and m values:
<a class="reference external" href="http://code.activestate.com/recipes/218332-generator-for-integer-partitions/">http://code.activestate.com/recipes/218332-generator-for-integer-partitions/</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.permute_signs">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">permute_signs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2657-L2670"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.permute_signs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return iterator in which the signs of non-zero elements
of t are permuted.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">permute_signs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">permute_signs</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">[(0, 1, 2), (0, -1, 2), (0, 1, -2), (0, -1, -2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.postfixes">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">postfixes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L912-L928"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.postfixes" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all postfixes of a sequence.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">postfixes</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">postfixes</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="go">[[4], [3, 4], [2, 3, 4], [1, 2, 3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.postorder_traversal">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">postorder_traversal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">node</span></em>, <em class="sig-param"><span class="n">keys</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L325-L379"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.postorder_traversal" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a postorder traversal of a tree.</p>
<p>This generator recursively yields nodes that it has visited in a postorder
fashion. That is, it descends through the tree depth-first to yield all of
a node’s children’s postorder traversal before yielding the node itself.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>node</strong> : sympy expression</p>
<blockquote>
<div><p>The expression to traverse.</p>
</div></blockquote>
<p><strong>keys</strong> : (default None) sort key(s)</p>
<blockquote>
<div><p>The key(s) used to sort args of Basic objects. When None, args of Basic
objects are processed in arbitrary order. If key is defined, it will
be passed along to ordered() as the only key(s) to use to sort the
arguments; if <code class="docutils literal notranslate"><span class="pre">key</span></code> is simply True then the default keys of
<code class="docutils literal notranslate"><span class="pre">ordered</span></code> will be used (node count and default_sort_key).</p>
</div></blockquote>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><p><strong>subtree</strong> : sympy expression</p>
<blockquote>
<div><p>All of the subtrees in the tree.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">postorder_traversal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<p>The nodes are returned in the order that they are encountered unless key
is given; simply passing key=True will guarantee that the traversal is
unique.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">postorder_traversal</span><span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">))</span> 
<span class="go">[z, y, x, x + y, z*(x + y), w, w + z*(x + y)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">postorder_traversal</span><span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[w, z, x, y, x + y, z*(x + y), w + z*(x + y)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.prefixes">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">prefixes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L893-L909"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.prefixes" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate all prefixes of a sequence.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">prefixes</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">prefixes</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
<span class="go">[[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.reshape">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">reshape</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">how</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L129-L186"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshape the sequence according to the template in <code class="docutils literal notranslate"><span class="pre">how</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">reshape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="c1"># lists of 4</span>
<span class="go">[[1, 2, 3, 4], [5, 6, 7, 8]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,))</span> <span class="c1"># tuples of 4</span>
<span class="go">[(1, 2, 3, 4), (5, 6, 7, 8)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1"># tuples of 4</span>
<span class="go">[(1, 2, 3, 4), (5, 6, 7, 8)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="c1"># (i, i, [i, i])</span>
<span class="go">[(1, 2, [3, 4]), (5, 6, [7, 8])]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="c1"># etc....</span>
<span class="go">[((1, 2), [3, 4]), ((5, 6), [7, 8])]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">[(1, [2, 3], 4), (5, [6, 7], 8)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)],))</span>
<span class="go">(([[1], 2, (3, 4)],), ([[5], 6, (7, 8)],))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)))</span>
<span class="go">(([1], 2, (3, 4)), ([5], 6, (7, 8)))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reshape</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">{</span><span class="mi">2</span><span class="p">},</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="mi">1</span><span class="p">)])</span>
<span class="go">[[0, 1, [2, 3, 4], {5, 6}, (7, (8, 9, 10), 11)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.rotate_left">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">rotate_left</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1239-L1255"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.rotate_left" title="Permalink to this definition">¶</a></dt>
<dd><p>Left rotates a list x by the number of steps specified
in y.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">rotate_left</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate_left</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[1, 2, 0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.rotate_right">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">rotate_right</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1258-L1274"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.rotate_right" title="Permalink to this definition">¶</a></dt>
<dd><p>Right rotates a list x by the number of steps specified
in y.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">rotate_right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate_right</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[2, 0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.rotations">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">rotations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">dir</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2692-L2709"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.rotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a generator giving the items in s as list where
each subsequent list has the items rotated to the left (default)
or right (dir=-1) relative to the previous list.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">rotations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">rotations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
<span class="go">[[1, 2, 3], [2, 3, 1], [3, 1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">rotations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1, 2, 3], [3, 1, 2], [2, 3, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.roundrobin">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">roundrobin</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">iterables</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2712-L2731"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.roundrobin" title="Permalink to this definition">¶</a></dt>
<dd><p>roundrobin recipe taken from itertools documentation:
<a class="reference external" href="https://docs.python.org/2/library/itertools.html#recipes">https://docs.python.org/2/library/itertools.html#recipes</a></p>
<p>roundrobin(‘ABC’, ‘D’, ‘EF’) –&gt; A D E B F C</p>
<p>Recipe credited to George Sakkis</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.runs">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">runs</code><span class="sig-paren">(</span><em class="sig-param">seq</em>, <em class="sig-param">op=&lt;built-in function gt&gt;</em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2494-L2528"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.runs" title="Permalink to this definition">¶</a></dt>
<dd><p>Group the sequence into lists in which successive elements
all compare the same with the comparison operator, <code class="docutils literal notranslate"><span class="pre">op</span></code>:
op(seq[i + 1], seq[i]) is True from all elements in a run.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">runs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">ge</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">runs</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">[[0, 1, 2], [2], [1, 4], [3], [2], [2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">runs</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">op</span><span class="o">=</span><span class="n">ge</span><span class="p">)</span>
<span class="go">[[0, 1, 2, 2], [1, 4], [3], [2, 2]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.sift">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">sift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">keyfunc</span></em>, <em class="sig-param"><span class="n">binary</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L735-L819"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.sift" title="Permalink to this definition">¶</a></dt>
<dd><p>Sift the sequence, <code class="docutils literal notranslate"><span class="pre">seq</span></code> according to <code class="docutils literal notranslate"><span class="pre">keyfunc</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>When <code class="docutils literal notranslate"><span class="pre">binary</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), the output is a dictionary</p>
<p>where elements of <code class="docutils literal notranslate"><span class="pre">seq</span></code> are stored in a list keyed to the value</p>
<p>of keyfunc for that element. If <code class="docutils literal notranslate"><span class="pre">binary</span></code> is True then a tuple</p>
<p>with lists <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">F</span></code> are returned where <code class="docutils literal notranslate"><span class="pre">T</span></code> is a list</p>
<p>containing elements of seq for which <code class="docutils literal notranslate"><span class="pre">keyfunc</span></code> was <code class="docutils literal notranslate"><span class="pre">True</span></code> and</p>
<p><code class="docutils literal notranslate"><span class="pre">F</span></code> containing those elements for which <code class="docutils literal notranslate"><span class="pre">keyfunc</span></code> was <code class="docutils literal notranslate"><span class="pre">False</span></code>;</p>
<p>a ValueError is raised if the <code class="docutils literal notranslate"><span class="pre">keyfunc</span></code> is not binary.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">sift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">Tuple</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sift</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">{0: [0, 2, 4], 1: [1, 3]}</span>
</pre></div>
</div>
<p>sift() returns a defaultdict() object, so any key that has no matches will
give [].</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sift</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">)</span>
<span class="go">{True: [x]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Sometimes you will not know how many keys you will get:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sift</span><span class="p">([</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>     <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">{E: [exp(x)], x: [sqrt(x)], y: [y**(2*x)]}</span>
</pre></div>
</div>
<p>Sometimes you expect the results to be binary; the
results can be unpacked by setting <code class="docutils literal notranslate"><span class="pre">binary</span></code> to True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sift</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([1, 3], [0, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sift</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pi</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_rational</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([1], [pi])</span>
</pre></div>
</div>
<p>A ValueError is raised if the predicate was not actually binary
(which is a good test for the logic where sifting is used and
binary results were expected):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unknown</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">pi</span>  <span class="c1"># the rationality of this is unknown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">unknown</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sift</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_rational</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">keyfunc gave non-binary output</span>
</pre></div>
</div>
<p>The non-binary sifting shows that there were 3 keys generated:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">sift</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">is_rational</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">{None, False, True}</span>
</pre></div>
</div>
<p>If you need to sort the sifted items it might be better to use
<code class="docutils literal notranslate"><span class="pre">ordered</span></code> which can economically apply multiple sort keys
to a sequence while sorting.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../core.html#sympy.core.compatibility.ordered" title="sympy.core.compatibility.ordered"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ordered</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.signed_permutations">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">signed_permutations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2673-L2689"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.signed_permutations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return iterator in which the signs of non-zero elements
of t and the order of the elements are permuted.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">signed_permutations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">signed_permutations</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="go">[(0, 1, 2), (0, -1, 2), (0, 1, -2), (0, -1, -2), (0, 2, 1),</span>
<span class="go">(0, -2, 1), (0, 2, -1), (0, -2, -1), (1, 0, 2), (-1, 0, 2),</span>
<span class="go">(1, 0, -2), (-1, 0, -2), (1, 2, 0), (-1, 2, 0), (1, -2, 0),</span>
<span class="go">(-1, -2, 0), (2, 0, 1), (-2, 0, 1), (2, 0, -1), (-2, 0, -1),</span>
<span class="go">(2, 1, 0), (-2, 1, 0), (2, -1, 0), (-2, -1, 0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.strongly_connected_components">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">strongly_connected_components</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">G</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L1045-L1165"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.strongly_connected_components" title="Permalink to this definition">¶</a></dt>
<dd><p>Strongly connected components of a directed graph in reverse topological
order.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>graph</strong> : tuple[list, list[tuple[T, T]]</p>
<blockquote>
<div><p>A tuple consisting of a list of vertices and a list of edges of
a graph whose strongly connected components are to be found.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Consider a directed graph (in dot notation):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">digraph</span> <span class="p">{</span>
    <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">B</span>
    <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">C</span>
    <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">C</span>
    <span class="n">C</span> <span class="o">-&gt;</span> <span class="n">B</span>
    <span class="n">B</span> <span class="o">-&gt;</span> <span class="n">D</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where vertices are the letters A, B, C and D. This graph can be encoded
using Python’s elementary data structures as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>The strongly connected components of this graph can be computed as</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">strongly_connected_components</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strongly_connected_components</span><span class="p">((</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">))</span>
<span class="go">[[&#39;D&#39;], [&#39;B&#39;, &#39;C&#39;], [&#39;A&#39;]]</span>
</pre></div>
</div>
<p>This also gives the components in reverse topological order.</p>
<p>Since the subgraph containing B and C has a cycle they must be together in
a strongly connected component. A and D are connected to the rest of the
graph but not in a cyclic manner so they appear as their own strongly
connected components.</p>
<p class="rubric">Notes</p>
<p>The vertices of the graph must be hashable for the data structures used.
If the vertices are unhashable replace them with integer indices.</p>
<p>This function uses Tarjan’s algorithm to compute the strongly connected
components in <span class="math notranslate nohighlight">\(O(|V|+|E|)\)</span> (linear) time.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.utilities.iterables.connected_components" title="sympy.utilities.iterables.connected_components"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.utilities.iterables.connected_components</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r847"><span class="brackets"><a class="fn-backref" href="#id17">R847</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Strongly_connected_component">https://en.wikipedia.org/wiki/Strongly_connected_component</a></p>
</dd>
<dt class="label" id="r848"><span class="brackets"><a class="fn-backref" href="#id18">R848</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.subsets">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">subsets</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">k</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repetition</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L592-L639"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.subsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates all <span class="math notranslate nohighlight">\(k\)</span>-subsets (combinations) from an <span class="math notranslate nohighlight">\(n\)</span>-element set, <code class="docutils literal notranslate"><span class="pre">seq</span></code>.</p>
<p>A <span class="math notranslate nohighlight">\(k\)</span>-subset of an <span class="math notranslate nohighlight">\(n\)</span>-element set is any subset of length exactly <span class="math notranslate nohighlight">\(k\)</span>. The
number of <span class="math notranslate nohighlight">\(k\)</span>-subsets of an <span class="math notranslate nohighlight">\(n\)</span>-element set is given by <code class="docutils literal notranslate"><span class="pre">binomial(n,</span> <span class="pre">k)</span></code>,
whereas there are <span class="math notranslate nohighlight">\(2^n\)</span> subsets all together. If <span class="math notranslate nohighlight">\(k\)</span> is <code class="docutils literal notranslate"><span class="pre">None</span></code> then all
<span class="math notranslate nohighlight">\(2^n\)</span> subsets will be returned from shortest to longest.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">subsets</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">subsets(seq,</span> <span class="pre">k)</span></code> will return the <span class="math notranslate nohighlight">\(\frac{n!}{k!(n - k)!}\)</span> <span class="math notranslate nohighlight">\(k\)</span>-subsets (combinations)
without repetition, i.e. once an item has been removed, it can no
longer be “taken”:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[(), (1,), (2,), (1, 2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(1, 2), (1, 3), (2, 3)]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">subsets(seq,</span> <span class="pre">k,</span> <span class="pre">repetition=True)</span></code> will return the <span class="math notranslate nohighlight">\(\frac{(n - 1 + k)!}{k!(n - 1)!}\)</span>
combinations <em>with</em> repetition:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subsets</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, 1), (1, 2), (2, 2)]</span>
</pre></div>
</div>
<p>If you ask for more items than are in the set you get the empty set unless
you allow repetitions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subsets</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subsets</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(0, 0, 0), (0, 0, 1), (0, 1, 1), (1, 1, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.take">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iter</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L822-L824"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal notranslate"><span class="pre">n</span></code> items from <code class="docutils literal notranslate"><span class="pre">iter</span></code> iterator.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.topological_sort">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">topological_sort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">graph</span></em>, <em class="sig-param"><span class="n">key</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L931-L1042"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.topological_sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Topological sort of graph’s vertices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>graph</strong> : tuple[list, list[tuple[T, T]]</p>
<blockquote>
<div><p>A tuple consisting of a list of vertices and a list of edges of
a graph to be sorted topologically.</p>
</div></blockquote>
<p><strong>key</strong> : callable[T] (optional)</p>
<blockquote>
<div><p>Ordering key for vertices on the same level. By default the natural
(e.g. lexicographic) ordering is used (in this case the base type
must implement ordering relations).</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Consider a graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+</span>     <span class="o">+---+</span>     <span class="o">+---+</span>
<span class="o">|</span> <span class="mi">7</span> <span class="o">|</span>\    <span class="o">|</span> <span class="mi">5</span> <span class="o">|</span>     <span class="o">|</span> <span class="mi">3</span> <span class="o">|</span>
<span class="o">+---+</span> \   <span class="o">+---+</span>     <span class="o">+---+</span>
  <span class="o">|</span>   <span class="n">_</span>\<span class="n">___</span><span class="o">/</span> <span class="n">____</span>   <span class="n">_</span><span class="o">/</span> <span class="o">|</span>
  <span class="o">|</span>  <span class="o">/</span>  \<span class="n">___</span><span class="o">/</span>    \ <span class="o">/</span>   <span class="o">|</span>
  <span class="n">V</span>  <span class="n">V</span>           <span class="n">V</span> <span class="n">V</span>   <span class="o">|</span>
 <span class="o">+----+</span>         <span class="o">+---+</span>  <span class="o">|</span>
 <span class="o">|</span> <span class="mi">11</span> <span class="o">|</span>         <span class="o">|</span> <span class="mi">8</span> <span class="o">|</span>  <span class="o">|</span>
 <span class="o">+----+</span>         <span class="o">+---+</span>  <span class="o">|</span>
  <span class="o">|</span> <span class="o">|</span> \<span class="n">____</span>   <span class="n">___</span><span class="o">/</span> <span class="n">_</span>   <span class="o">|</span>
  <span class="o">|</span> \      \ <span class="o">/</span>    <span class="o">/</span> \  <span class="o">|</span>
  <span class="n">V</span>  \     <span class="n">V</span> <span class="n">V</span>   <span class="o">/</span>  <span class="n">V</span>  <span class="n">V</span>
<span class="o">+---+</span> \   <span class="o">+---+</span> <span class="o">|</span>  <span class="o">+----+</span>
<span class="o">|</span> <span class="mi">2</span> <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span> <span class="mi">9</span> <span class="o">|</span> <span class="o">|</span>  <span class="o">|</span> <span class="mi">10</span> <span class="o">|</span>
<span class="o">+---+</span>  <span class="o">|</span>  <span class="o">+---+</span> <span class="o">|</span>  <span class="o">+----+</span>
       \<span class="n">________</span><span class="o">/</span>
</pre></div>
</div>
<p>where vertices are integers. This graph can be encoded using
elementary Python’s data structures as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
<span class="gp">... </span>     <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">)]</span>
</pre></div>
</div>
<p>To compute a topological sort for graph <code class="docutils literal notranslate"><span class="pre">(V,</span> <span class="pre">E)</span></code> issue:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">topological_sort</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">topological_sort</span><span class="p">((</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">))</span>
<span class="go">[3, 5, 7, 8, 11, 2, 9, 10]</span>
</pre></div>
</div>
<p>If specific tie breaking approach is needed, use <code class="docutils literal notranslate"><span class="pre">key</span></code> parameter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topological_sort</span><span class="p">((</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="n">v</span><span class="p">)</span>
<span class="go">[7, 5, 11, 3, 10, 8, 9, 2]</span>
</pre></div>
</div>
<p>Only acyclic graphs can be sorted. If the input graph has a cycle,
then <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">topological_sort</span><span class="p">((</span><span class="n">V</span><span class="p">,</span> <span class="n">E</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">cycle detected</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r849"><span class="brackets"><a class="fn-backref" href="#id19">R849</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Topological_sorting">https://en.wikipedia.org/wiki/Topological_sorting</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.unflatten">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">unflatten</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">iter</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L120-L126"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.unflatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Group <code class="docutils literal notranslate"><span class="pre">iter</span></code> into tuples of length <code class="docutils literal notranslate"><span class="pre">n</span></code>. Raise an error if
the length of <code class="docutils literal notranslate"><span class="pre">iter</span></code> is not a multiple of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.uniq">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">uniq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">result</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L2090-L2141"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.uniq" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield unique elements from <code class="docutils literal notranslate"><span class="pre">seq</span></code> as an iterator. The second
parameter <code class="docutils literal notranslate"><span class="pre">result</span></code>  is used internally; it is not necessary
to pass anything for this.</p>
<p>Note: changing the sequence during iteration will raise a
RuntimeError if the size of the sequence is known; if you pass
an iterator and advance the iterator you will change the
output of this routine but there will be no warning.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">uniq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">dat</span><span class="p">))</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">dat</span><span class="p">))</span>
<span class="go">[1, 4, 5, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dat</span><span class="p">))</span>
<span class="go">[1, 4, 5, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
<span class="go">[[1], [2, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.utilities.iterables.variations">
<code class="sig-prename descclassname">sympy.utilities.iterables.</code><code class="sig-name descname">variations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">repetition</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0c2500143edaa9ec2c5ef74f5f242ba5f9dee157/sympy/utilities/iterables.py#L547-L589"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.utilities.iterables.variations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a generator of the n-sized variations of <code class="docutils literal notranslate"><span class="pre">seq</span></code> (size N).
<code class="docutils literal notranslate"><span class="pre">repetition</span></code> controls whether items in <code class="docutils literal notranslate"><span class="pre">seq</span></code> can appear more than once;</p>
<p class="rubric">Examples</p>
<p><code class="docutils literal notranslate"><span class="pre">variations(seq,</span> <span class="pre">n)</span></code> will return <span class="math notranslate nohighlight">\(\frac{N!}{(N - n)!}\)</span> permutations without
repetition of <code class="docutils literal notranslate"><span class="pre">seq</span></code>’s elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">variations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">variations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[(1, 2), (2, 1)]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">variations(seq,</span> <span class="pre">n,</span> <span class="pre">True)</span></code> will return the <span class="math notranslate nohighlight">\(N^n\)</span> permutations obtained
by allowing repetition of elements:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">variations</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[(1, 1), (1, 2), (2, 1), (2, 2)]</span>
</pre></div>
</div>
<p>If you ask for more items than are in the set you get the empty set unless
you allow repetitions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">variations</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">variations</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="n">repetition</span><span class="o">=</span><span class="kc">True</span><span class="p">))[:</span><span class="mi">4</span><span class="p">]</span>
<span class="go">[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.permutations">itertools.permutations</a>,
<a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.product">itertools.product</a></p>
</div>
</dd></dl>

</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Iterables</a><ul>
<li><a class="reference internal" href="#cartes">cartes</a></li>
<li><a class="reference internal" href="#variations">variations</a></li>
<li><a class="reference internal" href="#partitions">partitions</a><ul>
<li><a class="reference internal" href="#module-sympy.utilities.iterables">Docstring</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="enumerative.html"
                        title="previous chapter">Enumerative</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="lambdify.html"
                        title="next chapter">Lambdify</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/utilities/iterables.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="lambdify.html" title="Lambdify"
             >next</a> |</li>
        <li class="right" >
          <a href="enumerative.html" title="Enumerative"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >Utilities</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Iterables</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 SymPy Development Team.
      Last updated on Jul 29, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.2.
    </div>
  </body>
</html>