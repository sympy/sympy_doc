
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ODE &#8212; SymPy 1.7.dev documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/solvers/ode.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Parsing" href="../parsing.html" />
    <link rel="prev" title="Numeric Computation" href="../numeric-computation.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../parsing.html" title="Parsing"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../numeric-computation.html" title="Numeric Computation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">SymPy Modules Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ODE</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ode">
<span id="ode-docs"></span><h1>ODE<a class="headerlink" href="#ode" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sympy.solvers.ode"></span><div class="section" id="user-functions">
<h2>User Functions<a class="headerlink" href="#user-functions" title="Permalink to this headline">¶</a></h2>
<p>These are functions that are imported into the global namespace with <code class="docutils literal notranslate"><span class="pre">from</span>
<span class="pre">sympy</span> <span class="pre">import</span> <span class="pre">*</span></code>.  These functions (unlike <a class="reference internal" href="#hint-functions">Hint Functions</a>, below) are
intended for use by ordinary users of SymPy.</p>
<div class="section" id="dsolve">
<h3>dsolve<a class="headerlink" href="#dsolve" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.dsolve">
<code class="sig-prename descclassname">sympy.solvers.ode.</code><code class="sig-name descname">dsolve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hint</span><span class="o">=</span><span class="default_value">'default'</span></em>, <em class="sig-param"><span class="n">simplify</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ics</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xi</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x0</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">6</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L380-L664"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.dsolve" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Solves any (supported) kind of ordinary differential equation and
system of ordinary differential equations.</p>
</div></blockquote>
<p class="rubric">For Single Ordinary Differential Equation</p>
<p>It is classified under this when number of equation in <code class="docutils literal notranslate"><span class="pre">eq</span></code> is one.
<strong>Usage</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span> <span class="pre">hint)</span></code> -&gt; Solve ordinary differential equation
<code class="docutils literal notranslate"><span class="pre">eq</span></code> for function <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>, using method <code class="docutils literal notranslate"><span class="pre">hint</span></code>.</p>
</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">eq</span></code> can be any supported ordinary differential equation (see the</dt><dd><p><a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code></a> docstring for supported methods).
This can either be an <a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></a>,
or an expression, which is assumed to be equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f(x)</span></code> is a function of one variable whose derivatives in that</dt><dd><p>variable make up the ordinary differential equation <code class="docutils literal notranslate"><span class="pre">eq</span></code>.  In
many cases it is not necessary to provide this; it will be
autodetected (and an error raised if it couldn’t be detected).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hint</span></code> is the solving method that you want dsolve to use.  Use</dt><dd><p><code class="docutils literal notranslate"><span class="pre">classify_ode(eq,</span> <span class="pre">f(x))</span></code> to get all of the possible hints for an
ODE.  The default hint, <code class="docutils literal notranslate"><span class="pre">default</span></code>, will use whatever hint is
returned first by <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>.  See
Hints below for more options that you can use for hint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">simplify</span></code> enables simplification by</dt><dd><p><a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a>.  See its docstring for more
information.  Turn this off, for example, to disable solving of
solutions for <code class="docutils literal notranslate"><span class="pre">func</span></code> or simplification of arbitrary constants.
It will still integrate with this hint. Note that the solution may
contain more arbitrary constants than the order of the ODE with
this option enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xi</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code> are the infinitesimal functions of an ordinary</dt><dd><p>differential equation. They are the infinitesimals of the Lie group
of point transformations for which the differential equation is
invariant. The user can specify values for the infinitesimals. If
nothing is specified, <code class="docutils literal notranslate"><span class="pre">xi</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code> are calculated using
<a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">infinitesimals()</span></code></a> with the help of various
heuristics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ics</span></code> is the set of initial/boundary conditions for the differential equation.</dt><dd><p>It should be given in the form of <code class="docutils literal notranslate"><span class="pre">{f(x0):</span> <span class="pre">x1,</span> <span class="pre">f(x).diff(x).subs(x,</span> <span class="pre">x2):</span>
<span class="pre">x3}</span></code> and so on.  For power series solutions, if no initial
conditions are specified <code class="docutils literal notranslate"><span class="pre">f(0)</span></code> is assumed to be <code class="docutils literal notranslate"><span class="pre">C0</span></code> and the power
series solution is calculated about 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x0</span></code> is the point about which the power series solution of a differential</dt><dd><p>equation is to be evaluated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> gives the exponent of the dependent variable up to which the power series</dt><dd><p>solution of a differential equation is to be evaluated.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>Aside from the various solving methods, there are also some meta-hints
that you can pass to <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">default</span></code>:</dt><dd><p>This uses whatever hint is returned first by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>. This is the
default argument to <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all</span></code>:</dt><dd><p>To make <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> apply all
relevant classification hints, use <code class="docutils literal notranslate"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&quot;all&quot;)</span></code>.  This will return a dictionary of
<code class="docutils literal notranslate"><span class="pre">hint:solution</span></code> terms.  If a hint causes dsolve to raise the
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>, value of that hint’s key will be the
exception object raised.  The dictionary will also include
some special keys:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">order</span></code>: The order of the ODE.  See also
<a class="reference internal" href="solvers.html#sympy.solvers.deutils.ode_order" title="sympy.solvers.deutils.ode_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_order()</span></code></a> in
<code class="docutils literal notranslate"><span class="pre">deutils.py</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">best</span></code>: The simplest hint; what would be returned by
<code class="docutils literal notranslate"><span class="pre">best</span></code> below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">best_hint</span></code>: The hint that would produce the solution
given by <code class="docutils literal notranslate"><span class="pre">best</span></code>.  If more than one hint produces the best
solution, the first one in the tuple returned by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> is chosen.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code>: The solution that would be returned by default.
This is the one produced by the hint that appears first in
the tuple returned by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>:</dt><dd><p>This is the same as <code class="docutils literal notranslate"><span class="pre">all</span></code>, except if a hint also has a
corresponding <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint, it only returns the
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint.  This is useful if <code class="docutils literal notranslate"><span class="pre">all</span></code> causes
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> to hang because of a
difficult or impossible integral.  This meta-hint will also be
much faster than <code class="docutils literal notranslate"><span class="pre">all</span></code>, because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> is an expensive
routine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">best</span></code>:</dt><dd><p>To have <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> try all methods
and return the simplest one.  This takes into account whether
the solution is solvable in the function, whether it contains
any Integral classes (i.e.  unevaluatable integrals), and
which one is the shortest in size.</p>
</dd>
</dl>
<p>See also the <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> docstring for
more info on hints, and the <a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code></a> docstring for
a list of all supported hints.</p>
</div></blockquote>
<p><strong>Tips</strong></p>
<blockquote>
<div><ul>
<li><p>You can declare the derivative of an unknown function this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span> <span class="c1"># x is the independent variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># f is a function of x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># f_ will be the derivative of f with respect to x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>See <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code> for many tests, which serves also as a set of
examples for how to use <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> always returns an
<a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></a> class (except for the
case when the hint is <code class="docutils literal notranslate"><span class="pre">all</span></code> or <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>).  If possible, it
solves the solution explicitly for the function being solved for.
Otherwise, it returns an implicit solution.</p></li>
<li><p>Arbitrary constants are symbols named <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, and so on.</p></li>
<li><p>Because all solutions should be mathematically equivalent, some
hints may return the exact same result for an ODE. Often, though,
two different hints will return the same solution formatted
differently.  The two should be equivalent. Also note that sometimes
the values of the arbitrary constants in two different solutions may
not be the same, because one constant may have “absorbed” other
constants into it.</p></li>
<li><p>Do <code class="docutils literal notranslate"><span class="pre">help(ode.ode_&lt;hintname&gt;)</span></code> to get help more information on a
specific hint, where <code class="docutils literal notranslate"><span class="pre">&lt;hintname&gt;</span></code> is the name of a hint without
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code>.</p></li>
</ul>
</div></blockquote>
<p class="rubric">For System Of Ordinary Differential Equations</p>
<dl>
<dt><strong>Usage</strong></dt><dd><blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">func)</span></code> -&gt; Solve a system of ordinary differential
equations <code class="docutils literal notranslate"><span class="pre">eq</span></code> for <code class="docutils literal notranslate"><span class="pre">func</span></code> being list of functions including
<span class="math notranslate nohighlight">\(x(t)\)</span>, <span class="math notranslate nohighlight">\(y(t)\)</span>, <span class="math notranslate nohighlight">\(z(t)\)</span> where number of functions in the list depends
upon the number of equations provided in <code class="docutils literal notranslate"><span class="pre">eq</span></code>.</p>
</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">eq</span></code> can be any supported system of ordinary differential equations
This can either be an <a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></a>,
or an expression, which is assumed to be equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">func</span></code> holds <code class="docutils literal notranslate"><span class="pre">x(t)</span></code> and <code class="docutils literal notranslate"><span class="pre">y(t)</span></code> being functions of one variable which
together with some of their derivatives make up the system of ordinary
differential equation <code class="docutils literal notranslate"><span class="pre">eq</span></code>. It is not necessary to provide this; it
will be autodetected (and an error raised if it couldn’t be detected).</p>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>The hints are formed by parameters returned by classify_sysode, combining
them give hints name used later for forming method name.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">Eq(f(x), C1*sin(3*x) + C2*cos(3*x))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">12</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">21</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[Eq(x(t), C1*x0(t) + C2*x0(t)*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)**2, t)),</span>
<span class="go">Eq(y(t), C1*y0(t) + C2*(y0(t)*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)**2, t) +</span>
<span class="go">exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">{Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t))), Eq(y(t), -1/(C1 - cos(t)))}</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="dsolve-system">
<h3>dsolve_system<a class="headerlink" href="#dsolve-system" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.systems.dsolve_system">
<code class="sig-prename descclassname">sympy.solvers.ode.systems.</code><code class="sig-name descname">dsolve_system</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eqs</span></em>, <em class="sig-param"><span class="n">funcs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ics</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">doit</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/systems.py#L1839-L1994"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.systems.dsolve_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves any(supported) system of Ordinary Differential Equations</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>eqs</strong> : List</p>
<blockquote>
<div><p>system of ODEs to be solved</p>
</div></blockquote>
<p><strong>funcs</strong> : List or None</p>
<blockquote>
<div><p>List of dependent variables that make up the system of ODEs</p>
</div></blockquote>
<p><strong>t</strong> : Symbol or None</p>
<blockquote>
<div><p>Independent variable in the system of ODEs</p>
</div></blockquote>
<p><strong>ics</strong> : Dict or None</p>
<blockquote>
<div><p>Set of initial boundary/conditions for the system of ODEs</p>
</div></blockquote>
<p><strong>doit</strong> : Boolean</p>
<blockquote>
<div><p>Evaluate the solutions if True. Default value is False</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of List of Equations</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>When the system of ODEs is not solvable by this function.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote>
<div><p>When the parameters passed aren’t in the required form.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This function takes a system of ODEs as an input, determines if the
it is solvable by this function, and returns the solution if found any.</p>
<p>This function can handle:
1. Linear, First Order, Constant coefficient homogeneous system of ODEs
2. Linear, First Order, Constant coefficient non-homogeneous system of ODEs
3. Linear, First Order, non-constant coefficient homogeneous system of ODEs
4. Linear, First Order, non-constant coefficient non-homogeneous system of ODEs
5. Any implicit system which can be divided into system of ODEs which is of the above 4 forms
6. Any higher order linear system of ODEs that can be reduced to one of the 5 forms of systems described above.</p>
<p>The types of systems described above aren’t limited by the number of equations, i.e. this
function can solve the above types irrespective of the number of equations in the system passed.
But, the bigger the system, the more time it will take to solve the system.</p>
<p>This function returns a list of solutions. Each solution is a list of equations where LHS is
the dependent variable and RHS is an expression in terms of the independent variable.</p>
<p>Among the non constant coefficient types, not all the systems are solvable by this function. Only
those which have either a coefficient matrix with a commutative antiderivative or those systems which
may be divided further so that the divided systems may have coefficient matrix with commutative antiderivative.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">dsolve_system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;f g&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve_system</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>
<span class="go">[[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]]</span>
</pre></div>
</div>
<p>You can also pass the initial conditions for the system of ODEs:
&gt;&gt;&gt; dsolve_system(eqs, ics={f(0): 1, g(0): 0})
[[Eq(f(x), exp(x)/2 + exp(-x)/2), Eq(g(x), exp(x)/2 - exp(-x)/2)]]</p>
<p>Optionally, you can pass the dependent variables and the independent
variable for which the system is to be solved:
&gt;&gt;&gt; funcs = [f(x), g(x)]
&gt;&gt;&gt; dsolve_system(eqs, funcs=funcs, t=x)
[[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]]</p>
<p>Lets look at an implicit system of ODEs:
&gt;&gt;&gt; eqs = [Eq(f(x).diff(x)**2, g(x)**2), Eq(g(x).diff(x), g(x))]
&gt;&gt;&gt; dsolve_system(eqs)
[[Eq(f(x), C1 - C2*exp(x)), Eq(g(x), C2*exp(x))], [Eq(f(x), C1 + C2*exp(x)), Eq(g(x), C2*exp(x))]]</p>
</dd></dl>

</div>
<div class="section" id="classify-ode">
<h3>classify_ode<a class="headerlink" href="#classify-ode" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.classify_ode">
<code class="sig-prename descclassname">sympy.solvers.ode.</code><code class="sig-name descname">classify_ode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dict</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ics</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">prep</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">xi</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eta</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L836-L1466"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.classify_ode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of possible <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>
classifications for an ODE.</p>
<p>The tuple is ordered so that first item is the classification that
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> uses to solve the ODE by default.  In
general, classifications at the near the beginning of the list will
produce better solutions faster than those near the end, thought there are
always exceptions.  To make <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> use a
different classification, use <code class="docutils literal notranslate"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&lt;classification&gt;)</span></code>.  See also the
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> docstring for different meta-hints
you can use.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dict</span></code> is true, <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> will
return a dictionary of <code class="docutils literal notranslate"><span class="pre">hint:match</span></code> expression terms. This is intended
for internal use by <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.  Note that
because dictionaries are ordered arbitrarily, this will most likely not be
in the same order as the tuple.</p>
<p>You can get help on different hints by executing
<code class="docutils literal notranslate"><span class="pre">help(ode.ode_hintname)</span></code>, where <code class="docutils literal notranslate"><span class="pre">hintname</span></code> is the name of the hint
without <code class="docutils literal notranslate"><span class="pre">_Integral</span></code>.</p>
<p>See <a class="reference internal" href="#sympy.solvers.ode.allhints" title="sympy.solvers.ode.allhints"><code class="xref py py-data docutils literal notranslate"><span class="pre">allhints</span></code></a> or the
<a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code></a> docstring for a list of all supported hints
that can be returned from <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>.</p>
<p class="rubric">Notes</p>
<p>These are remarks on hint names.</p>
<p><code class="docutils literal notranslate"><span class="pre">_Integral</span></code></p>
<blockquote>
<div><p>If a classification has <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> at the end, it will return the
expression with an unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>
class in it.  Note that a hint may do this anyway if
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> cannot do the integral,
though just using an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> will do so much faster.  Indeed, an
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint will always be faster than its corresponding hint
without <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> is an expensive routine.
If <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> hangs, it is probably because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> is hanging on a tough or
impossible integral.  Try using an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint or
<code class="docutils literal notranslate"><span class="pre">all_Integral</span></code> to get it return something.</p>
<p>Note that some hints do not have <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> counterparts. This is
because <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.integrate" title="sympy.integrals.integrals.integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">integrate()</span></code></a> is not used in
solving the ODE for those method. For example, <span class="math notranslate nohighlight">\(n\)</span>th order linear
homogeneous ODEs with constant coefficients do not require integration
to solve, so there is no
<code class="docutils literal notranslate"><span class="pre">nth_linear_homogeneous_constant_coeff_Integrate</span></code> hint. You can
easily evaluate any unevaluated
<a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>s in an expression by
doing <code class="docutils literal notranslate"><span class="pre">expr.doit()</span></code>.</p>
</div></blockquote>
<p>Ordinals</p>
<blockquote>
<div><p>Some hints contain an ordinal such as <code class="docutils literal notranslate"><span class="pre">1st_linear</span></code>.  This is to help
differentiate them from other hints, as well as from other methods
that may not be implemented yet. If a hint has <code class="docutils literal notranslate"><span class="pre">nth</span></code> in it, such as
the <code class="docutils literal notranslate"><span class="pre">nth_linear</span></code> hints, this means that the method used to applies
to ODEs of any order.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">indep</span></code> and <code class="docutils literal notranslate"><span class="pre">dep</span></code></p>
<blockquote>
<div><p>Some hints contain the words <code class="docutils literal notranslate"><span class="pre">indep</span></code> or <code class="docutils literal notranslate"><span class="pre">dep</span></code>.  These reference
the independent variable and the dependent function, respectively. For
example, if an ODE is in terms of <span class="math notranslate nohighlight">\(f(x)\)</span>, then <code class="docutils literal notranslate"><span class="pre">indep</span></code> will refer to
<span class="math notranslate nohighlight">\(x\)</span> and <code class="docutils literal notranslate"><span class="pre">dep</span></code> will refer to <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">subs</span></code></p>
<blockquote>
<div><p>If a hints has the word <code class="docutils literal notranslate"><span class="pre">subs</span></code> in it, it means the the ODE is solved
by substituting the expression given after the word <code class="docutils literal notranslate"><span class="pre">subs</span></code> for a
single dummy variable.  This is usually in terms of <code class="docutils literal notranslate"><span class="pre">indep</span></code> and
<code class="docutils literal notranslate"><span class="pre">dep</span></code> as above.  The substituted expression will be written only in
characters allowed for names of Python objects, meaning operators will
be spelled out.  For example, <code class="docutils literal notranslate"><span class="pre">indep</span></code>/<code class="docutils literal notranslate"><span class="pre">dep</span></code> will be written as
<code class="docutils literal notranslate"><span class="pre">indep_div_dep</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">coeff</span></code></p>
<blockquote>
<div><p>The word <code class="docutils literal notranslate"><span class="pre">coeff</span></code> in a hint refers to the coefficients of something
in the ODE, usually of the derivative terms.  See the docstring for
the individual methods for more info (<code class="docutils literal notranslate"><span class="pre">help(ode)</span></code>).  This is
contrast to <code class="docutils literal notranslate"><span class="pre">coefficients</span></code>, as in <code class="docutils literal notranslate"><span class="pre">undetermined_coefficients</span></code>,
which refers to the common name of a method.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">_best</span></code></p>
<blockquote>
<div><p>Methods that have more than one fundamental way to solve will have a
hint for each sub-method and a <code class="docutils literal notranslate"><span class="pre">_best</span></code> meta-classification. This
will evaluate all hints and return the best, using the same
considerations as the normal <code class="docutils literal notranslate"><span class="pre">best</span></code> meta-hint.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">classify_ode</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(&#39;nth_algebraic&#39;,</span>
<span class="go">&#39;separable&#39;,</span>
<span class="go">&#39;1st_linear&#39;,</span>
<span class="go">&#39;Bernoulli&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_best&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;,</span>
<span class="go">&#39;1st_power_series&#39;, &#39;lie_group&#39;, &#39;nth_linear_constant_coeff_homogeneous&#39;,</span>
<span class="go">&#39;nth_linear_euler_eq_homogeneous&#39;,</span>
<span class="go">&#39;nth_algebraic_Integral&#39;, &#39;separable_Integral&#39;,</span>
<span class="go">&#39;1st_linear_Integral&#39;, &#39;Bernoulli_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="checkodesol">
<h3>checkodesol<a class="headerlink" href="#checkodesol" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.checkodesol">
<code class="sig-prename descclassname">sympy.solvers.ode.</code><code class="sig-name descname">checkodesol</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode</span></em>, <em class="sig-param"><span class="n">sol</span></em>, <em class="sig-param"><span class="n">func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">solve_for_func</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/subscheck.py#L49-L289"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.checkodesol" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes <code class="docutils literal notranslate"><span class="pre">sol</span></code> into <code class="docutils literal notranslate"><span class="pre">ode</span></code> and checks that the result is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>This works when <code class="docutils literal notranslate"><span class="pre">func</span></code> is one function, like <span class="math notranslate nohighlight">\(f(x)\)</span> or a list of
functions like <span class="math notranslate nohighlight">\([f(x), g(x)]\)</span> when <span class="math notranslate nohighlight">\(ode\)</span> is a system of ODEs.  <code class="docutils literal notranslate"><span class="pre">sol</span></code> can
be a single solution or a list of solutions.  Each solution may be an
<a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></a> that the solution satisfies,
e.g. <code class="docutils literal notranslate"><span class="pre">Eq(f(x),</span> <span class="pre">C1),</span> <span class="pre">Eq(f(x)</span> <span class="pre">+</span> <span class="pre">C1,</span> <span class="pre">0)</span></code>; or simply an
<a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a>, e.g. <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">-</span> <span class="pre">C1</span></code>. In most cases it
will not be necessary to explicitly identify the function, but if the
function cannot be inferred from the original equation it can be supplied
through the <code class="docutils literal notranslate"><span class="pre">func</span></code> argument.</p>
<p>If a sequence of solutions is passed, the same sort of container will be
used to return the result for each solution.</p>
<p>It tries the following methods, in order, until it finds zero equivalence:</p>
<ol class="arabic simple">
<li><p>Substitute the solution for <span class="math notranslate nohighlight">\(f\)</span> in the original equation.  This only
works if <code class="docutils literal notranslate"><span class="pre">ode</span></code> is solved for <span class="math notranslate nohighlight">\(f\)</span>.  It will attempt to solve it first
unless <code class="docutils literal notranslate"><span class="pre">solve_for_func</span> <span class="pre">==</span> <span class="pre">False</span></code>.</p></li>
<li><p>Take <span class="math notranslate nohighlight">\(n\)</span> derivatives of the solution, where <span class="math notranslate nohighlight">\(n\)</span> is the order of
<code class="docutils literal notranslate"><span class="pre">ode</span></code>, and check to see if that is equal to the solution.  This only
works on exact ODEs.</p></li>
<li><p>Take the 1st, 2nd, …, <span class="math notranslate nohighlight">\(n\)</span>th derivatives of the solution, each time
solving for the derivative of <span class="math notranslate nohighlight">\(f\)</span> of that order (this will always be
possible because <span class="math notranslate nohighlight">\(f\)</span> is a linear operator). Then back substitute each
derivative into <code class="docutils literal notranslate"><span class="pre">ode</span></code> in reverse order.</p></li>
</ol>
<p>This function returns a tuple.  The first item in the tuple is <code class="docutils literal notranslate"><span class="pre">True</span></code> if
the substitution results in <code class="docutils literal notranslate"><span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. The second
item in the tuple is what the substitution results in.  It should always
be <code class="docutils literal notranslate"><span class="pre">0</span></code> if the first item is <code class="docutils literal notranslate"><span class="pre">True</span></code>. Sometimes this function will
return <code class="docutils literal notranslate"><span class="pre">False</span></code> even when an expression is identically equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.
This happens when <a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.simplify" title="sympy.simplify.simplify.simplify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">simplify()</span></code></a> does not
reduce the expression to <code class="docutils literal notranslate"><span class="pre">0</span></code>.  If an expression returned by this
function vanishes identically, then <code class="docutils literal notranslate"><span class="pre">sol</span></code> really is a solution to
the <code class="docutils literal notranslate"><span class="pre">ode</span></code>.</p>
<p>If this function seems to hang, it is probably because of a hard
simplification.</p>
<p>To use this function to test, test the first item of the tuple.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">checkodesol</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Derivative</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,C1,C2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;f g&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">(True, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(False, 2)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C2</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, [0, 0])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="homogeneous-order">
<h3>homogeneous_order<a class="headerlink" href="#homogeneous-order" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.homogeneous_order">
<code class="sig-prename descclassname">sympy.solvers.ode.</code><code class="sig-name descname">homogeneous_order</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">symbols</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3192-L3280"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.homogeneous_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order <span class="math notranslate nohighlight">\(n\)</span> if <span class="math notranslate nohighlight">\(g\)</span> is homogeneous and <code class="docutils literal notranslate"><span class="pre">None</span></code> if it is not
homogeneous.</p>
<p>Determines if a function is homogeneous and if so of what order.  A
function <span class="math notranslate nohighlight">\(f(x, y, \cdots)\)</span> is homogeneous of order <span class="math notranslate nohighlight">\(n\)</span> if <span class="math notranslate nohighlight">\(f(t x, t y,
\cdots) = t^n f(x, y, \cdots)\)</span>.</p>
<p>If the function is of two variables, <span class="math notranslate nohighlight">\(F(x, y)\)</span>, then <span class="math notranslate nohighlight">\(f\)</span> being homogeneous
of any order is equivalent to being able to rewrite <span class="math notranslate nohighlight">\(F(x, y)\)</span> as <span class="math notranslate nohighlight">\(G(x/y)\)</span>
or <span class="math notranslate nohighlight">\(H(y/x)\)</span>.  This fact is used to solve 1st order ordinary differential
equations whose coefficients are homogeneous of the same order (see the
docstrings of
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code></a> and
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code></a>).</p>
<p>Symbols can be functions, but every argument of the function must be a
symbol, and the arguments of the function that appear in the expression
must match those given in the list of symbols.  If a declared function
appears with different arguments than given in the list of symbols,
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">homogeneous_order</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="infinitesimals">
<h3>infinitesimals<a class="headerlink" href="#infinitesimals" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.infinitesimals">
<code class="sig-prename descclassname">sympy.solvers.ode.</code><code class="sig-name descname">infinitesimals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hint</span><span class="o">=</span><span class="default_value">'default'</span></em>, <em class="sig-param"><span class="n">match</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5507-L5648"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.infinitesimals" title="Permalink to this definition">¶</a></dt>
<dd><p>The infinitesimal functions of an ordinary differential equation, <span class="math notranslate nohighlight">\(\xi(x,y)\)</span>
and <span class="math notranslate nohighlight">\(\eta(x,y)\)</span>, are the infinitesimals of the Lie group of point transformations
for which the differential equation is invariant. So, the ODE <span class="math notranslate nohighlight">\(y'=f(x,y)\)</span>
would admit a Lie group <span class="math notranslate nohighlight">\(x^*=X(x,y;\varepsilon)=x+\varepsilon\xi(x,y)\)</span>,
<span class="math notranslate nohighlight">\(y^*=Y(x,y;\varepsilon)=y+\varepsilon\eta(x,y)\)</span> such that <span class="math notranslate nohighlight">\((y^*)'=f(x^*, y^*)\)</span>.
A change of coordinates, to <span class="math notranslate nohighlight">\(r(x,y)\)</span> and <span class="math notranslate nohighlight">\(s(x,y)\)</span>, can be performed so this Lie group
becomes the translation group, <span class="math notranslate nohighlight">\(r^*=r\)</span> and <span class="math notranslate nohighlight">\(s^*=s+\varepsilon\)</span>.
They are tangents to the coordinate curves of the new system.</p>
<p>Consider the transformation <span class="math notranslate nohighlight">\((x, y) \to (X, Y)\)</span> such that the
differential equation remains invariant. <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span> are the tangents to
the transformed coordinates <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>, at <span class="math notranslate nohighlight">\(\varepsilon=0\)</span>.</p>
<div class="math notranslate nohighlight">
\[\left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \xi,
\left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \eta,\]</div>
<p>The infinitesimals can be found by solving the following PDE:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">,</span> <span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># dy/dx = h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">h</span>
<span class="gp">... </span><span class="o">-</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xi</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">/d               d           \                     d              2       d</span>
<span class="go">|--(eta(x, y)) - --(xi(x, y))|*h(x, y) - eta(x, y)*--(h(x, y)) - h (x, y)*--(x</span>
<span class="go">\dy              dx          /                     dy                     dy</span>

<span class="go">                    d             d</span>
<span class="go">i(x, y)) - xi(x, y)*--(h(x, y)) + --(eta(x, y)) = 0</span>
<span class="go">                    dx            dx</span>
</pre></div>
</div>
<p>Solving the above mentioned PDE is not trivial, and can be solved only by
making intelligent assumptions for <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span> (heuristics). Once an
infinitesimal is found, the attempt to find more heuristics stops. This is done to
optimise the speed of solving the differential equation. If a list of all the
infinitesimals is needed, <code class="docutils literal notranslate"><span class="pre">hint</span></code> should be flagged as <code class="docutils literal notranslate"><span class="pre">all</span></code>, which gives
the complete list of infinitesimals. If the infinitesimals for a particular
heuristic needs to be found, it can be passed as a flag to <code class="docutils literal notranslate"><span class="pre">hint</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">infinitesimals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infinitesimals</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[{eta(x, f(x)): exp(x**3/3), xi(x, f(x)): 0}]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="checkinfsol">
<h3>checkinfsol<a class="headerlink" href="#checkinfsol" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.checkinfsol">
<code class="sig-prename descclassname">sympy.solvers.ode.</code><code class="sig-name descname">checkinfsol</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">infinitesimals</span></em>, <em class="sig-param"><span class="n">func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5202-L5276"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.checkinfsol" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to check if the given infinitesimals are the
actual infinitesimals of the given first order differential equation.
This method is specific to the Lie Group Solver of ODEs.</p>
<p>As of now, it simply checks, by substituting the infinitesimals in the
partial differential equation.</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x}\right)*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y} = 0\]</div>
<p>where <span class="math notranslate nohighlight">\(\eta\)</span>, and <span class="math notranslate nohighlight">\(\xi\)</span> are the infinitesimals and <span class="math notranslate nohighlight">\(h(x,y) = \frac{dy}{dx}\)</span></p>
<p>The infinitesimals should be given in the form of a list of dicts
<code class="docutils literal notranslate"><span class="pre">[{xi(x,</span> <span class="pre">y):</span> <span class="pre">inf,</span> <span class="pre">eta(x,</span> <span class="pre">y):</span> <span class="pre">inf}]</span></code>, corresponding to the
output of the function infinitesimals. It returns a list
of values of the form <code class="docutils literal notranslate"><span class="pre">[(True/False,</span> <span class="pre">sol)]</span></code> where <code class="docutils literal notranslate"><span class="pre">sol</span></code> is the value
obtained after substituting the infinitesimals in the PDE. If it
is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then <code class="docutils literal notranslate"><span class="pre">sol</span></code> would be 0.</p>
</dd></dl>

</div>
<div class="section" id="constantsimp">
<h3>constantsimp<a class="headerlink" href="#constantsimp" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.constantsimp">
<code class="sig-prename descclassname">sympy.solvers.ode.</code><code class="sig-name descname">constantsimp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">constants</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L2591-L2716"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.constantsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies an expression with arbitrary constants in it.</p>
<p>This function is written specifically to work with
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, and is not intended for general use.</p>
<p>Simplification is done by “absorbing” the arbitrary constants into other
arbitrary constants, numbers, and symbols that they are not independent
of.</p>
<p>The symbols must all have the same name with numbers after it, for
example, <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, <code class="docutils literal notranslate"><span class="pre">C3</span></code>.  The <code class="docutils literal notranslate"><span class="pre">symbolname</span></code> here would be
‘<code class="docutils literal notranslate"><span class="pre">C</span></code>’, the <code class="docutils literal notranslate"><span class="pre">startnumber</span></code> would be 1, and the <code class="docutils literal notranslate"><span class="pre">endnumber</span></code> would be 3.
If the arbitrary constants are independent of the variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, then the
independent symbol would be <code class="docutils literal notranslate"><span class="pre">x</span></code>.  There is no need to specify the
dependent function, such as <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>, because it already has the
independent symbol, <code class="docutils literal notranslate"><span class="pre">x</span></code>, in it.</p>
<p>Because terms are “absorbed” into arbitrary constants and because
constants are renumbered after simplifying, the arbitrary constants in
expr are not necessarily equal to the ones of the same name in the
returned result.</p>
<p>If two or more arbitrary constants are added, multiplied, or raised to the
power of each other, they are first absorbed together into a single
arbitrary constant.  Then the new constant is combined into other terms if
necessary.</p>
<p>Absorption of constants is done with limited assistance:</p>
<ol class="arabic simple">
<li><p>terms of <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code></a>s are collected to try join
constants so <span class="math notranslate nohighlight">\(e^x (C_1 \cos(x) + C_2 \cos(x))\)</span> will simplify to <span class="math notranslate nohighlight">\(e^x
C_1 \cos(x)\)</span>;</p></li>
<li><p>powers with exponents that are <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code></a>s are
expanded so <span class="math notranslate nohighlight">\(e^{C_1 + x}\)</span> will be simplified to <span class="math notranslate nohighlight">\(C_1 e^x\)</span>.</p></li>
</ol>
<p>Use <a class="reference internal" href="#sympy.solvers.ode.ode.constant_renumber" title="sympy.solvers.ode.ode.constant_renumber"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constant_renumber()</span></code></a> to renumber constants
after simplification or else arbitrary numbers on constants may appear,
e.g. <span class="math notranslate nohighlight">\(C_1 + C_3 x\)</span>.</p>
<p>In rare cases, a single constant can be “simplified” into two constants.
Every differential equation solution should have as many arbitrary
constants as the order of the differential equation.  The result here will
be technically correct, but it may, for example, have <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> in
an expression, when <span class="math notranslate nohighlight">\(C_1\)</span> is actually equal to <span class="math notranslate nohighlight">\(C_2\)</span>.  Use your discretion
in such situations, and also take advantage of the ability to use hints in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">constantsimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C1, C2, C3, x, y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1 + x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span><span class="o">*</span><span class="n">C2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">C2</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1 + C3*x</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="hint-functions">
<h2>Hint Functions<a class="headerlink" href="#hint-functions" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> and others.  Unlike <a class="reference internal" href="#user-functions">User Functions</a>,
above, these are not intended for every-day use by ordinary SymPy users.
Instead, functions such as <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> should be used.
Nonetheless, these functions contain useful information in their docstrings on
the various ODE solving methods. For this reason, they are documented here.</p>
<div class="section" id="allhints">
<h3>allhints<a class="headerlink" href="#allhints" title="Permalink to this headline">¶</a></h3>
<dl class="py data">
<dt id="sympy.solvers.ode.allhints">
<code class="sig-prename descclassname">sympy.solvers.ode.</code><code class="sig-name descname">allhints</code><em class="property"> = ('factorable', 'nth_algebraic', 'separable', '1st_exact', '1st_linear', 'Bernoulli', 'Riccati_special_minus2', '1st_homogeneous_coeff_best', '1st_homogeneous_coeff_subs_indep_div_dep', '1st_homogeneous_coeff_subs_dep_div_indep', 'almost_linear', 'linear_coefficients', 'separable_reduced', '1st_power_series', 'lie_group', 'nth_linear_constant_coeff_homogeneous', 'nth_linear_euler_eq_homogeneous', 'nth_linear_constant_coeff_undetermined_coefficients', 'nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients', 'nth_linear_constant_coeff_variation_of_parameters', 'nth_linear_euler_eq_nonhomogeneous_variation_of_parameters', 'Liouville', '2nd_linear_airy', '2nd_linear_bessel', '2nd_hypergeometric', '2nd_hypergeometric_Integral', 'nth_order_reducible', '2nd_power_series_ordinary', '2nd_power_series_regular', 'nth_algebraic_Integral', 'separable_Integral', '1st_exact_Integral', '1st_linear_Integral', 'Bernoulli_Integral', '1st_homogeneous_coeff_subs_indep_div_dep_Integral', '1st_homogeneous_coeff_subs_dep_div_indep_Integral', 'almost_linear_Integral', 'linear_coefficients_Integral', 'separable_reduced_Integral', 'nth_linear_constant_coeff_variation_of_parameters_Integral', 'nth_linear_euler_eq_nonhomogeneous_variation_of_parameters_Integral', 'Liouville_Integral')</em><a class="headerlink" href="#sympy.solvers.ode.allhints" title="Permalink to this definition">¶</a></dt>
<dd><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable’s items.</p>
<p>If the argument is a tuple, the return value is the same object.</p>
</dd></dl>

</div>
<div class="section" id="odesimp">
<h3>odesimp<a class="headerlink" href="#odesimp" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.odesimp">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">odesimp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode</span></em>, <em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">hint</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L2200-L2369"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.odesimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies solutions of ODEs, including trying to solve for <code class="docutils literal notranslate"><span class="pre">func</span></code> and
running <a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code></a>.</p>
<p>It may use knowledge of the type of solution that the hint returns to
apply additional simplifications.</p>
<p>It also attempts to integrate any <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>s
in the expression, if the hint is not an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint.</p>
<p>This function should have no effect on expressions returned by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, as
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> already calls
<a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a>, but the individual hint functions
do not call <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> (because the
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> wrapper does).  Therefore, this
function is designed for mainly internal use.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">odesimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,u2,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">                        x</span>
<span class="go">                       ----</span>
<span class="go">                       f(x)</span>
<span class="go">                         /</span>
<span class="go">                        |</span>
<span class="go">                        |   /        1   \</span>
<span class="go">                        |  -|u2 + -------|</span>
<span class="go">                        |   |        /1 \|</span>
<span class="go">                        |   |     sin|--||</span>
<span class="go">                        |   \        \u2//</span>
<span class="go">log(f(x)) = log(C1) +   |  ---------------- d(u2)</span>
<span class="go">                        |          2</span>
<span class="go">                        |        u2</span>
<span class="go">                        |</span>
<span class="go">                       /</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">odesimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">},</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span>
<span class="gp">... </span><span class="p">))</span> 
<span class="go">    x</span>
<span class="go">--------- = C1</span>
<span class="go">   /f(x)\</span>
<span class="go">tan|----|</span>
<span class="go">   \2*x /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constant-renumber">
<h3>constant_renumber<a class="headerlink" href="#constant-renumber" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.constant_renumber">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">constant_renumber</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">variables</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">newconstants</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L2719-L2840"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.constant_renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Renumber arbitrary constants in <code class="docutils literal notranslate"><span class="pre">expr</span></code> to use the symbol names as given
in <code class="docutils literal notranslate"><span class="pre">newconstants</span></code>. In the process, this reorders expression terms in a
standard way.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">newconstants</span></code> is not provided then the new constant names will be
<code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code> etc. Otherwise <code class="docutils literal notranslate"><span class="pre">newconstants</span></code> should be an iterable
giving the new symbols to use for the constants in order.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">variables</span></code> argument is a list of non-constant symbols. All other
free symbols found in <code class="docutils literal notranslate"><span class="pre">expr</span></code> are assumed to be constants and will be
renumbered. If <code class="docutils literal notranslate"><span class="pre">variables</span></code> is not given then any numbered symbol
beginning with <code class="docutils literal notranslate"><span class="pre">C</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">C1</span></code>) is assumed to be a constant.</p>
<p>Symbols are renumbered based on <code class="docutils literal notranslate"><span class="pre">.sort_key()</span></code>, so they should be
numbered roughly in the order that they appear in the final, printed
expression.  Note that this ordering is based in part on hashes, so it can
produce different results on different machines.</p>
<p>The structure of this function is very similar to that of
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">constant_renumber</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,C1:4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">C1*x**2  + C2*x + C3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="go">C1 + C2*x + C3*x**2</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">variables</span></code> argument specifies which are constants so that the
other symbols will not be renumbered:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="go">C1*x**2  + C2 + C3*x</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">newconstants</span></code> argument is used to specify what symbols to use when
replacing the constants:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">newconstants</span><span class="o">=</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;E1:4&#39;</span><span class="p">))</span>
<span class="go">E1 + E2*x + E3*x**2</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sol-simplicity">
<h3>sol_simplicity<a class="headerlink" href="#sol-simplicity" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_sol_simplicity">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_sol_simplicity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sol</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">trysolving</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L2372-L2493"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_sol_simplicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an extended integer representing how simple a solution to an ODE
is.</p>
<p>The following things are considered, in order from most simple to least:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>, but can be if passed to solve (e.g.,
a solution returned by <code class="docutils literal notranslate"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">simplify=False</span></code>).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>, then base the result on the
length of <code class="docutils literal notranslate"><span class="pre">sol</span></code>, as computed by <code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> has any unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>s,
this will automatically be considered less simple than any of the above.</p></li>
</ul>
<p>This function returns an integer such that if solution A is simpler than
solution B by above metric, then <code class="docutils literal notranslate"><span class="pre">ode_sol_simplicity(sola,</span> <span class="pre">func)</span> <span class="pre">&lt;</span>
<span class="pre">ode_sol_simplicity(solb,</span> <span class="pre">func)</span></code>.</p>
<p>Currently, the following are the numbers returned, but if the heuristic is
ever improved, this may change.  Only the ordering is guaranteed.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 71%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Simplicity</p></th>
<th class="head"><p>Return</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> solved for <code class="docutils literal notranslate"><span class="pre">func</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-2</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code> but can be</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved nor solvable for
<code class="docutils literal notranslate"><span class="pre">func</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> contains an
<a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integral</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">oo</span></code></p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">oo</span></code> here means the SymPy infinity, which should compare greater than
any integer.</p>
<p>If you already know <a class="reference internal" href="solvers.html#sympy.solvers.solvers.solve" title="sympy.solvers.solvers.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a> cannot solve
<code class="docutils literal notranslate"><span class="pre">sol</span></code>, you can use <code class="docutils literal notranslate"><span class="pre">trysolving=False</span></code> to skip that step, which is the
only potentially slow step.  For example,
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">simplify=False</span></code> flag
should do this.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> is a list of solutions, if the worst solution in the list
returns <code class="docutils literal notranslate"><span class="pre">oo</span></code> it returns that, otherwise it returns <code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code>,
that is, the length of the string representation of the whole list.</p>
<p class="rubric">Examples</p>
<p>This function is designed to be passed to <code class="docutils literal notranslate"><span class="pre">min</span></code> as the key argument,
such as <code class="docutils literal notranslate"><span class="pre">min(listofsolutions,</span> <span class="pre">key=lambda</span> <span class="pre">i:</span> <span class="pre">ode_sol_simplicity(i,</span>
<span class="pre">f(x)))</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">ode_sol_simplicity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, C1, C2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">C2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">]]</span>
<span class="go">[28, 35]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">Eq(f(x)/tan(f(x)/(2*x)), C1)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="factorable">
<h3>factorable<a class="headerlink" href="#factorable" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="sympy.solvers.ode.single.Factorable">
<em class="property">class </em><code class="sig-prename descclassname">sympy.solvers.ode.single.</code><code class="sig-name descname">Factorable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode_problem</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/single.py#L645-L717"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.single.Factorable" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves equations having a solvable factor.</p>
<p>This function is used to solve the equation having factors. Factors may be of type algebraic or ode. It
will try to solve each factor independently. Factors will be solved by calling dsolve. We will return the
list of solutions.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">                                -x</span>
<span class="go">[f(x) = 2, f(x) = -2, f(x) = C1*e  ]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-exact">
<h3>1st_exact<a class="headerlink" href="#st-exact" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_1st_exact">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_1st_exact</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L2872-L2940"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_1st_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order exact ordinary differential equations.</p>
<p>A 1st order differential equation is called exact if it is the total
differential of a function. That is, the differential equation</p>
<div class="math notranslate nohighlight">
\[P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0\]</div>
<p>is exact if there is some function <span class="math notranslate nohighlight">\(F(x, y)\)</span> such that <span class="math notranslate nohighlight">\(P(x, y) =
\partial{}F/\partial{}x\)</span> and <span class="math notranslate nohighlight">\(Q(x, y) = \partial{}F/\partial{}y\)</span>.  It can
be shown that a necessary and sufficient condition for a first order ODE
to be exact is that <span class="math notranslate nohighlight">\(\partial{}P/\partial{}y = \partial{}Q/\partial{}x\)</span>.
Then, the solution will be as given below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y,t,x0,y0,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Integral</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">Integral</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">))),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">            x                y</span>
<span class="go">            /                /</span>
<span class="go">           |                |</span>
<span class="go">F(x, y) =  |  P(t, y) dt +  |  Q(x0, t) dt = C1</span>
<span class="go">           |                |</span>
<span class="go">          /                /</span>
<span class="go">          x0               y0</span>
</pre></div>
</div>
<p>Where the first partials of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> exist and are continuous in a
simply connected region.</p>
<p>A note: SymPy currently has no way to represent inert substitution on an
expression, so the hint <code class="docutils literal notranslate"><span class="pre">1st_exact_Integral</span></code> will return an integral
with <span class="math notranslate nohighlight">\(dy\)</span>.  This is supposed to represent the function that you are
solving for.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">Eq(x*cos(f(x)) + f(x)**3/3, C1)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Exact_differential_equation">https://en.wikipedia.org/wiki/Exact_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 73</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-best">
<h3>1st_homogeneous_coeff_best<a class="headerlink" href="#st-homogeneous-coeff-best" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_1st_homogeneous_coeff_best</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L2943-L2997"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the best solution to an ODE from the two hints
<code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></code> and
<code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></code>.</p>
<p>This is as determined by <a class="reference internal" href="#sympy.solvers.ode.ode.ode_sol_simplicity" title="sympy.solvers.ode.ode.ode_sol_simplicity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_sol_simplicity()</span></code></a>.</p>
<p>See the
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code></a>
and
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code></a>
docstrings for more information on these hints.  Note that there is no
<code class="docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best_Integral</span></code> hint.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_best&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Homogeneous_differential_equation">https://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-subs-dep-div-indep">
<h3>1st_homogeneous_coeff_subs_dep_div_indep<a class="headerlink" href="#st-homogeneous-coeff-subs-dep-div-indep" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_1st_homogeneous_coeff_subs_dep_div_indep</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3000-L3090"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <span class="math notranslate nohighlight">\(u_1 = \frac{\text{&lt;dependent
variable&gt;}}{\text{&lt;independent variable&gt;}}\)</span>.</p>
<p>This is a differential equation</p>
<div class="math notranslate nohighlight">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
<p>such that <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> are homogeneous and of the same order.  A function
<span class="math notranslate nohighlight">\(F(x, y)\)</span> is homogeneous of order <span class="math notranslate nohighlight">\(n\)</span> if <span class="math notranslate nohighlight">\(F(x t, y t) = t^n F(x, y)\)</span>.
Equivalently, <span class="math notranslate nohighlight">\(F(x, y)\)</span> can be rewritten as <span class="math notranslate nohighlight">\(G(y/x)\)</span> or <span class="math notranslate nohighlight">\(H(x/y)\)</span>.  See
also the docstring of <a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code></a>.</p>
<p>If the coefficients <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <span class="math notranslate nohighlight">\(y = u_1 x\)</span> (i.e. <span class="math notranslate nohighlight">\(u_1 = y/x\)</span>) will turn the differential
equation into an equation separable in the variables <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(u\)</span>.  If
<span class="math notranslate nohighlight">\(h(u_1)\)</span> is the function that results from making the substitution <span class="math notranslate nohighlight">\(u_1 =
f(x)/x\)</span> on <span class="math notranslate nohighlight">\(P(x, f(x))\)</span> and <span class="math notranslate nohighlight">\(g(u_2)\)</span> is the function that results from the
substitution on <span class="math notranslate nohighlight">\(Q(x, f(x))\)</span> in the differential equation <span class="math notranslate nohighlight">\(P(x, f(x)) +
Q(x, f(x)) f'(x) = 0\)</span>, then the general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> /f(x)\    /f(x)\ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \ x  /    \ x  / dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;</span><span class="p">))</span>
<span class="go">               f(x)</span>
<span class="go">               ----</span>
<span class="go">                x</span>
<span class="go">                 /</span>
<span class="go">                |</span>
<span class="go">                |       -h(u1)</span>
<span class="go">log(x) = C1 +   |  ---------------- d(u1)</span>
<span class="go">                |  u1*h(u1) + g(u1)</span>
<span class="go">                |</span>
<span class="go">               /</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(u_1 h(u_1) + g(u_1) \ne 0\)</span> and <span class="math notranslate nohighlight">\(x \ne 0\)</span>.</p>
<p>See also the docstrings of
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code></a> and
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                      /          3   \</span>
<span class="go">                      |3*f(x)   f (x)|</span>
<span class="go">                   log|------ + -----|</span>
<span class="go">                      |  x         3 |</span>
<span class="go">                      \           x  /</span>
<span class="go">log(x) = log(C1) - -------------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Homogeneous_differential_equation">https://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-subs-indep-div-dep">
<h3>1st_homogeneous_coeff_subs_indep_div_dep<a class="headerlink" href="#st-homogeneous-coeff-subs-indep-div-dep" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_1st_homogeneous_coeff_subs_indep_div_dep</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3093-L3187"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <span class="math notranslate nohighlight">\(u_2 = \frac{\text{&lt;independent
variable&gt;}}{\text{&lt;dependent variable&gt;}}\)</span>.</p>
<p>This is a differential equation</p>
<div class="math notranslate nohighlight">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
<p>such that <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> are homogeneous and of the same order.  A function
<span class="math notranslate nohighlight">\(F(x, y)\)</span> is homogeneous of order <span class="math notranslate nohighlight">\(n\)</span> if <span class="math notranslate nohighlight">\(F(x t, y t) = t^n F(x, y)\)</span>.
Equivalently, <span class="math notranslate nohighlight">\(F(x, y)\)</span> can be rewritten as <span class="math notranslate nohighlight">\(G(y/x)\)</span> or <span class="math notranslate nohighlight">\(H(x/y)\)</span>.  See
also the docstring of <a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code></a>.</p>
<p>If the coefficients <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <span class="math notranslate nohighlight">\(x = u_2 y\)</span> (i.e. <span class="math notranslate nohighlight">\(u_2 = x/y\)</span>) will turn the differential
equation into an equation separable in the variables <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(u_2\)</span>.  If
<span class="math notranslate nohighlight">\(h(u_2)\)</span> is the function that results from making the substitution <span class="math notranslate nohighlight">\(u_2 =
x/f(x)\)</span> on <span class="math notranslate nohighlight">\(P(x, f(x))\)</span> and <span class="math notranslate nohighlight">\(g(u_2)\)</span> is the function that results from the
substitution on <span class="math notranslate nohighlight">\(Q(x, f(x))\)</span> in the differential equation <span class="math notranslate nohighlight">\(P(x, f(x)) +
Q(x, f(x)) f'(x) = 0\)</span>, then the general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> / x  \    / x  \ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \f(x)/    \f(x)/ dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">))</span>
<span class="go">             x</span>
<span class="go">            ----</span>
<span class="go">            f(x)</span>
<span class="go">              /</span>
<span class="go">             |</span>
<span class="go">             |       -g(u2)</span>
<span class="go">             |  ---------------- d(u2)</span>
<span class="go">             |  u2*g(u2) + h(u2)</span>
<span class="go">             |</span>
<span class="go">            /</span>

<span class="go">f(x) = C1*e</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(u_2 g(u_2) + h(u_2) \ne 0\)</span> and <span class="math notranslate nohighlight">\(f(x) \ne 0\)</span>.</p>
<p>See also the docstrings of
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code></a> and
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Homogeneous_differential_equation">https://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="st-linear">
<h3>1st_linear<a class="headerlink" href="#st-linear" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="sympy.solvers.ode.single.FirstLinear">
<em class="property">class </em><code class="sig-prename descclassname">sympy.solvers.ode.single.</code><code class="sig-name descname">FirstLinear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode_problem</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/single.py#L377-L448"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.single.FirstLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order linear differential equations.</p>
<p>These are differential equations of the form</p>
<div class="math notranslate nohighlight">
\[dy/dx + P(x) y = Q(x)\text{.}\]</div>
<p>These kinds of differential equations can be solved in a general way.  The
integrating factor <span class="math notranslate nohighlight">\(e^{\int P(x) \,dx}\)</span> will turn the equation into a
separable equation.  The general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_linear_Integral&#39;</span><span class="p">))</span>
<span class="go">        /       /                   \</span>
<span class="go">        |      |                    |</span>
<span class="go">        |      |         /          |     /</span>
<span class="go">        |      |        |           |    |</span>
<span class="go">        |      |        | P(x) dx   |  - | P(x) dx</span>
<span class="go">        |      |        |           |    |</span>
<span class="go">        |      |       /            |   /</span>
<span class="go">f(x) = |C1 +  | Q(x)*e           dx|*e</span>
<span class="go">        |      |                    |</span>
<span class="go">        \     /                     /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;1st_linear&#39;</span><span class="p">))</span>
<span class="go">f(x) = x*(C1 - cos(x))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation">https://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 92</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="nd-linear-airy">
<h3>2nd_linear_airy<a class="headerlink" href="#nd-linear-airy" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_2nd_linear_airy">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_2nd_linear_airy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3500-L3529"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_2nd_linear_airy" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives solution of the Airy differential equation</p>
<div class="math notranslate nohighlight">
\[\frac{d^2y}{dx^2} + (a + b x) y(x) = 0\]</div>
<p>in terms of Airy special functions airyai and airybi.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">Eq(f(x), C1*airyai(x) + C2*airybi(x))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nd-linear-bessel">
<h3>2nd_linear_bessel<a class="headerlink" href="#nd-linear-bessel" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_2nd_linear_bessel">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_2nd_linear_bessel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3654-L3696"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_2nd_linear_bessel" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives solution of the Bessel differential equation</p>
<div class="math notranslate nohighlight">
\[x^2 \frac{d^2y}{dx^2} + x \frac{dy}{dx} y(x) + (x^2-n^2) y(x)\]</div>
<p>if n is integer then the solution is of the form Eq(f(x), C0 besselj(n,x)
+ C1 bessely(n,x)) as both the solutions are linearly independent else if
n is a fraction then the solution is of the form Eq(f(x), C0 besselj(n,x)
+ C1 besselj(-n,x)) which can also transform into Eq(f(x), C0 besselj(n,x)
+ C1 bessely(n,x)).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">Eq(f(x), C1*besselj(v, x) + C2*bessely(v, x))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p><a class="reference external" href="https://www.math24.net/bessel-differential-equation/">https://www.math24.net/bessel-differential-equation/</a></p>
</dd></dl>

</div>
<div class="section" id="bernoulli">
<h3>Bernoulli<a class="headerlink" href="#bernoulli" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="sympy.solvers.ode.single.Bernoulli">
<em class="property">class </em><code class="sig-prename descclassname">sympy.solvers.ode.single.</code><code class="sig-name descname">Bernoulli</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode_problem</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/single.py#L538-L642"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.single.Bernoulli" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves Bernoulli differential equations.</p>
<p>These are equations of the form</p>
<div class="math notranslate nohighlight">
\[dy/dx + P(x) y = Q(x) y^n\text{, }n \ne 1`\text{.}\]</div>
<p>The substitution <span class="math notranslate nohighlight">\(w = 1/y^{1-n}\)</span> will transform an equation of this form
into one that is linear (see the docstring of
<a class="reference internal" href="#sympy.solvers.ode.single.FirstLinear" title="sympy.solvers.ode.single.FirstLinear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">FirstLinear()</span></code></a>).  The general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d                n</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)*f (x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Bernoulli_Integral&#39;</span><span class="p">),</span> <span class="n">num_columns</span><span class="o">=</span><span class="mi">110</span><span class="p">)</span>
<span class="go">                                                                                                      -1</span>
<span class="go">                                                                                                     -----</span>
<span class="go">                                                                                                     n - 1</span>
<span class="go">       //         /                                /                           \                    \</span>
<span class="go">       ||        |                                |                            |                    |</span>
<span class="go">       ||        |                 /              |                 /          |            /       |</span>
<span class="go">       ||        |                |               |                |           |           |        |</span>
<span class="go">       ||        |       (1 - n)* | P(x) dx       |       (1 - n)* | P(x) dx   |  (n - 1)* | P(x) dx|</span>
<span class="go">       ||        |                |               |                |           |           |        |</span>
<span class="go">       ||        |               /                |               /            |          /         |</span>
<span class="go">f(x) = ||C1 - n* | Q(x)*e                   dx +  | Q(x)*e                   dx|*e                  |</span>
<span class="go">       ||        |                                |                            |                    |</span>
<span class="go">       \\       /                                /                             /                    /</span>
</pre></div>
</div>
<p>Note that the equation is separable when <span class="math notranslate nohighlight">\(n = 1\)</span> (see the docstring of
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_separable" title="sympy.solvers.ode.ode.ode_separable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_separable()</span></code></a>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go">f(x)</span>
<span class="go">    /</span>
<span class="go">|                /</span>
<span class="go">|  1            |</span>
<span class="go">|  - dy = C1 +  | (-P(x) + Q(x)) dx</span>
<span class="go">|  y            |</span>
<span class="go">|              /</span>
<span class="go">/</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Bernoulli&#39;</span><span class="p">))</span>
<span class="go">                1</span>
<span class="go">f(x) =  -----------------</span>
<span class="go">        C1*x + log(x) + 1</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Bernoulli_differential_equation">https://en.wikipedia.org/wiki/Bernoulli_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 95</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="liouville">
<h3>Liouville<a class="headerlink" href="#liouville" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_Liouville">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_Liouville</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3283-L3352"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_Liouville" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 2nd order Liouville differential equations.</p>
<p>The general form of a Liouville ODE is</p>
<div class="math notranslate nohighlight">
\[\frac{d^2 y}{dx^2} + g(y) \left(\!
\frac{dy}{dx}\!\right)^2 + h(x)
\frac{dy}{dx}\text{.}\]</div>
<p>The general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                  2                    2</span>
<span class="go">        /d       \         d          d</span>
<span class="go">g(f(x))*|--(f(x))|  + h(x)*--(f(x)) + ---(f(x)) = 0</span>
<span class="go">        \dx      /         dx           2</span>
<span class="go">                                      dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Liouville_Integral&#39;</span><span class="p">))</span>
<span class="go">                                  f(x)</span>
<span class="go">          /                     /</span>
<span class="go">         |                     |</span>
<span class="go">         |     /               |     /</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |  - | h(x) dx        |    | g(y) dy</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |   /                 |   /</span>
<span class="go">C1 + C2* | e            dx +   |  e           dy = 0</span>
<span class="go">         |                     |</span>
<span class="go">        /                     /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Liouville&#39;</span><span class="p">))</span>
<span class="go">           ________________           ________________</span>
<span class="go">[f(x) = -\/ C1 + C2*log(x) , f(x) = \/ C1 + C2*log(x) ]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Goldstein and Braun, “Advanced Methods for the Solution of Differential
Equations”, pp. 98</p></li>
<li><p><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville</a></p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="riccati-special-minus2">
<h3>Riccati_special_minus2<a class="headerlink" href="#riccati-special-minus2" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="sympy.solvers.ode.single.RiccatiSpecial">
<em class="property">class </em><code class="sig-prename descclassname">sympy.solvers.ode.single.</code><code class="sig-name descname">RiccatiSpecial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode_problem</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/single.py#L720-L782"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.single.RiccatiSpecial" title="Permalink to this definition">¶</a></dt>
<dd><p>The general Riccati equation has the form</p>
<div class="math notranslate nohighlight">
\[dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}\]</div>
<p>While it does not have a general solution [1], the “special” form, <span class="math notranslate nohighlight">\(dy/dx
= a y^2 - b x^c\)</span>, does have solutions in many cases [2].  This routine
returns a solution for <span class="math notranslate nohighlight">\(a(dy/dx) = b y^2 + c y/x + d/x^2\)</span> that is obtained
by using a suitable change of variables to reduce it to the special form
and is valid when neither <span class="math notranslate nohighlight">\(a\)</span> nor <span class="math notranslate nohighlight">\(b\)</span> are zero and either <span class="math notranslate nohighlight">\(c\)</span> or <span class="math notranslate nohighlight">\(d\)</span> is
zero.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">checkodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">        /                                 /        __________________       \\</span>
<span class="go">        |           __________________    |       /                2        ||</span>
<span class="go">        |          /                2     |     \/  4*b*d - (a + c)  *log(x)||</span>
<span class="go">       -|a + c - \/  4*b*d - (a + c)  *tan|C1 + ----------------------------||</span>
<span class="go">        \                                 \                 2*a             //</span>
<span class="go">f(x) = ------------------------------------------------------------------------</span>
<span class="go">                                        2*b*x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati</a></p></li>
<li><p><a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf</a> -
<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf</a></p></li>
</ol>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-homogeneous">
<h3>nth_linear_constant_coeff_homogeneous<a class="headerlink" href="#nth-linear-constant-coeff-homogeneous" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_nth_linear_constant_coeff_homogeneous">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_nth_linear_constant_coeff_homogeneous</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">returns</span><span class="o">=</span><span class="default_value">'sol'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L4553-L4709"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_nth_linear_constant_coeff_homogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear homogeneous differential equation with
constant coefficients.</p>
<p>This is an equation of the form</p>
<div class="math notranslate nohighlight">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = 0\text{.}\]</div>
<p>These equations can be solved in a general manner, by taking the roots of
the characteristic equation <span class="math notranslate nohighlight">\(a_n m^n + a_{n-1} m^{n-1} + \cdots + a_1 m +
a_0 = 0\)</span>.  The solution will then be the sum of <span class="math notranslate nohighlight">\(C_n x^i e^{r x}\)</span> terms,
for each where <span class="math notranslate nohighlight">\(C_n\)</span> is an arbitrary constant, <span class="math notranslate nohighlight">\(r\)</span> is a root of the
characteristic equation and <span class="math notranslate nohighlight">\(i\)</span> is one of each from 0 to the multiplicity
of the root - 1 (for example, a root 3 of multiplicity 2 would create the
terms <span class="math notranslate nohighlight">\(C_1 e^{3 x} + C_2 x e^{3 x}\)</span>).  The exponential is usually expanded
for complex roots using Euler’s equation <span class="math notranslate nohighlight">\(e^{I x} = \cos(x) + I \sin(x)\)</span>.
Complex roots always come in conjugate pairs in polynomials with real
coefficients, so the two roots will be represented (after simplifying the
constants) as <span class="math notranslate nohighlight">\(e^{a x} \left(C_1 \cos(b x) + C_2 \sin(b x)\right)\)</span>.</p>
<p>If SymPy cannot find exact roots to the characteristic equation, a
<a class="reference internal" href="../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf" title="sympy.polys.rootoftools.ComplexRootOf"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComplexRootOf</span></code></a> instance will be return
instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">Eq(f(x), C5*exp(x*CRootOf(_x**5 + 10*_x - 2, 0))</span>
<span class="go">+ (C1*sin(x*im(CRootOf(_x**5 + 10*_x - 2, 1)))</span>
<span class="go">+ C2*cos(x*im(CRootOf(_x**5 + 10*_x - 2, 1))))*exp(x*re(CRootOf(_x**5 + 10*_x - 2, 1)))</span>
<span class="go">+ (C3*sin(x*im(CRootOf(_x**5 + 10*_x - 2, 3)))</span>
<span class="go">+ C4*cos(x*im(CRootOf(_x**5 + 10*_x - 2, 3))))*exp(x*re(CRootOf(_x**5 + 10*_x - 2, 3))))</span>
</pre></div>
</div>
<p>Note that because this method does not involve integration, there is no
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_homogeneous_Integral</span></code> hint.</p>
<p>The following is for internal use:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'sol'</span></code> returns the solution to the ODE.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'list'</span></code> returns a list of linearly independent solutions,
for use with non homogeneous solution methods like variation of
parameters and undetermined coefficients.  Note that, though the
solutions should be linearly independent, this function does not
explicitly check that.  You can do <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">simplify(wronskian(sollist))</span>
<span class="pre">!=</span> <span class="pre">0</span></code> to check for linear independence.  Also, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">len(sollist)</span> <span class="pre">==</span>
<span class="pre">order</span></code> will need to pass.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'both'</span></code>, return a dictionary <code class="docutils literal notranslate"><span class="pre">{'sol':</span> <span class="pre">&lt;solution</span> <span class="pre">to</span> <span class="pre">ODE&gt;,</span>
<span class="pre">'list':</span> <span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">linearly</span> <span class="pre">independent</span> <span class="pre">solutions&gt;}</span></code>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">))</span>
<span class="go">                    x                            -2*x</span>
<span class="go">f(x) = (C1 + C2*x)*e  + (C3*sin(x) + C4*cos(x))*e</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Linear_differential_equation">https://en.wikipedia.org/wiki/Linear_differential_equation</a> section:
Nonhomogeneous_equation_with_constant_coefficients</p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 211</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-undetermined-coefficients">
<h3>nth_linear_constant_coeff_undetermined_coefficients<a class="headerlink" href="#nth-linear-constant-coeff-undetermined-coefficients" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_nth_linear_constant_coeff_undetermined_coefficients">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_nth_linear_constant_coeff_undetermined_coefficients</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L4712-L4772"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_nth_linear_constant_coeff_undetermined_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear differential equation with constant
coefficients using the method of undetermined coefficients.</p>
<p>This method works on differential equations of the form</p>
<div class="math notranslate nohighlight">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = P(x)\text{,}\]</div>
<p>where <span class="math notranslate nohighlight">\(P(x)\)</span> is a function that has a finite number of linearly
independent derivatives.</p>
<p>Functions that fit this requirement are finite sums functions of the form
<span class="math notranslate nohighlight">\(a x^i e^{b x} \sin(c x + d)\)</span> or <span class="math notranslate nohighlight">\(a x^i e^{b x} \cos(c x + d)\)</span>, where <span class="math notranslate nohighlight">\(i\)</span>
is a non-negative integer and <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> are constants.  For
example any polynomial in <span class="math notranslate nohighlight">\(x\)</span>, functions like <span class="math notranslate nohighlight">\(x^2 e^{2 x}\)</span>, <span class="math notranslate nohighlight">\(x \sin(x)\)</span>,
and <span class="math notranslate nohighlight">\(e^x \cos(x)\)</span> can all be used.  Products of <span class="math notranslate nohighlight">\(\sin\)</span>’s and <span class="math notranslate nohighlight">\(\cos\)</span>’s have
a finite number of derivatives, because they can be expanded into <span class="math notranslate nohighlight">\(\sin(a
x)\)</span> and <span class="math notranslate nohighlight">\(\cos(b x)\)</span> terms.  However, SymPy currently cannot do that
expansion, so you will need to manually rewrite the expression in terms of
the above to use this method.  So, for example, you will need to manually
convert <span class="math notranslate nohighlight">\(\sin^2(x)\)</span> into <span class="math notranslate nohighlight">\((1 + \cos(2 x))/2\)</span> to properly apply the method
of undetermined coefficients on it.</p>
<p>This method works by creating a trial function from the expression and all
of its linear independent derivatives and substituting them into the
original ODE.  The coefficients for each term will be a system of linear
equations, which are be solved for and substituted, giving the solution.
If any of the trial functions are linearly dependent on the solution to
the homogeneous equation, they are multiplied by sufficient <span class="math notranslate nohighlight">\(x\)</span> to make
them linearly independent.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">4</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;</span><span class="p">))</span>
<span class="go">       /       /      3\\</span>
<span class="go">       |       |     x ||  -x   4*sin(2*x)   3*cos(2*x)</span>
<span class="go">f(x) = |C1 + x*|C2 + --||*e   - ---------- + ----------</span>
<span class="go">       \       \     3 //           25           25</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients">https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 221</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-variation-of-parameters">
<h3>nth_linear_constant_coeff_variation_of_parameters<a class="headerlink" href="#nth-linear-constant-coeff-variation-of-parameters" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_nth_linear_constant_coeff_variation_of_parameters">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_nth_linear_constant_coeff_variation_of_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5004-L5077"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_nth_linear_constant_coeff_variation_of_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear differential equation with constant
coefficients using the method of variation of parameters.</p>
<p>This method works on any differential equations of the form</p>
<div class="math notranslate nohighlight">
\[f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0
f(x) = P(x)\text{.}\]</div>
<p>This method works by assuming that the particular solution takes the form</p>
<div class="math notranslate nohighlight">
\[\sum_{x=1}^{n} c_i(x) y_i(x)\text{,}\]</div>
<p>where <span class="math notranslate nohighlight">\(y_i\)</span> is the <span class="math notranslate nohighlight">\(i\)</span>th solution to the homogeneous equation.  The
solution is then solved using Wronskian’s and Cramer’s Rule.  The
particular solution is given by</p>
<div class="math notranslate nohighlight">
\[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx
\right) y_i(x) \text{,}\]</div>
<p>where <span class="math notranslate nohighlight">\(W(x)\)</span> is the Wronskian of the fundamental system (the system of <span class="math notranslate nohighlight">\(n\)</span>
linearly independent solutions to the homogeneous equation), and <span class="math notranslate nohighlight">\(W_i(x)\)</span>
is the Wronskian of the fundamental system with the <span class="math notranslate nohighlight">\(i\)</span>th column replaced
with <span class="math notranslate nohighlight">\([0, 0, \cdots, 0, P(x)]\)</span>.</p>
<p>This method is general enough to solve any <span class="math notranslate nohighlight">\(n\)</span>th order inhomogeneous
linear differential equation with constant coefficients, but sometimes
SymPy cannot simplify the Wronskian well enough to integrate it.  If this
method hangs, try using the
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_variation_of_parameters_Integral</span></code> hint and
simplifying the integrals manually.  Also, prefer using
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></code> when it
applies, because it doesn’t use integration, making it faster and more
reliable.</p>
<p>Warning, using simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters’ in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> may cause it to hang, because it will
not attempt to simplify the Wronskian before integrating.  It is
recommended that you only use simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters_Integral’ for this
method, especially if the solution to the homogeneous equation has
trigonometric functions in it.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;</span><span class="p">))</span>
<span class="go">       /       /       /     x*log(x)   11*x\\\  x</span>
<span class="go">f(x) = |C1 + x*|C2 + x*|C3 + -------- - ----|||*e</span>
<span class="go">       \       \       \        6        36 ///</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Variation_of_parameters">https://en.wikipedia.org/wiki/Variation_of_parameters</a></p></li>
<li><p><a class="reference external" href="http://planetmath.org/VariationOfParameters">http://planetmath.org/VariationOfParameters</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 233</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="nth-algebraic">
<h3>nth_algebraic<a class="headerlink" href="#nth-algebraic" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="sympy.solvers.ode.single.NthAlgebraic">
<em class="property">class </em><code class="sig-prename descclassname">sympy.solvers.ode.single.</code><code class="sig-name descname">NthAlgebraic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode_problem</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/single.py#L275-L374"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthAlgebraic" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order ordinary differential equation using algebra and
integrals.</p>
<p>There is no general form for the kind of equation that this can solve. The
the equation is solved algebraically treating differentiation as an
invertible algebraic function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_algebraic&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), 0), Eq(f(x), C1 - x), Eq(f(x), C1 + x)]</span>
</pre></div>
</div>
<p>Note that this solver can return algebraic solutions that do not have any
integration constants (f(x) = 0 in the above example).</p>
</dd></dl>

</div>
<div class="section" id="nth-order-reducible">
<h3>nth_order_reducible<a class="headerlink" href="#nth-order-reducible" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_nth_order_reducible">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_nth_order_reducible</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3771-L3821"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_nth_order_reducible" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves ODEs that only involve derivatives of the dependent variable using
a substitution of the form <span class="math notranslate nohighlight">\(f^n(x) = g(x)\)</span>.</p>
<p>For example any second order ODE of the form <span class="math notranslate nohighlight">\(f''(x) = h(f'(x), x)\)</span> can be
transformed into a pair of 1st order ODEs <span class="math notranslate nohighlight">\(g'(x) = h(g(x), x)\)</span> and
<span class="math notranslate nohighlight">\(f'(x) = g(x)\)</span>. Usually the 1st order ODE for <span class="math notranslate nohighlight">\(g\)</span> is easier to solve. If
that gives an explicit solution for <span class="math notranslate nohighlight">\(g\)</span> then <span class="math notranslate nohighlight">\(f\)</span> is found simply by
integration.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_order_reducible&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">Eq(f(x), C1 - sqrt(-1/C2)*log(-C2*sqrt(-1/C2) + x) + sqrt(-1/C2)*log(C2*sqrt(-1/C2) + x))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="separable">
<h3>separable<a class="headerlink" href="#separable" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_separable">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_separable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5137-L5199"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_separable" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves separable 1st order differential equations.</p>
<p>This is any differential equation that can be written as <span class="math notranslate nohighlight">\(P(y)
\tfrac{dy}{dx} = Q(x)\)</span>.  The solution can then just be found by
rearranging terms and integrating: <span class="math notranslate nohighlight">\(\int P(y) \,dy = \int Q(x) \,dx\)</span>.
This hint uses <a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.separatevars" title="sympy.simplify.simplify.separatevars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.simplify.simplify.separatevars()</span></code></a> as its back
end, so if a separable equation is not caught by this solver, it is most
likely the fault of that function.
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.separatevars" title="sympy.simplify.simplify.separatevars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">separatevars()</span></code></a> is
smart enough to do most expansion and factoring necessary to convert a
separable equation <span class="math notranslate nohighlight">\(F(x, y)\)</span> into the proper form <span class="math notranslate nohighlight">\(P(x)\cdot{}Q(y)\)</span>.  The
general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">             d</span>
<span class="go">a(x)*b(f(x))*--(f(x)) = c(x)*d(f(x))</span>
<span class="go">             dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go">     f(x)</span>
<span class="go">   /                  /</span>
<span class="go">  |                  |</span>
<span class="go">  |  b(y)            | c(x)</span>
<span class="go">  |  ---- dy = C1 +  | ---- dx</span>
<span class="go">  |  d(y)            | a(x)</span>
<span class="go">  |                  |</span>
<span class="go"> /                  /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">   /   2       \         2</span>
<span class="go">log\3*f (x) - 1/        x</span>
<span class="go">---------------- = C1 + --</span>
<span class="go">       6                2</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 52</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

</div>
<div class="section" id="almost-linear">
<h3>almost_linear<a class="headerlink" href="#almost-linear" title="Permalink to this headline">¶</a></h3>
<dl class="py class">
<dt id="sympy.solvers.ode.single.AlmostLinear">
<em class="property">class </em><code class="sig-prename descclassname">sympy.solvers.ode.single.</code><code class="sig-name descname">AlmostLinear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ode_problem</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/single.py#L451-L535"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.single.AlmostLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an almost-linear differential equation.</p>
<p>The general form of an almost linear differential equation is</p>
<div class="math notranslate nohighlight">
\[a(x) g'(f(x)) f'(x) + b(x) g(f(x)) + c(x)\]</div>
<p>Here <span class="math notranslate nohighlight">\(f(x)\)</span> is the function to be solved for (the dependent variable).
The substitution <span class="math notranslate nohighlight">\(g(f(x)) = u(x)\)</span> leads to a linear differential equation
for <span class="math notranslate nohighlight">\(u(x)\)</span> of the form <span class="math notranslate nohighlight">\(a(x) u' + b(x) u + c(x) = 0\)</span>. This can be solved
for <span class="math notranslate nohighlight">\(u(x)\)</span> by the <span class="math notranslate nohighlight">\(first_linear\)</span> hint and then <span class="math notranslate nohighlight">\(f(x)\)</span> is found by solving
<span class="math notranslate nohighlight">\(g(f(x)) = u(x)\)</span>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">Eq(f(x), (C1 - Ei(x))*exp(-x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">                    -x</span>
<span class="go">f(x) = (C1 - Ei(x))*e</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="go">                    d</span>
<span class="go">sin(f(x)) + cos(f(x))*--(f(x)) + 1</span>
<span class="go">                    dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">                /    -x    \             /    -x    \</span>
<span class="go">[f(x) = pi - asin\C1*e   - 1/, f(x) = asin\C1*e   - 1/]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.ode.single.FirstLinear" title="sympy.solvers.ode.single.FirstLinear"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.single.FirstLinear()</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="linear-coefficients">
<h3>linear_coefficients<a class="headerlink" href="#linear-coefficients" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_linear_coefficients">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_linear_coefficients</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L4347-L4399"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_linear_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a differential equation with linear coefficients.</p>
<p>The general form of a differential equation with linear coefficients is</p>
<div class="math notranslate nohighlight">
\[y' + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y +
c_2}\!\right) = 0\text{,}\]</div>
<p>where <span class="math notranslate nohighlight">\(a_1\)</span>, <span class="math notranslate nohighlight">\(b_1\)</span>, <span class="math notranslate nohighlight">\(c_1\)</span>, <span class="math notranslate nohighlight">\(a_2\)</span>, <span class="math notranslate nohighlight">\(b_2\)</span>, <span class="math notranslate nohighlight">\(c_2\)</span> are constants and <span class="math notranslate nohighlight">\(a_1 b_2
- a_2 b_1 \ne 0\)</span>.</p>
<p>This can be solved by substituting:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x = x' + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1 b_2}\\y = y' + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1
    b_2}\text{.}\end{aligned}\end{align} \]</div>
<p>This substitution reduces the equation to a homogeneous differential
equation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;linear_coefficients&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -x - sqrt(C1 + 7*x**2) - 1), Eq(f(x), -x + sqrt(C1 + 7*x**2) - 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;linear_coefficients&#39;</span><span class="p">))</span>
<span class="go">                  ___________                     ___________</span>
<span class="go">               /         2                     /         2</span>
<span class="go">[f(x) = -x - \/  C1 + 7*x   - 1, f(x) = -x + \/  C1 + 7*x   - 1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best()</span></code></a>, <a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code></a>, <a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="separable-reduced">
<h3>separable_reduced<a class="headerlink" href="#separable-reduced" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_separable_reduced">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_separable_reduced</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L4402-L4475"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_separable_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a differential equation that can be reduced to the separable form.</p>
<p>The general form of this equation is</p>
<div class="math notranslate nohighlight">
\[y' + (y/x) H(x^n y) = 0\text{}.\]</div>
<p>This can be solved by substituting <span class="math notranslate nohighlight">\(u(y) = x^n y\)</span>.  The equation then
reduces to the separable form <span class="math notranslate nohighlight">\(\frac{u'}{u (\mathrm{power} - H(u))} -
\frac{1}{x} = 0\)</span>.</p>
<p>The general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                 / n     \</span>
<span class="go">d          f(x)*g\x *f(x)/</span>
<span class="go">--(f(x)) + ---------------</span>
<span class="go">dx                x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go"> n</span>
<span class="go">x *f(x)</span>
<span class="go">  /</span>
<span class="go"> |</span>
<span class="go"> |         1</span>
<span class="go"> |    ------------ dy = C1 + log(x)</span>
<span class="go"> |    y*(n - g(y))</span>
<span class="go"> |</span>
<span class="go"> /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), (1 - sqrt(C1*x**2 + 1))/x), Eq(f(x), (sqrt(C1*x**2 + 1) + 1)/x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go">               ___________            ___________</span>
<span class="go">              /     2                /     2</span>
<span class="go">        1 - \/  C1*x  + 1          \/  C1*x  + 1  + 1</span>
<span class="go">[f(x) = ------------------, f(x) = ------------------]</span>
<span class="go">                x                          x</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.ode.ode.ode_separable" title="sympy.solvers.ode.ode.ode_separable"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.ode.ode_separable()</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="lie-group">
<h3>lie_group<a class="headerlink" href="#lie-group" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_lie_group">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_lie_group</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5385-L5452"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_lie_group" title="Permalink to this definition">¶</a></dt>
<dd><p>This hint implements the Lie group method of solving first order differential
equations. The aim is to convert the given differential equation from the
given coordinate system into another coordinate system where it becomes
invariant under the one-parameter Lie group of translations. The converted
ODE can be easily solved by quadrature. It makes use of the
<a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.infinitesimals()</span></code></a> function which returns the
infinitesimals of the transformation.</p>
<p>The coordinates <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(s\)</span> can be found by solving the following Partial
Differential Equations.</p>
<div class="math notranslate nohighlight">
\[\xi\frac{\partial r}{\partial x} + \eta\frac{\partial r}{\partial y}
= 0\]</div>
<div class="math notranslate nohighlight">
\[\xi\frac{\partial s}{\partial x} + \eta\frac{\partial s}{\partial y}
= 1\]</div>
<p>The differential equation becomes separable in the new coordinate system</p>
<div class="math notranslate nohighlight">
\[\frac{ds}{dr} = \frac{\frac{\partial s}{\partial x} +
h(x, y)\frac{\partial s}{\partial y}}{
\frac{\partial r}{\partial x} + h(x, y)\frac{\partial r}{\partial y}}\]</div>
<p>After finding the solution by integration, it is then converted back to the original
coordinate system by substituting <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(s\)</span> in terms of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> again.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;lie_group&#39;</span><span class="p">))</span>
<span class="go">       /      2\    2</span>
<span class="go">       |     x |  -x</span>
<span class="go">f(x) = |C1 + --|*e</span>
<span class="go">       \     2 /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="st-power-series">
<h3>1st_power_series<a class="headerlink" href="#st-power-series" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_1st_power_series">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_1st_power_series</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L4478-L4550"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_1st_power_series" title="Permalink to this definition">¶</a></dt>
<dd><p>The power series solution is a method which gives the Taylor series expansion
to the solution of a differential equation.</p>
<p>For a first order differential equation <span class="math notranslate nohighlight">\(\frac{dy}{dx} = h(x, y)\)</span>, a power
series solution exists at a point <span class="math notranslate nohighlight">\(x = x_{0}\)</span> if <span class="math notranslate nohighlight">\(h(x, y)\)</span> is analytic at <span class="math notranslate nohighlight">\(x_{0}\)</span>.
The solution is given by</p>
<div class="math notranslate nohighlight">
\[y(x) = y(x_{0}) + \sum_{n = 1}^{\infty} \frac{F_{n}(x_{0},b)(x - x_{0})^n}{n!},\]</div>
<p>where <span class="math notranslate nohighlight">\(y(x_{0}) = b\)</span> is the value of y at the initial value of <span class="math notranslate nohighlight">\(x_{0}\)</span>.
To compute the values of the <span class="math notranslate nohighlight">\(F_{n}(x_{0},b)\)</span> the following algorithm is
followed, until the required number of terms are generated.</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(F_1 = h(x_{0}, b)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F_{n+1} = \frac{\partial F_{n}}{\partial x} + \frac{\partial F_{n}}{\partial y}F_{1}\)</span></p></li>
</ol>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_power_series&#39;</span><span class="p">))</span>
<span class="go">                       3       4       5</span>
<span class="go">                   C1*x    C1*x    C1*x     / 6\</span>
<span class="go">f(x) = C1 + C1*x - ----- + ----- + ----- + O\x /</span>
<span class="go">                     6       24      60</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Travis W. Walker, Analytic power series technique for solving first-order
differential equations, p.p 17, 18</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="nd-power-series-ordinary">
<h3>2nd_power_series_ordinary<a class="headerlink" href="#nd-power-series-ordinary" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_2nd_power_series_ordinary">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_2nd_power_series_ordinary</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3355-L3497"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_2nd_power_series_ordinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a power series solution to a second order homogeneous differential
equation with polynomial coefficients at an ordinary point. A homogeneous
differential equation is of the form</p>
<div class="math notranslate nohighlight">
\[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) = 0\]</div>
<p>For simplicity it is assumed that <span class="math notranslate nohighlight">\(P(x)\)</span>, <span class="math notranslate nohighlight">\(Q(x)\)</span> and <span class="math notranslate nohighlight">\(R(x)\)</span> are polynomials,
it is sufficient that <span class="math notranslate nohighlight">\(\frac{Q(x)}{P(x)}\)</span> and <span class="math notranslate nohighlight">\(\frac{R(x)}{P(x)}\)</span> exists at
<span class="math notranslate nohighlight">\(x_{0}\)</span>. A recurrence relation is obtained by substituting <span class="math notranslate nohighlight">\(y\)</span> as <span class="math notranslate nohighlight">\(\sum_{n=0}^\infty a_{n}x^{n}\)</span>,
in the differential equation, and equating the nth term. Using this relation
various terms can be generated.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;2nd_power_series_ordinary&#39;</span><span class="p">))</span>
<span class="go">          / 4    2    \        /     2\</span>
<span class="go">          |x    x     |        |    x |    / 6\</span>
<span class="go">f(x) = C2*|-- - -- + 1| + C1*x*|1 - --| + O\x /</span>
<span class="go">          \24   2     /        \    6 /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="http://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx">http://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx</a></p></li>
<li><p>George E. Simmons, “Differential Equations with Applications and
Historical Notes”, p.p 176 - 184</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="nd-power-series-regular">
<h3>2nd_power_series_regular<a class="headerlink" href="#nd-power-series-regular" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.ode_2nd_power_series_regular">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">ode_2nd_power_series_regular</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">order</span></em>, <em class="sig-param"><span class="n">match</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L3532-L3652"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_2nd_power_series_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a power series solution to a second order homogeneous differential
equation with polynomial coefficients at a regular point. A second order
homogeneous differential equation is of the form</p>
<div class="math notranslate nohighlight">
\[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) = 0\]</div>
<p>A point is said to regular singular at <span class="math notranslate nohighlight">\(x0\)</span> if <span class="math notranslate nohighlight">\(x - x0\frac{Q(x)}{P(x)}\)</span>
and <span class="math notranslate nohighlight">\((x - x0)^{2}\frac{R(x)}{P(x)}\)</span> are analytic at <span class="math notranslate nohighlight">\(x0\)</span>. For simplicity
<span class="math notranslate nohighlight">\(P(x)\)</span>, <span class="math notranslate nohighlight">\(Q(x)\)</span> and <span class="math notranslate nohighlight">\(R(x)\)</span> are assumed to be polynomials. The algorithm for
finding the power series solutions is:</p>
<ol class="arabic simple">
<li><p>Try expressing <span class="math notranslate nohighlight">\((x - x0)P(x)\)</span> and <span class="math notranslate nohighlight">\(((x - x0)^{2})Q(x)\)</span> as power series
solutions about x0. Find <span class="math notranslate nohighlight">\(p0\)</span> and <span class="math notranslate nohighlight">\(q0\)</span> which are the constants of the
power series expansions.</p></li>
<li><p>Solve the indicial equation <span class="math notranslate nohighlight">\(f(m) = m(m - 1) + m*p0 + q0\)</span>, to obtain the
roots <span class="math notranslate nohighlight">\(m1\)</span> and <span class="math notranslate nohighlight">\(m2\)</span> of the indicial equation.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(m1 - m2\)</span> is a non integer there exists two series solutions. If
<span class="math notranslate nohighlight">\(m1 = m2\)</span>, there exists only one solution. If <span class="math notranslate nohighlight">\(m1 - m2\)</span> is an integer,
then the existence of one solution is confirmed. The other solution may
or may not exist.</p></li>
</ol>
<p>The power series solution is of the form <span class="math notranslate nohighlight">\(x^{m}\sum_{n=0}^\infty a_{n}x^{n}\)</span>. The
coefficients are determined by the following recurrence relation.
<span class="math notranslate nohighlight">\(a_{n} = -\frac{\sum_{k=0}^{n-1} q_{n-k} + (m + k)p_{n-k}}{f(m + n)}\)</span>. For the case
in which <span class="math notranslate nohighlight">\(m1 - m2\)</span> is an integer, it can be seen from the recurrence relation
that for the lower root <span class="math notranslate nohighlight">\(m\)</span>, when <span class="math notranslate nohighlight">\(n\)</span> equals the difference of both the
roots, the denominator becomes zero. So if the numerator is not equal to zero,
a second series solution exists.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;2nd_power_series_regular&#39;</span><span class="p">))</span>
<span class="go">                              /    6    4    2    \</span>
<span class="go">                              |   x    x    x     |</span>
<span class="go">          /  4    2    \   C1*|- --- + -- - -- + 1|</span>
<span class="go">          | x    x     |      \  720   24   2     /    / 6\</span>
<span class="go">f(x) = C2*|--- - -- + 1| + ------------------------ + O\x /</span>
<span class="go">          \120   6     /              x</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>George E. Simmons, “Differential Equations with Applications and
Historical Notes”, p.p 176 - 184</p></li>
</ul>
</dd></dl>

</div>
</div>
<div class="section" id="lie-heuristics">
<h2>Lie heuristics<a class="headerlink" href="#lie-heuristics" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use of the Lie Group Solver.
Nonetheless, they contain useful information in their docstrings on the algorithms
implemented for the various heuristics.</p>
<div class="section" id="abaco1-simple">
<h3>abaco1_simple<a class="headerlink" href="#abaco1-simple" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_abaco1_simple">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_abaco1_simple</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5651-L5752"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_abaco1_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>The first heuristic uses the following four sets of
assumptions on <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
<div class="math notranslate nohighlight">
\[\xi = 0, \eta = f(x)\]</div>
<div class="math notranslate nohighlight">
\[\xi = 0, \eta = f(y)\]</div>
<div class="math notranslate nohighlight">
\[\xi = f(x), \eta = 0\]</div>
<div class="math notranslate nohighlight">
\[\xi = f(y), \eta = 0\]</div>
<p>The success of this heuristic is determined by algebraic factorisation.
For the first assumption <span class="math notranslate nohighlight">\(\xi = 0\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span> to be a function of <span class="math notranslate nohighlight">\(x\)</span>, the PDE</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x})*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi*\frac{\partial h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0\]</div>
<p>reduces to <span class="math notranslate nohighlight">\(f'(x) - f\frac{\partial h}{\partial y} = 0\)</span>
If <span class="math notranslate nohighlight">\(\frac{\partial h}{\partial y}\)</span> is a function of <span class="math notranslate nohighlight">\(x\)</span>, then this can usually
be integrated easily. A similar idea is applied to the other 3 assumptions as well.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco1-product">
<h3>abaco1_product<a class="headerlink" href="#abaco1-product" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_abaco1_product">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_abaco1_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5754-L5825"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_abaco1_product" title="Permalink to this definition">¶</a></dt>
<dd><p>The second heuristic uses the following two assumptions on <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
<div class="math notranslate nohighlight">
\[\eta = 0, \xi = f(x)*g(y)\]</div>
<div class="math notranslate nohighlight">
\[\eta = f(x)*g(y), \xi = 0\]</div>
<p>The first assumption of this heuristic holds good if
<span class="math notranslate nohighlight">\(\frac{1}{h^{2}}\frac{\partial^2}{\partial x \partial y}\log(h)\)</span> is
separable in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, then the separated factors containing <span class="math notranslate nohighlight">\(x\)</span>
is <span class="math notranslate nohighlight">\(f(x)\)</span>, and <span class="math notranslate nohighlight">\(g(y)\)</span> is obtained by</p>
<div class="math notranslate nohighlight">
\[e^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}\]</div>
<p>provided <span class="math notranslate nohighlight">\(f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\)</span> is a function
of <span class="math notranslate nohighlight">\(y\)</span> only.</p>
<p>The second assumption holds good if <span class="math notranslate nohighlight">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math notranslate nohighlight">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first assumption
satisfies. After obtaining <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(g(y)\)</span>, the coordinates are again
interchanged, to get <span class="math notranslate nohighlight">\(\eta\)</span> as <span class="math notranslate nohighlight">\(f(x)*g(y)\)</span></p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="bivariate">
<h3>bivariate<a class="headerlink" href="#bivariate" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_bivariate">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_bivariate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5827-L5897"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_bivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>The third heuristic assumes the infinitesimals <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span>
to be bi-variate polynomials in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. The assumption made here
for the logic below is that <span class="math notranslate nohighlight">\(h\)</span> is a rational function in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>
though that may not be necessary for the infinitesimals to be
bivariate polynomials. The coefficients of the infinitesimals
are found out by substituting them in the PDE and grouping similar terms
that are polynomials and since they form a linear system, solve and check
for non trivial solutions. The degree of the assumed bivariates
are increased till a certain maximum value.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Lie Groups and Differential Equations
pp. 327 - pp. 329</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="chi">
<h3>chi<a class="headerlink" href="#chi" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_chi">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_chi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5899-L5968"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>The aim of the fourth heuristic is to find the function <span class="math notranslate nohighlight">\(\chi(x, y)\)</span>
that satisfies the PDE <span class="math notranslate nohighlight">\(\frac{d\chi}{dx} + h\frac{d\chi}{dx}
- \frac{\partial h}{\partial y}\chi = 0\)</span>.</p>
<p>This assumes <span class="math notranslate nohighlight">\(\chi\)</span> to be a bivariate polynomial in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. By intuition,
<span class="math notranslate nohighlight">\(h\)</span> should be a rational function in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. The method used here is
to substitute a general binomial for <span class="math notranslate nohighlight">\(\chi\)</span> up to a certain maximum degree
is reached. The coefficients of the polynomials, are calculated by by collecting
terms of the same order in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>After finding <span class="math notranslate nohighlight">\(\chi\)</span>, the next step is to use <span class="math notranslate nohighlight">\(\eta = \xi*h + \chi\)</span>, to
determine <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span>. This can be done by dividing <span class="math notranslate nohighlight">\(\chi\)</span> by <span class="math notranslate nohighlight">\(h\)</span>
which would give <span class="math notranslate nohighlight">\(-\xi\)</span> as the quotient and <span class="math notranslate nohighlight">\(\eta\)</span> as the remainder.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco2-similar">
<h3>abaco2_similar<a class="headerlink" href="#abaco2-similar" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_abaco2_similar">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_abaco2_similar</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6060-L6165"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_abaco2_similar" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic uses the following two assumptions on <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
<div class="math notranslate nohighlight">
\[\eta = g(x), \xi = f(x)\]</div>
<div class="math notranslate nohighlight">
\[\eta = f(y), \xi = g(y)\]</div>
<p>For the first assumption,</p>
<ol class="arabic">
<li><p>First <span class="math notranslate nohighlight">\(\frac{\frac{\partial h}{\partial y}}{\frac{\partial^{2} h}{
\partial yy}}\)</span> is calculated. Let us say this value is A</p></li>
<li><p>If this is constant, then <span class="math notranslate nohighlight">\(h\)</span> is matched to the form <span class="math notranslate nohighlight">\(A(x) + B(x)e^{
\frac{y}{C}}\)</span> then, <span class="math notranslate nohighlight">\(\frac{e^{\int \frac{A(x)}{C} \,dx}}{B(x)}\)</span> gives <span class="math notranslate nohighlight">\(f(x)\)</span>
and <span class="math notranslate nohighlight">\(A(x)*f(x)\)</span> gives <span class="math notranslate nohighlight">\(g(x)\)</span></p></li>
<li><p>Otherwise <span class="math notranslate nohighlight">\(\frac{\frac{\partial A}{\partial X}}{\frac{\partial A}{
\partial Y}} = \gamma\)</span> is calculated. If</p>
<p>a] <span class="math notranslate nohighlight">\(\gamma\)</span> is a function of <span class="math notranslate nohighlight">\(x\)</span> alone</p>
<p>b] <span class="math notranslate nohighlight">\(\frac{\gamma\frac{\partial h}{\partial y} - \gamma'(x) - \frac{
\partial h}{\partial x}}{h + \gamma} = G\)</span> is a function of <span class="math notranslate nohighlight">\(x\)</span> alone.
then, <span class="math notranslate nohighlight">\(e^{\int G \,dx}\)</span> gives <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(-\gamma*f(x)\)</span> gives <span class="math notranslate nohighlight">\(g(x)\)</span></p>
</li>
</ol>
<p>The second assumption holds good if <span class="math notranslate nohighlight">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math notranslate nohighlight">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first assumption
satisfies. After obtaining <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(g(x)\)</span>, the coordinates are again
interchanged, to get <span class="math notranslate nohighlight">\(\xi\)</span> as <span class="math notranslate nohighlight">\(f(x^*)\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span> as <span class="math notranslate nohighlight">\(g(y^*)\)</span></p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="function-sum">
<h3>function_sum<a class="headerlink" href="#function-sum" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_function_sum">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_function_sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L5970-L6058"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_function_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic uses the following two assumptions on <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
<div class="math notranslate nohighlight">
\[\eta = 0, \xi = f(x) + g(y)\]</div>
<div class="math notranslate nohighlight">
\[\eta = f(x) + g(y), \xi = 0\]</div>
<p>The first assumption of this heuristic holds good if</p>
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial y}[(h\frac{\partial^{2}}{
\partial x^{2}}(h^{-1}))^{-1}]\]</div>
<p>is separable in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>,</p>
<ol class="arabic simple">
<li><p>The separated factors containing <span class="math notranslate nohighlight">\(y\)</span> is <span class="math notranslate nohighlight">\(\frac{\partial g}{\partial y}\)</span>.
From this <span class="math notranslate nohighlight">\(g(y)\)</span> can be determined.</p></li>
<li><p>The separated factors containing <span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(f''(x)\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(h\frac{\partial^{2}}{\partial x^{2}}(h^{-1})\)</span> equals
<span class="math notranslate nohighlight">\(\frac{f''(x)}{f(x) + g(y)}\)</span>. From this <span class="math notranslate nohighlight">\(f(x)\)</span> can be determined.</p></li>
</ol>
<p>The second assumption holds good if <span class="math notranslate nohighlight">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math notranslate nohighlight">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first
assumption satisfies. After obtaining <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(g(y)\)</span>, the coordinates
are again interchanged, to get <span class="math notranslate nohighlight">\(\eta\)</span> as <span class="math notranslate nohighlight">\(f(x) + g(y)\)</span>.</p>
<p>For both assumptions, the constant factors are separated among <span class="math notranslate nohighlight">\(g(y)\)</span>
and <span class="math notranslate nohighlight">\(f''(x)\)</span>, such that <span class="math notranslate nohighlight">\(f''(x)\)</span> obtained from 3] is the same as that
obtained from 2]. If not possible, then this heuristic fails.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco2-unique-unknown">
<h3>abaco2_unique_unknown<a class="headerlink" href="#abaco2-unique-unknown" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_abaco2_unique_unknown">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_abaco2_unique_unknown</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6168-L6243"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_abaco2_unique_unknown" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic assumes the presence of unknown functions or known functions
with non-integer powers.</p>
<ol class="arabic">
<li><p>A list of all functions and non-integer powers containing x and y</p></li>
<li><p>Loop over each element <span class="math notranslate nohighlight">\(f\)</span> in the list, find <span class="math notranslate nohighlight">\(\frac{\frac{\partial f}{\partial x}}{
\frac{\partial f}{\partial x}} = R\)</span></p>
<p>If it is separable in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, let <span class="math notranslate nohighlight">\(X\)</span> be the factors containing <span class="math notranslate nohighlight">\(x\)</span>. Then</p>
<dl class="simple">
<dt>a] Check if <span class="math notranslate nohighlight">\(\xi = X\)</span> and <span class="math notranslate nohighlight">\(\eta = -\frac{X}{R}\)</span> satisfy the PDE. If yes, then return</dt><dd><p><span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
</dd>
<dt>b] Check if <span class="math notranslate nohighlight">\(\xi = \frac{-R}{X}\)</span> and <span class="math notranslate nohighlight">\(\eta = -\frac{1}{X}\)</span> satisfy the PDE.</dt><dd><p>If yes, then return <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
</dd>
</dl>
<p>If not, then check if</p>
<p>a] <span class="math notranslate nohighlight">\(\xi = -R,\eta = 1\)</span></p>
<p>b] <span class="math notranslate nohighlight">\(\xi = 1, \eta = -\frac{1}{R}\)</span></p>
<p>are solutions.</p>
</li>
</ol>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco2-unique-general">
<h3>abaco2_unique_general<a class="headerlink" href="#abaco2-unique-general" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_abaco2_unique_general">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_abaco2_unique_general</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6246-L6318"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_abaco2_unique_general" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic finds if infinitesimals of the form <span class="math notranslate nohighlight">\(\eta = f(x)\)</span>, <span class="math notranslate nohighlight">\(\xi = g(y)\)</span>
without making any assumptions on <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>The complete sequence of steps is given in the paper mentioned below.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

</div>
<div class="section" id="linear">
<h3>linear<a class="headerlink" href="#linear" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode.lie_heuristic_linear">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">lie_heuristic_linear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">match</span></em>, <em class="sig-param"><span class="n">comp</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6321-L6391"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode.lie_heuristic_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic assumes</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\xi = ax + by + c\)</span> and</p></li>
<li><p><span class="math notranslate nohighlight">\(\eta = fx + gy + h\)</span></p></li>
</ol>
<p>After substituting the following assumptions in the determining PDE, it
reduces to</p>
<div class="math notranslate nohighlight">
\[f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x}
- (fx + gy + c)\frac{\partial h}{\partial y}\]</div>
<p>Solving the reduced PDE obtained, using the method of characteristics, becomes
impractical. The method followed is grouping similar terms and solving the system
of linear equations obtained. The difference between the bivariate heuristic is that
<span class="math notranslate nohighlight">\(h\)</span> need not be a rational function in this case.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

</div>
</div>
<div class="section" id="system-of-odes">
<h2>System of ODEs<a class="headerlink" href="#system-of-odes" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> for system of differential equations.</p>
<div class="section" id="linear-2-equations-order-1-type-6">
<h3>Linear, 2 equations, Order 1, Type 6<a class="headerlink" href="#linear-2-equations-order-1-type-6" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._linear_2eq_order1_type6">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_linear_2eq_order1_type6</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6432-L6483"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._linear_2eq_order1_type6" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type of ode are .</p>
<div class="math notranslate nohighlight">
\[x' = f(t) x + g(t) y\]</div>
<div class="math notranslate nohighlight">
\[y' = a [f(t) + a h(t)] x + a [g(t) - h(t)] y\]</div>
<p>This is solved by first multiplying the first equation by <span class="math notranslate nohighlight">\(-a\)</span> and adding
it to the second equation to obtain</p>
<div class="math notranslate nohighlight">
\[y' - a x' = -a h(t) (y - a x)\]</div>
<p>Setting <span class="math notranslate nohighlight">\(U = y - ax\)</span> and integrating the equation we arrive at</p>
<div class="math notranslate nohighlight">
\[y - ax = C_1 e^{-a \int h(t) \,dt}\]</div>
<p>and on substituting the value of y in first equation give rise to first order ODEs. After solving for
<span class="math notranslate nohighlight">\(x\)</span>, we can obtain <span class="math notranslate nohighlight">\(y\)</span> by substituting the value of <span class="math notranslate nohighlight">\(x\)</span> in second equation.</p>
</dd></dl>

</div>
<div class="section" id="linear-2-equations-order-1-type-7">
<h3>Linear, 2 equations, Order 1, Type 7<a class="headerlink" href="#linear-2-equations-order-1-type-7" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._linear_2eq_order1_type7">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_linear_2eq_order1_type7</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6485-L6544"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._linear_2eq_order1_type7" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type of ode are .</p>
<div class="math notranslate nohighlight">
\[x' = f(t) x + g(t) y\]</div>
<div class="math notranslate nohighlight">
\[y' = h(t) x + p(t) y\]</div>
<p>Differentiating the first equation and substituting the value of <span class="math notranslate nohighlight">\(y\)</span>
from second equation will give a second-order linear equation</p>
<div class="math notranslate nohighlight">
\[g x'' - (fg + gp + g') x' + (fgp - g^{2} h + f g' - f' g) x = 0\]</div>
<p>This above equation can be easily integrated if following conditions are satisfied.</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(fgp - g^{2} h + f g' - f' g = 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(fgp - g^{2} h + f g' - f' g = ag, fg + gp + g' = bg\)</span></p></li>
</ol>
<p>If first condition is satisfied then it is solved by current dsolve solver and in second case it becomes
a constant coefficient differential equation which is also solved by current solver.</p>
<p>Otherwise if the above condition fails then,
a particular solution is assumed as <span class="math notranslate nohighlight">\(x = x_0(t)\)</span> and <span class="math notranslate nohighlight">\(y = y_0(t)\)</span>
Then the general solution is expressed as</p>
<div class="math notranslate nohighlight">
\[x = C_1 x_0(t) + C_2 x_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt\]</div>
<div class="math notranslate nohighlight">
\[y = C_1 y_0(t) + C_2 [\frac{F(t) P(t)}{x_0(t)} + y_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt]\]</div>
<p>where C1 and C2 are arbitrary constants and</p>
<div class="math notranslate nohighlight">
\[F(t) = e^{\int f(t) \,dt} , P(t) = e^{\int p(t) \,dt}\]</div>
</dd></dl>

</div>
<div class="section" id="linear-ode-to-matrix">
<h3>Linear ODE to matrix<a class="headerlink" href="#linear-ode-to-matrix" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.systems.linear_ode_to_matrix">
<code class="sig-prename descclassname">sympy.solvers.ode.systems.</code><code class="sig-name descname">linear_ode_to_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eqs</span></em>, <em class="sig-param"><span class="n">funcs</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">order</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/systems.py#L212-L364"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.systems.linear_ode_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a linear system of ODEs to matrix form</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>eqs</strong> : list of sympy expressions or equalities</p>
<blockquote>
<div><p>The equations as expressions (assumed equal to zero).</p>
</div></blockquote>
<p><strong>funcs</strong> : list of applied functions</p>
<blockquote>
<div><p>The dependent variables of the system of ODEs.</p>
</div></blockquote>
<p><strong>t</strong> : symbol</p>
<blockquote>
<div><p>The independent variable.</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote>
<div><p>The order of the system of ODEs.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The tuple <code class="docutils literal notranslate"><span class="pre">(As,</span> <span class="pre">b)</span></code> where <code class="docutils literal notranslate"><span class="pre">As</span></code> is a tuple of matrices and <code class="docutils literal notranslate"><span class="pre">b</span></code> is the</p>
<p>the matrix representing the rhs of the matrix equation.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ODEOrderError</strong></p>
<blockquote>
<div><p>When the system of ODEs have an order greater than what was specified</p>
</div></blockquote>
<p><strong>ODENonlinearError</strong></p>
<blockquote>
<div><p>When the system of ODEs is nonlinear</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>Express a system of linear ordinary differential equations as a single
matrix differential equation [1]. For example the system <span class="math notranslate nohighlight">\(x' = x + y + 1\)</span>
and <span class="math notranslate nohighlight">\(y' = x - y\)</span> can be represented as</p>
<div class="math notranslate nohighlight">
\[A_1 X' = A0 X + b\]</div>
<p>where <span class="math notranslate nohighlight">\(A_1\)</span> and <span class="math notranslate nohighlight">\(A_0\)</span> are <span class="math notranslate nohighlight">\(2 \times 2\)</span> matrices and <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(X'\)</span> are
<span class="math notranslate nohighlight">\(2 \times 1\)</span> matrices with <span class="math notranslate nohighlight">\(X = [x, y]^T\)</span>.</p>
<p>Higher-order systems are represented with additional matrices e.g. a
second-order system would look like</p>
<div class="math notranslate nohighlight">
\[A_2 X'' =  A_1 X' + A_0 X  + b\]</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Eq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">linear_ode_to_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can create a system of linear ODEs like</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 1st order system</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">linear_ode_to_matrix</span></code> can represent this as a matrix
differential equation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A0</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A1</span>
<span class="go">Matrix([</span>
<span class="go">[1, 0],</span>
<span class="go">[0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A0</span>
<span class="go">Matrix([</span>
<span class="go">[1, 1],</span>
<span class="go">[1,  -1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[1],</span>
<span class="go">[0]])</span>
</pre></div>
</div>
<p>The original equations can be recovered from these matrices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs_mat</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">eqs</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A1</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">A0</span> <span class="o">*</span> <span class="n">X</span> <span class="o">-</span> <span class="n">b</span> <span class="o">==</span> <span class="n">eqs_mat</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the system of equations has a maximum order greater than the
order of the system specified, a ODEOrderError exception is raised.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ODEOrderError</span>: <span class="n">Cannot represent system in 1-order form</span>
</pre></div>
</div>
<p>If the system of equations is nonlinear, then ODENonlinearError is
raised.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ODENonlinearError</span>: <span class="n">The system of ODEs is nonlinear.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="solveset.html#sympy.solvers.solveset.linear_eq_to_matrix" title="sympy.solvers.solveset.linear_eq_to_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_eq_to_matrix</span></code></a></dt><dd><p>for systems of linear algebraic equations.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r694"><span class="brackets"><a class="fn-backref" href="#id1">R694</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_differential_equation">https://en.wikipedia.org/wiki/Matrix_differential_equation</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="canonical-equations-converter">
<h3>Canonical Equations Converter<a class="headerlink" href="#canonical-equations-converter" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.systems.canonical_odes">
<code class="sig-prename descclassname">sympy.solvers.ode.systems.</code><code class="sig-name descname">canonical_odes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eqs</span></em>, <em class="sig-param"><span class="n">funcs</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/systems.py#L884-L953"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.systems.canonical_odes" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that solves for highest order derivatives in a system</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>eqs</strong> : List</p>
<blockquote>
<div><p>List of the ODEs</p>
</div></blockquote>
<p><strong>funcs</strong> : List</p>
<blockquote>
<div><p>List of dependent variables</p>
</div></blockquote>
<p><strong>t</strong> : Symbol</p>
<blockquote>
<div><p>Independent variable</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List</p>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This function inputs a system of ODEs and based on the system,
the dependent variables and their highest order, returns the system
in the following form:</p>
<div class="math notranslate nohighlight">
\[X'(t) = A(t) X(t) + b(t)\]</div>
<p>Here, <span class="math notranslate nohighlight">\(X(t)\)</span> is the vector of dependent variables of lower order, <span class="math notranslate nohighlight">\(A(t)\)</span> is
the coefficient matrix, <span class="math notranslate nohighlight">\(b(t)\)</span> is the non-homogeneous term and <span class="math notranslate nohighlight">\(X'(t)\)</span> is the
vector of dependent variables in their respective highest order. We use the term
canonical form to imply the system of ODEs which is of the above form.</p>
<p>If the system passed has a non-linear term with multiple solutions, then a list of
systems is returned in its canonical form.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">canonical_odes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;f g&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">12</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">20</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">canonical_eqs</span> <span class="o">=</span> <span class="n">canonical_odes</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">canonical_eqs</span>
<span class="go">[[Eq(Derivative(f(x), x), 7*f(x) + 12*g(x)), Eq(Derivative(g(x), x), 20*f(x) - g(x))]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">canonical_system</span> <span class="o">=</span> <span class="n">canonical_odes</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">canonical_system</span>
<span class="go">[[Eq(Derivative(f(x), x), -1), Eq(Derivative(g(x), x), y*f(x))], [Eq(Derivative(f(x), x), 3), Eq(Derivative(g(x), x), y*f(x))]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="linodesolve-systems-information">
<h3>LinODESolve Systems Information<a class="headerlink" href="#linodesolve-systems-information" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.systems.linodesolve_type">
<code class="sig-prename descclassname">sympy.solvers.ode.systems.</code><code class="sig-name descname">linodesolve_type</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/systems.py#L73-L182"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.systems.linodesolve_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that determines the type of the system of ODEs for solving with <a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve" title="sympy.solvers.ode.systems.linodesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve()</span></code></a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> : Matrix</p>
<blockquote>
<div><p>Coefficient matrix of the system of ODEs</p>
</div></blockquote>
<p><strong>b</strong> : Matrix or None</p>
<blockquote>
<div><p>Non-homogeneous term of the system. The default value is None.
If this argument is None, then the system is assumed to be homogeneous.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Dict</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>When the coefficient matrix doesn’t have a commutative antiderivative</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This function takes in the coefficient matrix and/or the non-homogeneous term
and returns the type of the equation that can be solved by <a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve" title="sympy.solvers.ode.systems.linodesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve()</span></code></a>.</p>
<p>If the system is constant coefficient homogeneous, then “type1” is returned</p>
<p>If the system is constant coefficient non-homogeneous, then “type2” is returned</p>
<p>If the system is non-constant coefficient homogeneous, then “type3” is returned</p>
<p>If the system is non-constant coefficient non-homogeneous, then “type4” is returned</p>
<p>If the system has a non-constant coefficient matrix which can be factorized into constant
coefficient matrix, then “type5” or “type6” is returned for when the system is homogeneous or
non-homogeneous respectively.</p>
<p>Note that, if the system of ODEs is of “type3” or “type4”, then along with the type,
the commutative antiderivative of the coefficient matrix is also returned.</p>
<p>If the system cannot be solved by <a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve" title="sympy.solvers.ode.systems.linodesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve()</span></code></a>, then
NotImplementedError is raised.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">linodesolve_type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="go">{&#39;antiderivative&#39;: None, &#39;type_of_equation&#39;: &#39;type1&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="go">{&#39;antiderivative&#39;: None, &#39;type_of_equation&#39;: &#39;type2&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A_t</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="go">{&#39;antiderivative&#39;: Matrix([</span>
<span class="go">[      t, t**2/2],</span>
<span class="go">[-t**2/2,      t]]), &#39;type_of_equation&#39;: &#39;type3&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="go">{&#39;antiderivative&#39;: Matrix([</span>
<span class="go">[      t, t**2/2],</span>
<span class="go">[-t**2/2,      t]]), &#39;type_of_equation&#39;: &#39;type4&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A_non_commutative</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A_non_commutative</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span>:
<span class="go">The system doesn&#39;t have a commutative antiderivative, it can&#39;t be</span>
<span class="go">solved by linodesolve.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve" title="sympy.solvers.ode.systems.linodesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linodesolve</span></code></a></dt><dd><p>Function for which linodesolve_type gets the information</p>
</dd>
</dl>
</div>
</dd></dl>

</div>
<div class="section" id="matrix-exponential-jordan-form">
<h3>Matrix Exponential Jordan Form<a class="headerlink" href="#matrix-exponential-jordan-form" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.systems.matrix_exp_jordan_form">
<code class="sig-prename descclassname">sympy.solvers.ode.systems.</code><code class="sig-name descname">matrix_exp_jordan_form</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/systems.py#L442-L557"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.systems.matrix_exp_jordan_form" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix exponential <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> for the matrix <em>A</em> and scalar <em>t</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> : Matrix</p>
<blockquote>
<div><p>The matrix <span class="math notranslate nohighlight">\(A\)</span> in the expression <span class="math notranslate nohighlight">\(\exp(A*t)\)</span></p>
</div></blockquote>
<p><strong>t</strong> : Symbol</p>
<blockquote>
<div><p>The independent variable</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>Returns the Jordan form of the <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> along with the matrix <span class="math notranslate nohighlight">\(P\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[\exp(A*t) = P * expJ * P^{-1}\]</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">matrix_exp</span><span class="p">,</span> <span class="n">matrix_exp_jordan_form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We will consider a 2x2 defective matrix. This shows that our method
works even for defective matrices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>It can be observed that this function gives us the Jordan normal form
and the required invertible matrix P.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">expJ</span> <span class="o">=</span> <span class="n">matrix_exp_jordan_form</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, it is shown that P and expJ returned by this function is correct
as they satisfy the formula: P * expJ * P_inverse = exp(A*t).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">*</span> <span class="n">expJ</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">==</span> <span class="n">matrix_exp</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r695"><span class="brackets"><a class="fn-backref" href="#id2">R695</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Defective_matrix">https://en.wikipedia.org/wiki/Defective_matrix</a></p>
</dd>
<dt class="label" id="r696"><span class="brackets"><a class="fn-backref" href="#id3">R696</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Jordan_matrix">https://en.wikipedia.org/wiki/Jordan_matrix</a></p>
</dd>
<dt class="label" id="r697"><span class="brackets"><a class="fn-backref" href="#id4">R697</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Jordan_normal_form">https://en.wikipedia.org/wiki/Jordan_normal_form</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="matrix-exponential">
<h3>Matrix Exponential<a class="headerlink" href="#matrix-exponential" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.systems.matrix_exp">
<code class="sig-prename descclassname">sympy.solvers.ode.systems.</code><code class="sig-name descname">matrix_exp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/systems.py#L367-L439"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.systems.matrix_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix exponential <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> for the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> and scalar <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> : Matrix</p>
<blockquote>
<div><p>The matrix <span class="math notranslate nohighlight">\(A\)</span> in the expression <span class="math notranslate nohighlight">\(\exp(A*t)\)</span></p>
</div></blockquote>
<p><strong>t</strong> : Symbol</p>
<blockquote>
<div><p>The independent variable</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This functions returns the <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> by doing a simple
matrix multiplication:</p>
<div class="math notranslate nohighlight">
\[\exp(A*t) = P * expJ * P^{-1}\]</div>
<p>where <span class="math notranslate nohighlight">\(expJ\)</span> is <span class="math notranslate nohighlight">\(\exp(J*t)\)</span>. <span class="math notranslate nohighlight">\(J\)</span> is the Jordan normal
form of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(P\)</span> is matrix such that:</p>
<div class="math notranslate nohighlight">
\[A = P * J * P^{-1}\]</div>
<p>The matrix exponential <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> appears in the solution of linear
differential equations. For example if <span class="math notranslate nohighlight">\(x\)</span> is a vector and <span class="math notranslate nohighlight">\(A\)</span> is a matrix
then the initial value problem</p>
<div class="math notranslate nohighlight">
\[\frac{dx(t)}{dt} = A \times x(t),   x(0) = x0\]</div>
<p>has the unique solution</p>
<div class="math notranslate nohighlight">
\[x(t) = \exp(A t) x0\]</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">matrix_exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We will consider a 2x2 matrix for comupting the exponential</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[2  -5]</span>
<span class="go">[     ]</span>
<span class="go">[2  -4]</span>
</pre></div>
</div>
<p>Now, exp(A*t) is given as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">matrix_exp</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="go">[   -t           -t                    -t              ]</span>
<span class="go">[3*e  *sin(t) + e  *cos(t)         -5*e  *sin(t)       ]</span>
<span class="go">[                                                      ]</span>
<span class="go">[         -t                     -t           -t       ]</span>
<span class="go">[      2*e  *sin(t)         - 3*e  *sin(t) + e  *cos(t)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.matrix_exp_jordan_form" title="sympy.solvers.ode.systems.matrix_exp_jordan_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_exp_jordan_form</span></code></a></dt><dd><p>For exponential of Jordan normal form</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r698"><span class="brackets"><a class="fn-backref" href="#id5">R698</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Jordan_normal_form">https://en.wikipedia.org/wiki/Jordan_normal_form</a></p>
</dd>
<dt class="label" id="r699"><span class="brackets"><a class="fn-backref" href="#id6">R699</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_exponential">https://en.wikipedia.org/wiki/Matrix_exponential</a></p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="linear-n-equations-order-1-solver">
<h3>Linear, n equations, Order 1 Solver<a class="headerlink" href="#linear-n-equations-order-1-solver" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.systems.linodesolve">
<code class="sig-prename descclassname">sympy.solvers.ode.systems.</code><code class="sig-name descname">linodesolve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">b</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">B</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">doit</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">tau</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/systems.py#L561-L876"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.systems.linodesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>System of n equations linear first-order differential equations</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A</strong> : Matrix</p>
<blockquote>
<div><p>Coefficient matrix of the system of linear first order ODEs.</p>
</div></blockquote>
<p><strong>t</strong> : Symbol</p>
<blockquote>
<div><p>Independent variable in the system of ODEs.</p>
</div></blockquote>
<p><strong>b</strong> : Matrix or None</p>
<blockquote>
<div><p>Non-homogeneous term in the system of ODEs. If None is passed,
a homogeneous system of ODEs is assumed.</p>
</div></blockquote>
<p><strong>B</strong> : Matrix or None</p>
<blockquote>
<div><p>Antiderivative of the coefficient matrix. If the antiderivative
is not passed and the solution requires the term, then the solver
would compute it internally.</p>
</div></blockquote>
<p><strong>type</strong> : String</p>
<blockquote>
<div><p>Type of the system of ODEs passed. Depending on the type, the
solution is evaluated. The type values allowed and the corresponding
system it solves are: “type1” for constant coefficient homogeneous
“type2” for constant coefficient non-homogeneous, “type3” for non-constant
coefficient homogeneous, “type4” for non-constant coefficient non-homogeneous,
“type5” and “type6” for non-constant coefficient homogeneous and non-homogeneous
systems respectively where the coefficient matrix can be factorized to a constant
coefficient matrix.
The default value is “auto” which will let the solver decide the correct type of
the system passed.</p>
</div></blockquote>
<p><strong>doit</strong> : Boolean</p>
<blockquote>
<div><p>Evaluate the solution if True, default value is False</p>
</div></blockquote>
<p><strong>tau: Expression</strong></p>
<blockquote>
<div><p>Used to substitute for the value of <span class="math notranslate nohighlight">\(t\)</span> after we get the solution of the system.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong></p>
<blockquote>
<div><p>This error is raised when the coefficient matrix, non-homogeneous term
or the antiderivative, if passed, aren’t a matrix or
don’t have correct dimensions</p>
</div></blockquote>
<p><strong>NonSquareMatrixError</strong></p>
<blockquote>
<div><p>When the coefficient matrix or its antiderivative, if passed isn’t a square
matrix</p>
</div></blockquote>
<p><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>If the coefficient matrix doesn’t have a commutative antiderivative</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This solver solves the system of ODEs of the follwing form:</p>
<div class="math notranslate nohighlight">
\[X'(t) = A(t) X(t) +  b(t)\]</div>
<p>Here, <span class="math notranslate nohighlight">\(A(t)\)</span> is the coefficient matrix, <span class="math notranslate nohighlight">\(X(t)\)</span> is the vector of n independent variables,
<span class="math notranslate nohighlight">\(b(t)\)</span> is the non-homogeneous term and <span class="math notranslate nohighlight">\(X'(t)\)</span> is the derivative of <span class="math notranslate nohighlight">\(X(t)\)</span></p>
<p>Depending on the properties of <span class="math notranslate nohighlight">\(A(t)\)</span> and <span class="math notranslate nohighlight">\(b(t)\)</span>, this solver evaluates the solution
differently.</p>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is constant coefficient matrix and <span class="math notranslate nohighlight">\(b(t)\)</span> is zero vector i.e. system is homogeneous,
the system is “type1”. The solution is:</p>
<div class="math notranslate nohighlight">
\[X(t) = \exp(A t) C\]</div>
<p>Here, <span class="math notranslate nohighlight">\(C\)</span> is a vector of constants and <span class="math notranslate nohighlight">\(A\)</span> is the constant coefficient matrix.</p>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is constant coefficient matrix and <span class="math notranslate nohighlight">\(b(t)\)</span> is non-zero i.e. system is non-homogeneous,
the system is “type2”. The solution is:</p>
<div class="math notranslate nohighlight">
\[X(t) = e^{A t} ( \int e^{- A t} b \,dt + C)\]</div>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is coefficient matrix such that its commutative with its antiderivative <span class="math notranslate nohighlight">\(B(t)\)</span> and
<span class="math notranslate nohighlight">\(b(t)\)</span> is a zero vector i.e. system is homogeneous, the system is “type3”. The solution is:</p>
<div class="math notranslate nohighlight">
\[X(t) = \exp(B(t)) C\]</div>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is commutative with its antiderivative <span class="math notranslate nohighlight">\(B(t)\)</span> and <span class="math notranslate nohighlight">\(b(t)\)</span> is non-zero i.e. system is
non-homogeneous, the system is “type4”. The solution is:</p>
<div class="math notranslate nohighlight">
\[X(t) =  e^{B(t)} ( \int e^{-B(t)} b(t) \,dt + C)\]</div>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is a coefficient matrix such that it can be factorized into a scalar and a constant
coefficient matrix:</p>
<div class="math notranslate nohighlight">
\[A(t) = f(t) * A\]</div>
<p>Where <span class="math notranslate nohighlight">\(f(t)\)</span> is a scalar expression in the independent variable <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(A\)</span> is a constant matrix,
then we can do the following substitutions:</p>
<div class="math notranslate nohighlight">
\[tau = \int f(t) dt, X(t) = Y(tau), b(t) = b(f^{-1}(tau))\]</div>
<p>Here, the substitution for the non-homogeneous term is done only when its non-zero.
Using these substitutions, our original system becomes:</p>
<div class="math notranslate nohighlight">
\[Y'(tau) = A * Y(tau) + b(tau)/f(tau)\]</div>
<p>The above system can be easily solved using the solution for “type1” or “type2” depending
on the homogeneity of the system. After we get the solution for <span class="math notranslate nohighlight">\(Y(tau)\)</span>, we substitute the
solution for <span class="math notranslate nohighlight">\(tau\)</span> as <span class="math notranslate nohighlight">\(t\)</span> to get back <span class="math notranslate nohighlight">\(X(t)\)</span></p>
<div class="math notranslate nohighlight">
\[X(t) = Y(tau)\]</div>
<p>Systems of “type5” and “type6” have a commutative antiderivative but we use this solution
because its faster to compute.</p>
<p>The final solution is the general solution for all the four equations since a constant coefficient
matrix is always commutative with its antidervative.</p>
<p>An additional feature of this function is, if someone wants to substitute for value of the independent
variable, they can pass the substitution <span class="math notranslate nohighlight">\(tau\)</span> and the solution will have the independent variable
substituted with the passed expression(<span class="math notranslate nohighlight">\(tau\)</span>).</p>
<p class="rubric">Examples</p>
<p>To solve the system of ODEs using this function directly, several things must be
done in the right order. Wrong inputs to the function will lead to incorrect results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">canonical_odes</span><span class="p">,</span> <span class="n">linear_ode_to_matrix</span><span class="p">,</span> <span class="n">linodesolve</span><span class="p">,</span> <span class="n">linodesolve_type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.subscheck</span> <span class="kn">import</span> <span class="n">checkodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;f, g&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x, a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
</pre></div>
</div>
<p>Here, it is important to note that before we derive the coefficient matrix, it is
important to get the system of ODEs into the desired form. For that we will use
<a class="reference internal" href="#sympy.solvers.ode.systems.canonical_odes" title="sympy.solvers.ode.systems.canonical_odes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.canonical_odes()</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="n">canonical_odes</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span>
<span class="go">[[Eq(Derivative(f(x), x), a*g(x) + f(x) + 1), Eq(Derivative(g(x), x), a*f(x) - g(x))]]</span>
</pre></div>
</div>
<p>Now, we will use <a class="reference internal" href="#sympy.solvers.ode.systems.linear_ode_to_matrix" title="sympy.solvers.ode.systems.linear_ode_to_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linear_ode_to_matrix()</span></code></a> to get the coefficient matrix and the
non-homogeneous term if it is there.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="n">eqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A0</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">A0</span>
</pre></div>
</div>
<p>We have the coefficient matrices and the non-homogeneous term ready. Now, we can use
<a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve_type" title="sympy.solvers.ode.systems.linodesolve_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve_type()</span></code></a> to get the information for the system of ODEs
to finally pass it to the solver.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system_info</span> <span class="o">=</span> <span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol_vector</span> <span class="o">=</span> <span class="n">linodesolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">system_info</span><span class="p">[</span><span class="s1">&#39;antiderivative&#39;</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="n">system_info</span><span class="p">[</span><span class="s1">&#39;type_of_equation&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Now, we can prove if the solution is correct or not by using <a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.checkodesol()</span></code></a></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">sol_vector</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, [0, 0])</span>
</pre></div>
</div>
<p>We can also use the doit method to evaluate the solutions passed by the function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol_vector_evaluated</span> <span class="o">=</span> <span class="n">linodesolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;type2&quot;</span><span class="p">,</span> <span class="n">doit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we will look at a system of ODEs which is non-constant.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
</pre></div>
</div>
<p>The system defined above is already in the desired form, so we don’t have to convert it.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A0</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">A0</span>
</pre></div>
</div>
<p>A user can also pass the commutative antiderivative required for type3 and type4 system of ODEs.
Passing an incorrect one will lead to incorrect results. If the coefficient matrix is not commutative
with its antiderivative, then <a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve_type" title="sympy.solvers.ode.systems.linodesolve_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve_type()</span></code></a> raises a NotImplementedError.
If it does have a commutative antiderivative, then the function just returns the information about the system.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system_info</span> <span class="o">=</span> <span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we can pass the antiderivative as an argument to get the solution. If the system information is not
passed, then the solver will compute the required arguments internally.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol_vector</span> <span class="o">=</span> <span class="n">linodesolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Once again, we can verify the solution obtained.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">sol_vector</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, [0, 0])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.linear_ode_to_matrix" title="sympy.solvers.ode.systems.linear_ode_to_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_ode_to_matrix</span></code></a></dt><dd><p>Coefficient matrix computation function</p>
</dd>
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.canonical_odes" title="sympy.solvers.ode.systems.canonical_odes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_odes</span></code></a></dt><dd><p>System of ODEs representation change</p>
</dd>
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve_type" title="sympy.solvers.ode.systems.linodesolve_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linodesolve_type</span></code></a></dt><dd><p>Getting information about systems of ODEs to pass in this solver</p>
</dd>
</dl>
</div>
</dd></dl>

</div>
<div class="section" id="nonlinear-2-equations-order-1-type-1">
<h3>Nonlinear, 2 equations, Order 1, Type 1<a class="headerlink" href="#nonlinear-2-equations-order-1-type-1" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type1">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_2eq_order1_type1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6573-L6616"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type1" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math notranslate nohighlight">
\[x' = x^n F(x,y)\]</div>
<div class="math notranslate nohighlight">
\[y' = g(y) F(x,y)\]</div>
<p>Solution:</p>
<div class="math notranslate nohighlight">
\[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]</div>
<p>where</p>
<p>if <span class="math notranslate nohighlight">\(n \neq 1\)</span></p>
<div class="math notranslate nohighlight">
\[\varphi = [C_1 + (1-n) \int \frac{1}{g(y)} \,dy]^{\frac{1}{1-n}}\]</div>
<p>if <span class="math notranslate nohighlight">\(n = 1\)</span></p>
<div class="math notranslate nohighlight">
\[\varphi = C_1 e^{\int \frac{1}{g(y)} \,dy}\]</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants.</p>
</dd></dl>

</div>
<div class="section" id="nonlinear-2-equations-order-1-type-2">
<h3>Nonlinear, 2 equations, Order 1, Type 2<a class="headerlink" href="#nonlinear-2-equations-order-1-type-2" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type2">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_2eq_order1_type2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6618-L6661"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type2" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math notranslate nohighlight">
\[x' = e^{\lambda x} F(x,y)\]</div>
<div class="math notranslate nohighlight">
\[y' = g(y) F(x,y)\]</div>
<p>Solution:</p>
<div class="math notranslate nohighlight">
\[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]</div>
<p>where</p>
<p>if <span class="math notranslate nohighlight">\(\lambda \neq 0\)</span></p>
<div class="math notranslate nohighlight">
\[\varphi = -\frac{1}{\lambda} log(C_1 - \lambda \int \frac{1}{g(y)} \,dy)\]</div>
<p>if <span class="math notranslate nohighlight">\(\lambda = 0\)</span></p>
<div class="math notranslate nohighlight">
\[\varphi = C_1 + \int \frac{1}{g(y)} \,dy\]</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants.</p>
</dd></dl>

</div>
<div class="section" id="nonlinear-2-equations-order-1-type-3">
<h3>Nonlinear, 2 equations, Order 1, Type 3<a class="headerlink" href="#nonlinear-2-equations-order-1-type-3" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type3">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_2eq_order1_type3</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6663-L6699"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type3" title="Permalink to this definition">¶</a></dt>
<dd><p>Autonomous system of general form</p>
<div class="math notranslate nohighlight">
\[x' = F(x,y)\]</div>
<div class="math notranslate nohighlight">
\[y' = G(x,y)\]</div>
<p>Assuming <span class="math notranslate nohighlight">\(y = y(x, C_1)\)</span> where <span class="math notranslate nohighlight">\(C_1\)</span> is an arbitrary constant is the general
solution of the first-order equation</p>
<div class="math notranslate nohighlight">
\[F(x,y) y'_x = G(x,y)\]</div>
<p>Then the general solution of the original system of equations has the form</p>
<div class="math notranslate nohighlight">
\[\int \frac{1}{F(x,y(x,C_1))} \,dx = t + C_1\]</div>
</dd></dl>

</div>
<div class="section" id="nonlinear-2-equations-order-1-type-4">
<h3>Nonlinear, 2 equations, Order 1, Type 4<a class="headerlink" href="#nonlinear-2-equations-order-1-type-4" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type4">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_2eq_order1_type4</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6701-L6746"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type4" title="Permalink to this definition">¶</a></dt>
<dd><p>Equation:</p>
<div class="math notranslate nohighlight">
\[x' = f_1(x) g_1(y) \phi(x,y,t)\]</div>
<div class="math notranslate nohighlight">
\[y' = f_2(x) g_2(y) \phi(x,y,t)\]</div>
<p>First integral:</p>
<div class="math notranslate nohighlight">
\[\int \frac{f_2(x)}{f_1(x)} \,dx - \int \frac{g_1(y)}{g_2(y)} \,dy = C\]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is an arbitrary constant.</p>
<p>On solving the first integral for <span class="math notranslate nohighlight">\(x\)</span> (resp., <span class="math notranslate nohighlight">\(y\)</span> ) and on substituting the
resulting expression into either equation of the original solution, one
arrives at a first-order equation for determining <span class="math notranslate nohighlight">\(y\)</span> (resp., <span class="math notranslate nohighlight">\(x\)</span> ).</p>
</dd></dl>

</div>
<div class="section" id="nonlinear-2-equations-order-1-type-5">
<h3>Nonlinear, 2 equations, Order 1, Type 5<a class="headerlink" href="#nonlinear-2-equations-order-1-type-5" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type5">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_2eq_order1_type5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6748-L6795"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type5" title="Permalink to this definition">¶</a></dt>
<dd><p>Clairaut system of ODEs</p>
<div class="math notranslate nohighlight">
\[x = t x' + F(x',y')\]</div>
<div class="math notranslate nohighlight">
\[y = t y' + G(x',y')\]</div>
<p>The following are solutions of the system</p>
<p><span class="math notranslate nohighlight">\((i)\)</span> straight lines:</p>
<div class="math notranslate nohighlight">
\[x = C_1 t + F(C_1, C_2), y = C_2 t + G(C_1, C_2)\]</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants;</p>
<p><span class="math notranslate nohighlight">\((ii)\)</span> envelopes of the above lines;</p>
<p><span class="math notranslate nohighlight">\((iii)\)</span> continuously differentiable lines made up from segments of the lines
<span class="math notranslate nohighlight">\((i)\)</span> and <span class="math notranslate nohighlight">\((ii)\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="nonlinear-3-equations-order-1-type-1">
<h3>Nonlinear, 3 equations, Order 1, Type 1<a class="headerlink" href="#nonlinear-3-equations-order-1-type-1" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type1">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_3eq_order1_type1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6815-L6862"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type1" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math notranslate nohighlight">
\[a x' = (b - c) y z, \enspace b y' = (c - a) z x, \enspace c z' = (a - b) x y\]</div>
<p>First Integrals:</p>
<div class="math notranslate nohighlight">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
<div class="math notranslate nohighlight">
\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2} = C_2\]</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants. On solving the integrals for <span class="math notranslate nohighlight">\(y\)</span> and
<span class="math notranslate nohighlight">\(z\)</span> and on substituting the resulting expressions into the first equation of the
system, we arrives at a separable first-order equation on <span class="math notranslate nohighlight">\(x\)</span>. Similarly doing that
for other two equations, we will arrive at first order equation on <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> too.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="nonlinear-3-equations-order-1-type-2">
<h3>Nonlinear, 3 equations, Order 1, Type 2<a class="headerlink" href="#nonlinear-3-equations-order-1-type-2" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type2">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_3eq_order1_type2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6865-L6918"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type2" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math notranslate nohighlight">
\[a x' = (b - c) y z f(x, y, z, t)\]</div>
<div class="math notranslate nohighlight">
\[b y' = (c - a) z x f(x, y, z, t)\]</div>
<div class="math notranslate nohighlight">
\[c z' = (a - b) x y f(x, y, z, t)\]</div>
<p>First Integrals:</p>
<div class="math notranslate nohighlight">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
<div class="math notranslate nohighlight">
\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2} = C_2\]</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants. On solving the integrals for <span class="math notranslate nohighlight">\(y\)</span> and
<span class="math notranslate nohighlight">\(z\)</span> and on substituting the resulting expressions into the first equation of the
system, we arrives at a first-order differential equations on <span class="math notranslate nohighlight">\(x\)</span>. Similarly doing
that for other two equations we will arrive at first order equation on <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="nonlinear-3-equations-order-1-type-3">
<h3>Nonlinear, 3 equations, Order 1, Type 3<a class="headerlink" href="#nonlinear-3-equations-order-1-type-3" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type3">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_3eq_order1_type3</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6920-L6978"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type3" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math notranslate nohighlight">
\[x' = c F_2 - b F_3, \enspace y' = a F_3 - c F_1, \enspace z' = b F_1 - a F_2\]</div>
<p>where <span class="math notranslate nohighlight">\(F_n = F_n(x, y, z, t)\)</span>.</p>
<ol class="arabic simple">
<li><p>First Integral:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[a x + b y + c z = C_1,\]</div>
<p>where C is an arbitrary constant.</p>
<p>2. If we assume function <span class="math notranslate nohighlight">\(F_n\)</span> to be independent of <span class="math notranslate nohighlight">\(t\)</span>,i.e, <span class="math notranslate nohighlight">\(F_n\)</span> = <span class="math notranslate nohighlight">\(F_n (x, y, z)\)</span>
Then, on eliminating <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(z\)</span> from the first two equation of the system, one
arrives at the first-order equation</p>
<div class="math notranslate nohighlight">
\[\frac{dy}{dx} = \frac{a F_3 (x, y, z) - c F_1 (x, y, z)}{c F_2 (x, y, z) -
b F_3 (x, y, z)}\]</div>
<p>where <span class="math notranslate nohighlight">\(z = \frac{1}{c} (C_1 - a x - b y)\)</span></p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="nonlinear-3-equations-order-1-type-4">
<h3>Nonlinear, 3 equations, Order 1, Type 4<a class="headerlink" href="#nonlinear-3-equations-order-1-type-4" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type4">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_3eq_order1_type4</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L6980-L7037"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type4" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math notranslate nohighlight">
\[x' = c z F_2 - b y F_3, \enspace y' = a x F_3 - c z F_1, \enspace z' = b y F_1 - a x F_2\]</div>
<p>where <span class="math notranslate nohighlight">\(F_n = F_n (x, y, z, t)\)</span></p>
<ol class="arabic simple">
<li><p>First integral:</p></li>
</ol>
<div class="math notranslate nohighlight">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is an arbitrary constant.</p>
<p>2. Assuming the function <span class="math notranslate nohighlight">\(F_n\)</span> is independent of <span class="math notranslate nohighlight">\(t\)</span>: <span class="math notranslate nohighlight">\(F_n = F_n (x, y, z)\)</span>. Then on
eliminating <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(z\)</span> from the first two equations of the system, one arrives at
the first-order equation</p>
<div class="math notranslate nohighlight">
\[\frac{dy}{dx} = \frac{a x F_3 (x, y, z) - c z F_1 (x, y, z)}
{c z F_2 (x, y, z) - b y F_3 (x, y, z)}\]</div>
<p>where <span class="math notranslate nohighlight">\(z = \pm \sqrt{\frac{1}{c} (C_1 - a x^{2} - b y^{2})}\)</span></p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="nonlinear-3-equations-order-1-type-5">
<h3>Nonlinear, 3 equations, Order 1, Type 5<a class="headerlink" href="#nonlinear-3-equations-order-1-type-5" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type5">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_nonlinear_3eq_order1_type5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">z</span></em>, <em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">eq</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L7039-L7088"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type5" title="Permalink to this definition">¶</a></dt>
<dd><div class="math notranslate nohighlight">
\[x' = x (c F_2 - b F_3), \enspace y' = y (a F_3 - c F_1), \enspace z' = z (b F_1 - a F_2)\]</div>
<p>where <span class="math notranslate nohighlight">\(F_n = F_n (x, y, z, t)\)</span> and are arbitrary functions.</p>
<p>First Integral:</p>
<div class="math notranslate nohighlight">
\[\left|x\right|^{a} \left|y\right|^{b} \left|z\right|^{c} = C_1\]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is an arbitrary constant. If the function <span class="math notranslate nohighlight">\(F_n\)</span> is independent of <span class="math notranslate nohighlight">\(t\)</span>,
then, by eliminating <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(z\)</span> from the first two equations of the system, one
arrives at a first-order equation.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf</a></p>
</dd></dl>

</div>
</div>
<div class="section" id="module-sympy.solvers.ode.ode">
<span id="information-on-the-ode-module"></span><h2>Information on the ode module<a class="headerlink" href="#module-sympy.solvers.ode.ode" title="Permalink to this headline">¶</a></h2>
<p>This module contains <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> and different helper
functions that it uses.</p>
<p><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> solves ordinary differential equations.
See the docstring on the various functions for their uses.  Note that partial
differential equations support is in <code class="docutils literal notranslate"><span class="pre">pde.py</span></code>.  Note that hint functions
have docstrings describing their various methods, but they are intended for
internal use.  Use <code class="docutils literal notranslate"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">hint=hint)</span></code> to solve an ODE using a
specific hint.  See also the docstring on
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p>
<p><strong>Functions in this module</strong></p>
<blockquote>
<div><p>These are the user functions in this module:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> - Solves ODEs.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> - Classifies ODEs into
possible hints for <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkodesol()</span></code></a> - Checks if an equation is the
solution to an ODE.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code></a> - Returns the
homogeneous order of an expression.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">infinitesimals()</span></code></a> - Returns the infinitesimals
of the Lie group of point transformations of an ODE, such that it is
invariant.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.checkinfsol" title="sympy.solvers.ode.checkinfsol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkinfsol()</span></code></a> - Checks if the given infinitesimals
are the actual infinitesimals of a first order ODE.</p></li>
</ul>
<p>These are the non-solver helper functions that are for internal use.  The
user should use the various options to
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> to obtain the functionality provided
by these functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> - Does all forms of ODE
simplification.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.ode.ode_sol_simplicity" title="sympy.solvers.ode.ode.ode_sol_simplicity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_sol_simplicity()</span></code></a> - A key function for
comparing solutions by simplicity.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code></a> - Simplifies arbitrary
constants.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.ode.constant_renumber" title="sympy.solvers.ode.ode.constant_renumber"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constant_renumber()</span></code></a> - Renumber arbitrary
constants.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.ode._handle_Integral" title="sympy.solvers.ode.ode._handle_Integral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_handle_Integral()</span></code></a> - Evaluate unevaluated
Integrals.</p></li>
</ul>
<p>See also the docstrings of these functions.</p>
</div></blockquote>
<p><strong>Currently implemented solver methods</strong></p>
<p>The following methods are implemented for solving ordinary differential
equations.  See the docstrings of the various hint functions for more
information on each (run <code class="docutils literal notranslate"><span class="pre">help(ode)</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li><p>1st order separable differential equations.</p></li>
<li><p>1st order differential equations whose coefficients or <span class="math notranslate nohighlight">\(dx\)</span> and <span class="math notranslate nohighlight">\(dy\)</span> are
functions homogeneous of the same order.</p></li>
<li><p>1st order exact differential equations.</p></li>
<li><p>1st order linear differential equations.</p></li>
<li><p>1st order Bernoulli differential equations.</p></li>
<li><p>Power series solutions for first order differential equations.</p></li>
<li><p>Lie Group method of solving first order differential equations.</p></li>
<li><p>2nd order Liouville differential equations.</p></li>
<li><p>Power series solutions for second order differential equations
at ordinary and regular singular points.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>th order differential equation that can be solved with algebraic
rearrangement and integration.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>th order linear homogeneous differential equation with constant
coefficients.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>th order linear inhomogeneous differential equation with constant
coefficients using the method of undetermined coefficients.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>th order linear inhomogeneous differential equation with constant
coefficients using the method of variation of parameters.</p></li>
</ul>
</div></blockquote>
<p><strong>Philosophy behind this module</strong></p>
<p>This module is designed to make it easy to add new ODE solving methods without
having to mess with the solving code for other methods.  The idea is that
there is a <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> function, which takes in
an ODE and tells you what hints, if any, will solve the ODE.  It does this
without attempting to solve the ODE, so it is fast.  Each solving method is a
hint, and it has its own function, named <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;</span></code>.  That function takes
in the ODE and any match expression gathered by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> and returns a solved result.  If
this result has any integrals in it, the hint function will return an
unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> class.
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, which is the user wrapper function
around all of this, will then call <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> on
the result, which, among other things, will attempt to solve the equation for
the dependent variable (the function we are solving for), simplify the
arbitrary constants in the expression, and evaluate any integrals, if the hint
allows it.</p>
<p><strong>How to add new solution methods</strong></p>
<p>If you have an ODE that you want <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> to be
able to solve, try to avoid adding special case code here.  Instead, try
finding a general method that will solve your ODE, as well as others.  This
way, the <a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code></a> module will become more robust, and
unhindered by special case hacks.  WolphramAlpha and Maple’s
DETools[odeadvisor] function are two resources you can use to classify a
specific ODE.  It is also better for a method to work with an <span class="math notranslate nohighlight">\(n\)</span>th order ODE
instead of only with specific orders, if possible.</p>
<p>To add a new method, there are a few things that you need to do.  First, you
need a hint name for your method.  Try to name your hint so that it is
unambiguous with all other methods, including ones that may not be implemented
yet.  If your method uses integrals, also include a <code class="docutils literal notranslate"><span class="pre">hint_Integral</span></code> hint.
If there is more than one way to solve ODEs with your method, include a hint
for each one, as well as a <code class="docutils literal notranslate"><span class="pre">&lt;hint&gt;_best</span></code> hint.  Your <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;_best()</span></code>
function should choose the best using min with <code class="docutils literal notranslate"><span class="pre">ode_sol_simplicity</span></code> as the
key argument.  See
<a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode.ode_1st_homogeneous_coeff_best"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code></a>, for example.
The function that uses your method will be called <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;()</span></code>, so the
hint must only use characters that are allowed in a Python function name
(alphanumeric characters and the underscore ‘<code class="docutils literal notranslate"><span class="pre">_</span></code>’ character).  Include a
function for every hint, except for <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hints
(<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> takes care of those automatically).
Hint names should be all lowercase, unless a word is commonly capitalized
(such as Integral or Bernoulli).  If you have a hint that you do not want to
run with <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code> that doesn’t have an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> counterpart (such
as a best hint that would defeat the purpose of <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>), you will
need to remove it manually in the <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> code.
See also the <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> docstring for
guidelines on writing a hint name.</p>
<p>Determine <em>in general</em> how the solutions returned by your method compare with
other methods that can potentially solve the same ODEs.  Then, put your hints
in the <a class="reference internal" href="#sympy.solvers.ode.allhints" title="sympy.solvers.ode.allhints"><code class="xref py py-data docutils literal notranslate"><span class="pre">allhints</span></code></a> tuple in the order that they
should be called.  The ordering of this tuple determines which hints are
default.  Note that exceptions are ok, because it is easy for the user to
choose individual hints with <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.  In
general, <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> variants should go at the end of the list, and
<code class="docutils literal notranslate"><span class="pre">_best</span></code> variants should go before the various hints they apply to.  For
example, the <code class="docutils literal notranslate"><span class="pre">undetermined_coefficients</span></code> hint comes before the
<code class="docutils literal notranslate"><span class="pre">variation_of_parameters</span></code> hint because, even though variation of parameters
is more general than undetermined coefficients, undetermined coefficients
generally returns cleaner results for the ODEs that it can solve than
variation of parameters does, and it does not require integration, so it is
much faster.</p>
<p>Next, you need to have a match expression or a function that matches the type
of the ODE, which you should put in <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>
(if the match function is more than just a few lines, like
<a class="reference internal" href="#sympy.solvers.ode.ode._undetermined_coefficients_match" title="sympy.solvers.ode.ode._undetermined_coefficients_match"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_undetermined_coefficients_match()</span></code></a>, it should go
outside of <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>).  It should match the
ODE without solving for it as much as possible, so that
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> remains fast and is not hindered by
bugs in solving code.  Be sure to consider corner cases.  For example, if your
solution method involves dividing by something, make sure you exclude the case
where that division will be 0.</p>
<p>In most cases, the matching of the ODE will also give you the various parts
that you need to solve it.  You should put that in a dictionary (<code class="docutils literal notranslate"><span class="pre">.match()</span></code>
will do this for you), and add that as <code class="docutils literal notranslate"><span class="pre">matching_hints['hint']</span> <span class="pre">=</span> <span class="pre">matchdict</span></code>
in the relevant part of <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>.
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> will then send this to
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, which will send it to your function as
the <code class="docutils literal notranslate"><span class="pre">match</span></code> argument.  Your function should be named <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;(eq,</span> <span class="pre">func,</span>
<span class="pre">order,</span> <span class="pre">match)`.</span>&#160; <span class="pre">If</span> <span class="pre">you</span> <span class="pre">need</span> <span class="pre">to</span> <span class="pre">send</span> <span class="pre">more</span> <span class="pre">information,</span> <span class="pre">put</span> <span class="pre">it</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``match</span></code>
dictionary.  For example, if you had to substitute in a dummy variable in
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> to match the ODE, you will need to
pass it to your function using the <span class="math notranslate nohighlight">\(match\)</span> dict to access it.  You can access
the independent variable using <code class="docutils literal notranslate"><span class="pre">func.args[0]</span></code>, and the dependent variable
(the function you are trying to solve for) as <code class="docutils literal notranslate"><span class="pre">func.func</span></code>.  If, while trying
to solve the ODE, you find that you cannot, raise <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> will catch this error with the <code class="docutils literal notranslate"><span class="pre">all</span></code>
meta-hint, rather than causing the whole routine to fail.</p>
<p>Add a docstring to your function that describes the method employed.  Like
with anything else in SymPy, you will need to add a doctest to the docstring,
in addition to real tests in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>.  Try to maintain consistency
with the other hint functions’ docstrings.  Add your method to the list at the
top of this docstring.  Also, add your method to <code class="docutils literal notranslate"><span class="pre">ode.rst</span></code> in the
<code class="docutils literal notranslate"><span class="pre">docs/src</span></code> directory, so that the Sphinx docs will pull its docstring into
the main SymPy documentation.  Be sure to make the Sphinx documentation by
running <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">html</span></code> from within the doc directory to verify that the
docstring formats correctly.</p>
<p>If your solution method involves integrating, use <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integral</span></code></a> instead of
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.  This allows the user to bypass
hard/slow integration by using the <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> variant of your hint.  In
most cases, calling <a class="reference internal" href="../core.html#sympy.core.basic.Basic.doit" title="sympy.core.basic.Basic.doit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.core.basic.Basic.doit()</span></code></a> will integrate your
solution.  If this is not the case, you will need to write special code in
<a class="reference internal" href="#sympy.solvers.ode.ode._handle_Integral" title="sympy.solvers.ode.ode._handle_Integral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_handle_Integral()</span></code></a>.  Arbitrary constants should be
symbols named <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, and so on.  All solution methods should return
an equality instance.  If you need an arbitrary number of arbitrary constants,
you can use <code class="docutils literal notranslate"><span class="pre">constants</span> <span class="pre">=</span> <span class="pre">numbered_symbols(prefix='C',</span> <span class="pre">cls=Symbol,</span> <span class="pre">start=1)</span></code>.
If it is possible to solve for the dependent function in a general way, do so.
Otherwise, do as best as you can, but do not call solve in your
<code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;()</span></code> function.  <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> will attempt
to solve the solution for you, so you do not need to do that.  Lastly, if your
ODE has a common simplification that can be applied to your solutions, you can
add a special case in <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> for it.  For
example, solutions returned from the <code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff</span></code> hints often
have many <a class="reference internal" href="../functions/elementary.html#sympy.functions.elementary.exponential.log" title="sympy.functions.elementary.exponential.log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log</span></code></a> terms, so
<a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> calls
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.logcombine" title="sympy.simplify.simplify.logcombine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logcombine()</span></code></a> on them (it also helps to write
the arbitrary constant as <code class="docutils literal notranslate"><span class="pre">log(C1)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">C1</span></code> in this case).  Also
consider common ways that you can rearrange your solution to have
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code></a> take better advantage of it.  It is
better to put simplification in <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> than in
your method, because it can then be turned off with the simplify flag in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.  If you have any extraneous
simplification in your function, be sure to only run it using <code class="docutils literal notranslate"><span class="pre">if</span>
<span class="pre">match.get('simplify',</span> <span class="pre">True):</span></code>, especially if it can be slow or if it can
reduce the domain of the solution.</p>
<p>Finally, as with every contribution to SymPy, your method will need to be
tested.  Add a test for each method in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>.  Follow the
conventions there, i.e., test the solver using <code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span>
<span class="pre">hint=your_hint)</span></code>, and also test the solution using
<a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkodesol()</span></code></a> (you can put these in a separate
tests and skip/XFAIL if it runs too slow/doesn’t work).  Be sure to call your
hint specifically in <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, that way the test
won’t be broken simply by the introduction of another matching hint.  If your
method works for higher order (&gt;1) ODEs, you will need to run <code class="docutils literal notranslate"><span class="pre">sol</span> <span class="pre">=</span>
<span class="pre">constant_renumber(sol,</span> <span class="pre">'C',</span> <span class="pre">1,</span> <span class="pre">order)</span></code> for each solution, where <code class="docutils literal notranslate"><span class="pre">order</span></code> is
the order of the ODE.  This is because <code class="docutils literal notranslate"><span class="pre">constant_renumber</span></code> renumbers the
arbitrary constants by printing order, which is platform dependent.  Try to
test every corner case of your solver, including a range of orders if it is a
<span class="math notranslate nohighlight">\(n\)</span>th order solver, but if your solver is slow, such as if it involves hard
integration, try to keep the test run time down.</p>
<p>Feel free to refactor existing hints to avoid duplicating code or creating
inconsistencies.  If you can show that your method exactly duplicates an
existing method, including in the simplicity and speed of obtaining the
solutions, then you can remove the old, less general method.  The existing
code is tested extensively in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>, so if anything is broken, one
of those tests will surely fail.</p>
<div class="section" id="internal-functions">
<h3>Internal functions<a class="headerlink" href="#internal-functions" title="Permalink to this headline">¶</a></h3>
<p>These functions are not intended for end-user use.</p>
<dl class="py function">
<dt id="sympy.solvers.ode.ode._undetermined_coefficients_match">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_undetermined_coefficients_match</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">func</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eq_homogeneous</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L4846-L5001"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._undetermined_coefficients_match" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a trial function match if undetermined coefficients can be applied
to <code class="docutils literal notranslate"><span class="pre">expr</span></code>, and <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
<p>A trial expression can be found for an expression for use with the method
of undetermined coefficients if the expression is an
additive/multiplicative combination of constants, polynomials in <span class="math notranslate nohighlight">\(x\)</span> (the
independent variable of expr), <span class="math notranslate nohighlight">\(\sin(a x + b)\)</span>, <span class="math notranslate nohighlight">\(\cos(a x + b)\)</span>, and
<span class="math notranslate nohighlight">\(e^{a x}\)</span> terms (in other words, it has a finite number of linearly
independent derivatives).</p>
<p>Note that you may still need to multiply each term returned here by
sufficient <span class="math notranslate nohighlight">\(x\)</span> to make it linearly independent with the solutions to the
homogeneous equation.</p>
<p>This is intended for internal use by <code class="docutils literal notranslate"><span class="pre">undetermined_coefficients</span></code> hints.</p>
<p>SymPy currently has no way to convert <span class="math notranslate nohighlight">\(\sin^n(x) \cos^m(y)\)</span> into a sum of
only <span class="math notranslate nohighlight">\(\sin(a x)\)</span> and <span class="math notranslate nohighlight">\(\cos(b x)\)</span> terms, so these are not implemented.  So,
for example, you will need to manually convert <span class="math notranslate nohighlight">\(\sin^2(x)\)</span> into <span class="math notranslate nohighlight">\([1 +
\cos(2 x)]/2\)</span> to properly apply the method of undetermined coefficients on
it.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">_undetermined_coefficients_match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_undetermined_coefficients_match</span><span class="p">(</span><span class="mi">9</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{&#39;test&#39;: True, &#39;trialset&#39;: {x*exp(x), exp(-x), exp(x)}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_undetermined_coefficients_match</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{&#39;test&#39;: False}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.ode.ode._handle_Integral">
<code class="sig-prename descclassname">sympy.solvers.ode.ode.</code><code class="sig-name descname">_handle_Integral</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">hint</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/ode/ode.py#L2843-L2866"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode._handle_Integral" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a solution with Integrals in it into an actual solution.</p>
<p>For most hints, this simply runs <code class="docutils literal notranslate"><span class="pre">expr.doit()</span></code>.</p>
</dd></dl>

</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ODE</a><ul>
<li><a class="reference internal" href="#user-functions">User Functions</a><ul>
<li><a class="reference internal" href="#dsolve">dsolve</a></li>
<li><a class="reference internal" href="#dsolve-system">dsolve_system</a></li>
<li><a class="reference internal" href="#classify-ode">classify_ode</a></li>
<li><a class="reference internal" href="#checkodesol">checkodesol</a></li>
<li><a class="reference internal" href="#homogeneous-order">homogeneous_order</a></li>
<li><a class="reference internal" href="#infinitesimals">infinitesimals</a></li>
<li><a class="reference internal" href="#checkinfsol">checkinfsol</a></li>
<li><a class="reference internal" href="#constantsimp">constantsimp</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hint-functions">Hint Functions</a><ul>
<li><a class="reference internal" href="#allhints">allhints</a></li>
<li><a class="reference internal" href="#odesimp">odesimp</a></li>
<li><a class="reference internal" href="#constant-renumber">constant_renumber</a></li>
<li><a class="reference internal" href="#sol-simplicity">sol_simplicity</a></li>
<li><a class="reference internal" href="#factorable">factorable</a></li>
<li><a class="reference internal" href="#st-exact">1st_exact</a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-best">1st_homogeneous_coeff_best</a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-subs-dep-div-indep">1st_homogeneous_coeff_subs_dep_div_indep</a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-subs-indep-div-dep">1st_homogeneous_coeff_subs_indep_div_dep</a></li>
<li><a class="reference internal" href="#st-linear">1st_linear</a></li>
<li><a class="reference internal" href="#nd-linear-airy">2nd_linear_airy</a></li>
<li><a class="reference internal" href="#nd-linear-bessel">2nd_linear_bessel</a></li>
<li><a class="reference internal" href="#bernoulli">Bernoulli</a></li>
<li><a class="reference internal" href="#liouville">Liouville</a></li>
<li><a class="reference internal" href="#riccati-special-minus2">Riccati_special_minus2</a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-homogeneous">nth_linear_constant_coeff_homogeneous</a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-undetermined-coefficients">nth_linear_constant_coeff_undetermined_coefficients</a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-variation-of-parameters">nth_linear_constant_coeff_variation_of_parameters</a></li>
<li><a class="reference internal" href="#nth-algebraic">nth_algebraic</a></li>
<li><a class="reference internal" href="#nth-order-reducible">nth_order_reducible</a></li>
<li><a class="reference internal" href="#separable">separable</a></li>
<li><a class="reference internal" href="#almost-linear">almost_linear</a></li>
<li><a class="reference internal" href="#linear-coefficients">linear_coefficients</a></li>
<li><a class="reference internal" href="#separable-reduced">separable_reduced</a></li>
<li><a class="reference internal" href="#lie-group">lie_group</a></li>
<li><a class="reference internal" href="#st-power-series">1st_power_series</a></li>
<li><a class="reference internal" href="#nd-power-series-ordinary">2nd_power_series_ordinary</a></li>
<li><a class="reference internal" href="#nd-power-series-regular">2nd_power_series_regular</a></li>
</ul>
</li>
<li><a class="reference internal" href="#lie-heuristics">Lie heuristics</a><ul>
<li><a class="reference internal" href="#abaco1-simple">abaco1_simple</a></li>
<li><a class="reference internal" href="#abaco1-product">abaco1_product</a></li>
<li><a class="reference internal" href="#bivariate">bivariate</a></li>
<li><a class="reference internal" href="#chi">chi</a></li>
<li><a class="reference internal" href="#abaco2-similar">abaco2_similar</a></li>
<li><a class="reference internal" href="#function-sum">function_sum</a></li>
<li><a class="reference internal" href="#abaco2-unique-unknown">abaco2_unique_unknown</a></li>
<li><a class="reference internal" href="#abaco2-unique-general">abaco2_unique_general</a></li>
<li><a class="reference internal" href="#linear">linear</a></li>
</ul>
</li>
<li><a class="reference internal" href="#system-of-odes">System of ODEs</a><ul>
<li><a class="reference internal" href="#linear-2-equations-order-1-type-6">Linear, 2 equations, Order 1, Type 6</a></li>
<li><a class="reference internal" href="#linear-2-equations-order-1-type-7">Linear, 2 equations, Order 1, Type 7</a></li>
<li><a class="reference internal" href="#linear-ode-to-matrix">Linear ODE to matrix</a></li>
<li><a class="reference internal" href="#canonical-equations-converter">Canonical Equations Converter</a></li>
<li><a class="reference internal" href="#linodesolve-systems-information">LinODESolve Systems Information</a></li>
<li><a class="reference internal" href="#matrix-exponential-jordan-form">Matrix Exponential Jordan Form</a></li>
<li><a class="reference internal" href="#matrix-exponential">Matrix Exponential</a></li>
<li><a class="reference internal" href="#linear-n-equations-order-1-solver">Linear, n equations, Order 1 Solver</a></li>
<li><a class="reference internal" href="#nonlinear-2-equations-order-1-type-1">Nonlinear, 2 equations, Order 1, Type 1</a></li>
<li><a class="reference internal" href="#nonlinear-2-equations-order-1-type-2">Nonlinear, 2 equations, Order 1, Type 2</a></li>
<li><a class="reference internal" href="#nonlinear-2-equations-order-1-type-3">Nonlinear, 2 equations, Order 1, Type 3</a></li>
<li><a class="reference internal" href="#nonlinear-2-equations-order-1-type-4">Nonlinear, 2 equations, Order 1, Type 4</a></li>
<li><a class="reference internal" href="#nonlinear-2-equations-order-1-type-5">Nonlinear, 2 equations, Order 1, Type 5</a></li>
<li><a class="reference internal" href="#nonlinear-3-equations-order-1-type-1">Nonlinear, 3 equations, Order 1, Type 1</a></li>
<li><a class="reference internal" href="#nonlinear-3-equations-order-1-type-2">Nonlinear, 3 equations, Order 1, Type 2</a></li>
<li><a class="reference internal" href="#nonlinear-3-equations-order-1-type-3">Nonlinear, 3 equations, Order 1, Type 3</a></li>
<li><a class="reference internal" href="#nonlinear-3-equations-order-1-type-4">Nonlinear, 3 equations, Order 1, Type 4</a></li>
<li><a class="reference internal" href="#nonlinear-3-equations-order-1-type-5">Nonlinear, 3 equations, Order 1, Type 5</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-sympy.solvers.ode.ode">Information on the ode module</a><ul>
<li><a class="reference internal" href="#internal-functions">Internal functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../numeric-computation.html"
                        title="previous chapter">Numeric Computation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../parsing.html"
                        title="next chapter">Parsing</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/solvers/ode.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../parsing.html" title="Parsing"
             >next</a> |</li>
        <li class="right" >
          <a href="../numeric-computation.html" title="Numeric Computation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ODE</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 SymPy Development Team.
      Last updated on Oct 01, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>