<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Scalar and Vector Field Functionality &mdash; SymPy 0.7.5-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.5-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.5-git documentation" href="../../../index.html" />
    <link rel="up" title="The Physics Vector Module" href="index.html" />
    <link rel="next" title="Essential Classes" href="api/classes.html" />
    <link rel="prev" title="Potential Issues/Advanced Topics/Future Features in Physics/Vector Module" href="advanced.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api/classes.html" title="Essential Classes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Potential Issues/Advanced Topics/Future Features in Physics/Vector Module"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.5-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >SymPy Modules Reference</a> &raquo;</li>
          <li><a href="../index.html" >Physics Module</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">The Physics Vector Module</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="scalar-and-vector-field-functionality">
<h1>Scalar and Vector Field Functionality<a class="headerlink" href="#scalar-and-vector-field-functionality" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="vectors-and-scalars">
<h3>Vectors and Scalars<a class="headerlink" href="#vectors-and-scalars" title="Permalink to this headline">¶</a></h3>
<p>In physics, we deal with two kinds of quantities – scalars and vectors.</p>
<p>A scalar is an entity which only has a magnitude – no direction. Examples of
scalar quantities include mass, electric charge, temperature, distance, etc.</p>
<p>A vector, on the other hand, is an entity that is characterized by a
magnitude and a direction. Examples of vector quantities are displacement,
velocity, magnetic field, etc.</p>
<p>A scalar can be depicted just by a number, for e.g. a temperature of 300 K.
On the other hand, vectorial quantities like acceleration are usually denoted
by a vector. Given a vector <span class="math">\(\mathbf{V}\)</span>, the magnitude of the
corresponding quantity can be calculated as the magnitude of the vector
itself <span class="math">\(\Vert \mathbf{V} \Vert\)</span>, while the direction would be specified
by a unit vector in the direction of the original vector,
<span class="math">\(\mathbf{\hat{V}} = \frac{\mathbf{V}}{\Vert \mathbf{V} \Vert}\)</span>.</p>
<p>For example, consider a displacement of
<span class="math">\((3\mathbf{\hat{i}} + 4\mathbf{\hat{j}} + 5\mathbf{\hat{k}})\)</span> m,
where , as per standard convention, <span class="math">\(\mathbf{\hat{i}}\)</span>,
<span class="math">\(\mathbf{\hat{j}}\)</span> and <span class="math">\(\mathbf{\hat{k}}\)</span> represent unit vectors
in the <span class="math">\(\mathbf{X}\)</span>, <span class="math">\(\mathbf{Y}\)</span> and <span class="math">\(\mathbf{Z}\)</span>
directions respectively. Therefore, it can be concluded that the distance
traveled is
<span class="math">\(\Vert 3\mathbf{\hat{i}} + 4\mathbf{\hat{j}} + 5\mathbf{\hat{k}} \Vert\)</span>
m = <span class="math">\(5\sqrt{2}\)</span> m. The direction of travel is given by the unit vector
<span class="math">\(\frac{3}{5\sqrt{2}}\mathbf{\hat{i}} +
\frac{4}{5\sqrt{2}}\mathbf{\hat{j}} + \frac{5}{5\sqrt{2}}\mathbf{\hat{k}}\)</span>.</p>
</div>
<div class="section" id="fields">
<h3>Fields<a class="headerlink" href="#fields" title="Permalink to this headline">¶</a></h3>
<p>In general, a <span class="math">\(field\)</span> is a vector or scalar quantity that can be
specified everywhere in space as a function of position (Note that in general
a field may also be dependent on time and other custom variables). In this
module, we deal with 3-dimensional spaces only. Hence, a field is defined as
a function of the <span class="math">\(x\)</span>, <span class="math">\(y\)</span> and <span class="math">\(z\)</span> coordinates corresponding
to a location in 3D space.</p>
<p>For example, temperate in 3 dimensional space (a temperature field) can be
written as <span class="math">\(T(x, y, z)\)</span> – a scalar function of the position.
An example of a scalar field in electromagnetism is the electric potential.</p>
<p>In a similar manner, a vector field can be defined as a vectorial function
of the location <span class="math">\((x, y, z)\)</span> of any point in space.</p>
<p>For instance, every point on the earth may be considered to be in the
gravitational force field of the earth. We may specify the field by the
magnitude and the direction of acceleration due to gravity
(i.e. force per unit mass ) <span class="math">\(g(x, y, z)\)</span> at every point in space.</p>
<p>To give an example from electromagnetism, consider an electric potential
of form <span class="math">\(2{x}^{2}y\)</span>, a scalar field in 3D space. The corresponding
conservative electric field can be computed as the gradient of the electric
potential function, and expressed as <span class="math">\(4xy\mathbf{\hat{i}} +
2{x}^{2}\mathbf{\hat{j}}\)</span>.
The magnitude of this electric field can in turn be expressed
as a scalar field of the form
<span class="math">\(\sqrt{4{x}^{4} + 16{x}^{2}{y}^{2}}\)</span>.</p>
</div>
</div>
<div class="section" id="implementation-of-fields-in-sympy-physics-vector">
<h2>Implementation of fields in sympy.physics.vector<a class="headerlink" href="#implementation-of-fields-in-sympy-physics-vector" title="Permalink to this headline">¶</a></h2>
<p>In sympy.physics.vector, every <tt class="xref py py-mod docutils literal"><span class="pre">ReferenceFrame</span></tt> instance is assigned basis
vectors corresponding to the <span class="math">\(X\)</span>, <span class="math">\(Y\)</span> and
<span class="math">\(Z\)</span> directions. These can be accessed using the attributes
named <tt class="xref py py-mod docutils literal"><span class="pre">x</span></tt>, <tt class="xref py py-mod docutils literal"><span class="pre">y</span></tt> and <tt class="xref py py-mod docutils literal"><span class="pre">z</span></tt> respectively. Hence, to define a vector
<span class="math">\(\mathbf{v}\)</span> of the form
<span class="math">\(3\mathbf{\hat{i}} + 4\mathbf{\hat{j}} + 5\mathbf{\hat{k}}\)</span> with
respect to a given frame <span class="math">\(\mathbf{R}\)</span>, you would do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span>
</pre></div>
</div>
<p>Vector math and basic calculus operations with respect to vectors have
already been elaborated upon in other sections of this module&#8217;s
documentation.</p>
<p>On the other hand, base scalars (or coordinate variables) are implemented
as special <tt class="xref py py-mod docutils literal"><span class="pre">SymPy</span></tt> <tt class="xref py py-mod docutils literal"><span class="pre">Symbol</span></tt> s assigned to every frame, one for each
direction from <span class="math">\(X\)</span>, <span class="math">\(Y\)</span> and <span class="math">\(Z\)</span>. For a frame
<tt class="xref py py-mod docutils literal"><span class="pre">R</span></tt>, the <span class="math">\(X\)</span>, <span class="math">\(Y\)</span> and <span class="math">\(Z\)</span>
base scalar <tt class="xref py py-mod docutils literal"><span class="pre">Symbol</span></tt> s can be accessed using the <tt class="xref py py-mod docutils literal"><span class="pre">R[0]</span></tt>, <tt class="xref py py-mod docutils literal"><span class="pre">R[1]</span></tt>
and <tt class="xref py py-mod docutils literal"><span class="pre">R[2]</span></tt> expressions respectively.</p>
<p>Therefore, to generate the expression for the aforementioned electric
potential field <span class="math">\(2{x}^{2}y\)</span>, you would have to do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span>
<span class="go">2*R_x**2*R_y</span>
</pre></div>
</div>
<p>In string representation, <tt class="xref py py-mod docutils literal"><span class="pre">R_x</span></tt> denotes the <span class="math">\(X\)</span> base
scalar assigned to <tt class="xref py py-mod docutils literal"><span class="pre">ReferenceFrame</span></tt> <tt class="xref py py-mod docutils literal"><span class="pre">R</span></tt>. Essentially, <tt class="xref py py-mod docutils literal"><span class="pre">R_x</span></tt> is
the string representation of <tt class="xref py py-mod docutils literal"><span class="pre">R[0]</span></tt>.</p>
<p>Scalar fields can be treated just as any other <tt class="xref py py-mod docutils literal"><span class="pre">SymPy</span></tt> expression,
for any math/calculus functionality. Hence, to differentiate the above
electric potential with respect to <span class="math">\(x\)</span> (i.e. <tt class="xref py py-mod docutils literal"><span class="pre">R[0]</span></tt>), you would
have to use the <tt class="xref py py-mod docutils literal"><span class="pre">diff</span></tt> method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">4*R_x*R_y</span>
</pre></div>
</div>
<p>Like vectors (and vector fields), scalar fields can also be re-expressed in
other frames of reference, apart from the one they were defined in – assuming
that an orientation relationship exists between the concerned frames. This
can be done using the <tt class="xref py py-mod docutils literal"><span class="pre">express</span></tt> method, in a way similar to vectors -
but with the <tt class="xref py py-mod docutils literal"><span class="pre">variables</span></tt> parameter set to <tt class="xref py py-mod docutils literal"><span class="pre">True</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">dynamicsymbols</span><span class="p">,</span> <span class="n">express</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">dynamicsymbols</span><span class="p">(</span><span class="s">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">orientnew</span><span class="p">(</span><span class="s">&#39;R1&#39;</span><span class="p">,</span> <span class="n">rot_type</span> <span class="o">=</span> <span class="s">&#39;Axis&#39;</span><span class="p">,</span> <span class="n">amounts</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">express</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">2*(R1_x*sin(q(t)) + R1_y*cos(q(t)))*(R1_x*cos(q(t)) - R1_y*sin(q(t)))**2</span>
</pre></div>
</div>
<p>Moreover, considering scalars can also be functions of time just as vectors,
differentiation with respect to time is also possible. Depending on the
<tt class="xref py py-mod docutils literal"><span class="pre">Symbol</span></tt> s present in the expression and the frame with respect to which
the time differentiation is being done, the output will change/remain the same.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">dynamicsymbols</span><span class="p">(</span><span class="s">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">orientnew</span><span class="p">(</span><span class="s">&#39;R1&#39;</span><span class="p">,</span> <span class="n">rot_type</span> <span class="o">=</span> <span class="s">&#39;Axis&#39;</span><span class="p">,</span> <span class="n">amounts</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">time_derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time_derivative</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time_derivative</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R1</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
<span class="go">(R1_x*cos(q(t)) - R1_y*sin(q(t)))*(3*R1_x**2*cos(2*q(t)) - R1_x**2 -</span>
<span class="go">6*R1_x*R1_y*sin(2*q(t)) - 3*R1_y**2*cos(2*q(t)) - R1_y**2)*Derivative(q(t), t)</span>
</pre></div>
</div>
</div>
<div class="section" id="field-operators-and-other-related-functions">
<h2>Field operators and other related functions<a class="headerlink" href="#field-operators-and-other-related-functions" title="Permalink to this headline">¶</a></h2>
<p>Here we describe some basic field-related functionality implemented in
sympy.physics.vector</p>
<div class="section" id="curl">
<h3>Curl<a class="headerlink" href="#curl" title="Permalink to this headline">¶</a></h3>
<p>A curl is a mathematical operator that describes an infinitesimal rotation of a
vector in 3D space. The direction is determined by the right-hand rule (along the
axis of rotation), and the magnitude is given by the magnitude of rotation.</p>
<p>In the 3D Cartesian system, the curl of a 3D vector <span class="math">\(\mathbf{F}\)</span> ,
denoted by <span class="math">\(\nabla \times \mathbf{F}\)</span> is given by -</p>
<p><span class="math">\(\nabla \times \mathbf{F} = \left(\frac{\partial F_z}{\partial y}  -
\frac{\partial F_y}{\partial z}\right) \mathbf{\hat{i}} +
\left(\frac{\partial F_x}{\partial z} -
\frac{\partial F_z}{\partial x}\right) \mathbf{\hat{j}} +
\left(\frac{\partial F_y}{\partial x} -
\frac{\partial F_x}{\partial y}\right) \mathbf{\hat{k}}\)</span></p>
<p>where <span class="math">\(F_x\)</span> denotes the <span class="math">\(X\)</span> component of vector <span class="math">\(\mathbf{F}\)</span>.</p>
<p>To compute the curl of a vector field in <tt class="xref py py-mod docutils literal"><span class="pre">physics.vector</span></tt>, you would do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">curl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curl</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">R_x*R_y*R.y - R_x*R_z*R.z</span>
</pre></div>
</div>
</div>
<div class="section" id="divergence">
<h3>Divergence<a class="headerlink" href="#divergence" title="Permalink to this headline">¶</a></h3>
<p>Divergence is a vector operator that measures the magnitude of a vector field&#8217;s
source or sink at a given point, in terms of a signed scalar.</p>
<p>The divergence operator always returns a scalar after operating on a vector.</p>
<p>In the 3D Cartesian system, the divergence of a 3D vector <span class="math">\(\mathbf{F}\)</span>,
denoted by <span class="math">\(\nabla\cdot\mathbf{F}\)</span> is given by -</p>
<p><span class="math">\(\nabla\cdot\mathbf{F} =\frac{\partial U}{\partial x}
+\frac{\partial V}{\partial y}
+\frac{\partial W}{\partial z
}\)</span></p>
<p>where <span class="math">\(U\)</span>, <span class="math">\(V\)</span> and <span class="math">\(W\)</span> denote the <span class="math">\(X\)</span>, <span class="math">\(Y\)</span> and
<span class="math">\(Z\)</span> components of <span class="math">\(\mathbf{F}\)</span> respectively.</p>
<p>To compute the divergence of a vector field in <tt class="xref py py-mod docutils literal"><span class="pre">physics.vector</span></tt>, you
would do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">divergence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">+</span><span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">R_x*R_y + R_x*R_z + R_y*R_z</span>
</pre></div>
</div>
</div>
<div class="section" id="gradient">
<h3>Gradient<a class="headerlink" href="#gradient" title="Permalink to this headline">¶</a></h3>
<p>Consider a scalar field <span class="math">\(f(x, y, z)\)</span> in 3D space. The gradient of this field
is defined as the vector of the 3 partial derivatives of <span class="math">\(f\)</span> with respect to
<span class="math">\(x\)</span>, <span class="math">\(y\)</span> and <span class="math">\(z\)</span> in the <span class="math">\(X\)</span>, <span class="math">\(Y\)</span> and <span class="math">\(Z\)</span>
directions respectively.</p>
<p>In the 3D Cartesian system, the divergence of a scalar field <span class="math">\(f\)</span>,
denoted by <span class="math">\(\nabla f\)</span> is given by -</p>
<p><span class="math">\(\nabla f = \frac{\partial f}{\partial x} \mathbf{\hat{i}} +
\frac{\partial f}{\partial y}  \mathbf{\hat{j}} +
\frac{\partial f}{\partial z} \mathbf{\hat{k}}\)</span></p>
<p>To compute the divergence of a vector field in <tt class="xref py py-mod docutils literal"><span class="pre">physics.vector</span></tt>, you
would do</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">gradient</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient</span><span class="p">(</span><span class="n">scalar_field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">R_y*R_z*R.x + R_x*R_z*R.y + R_x*R_y*R.z</span>
</pre></div>
</div>
</div>
<div class="section" id="conservative-and-solenoidal-fields">
<h3>Conservative and Solenoidal fields<a class="headerlink" href="#conservative-and-solenoidal-fields" title="Permalink to this headline">¶</a></h3>
<p>In vector calculus, a conservative field is a field that is the gradient of
some scalar field. Conservative fields have the property that their line
integral over any path depends only on the end-points, and is independent
of the path between them.
A conservative vector field is also said to be &#8216;irrotational&#8217;, since the
curl of a conservative field is always zero.</p>
<p>In physics, conservative fields represent forces in physical systems where
energy is conserved.</p>
<p>To check if a vector field is conservative in <tt class="xref py py-mod docutils literal"><span class="pre">physics.vector</span></tt>, use
the <tt class="xref py py-mod docutils literal"><span class="pre">is_conservative</span></tt> function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">is_conservative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_conservative</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curl</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>A solenoidal field, on the other hand, is a vector field whose divergence
is zero at all points in space.</p>
<p>To check if a vector field is solenoidal in <tt class="xref py py-mod docutils literal"><span class="pre">physics.vector</span></tt>, use
the <tt class="xref py py-mod docutils literal"><span class="pre">is_solenoidal</span></tt> function.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">is_solenoidal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_solenoidal</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</div>
<div class="section" id="scalar-potential-functions">
<h3>Scalar potential functions<a class="headerlink" href="#scalar-potential-functions" title="Permalink to this headline">¶</a></h3>
<p>We have previously mentioned that every conservative field can be defined as
the gradient of some scalar field. This scalar field is also called the &#8216;scalar
potential field&#8217; corresponding to the aforementioned conservative field.</p>
<p>The <tt class="xref py py-mod docutils literal"><span class="pre">scalar_potential</span></tt> function in <tt class="xref py py-mod docutils literal"><span class="pre">physics.vector</span></tt> calculates the
scalar potential field corresponding to a given conservative vector field in
3D space - minus the extra constant of integration, of course.</p>
<p>Example of usage -</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">scalar_potential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conservative_field</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_potential</span><span class="p">(</span><span class="n">conservative_field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">2*R_x**2*R_y*R_z</span>
</pre></div>
</div>
<p>Providing a non-conservative vector field as an argument to
<tt class="xref py py-mod docutils literal"><span class="pre">scalar_potential</span></tt> raises a <tt class="xref py py-mod docutils literal"><span class="pre">ValueError</span></tt>.</p>
<p>The scalar potential difference, or simply &#8216;potential difference&#8217;,
corresponding to a conservative vector field can be defined as the difference
between the values of its scalar potential function at two points in space.
This is useful in calculating a line integral with respect to a conservative
function, since it depends only on the endpoints of the path.</p>
<p>This computation is performed as follows in <tt class="xref py py-mod docutils literal"><span class="pre">physics.vector</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">Point</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">scalar_potential_difference</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="s">&#39;O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">locatenew</span><span class="p">(</span><span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectfield</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_potential_difference</span><span class="p">(</span><span class="n">vectfield</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>If provided with a scalar expression instead of a vector field,
<tt class="xref py py-mod docutils literal"><span class="pre">scalar_potential_difference</span></tt> returns the difference between the values
of that scalar field at the two given points in space.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Scalar and Vector Field Functionality</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#vectors-and-scalars">Vectors and Scalars</a></li>
<li><a class="reference internal" href="#fields">Fields</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-fields-in-sympy-physics-vector">Implementation of fields in sympy.physics.vector</a></li>
<li><a class="reference internal" href="#field-operators-and-other-related-functions">Field operators and other related functions</a><ul>
<li><a class="reference internal" href="#curl">Curl</a></li>
<li><a class="reference internal" href="#divergence">Divergence</a></li>
<li><a class="reference internal" href="#gradient">Gradient</a></li>
<li><a class="reference internal" href="#conservative-and-solenoidal-fields">Conservative and Solenoidal fields</a></li>
<li><a class="reference internal" href="#scalar-potential-functions">Scalar potential functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="advanced.html"
                        title="previous chapter">Potential Issues/Advanced Topics/Future Features in Physics/Vector Module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api/classes.html"
                        title="next chapter">Essential Classes</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../_sources/modules/physics/vector/fields.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api/classes.html" title="Essential Classes"
             >next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Potential Issues/Advanced Topics/Future Features in Physics/Vector Module"
             >previous</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.5-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >SymPy Modules Reference</a> &raquo;</li>
          <li><a href="../index.html" >Physics Module</a> &raquo;</li>
          <li><a href="index.html" >The Physics Vector Module</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014 SymPy Development Team.
      Last updated on Jun 24, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>