
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Kane’s Method &amp; Lagrange’s Method (Docstrings) &#8212; SymPy 1.6 documentation</title>
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <link rel="shortcut icon" href="../../../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/physics/mechanics/api/kane_lagrange.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="SymbolicSystem (Docstrings)" href="system.html" />
    <link rel="prev" title="Masses, Inertias &amp; Particles, RigidBodys (Docstrings)" href="part_bod.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="system.html" title="SymbolicSystem (Docstrings)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="part_bod.html" title="Masses, Inertias &amp; Particles, RigidBodys (Docstrings)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SymPy 1.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" >Physics</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" accesskey="U">Classical Mechanics</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="kane-s-method-lagrange-s-method-docstrings">
<span id="kane-lagrange"></span><h1>Kane’s Method &amp; Lagrange’s Method (Docstrings)<a class="headerlink" href="#kane-s-method-lagrange-s-method-docstrings" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-sympy.physics.mechanics.kane">
<span id="kanemethod"></span><h2>KaneMethod<a class="headerlink" href="#module-sympy.physics.mechanics.kane" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="sympy.physics.mechanics.kane.KanesMethod">
<em class="property">class </em><code class="sig-prename descclassname">sympy.physics.mechanics.kane.</code><code class="sig-name descname">KanesMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame</span></em>, <em class="sig-param"><span class="n">q_ind</span></em>, <em class="sig-param"><span class="n">u_ind</span></em>, <em class="sig-param"><span class="n">kd_eqs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">q_dependent</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">configuration_constraints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">u_dependent</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">velocity_constraints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">acceleration_constraints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">u_auxiliary</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/kane.py#L19-L660"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Kane’s method object.</p>
<p>This object is used to do the “book-keeping” as you go through and form
equations of motion in the way Kane presents in:
Kane, T., Levinson, D. Dynamics Theory and Applications. 1985 McGraw-Hill</p>
<p>The attributes are for equations in the form [M] udot = forcing.</p>
<p class="rubric">Examples</p>
<p>This is a simple example for a one degree of freedom translational
spring-mass-damper.</p>
<p>In this example, we first need to do the kinematics.
This involves creating generalized speeds and coordinates and their
derivatives.
Then we create a point and set its velocity in a frame.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.mechanics</span> <span class="kn">import</span> <span class="n">dynamicsymbols</span><span class="p">,</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.mechanics</span> <span class="kn">import</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Particle</span><span class="p">,</span> <span class="n">KanesMethod</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">dynamicsymbols</span><span class="p">(</span><span class="s1">&#39;q u&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qd</span><span class="p">,</span> <span class="n">ud</span> <span class="o">=</span> <span class="n">dynamicsymbols</span><span class="p">(</span><span class="s1">&#39;q u&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;m c k&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">set_vel</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">u</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we need to arrange/store information in the way that KanesMethod
requires.  The kinematic differential equations need to be stored in a
dict.  A list of forces/torques must be constructed, where each entry in
the list is a (Point, Vector) or (ReferenceFrame, Vector) tuple, where the
Vectors represent the Force or Torque.
Next a particle needs to be created, and it needs to have a point and mass
assigned to it.
Finally, a list of all bodies and particles needs to be created.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kd</span> <span class="o">=</span> <span class="p">[</span><span class="n">qd</span> <span class="o">-</span> <span class="n">u</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FL</span> <span class="o">=</span> <span class="p">[(</span><span class="n">P</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">k</span> <span class="o">*</span> <span class="n">q</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">x</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pa</span> <span class="o">=</span> <span class="n">Particle</span><span class="p">(</span><span class="s1">&#39;pa&#39;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BL</span> <span class="o">=</span> <span class="p">[</span><span class="n">pa</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally we can generate the equations of motion.
First we create the KanesMethod object and supply an inertial frame,
coordinates, generalized speeds, and the kinematic differential equations.
Additional quantities such as configuration and motion constraints,
dependent coordinates and speeds, and auxiliary speeds are also supplied
here (see the online documentation).
Next we form FR* and FR to complete: Fr + Fr* = 0.
We have the equations of motion at this point.
It makes sense to rearrange them though, so we calculate the mass matrix and
the forcing terms, for E.o.M. in the form: [MM] udot = forcing, where MM is
the mass matrix, udot is a vector of the time derivatives of the
generalized speeds, and forcing is a vector representing “forcing” terms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">KM</span> <span class="o">=</span> <span class="n">KanesMethod</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">q_ind</span><span class="o">=</span><span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">u_ind</span><span class="o">=</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">kd_eqs</span><span class="o">=</span><span class="n">kd</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">frstar</span><span class="p">)</span> <span class="o">=</span> <span class="n">KM</span><span class="o">.</span><span class="n">kanes_equations</span><span class="p">(</span><span class="n">BL</span><span class="p">,</span> <span class="n">FL</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MM</span> <span class="o">=</span> <span class="n">KM</span><span class="o">.</span><span class="n">mass_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">forcing</span> <span class="o">=</span> <span class="n">KM</span><span class="o">.</span><span class="n">forcing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rhs</span> <span class="o">=</span> <span class="n">MM</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">*</span> <span class="n">forcing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rhs</span>
<span class="go">Matrix([[(-c*u(t) - k*q(t))/m]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">KM</span><span class="o">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">A_and_B</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">Matrix([</span>
<span class="go">[   0,    1],</span>
<span class="go">[-k/m, -c/m]])</span>
</pre></div>
</div>
<p>Please look at the documentation pages for more information on how to
perform linearization and how to deal with dependent coordinates &amp; speeds,
and how do deal with bringing non-contributing forces into evidence.</p>
<p class="rubric">Attributes</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>q, u</p></td>
<td><p>(Matrix) Matrices of the generalized coordinates and speeds</p></td>
</tr>
<tr class="row-even"><td><p>bodylist</p></td>
<td><p>(iterable) Iterable of Point and RigidBody objects in the system.</p></td>
</tr>
<tr class="row-odd"><td><p>forcelist</p></td>
<td><p>(iterable) Iterable of (Point, vector) or (ReferenceFrame, vector) tuples describing the forces on the system.</p></td>
</tr>
<tr class="row-even"><td><p>auxiliary</p></td>
<td><p>(Matrix) If applicable, the set of auxiliary Kane’s equations used to solve for non-contributing forces.</p></td>
</tr>
<tr class="row-odd"><td><p>mass_matrix</p></td>
<td><p>(Matrix) The system’s mass matrix</p></td>
</tr>
<tr class="row-even"><td><p>forcing</p></td>
<td><p>(Matrix) The system’s forcing vector</p></td>
</tr>
<tr class="row-odd"><td><p>mass_matrix_full</p></td>
<td><p>(Matrix) The “mass matrix” for the u’s and q’s</p></td>
</tr>
<tr class="row-even"><td><p>forcing_full</p></td>
<td><p>(Matrix) The “forcing vector” for the u’s and q’s</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.auxiliary_eqs">
<em class="property">property </em><code class="sig-name descname">auxiliary_eqs</code><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.auxiliary_eqs" title="Permalink to this definition">¶</a></dt>
<dd><p>A matrix containing the auxiliary equations.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.forcing">
<em class="property">property </em><code class="sig-name descname">forcing</code><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.forcing" title="Permalink to this definition">¶</a></dt>
<dd><p>The forcing vector of the system.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.forcing_full">
<em class="property">property </em><code class="sig-name descname">forcing_full</code><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.forcing_full" title="Permalink to this definition">¶</a></dt>
<dd><p>The forcing vector of the system, augmented by the kinematic
differential equations.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.kanes_equations">
<code class="sig-name descname">kanes_equations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bodies</span></em>, <em class="sig-param"><span class="n">loads</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/kane.py#L508-L562"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.kanes_equations" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to form Kane’s equations, Fr + Fr* = 0.</p>
<p>Returns (Fr, Fr*). In the case where auxiliary generalized speeds are
present (say, s auxiliary speeds, o generalized speeds, and m motion
constraints) the length of the returned vectors will be o - m + s in
length. The first o - m equations will be the constrained Kane’s
equations, then the s auxiliary Kane’s equations. These auxiliary
equations can be accessed with the auxiliary_eqs().</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bodies</strong> : iterable</p>
<blockquote>
<div><p>An iterable of all RigidBody’s and Particle’s in the system.
A system must have at least one body.</p>
</div></blockquote>
<p><strong>loads</strong> : iterable</p>
<blockquote>
<div><p>Takes in an iterable of (Particle, Vector) or (ReferenceFrame, Vector)
tuples which represent the force at a point or torque on a frame.
Must be either a non-empty iterable of tuples or None which corresponds
to a system with no constraints.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.kindiffdict">
<code class="sig-name descname">kindiffdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/kane.py#L596-L601"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.kindiffdict" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary mapping q’ to u.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.linearize">
<code class="sig-name descname">linearize</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/kane.py#L476-L506"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearize the equations of motion about a symbolic operating point.</p>
<p>If kwarg A_and_B is False (default), returns M, A, B, r for the
linearized form, M*[q’, u’]^T = A*[q_ind, u_ind]^T + B*r.</p>
<p>If kwarg A_and_B is True, returns A, B, r for the linearized form
dx = A*x + B*r, where x = [q_ind, u_ind]^T. Note that this is
computationally intensive if there are many symbolic parameters. For
this reason, it may be more desirable to use the default A_and_B=False,
returning M, A, and B. Values may then be substituted in to these
matrices, and the state space form found as
A = P.T*M.inv()*A, B = P.T*M.inv()*B, where P = Linearizer.perm_mat.</p>
<p>In both cases, r is found as all dynamicsymbols in the equations of
motion that are not part of q, u, q’, or u’. They are sorted in
canonical form.</p>
<p>The operating points may be also entered using the <code class="docutils literal notranslate"><span class="pre">op_point</span></code> kwarg.
This takes a dictionary of {symbol: value}, or a an iterable of such
dictionaries. The values may be numeric or symbolic. The more values
you can specify beforehand, the faster this computation will run.</p>
<p>For more documentation, please see the <code class="docutils literal notranslate"><span class="pre">Linearizer</span></code> class.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.mass_matrix">
<em class="property">property </em><code class="sig-name descname">mass_matrix</code><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>The mass matrix of the system.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.mass_matrix_full">
<em class="property">property </em><code class="sig-name descname">mass_matrix_full</code><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.mass_matrix_full" title="Permalink to this definition">¶</a></dt>
<dd><p>The mass matrix of the system, augmented by the kinematic
differential equations.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.rhs">
<code class="sig-name descname">rhs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inv_method</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/kane.py#L564-L594"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.rhs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the system’s equations of motion in first order form. The
output is the right hand side of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="s1">&#39; = |q&#39;</span><span class="o">|</span> <span class="o">=</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
     <span class="o">|</span><span class="sa">u</span><span class="s1">&#39;|</span>
</pre></div>
</div>
<p>The right hand side is what is needed by most numerical ODE
integrators.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inv_method</strong> : str</p>
<blockquote>
<div><p>The specific sympy inverse matrix calculation method to use. For a
list of valid methods, see
<a class="reference internal" href="../../../matrices/matrices.html#sympy.matrices.matrices.MatrixBase.inv" title="sympy.matrices.matrices.MatrixBase.inv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inv()</span></code></a></p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.kane.KanesMethod.to_linearizer">
<code class="sig-name descname">to_linearizer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/kane.py#L403-L474"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.kane.KanesMethod.to_linearizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an instance of the Linearizer class, initiated from the
data in the KanesMethod class. This may be more desirable than using
the linearize class method, as the Linearizer object will allow more
efficient recalculation (i.e. about varying operating points).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-sympy.physics.mechanics.lagrange">
<span id="lagrangesmethod"></span><h2>LagrangesMethod<a class="headerlink" href="#module-sympy.physics.mechanics.lagrange" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod">
<em class="property">class </em><code class="sig-prename descclassname">sympy.physics.mechanics.lagrange.</code><code class="sig-name descname">LagrangesMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Lagrangian</span></em>, <em class="sig-param"><span class="n">qs</span></em>, <em class="sig-param"><span class="n">forcelist</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">bodies</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">frame</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">hol_coneqs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nonhol_coneqs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/lagrange.py#L14-L459"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>Lagrange’s method object.</p>
<p>This object generates the equations of motion in a two step procedure. The
first step involves the initialization of LagrangesMethod by supplying the
Lagrangian and the generalized coordinates, at the bare minimum. If there
are any constraint equations, they can be supplied as keyword arguments.
The Lagrange multipliers are automatically generated and are equal in
number to the constraint equations. Similarly any non-conservative forces
can be supplied in an iterable (as described below and also shown in the
example) along with a ReferenceFrame. This is also discussed further in the
__init__ method.</p>
<p class="rubric">Examples</p>
<p>This is a simple example for a one degree of freedom translational
spring-mass-damper.</p>
<p>In this example, we first need to do the kinematics.
This involves creating generalized coordinates and their derivatives.
Then we create a point and set its velocity in a frame.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.mechanics</span> <span class="kn">import</span> <span class="n">LagrangesMethod</span><span class="p">,</span> <span class="n">Lagrangian</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.mechanics</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">Particle</span><span class="p">,</span> <span class="n">Point</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.mechanics</span> <span class="kn">import</span> <span class="n">dynamicsymbols</span><span class="p">,</span> <span class="n">kinetic_energy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">dynamicsymbols</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qd</span> <span class="o">=</span> <span class="n">dynamicsymbols</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;m k b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="o">.</span><span class="n">set_vel</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">qd</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>We need to then prepare the information as required by LagrangesMethod to
generate equations of motion.
First we create the Particle, which has a point attached to it.
Following this the lagrangian is created from the kinetic and potential
energies.
Then, an iterable of nonconservative forces/torques must be constructed,
where each item is a (Point, Vector) or (ReferenceFrame, Vector) tuple,
with the Vectors representing the nonconservative forces or torques.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Pa</span> <span class="o">=</span> <span class="n">Particle</span><span class="p">(</span><span class="s1">&#39;Pa&#39;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Pa</span><span class="o">.</span><span class="n">potential_energy</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">q</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">Lagrangian</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Pa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fl</span> <span class="o">=</span> <span class="p">[(</span><span class="n">P</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span> <span class="o">*</span> <span class="n">qd</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">x</span><span class="p">)]</span>
</pre></div>
</div>
<p>Finally we can generate the equations of motion.
First we create the LagrangesMethod object. To do this one must supply
the Lagrangian, and the generalized coordinates. The constraint equations,
the forcelist, and the inertial frame may also be provided, if relevant.
Next we generate Lagrange’s equations of motion, such that:
Lagrange’s equations of motion = 0.
We have the equations of motion at this point.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="n">LagrangesMethod</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="p">[</span><span class="n">q</span><span class="p">],</span> <span class="n">forcelist</span> <span class="o">=</span> <span class="n">fl</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">form_lagranges_equations</span><span class="p">())</span>
<span class="go">Matrix([[b*Derivative(q(t), t) + 1.0*k*q(t) + m*Derivative(q(t), (t, 2))]])</span>
</pre></div>
</div>
<p>We can also solve for the states using the ‘rhs’ method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">rhs</span><span class="p">())</span>
<span class="go">Matrix([[Derivative(q(t), t)], [(-b*Derivative(q(t), t) - 1.0*k*q(t))/m]])</span>
</pre></div>
</div>
<p>Please refer to the docstrings on each method for more details.</p>
<p class="rubric">Attributes</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 87%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>q, u</p></td>
<td><p>(Matrix) Matrices of the generalized coordinates and speeds</p></td>
</tr>
<tr class="row-even"><td><p>forcelist</p></td>
<td><p>(iterable) Iterable of (Point, vector) or (ReferenceFrame, vector) tuples describing the forces on the system.</p></td>
</tr>
<tr class="row-odd"><td><p>bodies</p></td>
<td><p>(iterable) Iterable containing the rigid bodies and particles of the system.</p></td>
</tr>
<tr class="row-even"><td><p>mass_matrix</p></td>
<td><p>(Matrix) The system’s mass matrix</p></td>
</tr>
<tr class="row-odd"><td><p>forcing</p></td>
<td><p>(Matrix) The system’s forcing vector</p></td>
</tr>
<tr class="row-even"><td><p>mass_matrix_full</p></td>
<td><p>(Matrix) The “mass matrix” for the qdot’s, qdoubledot’s, and the lagrange multipliers (lam)</p></td>
</tr>
<tr class="row-odd"><td><p>forcing_full</p></td>
<td><p>(Matrix) The forcing vector for the qdot’s, qdoubledot’s and lagrange multipliers (lam)</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.forcing">
<em class="property">property </em><code class="sig-name descname">forcing</code><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.forcing" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the forcing vector from ‘lagranges_equations’ method.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.forcing_full">
<em class="property">property </em><code class="sig-name descname">forcing_full</code><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.forcing_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Augments qdots to the forcing vector above.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.form_lagranges_equations">
<code class="sig-name descname">form_lagranges_equations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/lagrange.py#L171-L225"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.form_lagranges_equations" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to form Lagrange’s equations of motion.</p>
<p>Returns a vector of equations of motion using Lagrange’s equations of
the second kind.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.linearize">
<code class="sig-name descname">linearize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q_ind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">qd_ind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">q_dep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">qd_dep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/lagrange.py#L347-L375"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>Linearize the equations of motion about a symbolic operating point.</p>
<p>If kwarg A_and_B is False (default), returns M, A, B, r for the
linearized form, M*[q’, u’]^T = A*[q_ind, u_ind]^T + B*r.</p>
<p>If kwarg A_and_B is True, returns A, B, r for the linearized form
dx = A*x + B*r, where x = [q_ind, u_ind]^T. Note that this is
computationally intensive if there are many symbolic parameters. For
this reason, it may be more desirable to use the default A_and_B=False,
returning M, A, and B. Values may then be substituted in to these
matrices, and the state space form found as
A = P.T*M.inv()*A, B = P.T*M.inv()*B, where P = Linearizer.perm_mat.</p>
<p>In both cases, r is found as all dynamicsymbols in the equations of
motion that are not part of q, u, q’, or u’. They are sorted in
canonical form.</p>
<p>The operating points may be also entered using the <code class="docutils literal notranslate"><span class="pre">op_point</span></code> kwarg.
This takes a dictionary of {symbol: value}, or a an iterable of such
dictionaries. The values may be numeric or symbolic. The more values
you can specify beforehand, the faster this computation will run.</p>
<p>For more documentation, please see the <code class="docutils literal notranslate"><span class="pre">Linearizer</span></code> class.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.mass_matrix">
<em class="property">property </em><code class="sig-name descname">mass_matrix</code><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.mass_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mass matrix, which is augmented by the Lagrange
multipliers, if necessary.</p>
<p>If the system is described by ‘n’ generalized coordinates and there are
no constraint equations then an n X n matrix is returned.</p>
<p>If there are ‘n’ generalized coordinates and ‘m’ constraint equations
have been supplied during initialization then an n X (n+m) matrix is
returned. The (n + m - 1)th and (n + m)th columns contain the
coefficients of the Lagrange multipliers.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.mass_matrix_full">
<em class="property">property </em><code class="sig-name descname">mass_matrix_full</code><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.mass_matrix_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Augments the coefficients of qdots to the mass_matrix.</p>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.rhs">
<code class="sig-name descname">rhs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">inv_method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/lagrange.py#L426-L443"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.rhs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns equations that can be solved numerically</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inv_method</strong> : str</p>
<blockquote>
<div><p>The specific sympy inverse matrix calculation method to use. For a
list of valid methods, see
<a class="reference internal" href="../../../matrices/matrices.html#sympy.matrices.matrices.MatrixBase.inv" title="sympy.matrices.matrices.MatrixBase.inv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inv()</span></code></a></p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.solve_multipliers">
<code class="sig-name descname">solve_multipliers</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">op_point</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sol_type</span><span class="o">=</span><span class="default_value">'dict'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/lagrange.py#L377-L424"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.solve_multipliers" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the values of the lagrange multipliers symbolically at
the specified operating point</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>op_point</strong> : dict or iterable of dicts, optional</p>
<blockquote>
<div><p>Point at which to solve at. The operating point is specified as
a dictionary or iterable of dictionaries of {symbol: value}. The
value may be numeric or symbolic itself.</p>
</div></blockquote>
<p><strong>sol_type</strong> : str, optional</p>
<blockquote>
<div><p>Solution return type. Valid options are:
- ‘dict’: A dict of {symbol : value} (default)
- ‘Matrix’: An ordered column matrix of the solution</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="sympy.physics.mechanics.lagrange.LagrangesMethod.to_linearizer">
<code class="sig-name descname">to_linearizer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">q_ind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">qd_ind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">q_dep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">qd_dep</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/b92b971eb4712e9ccfbdae993c42b3563ce8f86d/sympy/physics/mechanics/lagrange.py#L283-L345"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.physics.mechanics.lagrange.LagrangesMethod.to_linearizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an instance of the Linearizer class, initiated from the
data in the LagrangesMethod class. This may be more desirable than using
the linearize class method, as the Linearizer object will allow more
efficient recalculation (i.e. about varying operating points).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>q_ind, qd_ind</strong> : array_like, optional</p>
<blockquote>
<div><p>The independent generalized coordinates and speeds.</p>
</div></blockquote>
<p><strong>q_dep, qd_dep</strong> : array_like, optional</p>
<blockquote>
<div><p>The dependent generalized coordinates and speeds.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Kane’s Method &amp; Lagrange’s Method (Docstrings)</a><ul>
<li><a class="reference internal" href="#module-sympy.physics.mechanics.kane">KaneMethod</a></li>
<li><a class="reference internal" href="#module-sympy.physics.mechanics.lagrange">LagrangesMethod</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="part_bod.html"
                        title="previous chapter">Masses, Inertias &amp; Particles, RigidBodys (Docstrings)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="system.html"
                        title="next chapter">SymbolicSystem (Docstrings)</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../_sources/modules/physics/mechanics/api/kane_lagrange.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="system.html" title="SymbolicSystem (Docstrings)"
             >next</a> |</li>
        <li class="right" >
          <a href="part_bod.html" title="Masses, Inertias &amp; Particles, RigidBodys (Docstrings)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SymPy 1.6 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" >Physics</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >Classical Mechanics</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 SymPy Development Team.
      Last updated on May 23, 2020.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.3.
    </div>
  </body>
</html>