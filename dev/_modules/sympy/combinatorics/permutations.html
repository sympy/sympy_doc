

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.combinatorics.permutations &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy.combinatorics" href="../combinatorics.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../combinatorics.html" accesskey="U">sympy.combinatorics</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.combinatorics.permutations</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Basic</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">is_sequence</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="p">(</span><span class="n">flatten</span><span class="p">,</span> <span class="n">has_variety</span><span class="p">,</span> <span class="n">minlex</span><span class="p">,</span>
    <span class="n">has_dups</span><span class="p">,</span> <span class="n">runs</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.polys.polytools</span> <span class="kn">import</span> <span class="n">lcm</span>
<span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">zeros</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath.libmp.libintmath</span> <span class="kn">import</span> <span class="n">ifac</span>


<span class="k">def</span> <span class="nf">_af_rmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the product b*a; input and output are array forms. The ith value</span>
<span class="sd">    is a[b[i]].</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import _af_rmul, Permutation</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = False</span>

<span class="sd">    &gt;&gt;&gt; a, b = [1, 0, 2], [0, 2, 1]</span>
<span class="sd">    &gt;&gt;&gt; _af_rmul(a, b)</span>
<span class="sd">    [1, 2, 0]</span>
<span class="sd">    &gt;&gt;&gt; [a[b[i]] for i in range(3)]</span>
<span class="sd">    [1, 2, 0]</span>

<span class="sd">    This handles the operands in reverse order compared to the ``*`` operator:</span>

<span class="sd">    &gt;&gt;&gt; a = Permutation(a); b = Permutation(b)</span>
<span class="sd">    &gt;&gt;&gt; list(a*b)</span>
<span class="sd">    [2, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; [b(a(i)) for i in range(3)]</span>
<span class="sd">    [2, 0, 1]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    rmul, _af_rmuln</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_af_rmuln</span><span class="p">(</span><span class="o">*</span><span class="n">abc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given [a, b, c, ...] return the product of ...*c*b*a using array forms.</span>
<span class="sd">    The ith value is a[b[c[i]]].</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import _af_rmul, Permutation</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = False</span>

<span class="sd">    &gt;&gt;&gt; a, b = [1, 0, 2], [0, 2, 1]</span>
<span class="sd">    &gt;&gt;&gt; _af_rmul(a, b)</span>
<span class="sd">    [1, 2, 0]</span>
<span class="sd">    &gt;&gt;&gt; [a[b[i]] for i in range(3)]</span>
<span class="sd">    [1, 2, 0]</span>

<span class="sd">    This handles the operands in reverse order compared to the ``*`` operator:</span>

<span class="sd">    &gt;&gt;&gt; a = Permutation(a); b = Permutation(b)</span>
<span class="sd">    &gt;&gt;&gt; list(a*b)</span>
<span class="sd">    [2, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; [b(a(i)) for i in range(3)]</span>
<span class="sd">    [2, 0, 1]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    rmul, _af_rmul</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">abc</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p3</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">p3</span><span class="p">[</span><span class="n">i</span><span class="p">]]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p4</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">p3</span><span class="p">[</span><span class="n">p4</span><span class="p">[</span><span class="n">i</span><span class="p">]]]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p5</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p5</span><span class="p">,</span> <span class="n">p6</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">p3</span><span class="p">[</span><span class="n">p4</span><span class="p">[</span><span class="n">p5</span><span class="p">[</span><span class="n">i</span><span class="p">]]]]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p6</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p5</span><span class="p">,</span> <span class="n">p6</span><span class="p">,</span> <span class="n">p7</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">p3</span><span class="p">[</span><span class="n">p4</span><span class="p">[</span><span class="n">p5</span><span class="p">[</span><span class="n">p6</span><span class="p">[</span><span class="n">i</span><span class="p">]]]]]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p7</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">_af_rmuln</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">[:</span><span class="n">m</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">_af_rmuln</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="o">//</span><span class="mi">2</span><span class="p">:])</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_af_parity</span><span class="p">(</span><span class="n">pi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the parity of a permutation in array form.</span>

<span class="sd">    The parity of a permutation reflects the parity of the</span>
<span class="sd">    number of inversions in the permutation, i.e., the</span>
<span class="sd">    number of pairs of x and y such that x &gt; y but p[x] &lt; p[y].</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import _af_parity</span>
<span class="sd">    &gt;&gt;&gt; _af_parity([0,1,2,3])</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _af_parity([3,2,0,1])</span>
<span class="sd">    1</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Permutation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">while</span> <span class="n">pi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">_af_invert</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the inverse, ~A, of a permutation, A, given in array form.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import _af_invert, _af_rmul</span>
<span class="sd">    &gt;&gt;&gt; A = [1, 2, 0, 3]</span>
<span class="sd">    &gt;&gt;&gt; _af_invert(A)</span>
<span class="sd">    [2, 0, 1, 3]</span>
<span class="sd">    &gt;&gt;&gt; _af_rmul(_, A)</span>
<span class="sd">    [0, 1, 2, 3]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Permutation, __invert__</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inv_form</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">inv_form</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">inv_form</span>

<span class="k">def</span> <span class="nf">_af_pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Routine for finding powers of a permutation.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation, _af_pow</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">    &gt;&gt;&gt; p = Permutation([2,0,3,1])</span>
<span class="sd">    &gt;&gt;&gt; p.order()</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; _af_pow(p._array_form, 4)</span>
<span class="sd">    [0, 1, 2, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_af_pow</span><span class="p">(</span><span class="n">_af_invert</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="o">-</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[:]</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># use binary multiplication</span>
        <span class="n">b</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
                <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">_af_commutes_with</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if the two permutations with array forms</span>
<span class="sd">    given by ``a`` and ``b`` commute.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import _af_commutes_with</span>
<span class="sd">    &gt;&gt;&gt; _af_commutes_with([1,2,0], [0,2,1])</span>
<span class="sd">    False</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Permutation, commutes_with</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>


<div class="viewcode-block" id="Cycle"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Cycle">[docs]</a><span class="k">class</span> <span class="nc">Cycle</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around dict which provides the functionality of a disjoint cycle.</span>

<span class="sd">    A cycle shows the rule to use to move subsets of elements to obtain</span>
<span class="sd">    a permutation. The Cycle class is more flexible that Permutation in</span>
<span class="sd">    that 1) all elements need not be present in order to investigate how</span>
<span class="sd">    multiple cycles act in sequence and 2) it can contain singletons:</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import Perm, Cycle</span>

<span class="sd">    A Cycle will automatically parse a cycle given as a tuple on the rhs:</span>

<span class="sd">    &gt;&gt;&gt; Cycle(1, 2)(2, 3)</span>
<span class="sd">    Cycle(1, 3, 2)</span>

<span class="sd">    The identity cycle, Cycle(), can be used to start a product:</span>

<span class="sd">    &gt;&gt;&gt; Cycle()(1, 2)(2,3)</span>
<span class="sd">    Cycle(1, 3, 2)</span>

<span class="sd">    The array form of a Cycle can be obtained by calling the list</span>
<span class="sd">    method (or passing it to the list function) and all elements from</span>
<span class="sd">    0 will be shown:</span>

<span class="sd">    &gt;&gt;&gt; a = Cycle(1, 2)</span>
<span class="sd">    &gt;&gt;&gt; a.list()</span>
<span class="sd">    [0, 2, 1]</span>
<span class="sd">    &gt;&gt;&gt; list(a)</span>
<span class="sd">    [0, 2, 1]</span>

<span class="sd">    If a larger (or smaller) range is desired use the list method and</span>
<span class="sd">    provide the desired size -- but the Cycle cannot be truncated to</span>
<span class="sd">    a size smaller than the largest element that is out of place:</span>

<span class="sd">    &gt;&gt;&gt; b = Cycle(2,4)(1,2)(3,1,4)(1,3)</span>
<span class="sd">    &gt;&gt;&gt; b.list()</span>
<span class="sd">    [0, 2, 1, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; b.list(b.size + 1)</span>
<span class="sd">    [0, 2, 1, 3, 4, 5]</span>
<span class="sd">    &gt;&gt;&gt; b.list(-1)</span>
<span class="sd">    [0, 2, 1]</span>

<span class="sd">    Singletons are not shown when printing with one exception: the largest</span>
<span class="sd">    element is always shown -- as a singleton if necessary:</span>

<span class="sd">    &gt;&gt;&gt; Cycle(1, 4, 10)(4, 5)</span>
<span class="sd">    Cycle(1, 5, 4, 10)</span>
<span class="sd">    &gt;&gt;&gt; Cycle(1, 2)(4)(5)(10)</span>
<span class="sd">    Cycle(1, 2)(10)</span>

<span class="sd">    The array form can be used to instantiate a Permutation so other</span>
<span class="sd">    properties of the permutation can be investigated:</span>

<span class="sd">    &gt;&gt;&gt; Perm(Cycle(1,2)(3,4).list()).transpositions()</span>
<span class="sd">    [(1, 2), (3, 4)]</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    The underlying structure of the Cycle is a dictionary and although</span>
<span class="sd">    the __iter__ method has been redefiend to give the array form of the</span>
<span class="sd">    cycle, the underlying dictionary items are still available with the</span>
<span class="sd">    such methods as items():</span>

<span class="sd">    &gt;&gt;&gt; Cycle(1, 2).items()</span>
<span class="sd">    [(1, 2), (2, 1)]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Permutation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enter arg into dictionary and return arg.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">return</span> <span class="n">arg</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return product of cycles processed from R to L.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Cycle as C</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation as Perm</span>
<span class="sd">        &gt;&gt;&gt; C(1, 2)(2, 3)</span>
<span class="sd">        Cycle(1, 3, 2)</span>

<span class="sd">        An instance of a Cycle will automatically parse list-like</span>
<span class="sd">        objects and Permutations that are on the right. It is more</span>
<span class="sd">        flexible than the Permutation in that all elements need not</span>
<span class="sd">        be present:</span>

<span class="sd">        &gt;&gt;&gt; a = C(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; a(2, 3)</span>
<span class="sd">        Cycle(1, 3, 2)</span>
<span class="sd">        &gt;&gt;&gt; a(2, 3)(4, 5)</span>
<span class="sd">        Cycle(1, 3, 2)(4, 5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">Cycle</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="p">[</span><span class="n">rv</span><span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>
            <span class="n">rv</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">rv</span>

<div class="viewcode-block" id="Cycle.list"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Cycle.list">[docs]</a>    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the cycles as an explicit list starting from 0 up</span>
<span class="sd">        to the greater of the largest value in the cycles and size.</span>

<span class="sd">        Truncation of trailing unmoved items will occur when size</span>
<span class="sd">        is less than the maximum element in the cycle; if this is</span>
<span class="sd">        desired, setting ``size=-1`` will guarantee such trimming.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Cycle</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Cycle(2, 3)(4, 5)</span>
<span class="sd">        &gt;&gt;&gt; p.list()</span>
<span class="sd">        [0, 1, 3, 2, 5, 4]</span>
<span class="sd">        &gt;&gt;&gt; p.list(10)</span>
<span class="sd">        [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]</span>

<span class="sd">        Passing a length too small will trim trailing, unchanged elements</span>
<span class="sd">        in the permutation:</span>

<span class="sd">        &gt;&gt;&gt; Cycle(2, 4)(1, 2, 4).list(-1)</span>
<span class="sd">        [0, 2, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;must give size for empty Cycle&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">big</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">big</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;We want it to print as a Cycle, not as a dict.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Cycle</span>
<span class="sd">        &gt;&gt;&gt; Cycle(1, 2)</span>
<span class="sd">        Cycle(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; print _</span>
<span class="sd">        Cycle(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; Cycle(1, 2).items()</span>
<span class="sd">        [(1, 2), (2, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;Cycle()&#39;</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">cyclic_form</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">)</span>
        <span class="n">big</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">big</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cycles</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">big</span>
        <span class="k">return</span> <span class="s">&#39;Cycle</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load up a Cycle instance with the values for the cycle.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Cycle</span>
<span class="sd">        &gt;&gt;&gt; Cycle(1, 2, 6)</span>
<span class="sd">        Cycle(1, 2, 6)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Permutation</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cyclic_form</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">))</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Cycle</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">return</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">has_dups</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;All elements must be unique in a cycle.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation">[docs]</a><span class="k">class</span> <span class="nc">Permutation</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A permutation, alternatively known as an &#39;arrangement number&#39; or &#39;ordering&#39;</span>
<span class="sd">    is an arrangement of the elements of an ordered list into a one-to-one</span>
<span class="sd">    mapping with itself. The permutation of a given arrangement is given by</span>
<span class="sd">    indicating the positions of the elements after re-arrangment [2]_. For</span>
<span class="sd">    example, if one started with elements [x, y, a, b] (in that order) and</span>
<span class="sd">    they were reordered as [x, y, b, a] then the permutation would be</span>
<span class="sd">    [0, 1, 3, 2]. Notice that (in SymPy) the first element is always referred</span>
<span class="sd">    to as 0 and the permutation uses the indices of the elements in the</span>
<span class="sd">    original ordering, not the elements (a, b, etc...) themselves.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = False</span>

<span class="sd">    Permutations Notation</span>
<span class="sd">    =====================</span>

<span class="sd">    Permutations are commonly represented in disjoint cycle or array forms.</span>

<span class="sd">    Array Notation and 2-line Form</span>
<span class="sd">    ------------------------------------</span>

<span class="sd">    In the 2-line form, the elements and their final positions are shown</span>
<span class="sd">    as a matrix with 2 rows:</span>

<span class="sd">    [0    1    2     ... n-1]</span>
<span class="sd">    [p(0) p(1) p(2)  ... p(n-1)]</span>

<span class="sd">    Since the first line is always range(n), where n is the size of p,</span>
<span class="sd">    it is sufficient to represent the permutation by the second line,</span>
<span class="sd">    referred to as the &quot;array form&quot; of the permutation. This is entered</span>
<span class="sd">    in brackets as the argument to the Permutation class:</span>

<span class="sd">    &gt;&gt;&gt; p = Permutation([0, 2, 1]); p</span>
<span class="sd">    Permutation([0, 2, 1])</span>

<span class="sd">    Given i in range(p.size), the permutation maps i to i^p</span>

<span class="sd">    &gt;&gt;&gt; [i^p for i in range(p.size)]</span>
<span class="sd">    [0, 2, 1]</span>

<span class="sd">    The composite of two permutations p*q means first apply p, then q, so</span>
<span class="sd">    i^(p*q) = (i^p)^q which is i^p^q according to Python precedence rules:</span>

<span class="sd">    &gt;&gt;&gt; q = Permutation([2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; [i^p^q for i in range(3)]</span>
<span class="sd">    [2, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; [i^(p*q) for i in range(3)]</span>
<span class="sd">    [2, 0, 1]</span>

<span class="sd">    One can use also the notation p(i) = i^p, but then the composition</span>
<span class="sd">    rule is (p*q)(i) = q(p(i)), not p(q(i)):</span>

<span class="sd">    &gt;&gt;&gt; [(p*q)(i) for i in range(p.size)]</span>
<span class="sd">    [2, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; [q(p(i)) for i in range(p.size)]</span>
<span class="sd">    [2, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; [p(q(i)) for i in range(p.size)]</span>
<span class="sd">    [1, 2, 0]</span>

<span class="sd">    Disjoint Cycle Notation</span>
<span class="sd">    -----------------------</span>

<span class="sd">    In disjoint cycle notation, only the elements that have shifted are</span>
<span class="sd">    indicated. In the above case, the 2 and 1 switched places. This can</span>
<span class="sd">    be entered in two ways:</span>

<span class="sd">    &gt;&gt;&gt; Permutation(1, 2) == Permutation([[1, 2]]) == p</span>
<span class="sd">    True</span>

<span class="sd">    Only the relative ordering of elements in a cycle matter:</span>

<span class="sd">    &gt;&gt;&gt; Permutation(1,2,3) == Permutation(2,3,1) == Permutation(3,1,2)</span>
<span class="sd">    True</span>

<span class="sd">    The disjoint cycle notation is convenient when representing permutations</span>
<span class="sd">    that have several cycles in them:</span>

<span class="sd">    &gt;&gt;&gt; Permutation(1, 2)(3, 5) == Permutation([[1, 2], [3, 5]])</span>
<span class="sd">    True</span>

<span class="sd">    It also provides some economy in entry when computing products of</span>
<span class="sd">    permutations that are written in disjoint cycle notation:</span>

<span class="sd">    &gt;&gt;&gt; Permutation(1, 2)(1, 3)(2, 3)</span>
<span class="sd">    Permutation([0, 3, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; _ == Permutation([[1, 2]])*Permutation([[1, 3]])*Permutation([[2, 3]])</span>
<span class="sd">    True</span>

<span class="sd">    Entering a singleton in a permutation is a way to indicate the size of the</span>
<span class="sd">    permutation. The ``size`` keyword can also be used.</span>

<span class="sd">    Array-form entry:</span>

<span class="sd">    &gt;&gt;&gt; Permutation([[1, 2], [9]])</span>
<span class="sd">    Permutation([0, 2, 1], size=10)</span>
<span class="sd">    &gt;&gt;&gt; Permutation([[1, 2]], size=10)</span>
<span class="sd">    Permutation([0, 2, 1], size=10)</span>

<span class="sd">    Cyclic-form entry:</span>

<span class="sd">    &gt;&gt;&gt; Permutation(1, 2, size=10)</span>
<span class="sd">    Permutation([0, 2, 1], size=10)</span>
<span class="sd">    &gt;&gt;&gt; Permutation(9)(1, 2)</span>
<span class="sd">    Permutation([0, 2, 1], size=10)</span>

<span class="sd">    Caution: no singleton containing an element larger than the largest</span>
<span class="sd">    in any previous cycle can be entered. This is an important difference</span>
<span class="sd">    in how Permutation and Cycle handle the __call__ syntax. A singleton</span>
<span class="sd">    argument at the start of a Permutation performs instantiation of the</span>
<span class="sd">    Permutation and is permitted:</span>

<span class="sd">    &gt;&gt;&gt; Permutation(5)</span>
<span class="sd">    Permutation([], size=6)</span>

<span class="sd">    A singleton entered after instantiation is a call to the permutation</span>
<span class="sd">    -- a function call -- and if the argument is out of range it will</span>
<span class="sd">    trigger an error. For this reason, it is better to start the cycle</span>
<span class="sd">    with the singleton:</span>

<span class="sd">    The following fails because there is is no element 3:</span>

<span class="sd">    &gt;&gt;&gt; Permutation(1, 2)(3)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    IndexError: list index out of range</span>

<span class="sd">    This is ok: only the call to an out of range singleton is prohibited;</span>
<span class="sd">    otherwise the permutation autosizes:</span>

<span class="sd">    &gt;&gt;&gt; Permutation(3)(1, 2)</span>
<span class="sd">    Permutation([0, 2, 1, 3])</span>
<span class="sd">    &gt;&gt;&gt; Permutation(1, 2)(3, 4) == Permutation(3, 4)(1, 2)</span>
<span class="sd">    True</span>


<span class="sd">    Equality testing</span>
<span class="sd">    ----------------</span>

<span class="sd">    The array forms must be the same in order for permutations to be equal:</span>

<span class="sd">    &gt;&gt;&gt; Permutation([1, 0, 2, 3]) == Permutation([1, 0])</span>
<span class="sd">    False</span>


<span class="sd">    Identity Permutation</span>
<span class="sd">    --------------------</span>

<span class="sd">    The identity permutation is a permutation in which no element is out of</span>
<span class="sd">    place. It can be entered in a variety of ways. All the following create</span>
<span class="sd">    an identity permutation of size 4:</span>

<span class="sd">    &gt;&gt;&gt; I = Permutation([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; all(p == I for p in [</span>
<span class="sd">    ... Permutation(3),</span>
<span class="sd">    ... Permutation(range(4)),</span>
<span class="sd">    ... Permutation([], size=4),</span>
<span class="sd">    ... Permutation(size=4)])</span>
<span class="sd">    True</span>

<span class="sd">    Watch out for entering the range *inside* a set of brackets (which is</span>
<span class="sd">    cycle notation):</span>

<span class="sd">    &gt;&gt;&gt; I == Permutation([range(4)])</span>
<span class="sd">    False</span>


<span class="sd">    Permutation Printing</span>
<span class="sd">    ====================</span>

<span class="sd">    There are a few things to note about how Permutations are printed.</span>

<span class="sd">    1) If you prefer one form (array or cycle) over another, you can set that</span>
<span class="sd">    with the print_cyclic flag.</span>

<span class="sd">    &gt;&gt;&gt; Permutation(1, 2)(4, 5)(3, 4)</span>
<span class="sd">    Permutation([0, 2, 1, 4, 5, 3])</span>
<span class="sd">    &gt;&gt;&gt; p = _</span>

<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">    &gt;&gt;&gt; p</span>
<span class="sd">    Permutation(1, 2)(3, 4, 5)</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = False</span>

<span class="sd">    2) Regardless of the setting, a list of elements in the array for cyclic</span>
<span class="sd">    form can be obtained and either of those can be copied and supplied as</span>
<span class="sd">    the argument to Permutation:</span>

<span class="sd">    &gt;&gt;&gt; p.array_form</span>
<span class="sd">    [0, 2, 1, 4, 5, 3]</span>
<span class="sd">    &gt;&gt;&gt; p.cyclic_form</span>
<span class="sd">    [[1, 2], [3, 4, 5]]</span>
<span class="sd">    &gt;&gt;&gt; Permutation(_) == p</span>
<span class="sd">    True</span>

<span class="sd">    3) Printing is economical in that as little as possible is printed while</span>
<span class="sd">    retaining all information about the size of the permutation:</span>

<span class="sd">    &gt;&gt;&gt; Permutation([1, 0, 2, 3])</span>
<span class="sd">    Permutation([1, 0, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; Permutation([1, 0, 2, 3], size=20)</span>
<span class="sd">    Permutation([1, 0], size=20)</span>
<span class="sd">    &gt;&gt;&gt; Permutation([1, 0, 2, 4, 3, 5, 6], size=20)</span>
<span class="sd">    Permutation([1, 0, 2, 4, 3], size=20)</span>

<span class="sd">    &gt;&gt;&gt; p = Permutation([1, 0, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">    &gt;&gt;&gt; p</span>
<span class="sd">    Permutation(3)(0, 1)</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = False</span>

<span class="sd">    The 2 was not printed but it is still there as can be seen with the</span>
<span class="sd">    array_form and size methods:</span>

<span class="sd">    &gt;&gt;&gt; p.array_form</span>
<span class="sd">    [1, 0, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; p.size</span>
<span class="sd">    4</span>

<span class="sd">    Short introduction to other methods</span>
<span class="sd">    ===================================</span>

<span class="sd">    The permutation can act as a bijective function, telling what element is</span>
<span class="sd">    located at a given position</span>

<span class="sd">    &gt;&gt;&gt; q = Permutation([5, 2, 3, 4, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; q.array_form[1] # the hard way</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; q(1) # the easy way</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; dict([(i, q(i)) for i in range(q.size)]) # showing the bijection</span>
<span class="sd">    {0: 5, 1: 2, 2: 3, 3: 4, 4: 1, 5: 0}</span>

<span class="sd">    The full cyclic form (including singletons) can be obtained:</span>

<span class="sd">    &gt;&gt;&gt; p.full_cyclic_form</span>
<span class="sd">    [[0, 1], [2], [3]]</span>

<span class="sd">    Any permutation can be factored into transpositions of pairs of elements:</span>

<span class="sd">    &gt;&gt;&gt; Permutation([[1, 2], [3, 4, 5]]).transpositions()</span>
<span class="sd">    [(1, 2), (3, 5), (3, 4)]</span>
<span class="sd">    &gt;&gt;&gt; Permutation.rmul(*[Permutation([ti], size=6) for ti in _]).cyclic_form</span>
<span class="sd">    [[1, 2], [3, 4, 5]]</span>

<span class="sd">    The number of permutations on a set of n elements is given by n! and is</span>
<span class="sd">    called the cardinality.</span>

<span class="sd">    &gt;&gt;&gt; p.size</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; p.cardinality</span>
<span class="sd">    24</span>

<span class="sd">    A given permutation has a rank among all the possible permutations of the</span>
<span class="sd">    same elements, but what that rank is depends on how the permutations are</span>
<span class="sd">    enumerated. (There are a number of different methods of doing so.) The</span>
<span class="sd">    lexicographic rank is given by the rank method and this rank is used to</span>
<span class="sd">    increment a partion with addition/subtraction:</span>

<span class="sd">    &gt;&gt;&gt; p.rank()</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; p + 1</span>
<span class="sd">    Permutation([1, 0, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; p.next_lex()</span>
<span class="sd">    Permutation([1, 0, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; _.rank()</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt; p.unrank_lex(p.size, rank=7)</span>
<span class="sd">    Permutation([1, 0, 3, 2])</span>

<span class="sd">    The product of two permutations p and q is defined as their composition as</span>
<span class="sd">    functions, (p*q)(i) = q(p(i)) [6]_.</span>

<span class="sd">    &gt;&gt;&gt; p = Permutation([1, 0, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; q = Permutation([2, 3, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; list(q*p)</span>
<span class="sd">    [2, 3, 0, 1]</span>
<span class="sd">    &gt;&gt;&gt; list(p*q)</span>
<span class="sd">    [3, 2, 1, 0]</span>
<span class="sd">    &gt;&gt;&gt; [q(p(i)) for i in range(p.size)]</span>
<span class="sd">    [3, 2, 1, 0]</span>

<span class="sd">    The permutation can be &#39;applied&#39; to any list-like object, not only</span>
<span class="sd">    Permutations:</span>

<span class="sd">    &gt;&gt;&gt; p([&#39;zero&#39;, &#39;one&#39;, &#39;four&#39;, &#39;two&#39;])</span>
<span class="sd">     [&#39;one&#39;, &#39;zero&#39;, &#39;four&#39;, &#39;two&#39;]</span>
<span class="sd">    &gt;&gt;&gt; p(&#39;zo42&#39;)</span>
<span class="sd">    [&#39;o&#39;, &#39;z&#39;, &#39;4&#39;, &#39;2&#39;]</span>

<span class="sd">    If you have a list of arbitrary elements, the corresponding permutation</span>
<span class="sd">    can be found with the from_sequence method:</span>

<span class="sd">    &gt;&gt;&gt; Permutation.from_sequence(&#39;SymPy&#39;)</span>
<span class="sd">    Permutation([1, 3, 2, 0, 4])</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Cycle</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [1] Skiena, S. &#39;Permutations.&#39; 1.1 in Implementing Discrete Mathematics</span>
<span class="sd">           Combinatorics and Graph Theory with Mathematica.  Reading, MA:</span>
<span class="sd">           Addison-Wesley, pp. 3-16, 1990.</span>

<span class="sd">    .. [2] Knuth, D. E. The Art of Computer Programming, Vol. 4: Combinatorial</span>
<span class="sd">           Algorithms, 1st ed. Reading, MA: Addison-Wesley, 2011.</span>

<span class="sd">    .. [3] Wendy Myrvold and Frank Ruskey. 2001. Ranking and unranking</span>
<span class="sd">           permutations in linear time. Inf. Process. Lett. 79, 6 (September 2001),</span>
<span class="sd">           281-284. DOI=10.1016/S0020-0190(01)00141-7</span>

<span class="sd">    .. [4] D. L. Kreher, D. R. Stinson &#39;Combinatorial Algorithms&#39;</span>
<span class="sd">           CRC Press, 1999</span>

<span class="sd">    .. [5] Graham, R. L.; Knuth, D. E.; and Patashnik, O.</span>
<span class="sd">           Concrete Mathematics: A Foundation for Computer Science, 2nd ed.</span>
<span class="sd">           Reading, MA: Addison-Wesley, 1994.</span>

<span class="sd">    .. [6] http://en.wikipedia.org/wiki/Permutation#Product_and_inverse</span>

<span class="sd">    .. [7] http://en.wikipedia.org/wiki/Lehmer_code</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_Permutation</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">_array_form</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_cyclic_form</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_cycle_structure</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_size</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_rank</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for the Permutation object from a list or a</span>
<span class="sd">        list of lists in which all elements of the permutation may</span>
<span class="sd">        appear only once.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>

<span class="sd">        Permutations entered in array-form are left unaltered:</span>

<span class="sd">        &gt;&gt;&gt; Permutation([0, 2, 1])</span>
<span class="sd">        Permutation([0, 2, 1])</span>

<span class="sd">        Permutations entered in cyclic form are converted to array form;</span>
<span class="sd">        singletons need not be entered, but can be entered to indicate the</span>
<span class="sd">        largest element:</span>

<span class="sd">        &gt;&gt;&gt; Permutation([[4, 5, 6], [0, 1]])</span>
<span class="sd">        Permutation([1, 0, 2, 3, 5, 6, 4])</span>
<span class="sd">        &gt;&gt;&gt; Permutation([[4, 5, 6], [0, 1], [19]])</span>
<span class="sd">        Permutation([1, 0, 2, 3, 5, 6, 4], size=20)</span>

<span class="sd">        All manipulation of permutations assumes that the smallest element</span>
<span class="sd">        is 0 (in keeping with 0-based indexing in Python) so if the 0 is</span>
<span class="sd">        missing when entering a permutation in array form, an error will be</span>
<span class="sd">        raised:</span>

<span class="sd">        &gt;&gt;&gt; Permutation([2, 1])</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: Integers 0 through 2 must be present.</span>

<span class="sd">        If a permutation is entered in cyclic form, it can be entered without</span>
<span class="sd">        singletons and the ``size`` specified so those values can be filled</span>
<span class="sd">        in, otherwise the array form will only extend to the maximum value</span>
<span class="sd">        in the cycles:</span>

<span class="sd">        &gt;&gt;&gt; Permutation([[1, 4], [3, 5, 2]], size=10)</span>
<span class="sd">        Permutation([0, 4, 3, 5, 1, 2], size=10)</span>
<span class="sd">        &gt;&gt;&gt; _.array_form</span>
<span class="sd">        [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;size&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="c">#a) ()</span>
        <span class="c">#b) (1) = identity</span>
        <span class="c">#c) (1, 2) = cycle</span>
        <span class="c">#d) ([1, 2, 3]) = array form</span>
        <span class="c">#e) ([[1, 2]]) = cyclic form</span>
        <span class="c">#f) (Cycle) = conversion to permutation</span>
        <span class="c">#g) (Permutation) = adjust size or return copy</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>  <span class="c"># a</span>
            <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">size</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># c</span>
            <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">Cycle</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Perm</span><span class="p">):</span>  <span class="c"># g</span>
                <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">a</span>
                <span class="k">return</span> <span class="n">Perm</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">array_form</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Cycle</span><span class="p">):</span>  <span class="c"># f</span>
                <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">list</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>  <span class="c"># b</span>
                <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">has_variety</span><span class="p">(</span><span class="n">is_sequence</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">a</span><span class="p">):</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Permutation argument must be a list of ints, &quot;</span>
                             <span class="s">&quot;a list of lists, Permutation or Cycle.&quot;</span><span class="p">)</span>


        <span class="c"># safe to assume args are valid; this also makes a copy</span>
        <span class="c"># of the args</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">is_cycle</span> <span class="o">=</span> <span class="n">args</span> <span class="ow">and</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">is_cycle</span><span class="p">:</span>  <span class="c"># e</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c"># d</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

        <span class="c"># if there are n elements present, 0, 1, ..., n-1 should be present</span>
        <span class="c"># unless a cycle notation has been provided. A 0 will be added</span>
        <span class="c"># for convenience in case one wants to enter permutations where</span>
        <span class="c"># counting starts from 1.</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_dups</span><span class="p">(</span><span class="n">temp</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_cycle</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;there were repeated elements; to resolve &#39;</span>
                <span class="s">&#39;cycles use Cycle</span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;there were repeated elements.&#39;</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_cycle</span> <span class="ow">and</span> \
                <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Integers 0 through </span><span class="si">%s</span><span class="s"> must be present.&quot;</span> <span class="o">%</span>
                             <span class="nb">max</span><span class="p">(</span><span class="n">temp</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_cycle</span><span class="p">:</span>
            <span class="c"># it&#39;s not necessarily canonical so we won&#39;t store</span>
            <span class="c"># it -- use the array form instead</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">Cycle</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="o">*</span><span class="n">ci</span><span class="p">)</span>
            <span class="n">aform</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aform</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">aform</span><span class="p">):</span>
            <span class="c"># don&#39;t allow for truncation of permutation which</span>
            <span class="c"># might split a cycle and lead to an invalid aform</span>
            <span class="c"># but do allow the permutation size to be increased</span>
            <span class="n">aform</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">aform</span><span class="p">),</span> <span class="n">size</span><span class="p">))</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aform</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">aform</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_array_form</span> <span class="o">=</span> <span class="n">aform</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_af_new</span><span class="p">(</span><span class="n">perm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A method to produce a Permutation object from a list;</span>
<span class="sd">        the list is bound to the _array_form attribute, so it must</span>
<span class="sd">        not be modified; this method is meant for internal use only;</span>
<span class="sd">        the list ``a`` is supposed to be generated as a temporary value</span>
<span class="sd">        in a method, so p = Perm._af_new(a) is the only object</span>
<span class="sd">        to hold a reference to ``a``::</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Perm</span>
<span class="sd">        &gt;&gt;&gt; Perm.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; a = [2,1,3,0]</span>
<span class="sd">        &gt;&gt;&gt; p = Perm._af_new(a)</span>
<span class="sd">        &gt;&gt;&gt; p</span>
<span class="sd">        Permutation([2, 1, 3, 0])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">Perm</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">_array_form</span> <span class="o">=</span> <span class="n">perm</span>
        <span class="n">p</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">_hashable_content</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># the array_form (a list) is the Permutation arg, so we need to</span>
        <span class="c"># return a tuple, instead</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.array_form"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.array_form">[docs]</a>    <span class="k">def</span> <span class="nf">array_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the attribute _array_form</span>
<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([[2,0], [3,1]])</span>
<span class="sd">        &gt;&gt;&gt; p.array_form</span>
<span class="sd">        [2, 3, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; Permutation([[2,0,3,1]]).array_form</span>
<span class="sd">        [3, 2, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; Permutation([2,0,3,1]).array_form</span>
<span class="sd">        [2, 0, 3, 1]</span>
<span class="sd">        &gt;&gt;&gt; Permutation([[1, 2], [4, 5]]).array_form</span>
<span class="sd">        [0, 2, 1, 3, 5, 4]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[:]</span>
</div>
<div class="viewcode-block" id="Permutation.list"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.list">[docs]</a>    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the permutation as an explicit list, possibly</span>
<span class="sd">        trimming unmoved elements if size is less than the maximum</span>
<span class="sd">        element in the permutation; if this is desired, setting</span>
<span class="sd">        ``size=-1`` will guarantee such trimming.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation(2, 3)(4, 5)</span>
<span class="sd">        &gt;&gt;&gt; p.list()</span>
<span class="sd">        [0, 1, 3, 2, 5, 4]</span>
<span class="sd">        &gt;&gt;&gt; p.list(10)</span>
<span class="sd">        [0, 1, 3, 2, 5, 4, 6, 7, 8, 9]</span>

<span class="sd">        Passing a length too small will trim trailing, unchanged elements</span>
<span class="sd">        in the permutation:</span>

<span class="sd">        &gt;&gt;&gt; Permutation(2, 4)(1, 2, 4).list(-1)</span>
<span class="sd">        [0, 2, 1]</span>
<span class="sd">        &gt;&gt;&gt; Permutation(3).list(-1)</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">size</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;must give size for empty Cycle&#39;</span><span class="p">)</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">rv</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># find first value from rhs where rv[i] != i</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">rv</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">rv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">rv</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">rv</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.cyclic_form"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.cyclic_form">[docs]</a>    <span class="k">def</span> <span class="nf">cyclic_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is used to convert to the cyclic notation</span>
<span class="sd">        from the canonical notation. Singletons are omitted.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0, 3, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; p.cyclic_form</span>
<span class="sd">        [[1, 3, 2]]</span>
<span class="sd">        &gt;&gt;&gt; Permutation([1, 0, 2, 4, 3, 5]).cyclic_form</span>
<span class="sd">        [[0, 1], [3, 4]]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        array_form, full_cyclic_form</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cyclic_form</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cyclic_form</span><span class="p">)</span>
        <span class="n">array_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">unchecked</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_form</span><span class="p">)</span>
        <span class="n">cyclic_form</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array_form</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">unchecked</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">unchecked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">while</span> <span class="n">unchecked</span><span class="p">[</span><span class="n">array_form</span><span class="p">[</span><span class="n">j</span><span class="p">]]:</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">array_form</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">unchecked</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">cyclic_form</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">cycle</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">minlex</span><span class="p">(</span><span class="n">cycle</span><span class="p">,</span> <span class="n">is_set</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        <span class="n">cyclic_form</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cyclic_form</span> <span class="o">=</span> <span class="n">cyclic_form</span><span class="p">[:]</span>
        <span class="k">return</span> <span class="n">cyclic_form</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.full_cyclic_form"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.full_cyclic_form">[docs]</a>    <span class="k">def</span> <span class="nf">full_cyclic_form</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return permutation in cyclic form including singletons.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation([0, 2, 1]).full_cyclic_form</span>
<span class="sd">        [[0], [1, 2]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">need</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cyclic_form</span><span class="p">))</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic_form</span>
        <span class="n">rv</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">need</span><span class="p">])</span>
        <span class="n">rv</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">rv</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.size"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of elements in the permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation([[3, 2], [0, 1]]).size</span>
<span class="sd">        4</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        cardinality, length, order, rank</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
</div>
<div class="viewcode-block" id="Permutation.support"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.support">[docs]</a>    <span class="k">def</span> <span class="nf">support</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the elements in permutation, P, for which P[i] != i.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([[3, 2], [0, 1], [4]])</span>
<span class="sd">        &gt;&gt;&gt; p.array_form</span>
<span class="sd">        [1, 0, 3, 2, 4]</span>
<span class="sd">        &gt;&gt;&gt; p.support()</span>
<span class="sd">        [0, 1, 2, 3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return permutation that is other higher in rank than self.</span>

<span class="sd">        The rank is the lexicographical rank, with the identity permutation</span>
<span class="sd">        having rank of 0.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; I = Permutation([0, 1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([2, 1, 3, 0])</span>
<span class="sd">        &gt;&gt;&gt; I + a.rank() == a</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        __sub__, inversion_vector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cardinality</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">Perm</span><span class="o">.</span><span class="n">unrank_lex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
        <span class="n">rv</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">rank</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the permutation that is other lower in rank than self.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        __add__</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Permutation.rmul"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.rmul">[docs]</a>    <span class="k">def</span> <span class="nf">rmul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return product of Permutations [a, b, c, ...] as the Permutation whose</span>
<span class="sd">        ith value is a(b(c(i))).</span>

<span class="sd">        a, b, c, ... can be Permutation objects or tuples.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import _af_rmul, Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>

<span class="sd">        &gt;&gt;&gt; a, b = [1, 0, 2], [0, 2, 1]</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation(a); b = Permutation(b)</span>
<span class="sd">        &gt;&gt;&gt; list(Permutation.rmul(a, b))</span>
<span class="sd">        [1, 2, 0]</span>
<span class="sd">        &gt;&gt;&gt; [a(b(i)) for i in range(3)]</span>
<span class="sd">        [1, 2, 0]</span>

<span class="sd">        This handles the operands in reverse order compared to the ``*`` operator:</span>

<span class="sd">        &gt;&gt;&gt; a = Permutation(a); b = Permutation(b)</span>
<span class="sd">        &gt;&gt;&gt; list(a*b)</span>
<span class="sd">        [2, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; [b(a(i)) for i in range(3)]</span>
<span class="sd">        [2, 0, 1]</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        All items in the sequence will be parsed by Permutation as</span>
<span class="sd">        necessary as long as the first item is a Permutation:</span>

<span class="sd">        &gt;&gt;&gt; Permutation.rmul(a, [0, 2, 1]) == Permutation.rmul(a, b)</span>
<span class="sd">        True</span>

<span class="sd">        The reverse order of arguments will raise a TypeError.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">rv</span>
        <span class="k">return</span> <span class="n">rv</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Permutation.rmul_with_af"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.rmul_with_af">[docs]</a>    <span class="k">def</span> <span class="nf">rmul_with_af</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        same as rmul, but the elements of args are Permutation objects</span>
<span class="sd">        which have _array_form</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">_af_rmuln</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rv</span>
</div>
<div class="viewcode-block" id="Permutation.mul_inv"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.mul_inv">[docs]</a>    <span class="k">def</span> <span class="nf">mul_inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        other*~self, self and other have _array_form</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_af_invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_form</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_array_form</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">_af_rmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This is needed to coerse other to Permutation in rmul.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Perm</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the product a*b as a Permutation; the ith value is b(a(i)).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import _af_rmul, Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>

<span class="sd">        &gt;&gt;&gt; a, b = [1, 0, 2], [0, 2, 1]</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation(a); b = Permutation(b)</span>
<span class="sd">        &gt;&gt;&gt; list(a*b)</span>
<span class="sd">        [2, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; [b(a(i)) for i in range(3)]</span>
<span class="sd">        [2, 0, 1]</span>

<span class="sd">        This handles operands in reverse order compared to _af_rmul and rmul:</span>

<span class="sd">        &gt;&gt;&gt; al = list(a); bl = list(b)</span>
<span class="sd">        &gt;&gt;&gt; _af_rmul(al, bl)</span>
<span class="sd">        [1, 2, 0]</span>
<span class="sd">        &gt;&gt;&gt; [al[bl[i]] for i in range(3)]</span>
<span class="sd">        [1, 2, 0]</span>

<span class="sd">        It is acceptable for the arrays to have different lengths; the shorter</span>
<span class="sd">        one will be padded to match the longer one:</span>

<span class="sd">        &gt;&gt;&gt; b*Permutation([1, 0])</span>
<span class="sd">        Permutation([1, 2, 0])</span>
<span class="sd">        &gt;&gt;&gt; Permutation([1, 0])*b</span>
<span class="sd">        Permutation([2, 0, 1])</span>

<span class="sd">        It is also acceptable to allow coercion to handle conversion of a</span>
<span class="sd">        single list to the left of a Permutation:</span>

<span class="sd">        &gt;&gt;&gt; [0, 1]*a # no change: 2-element identity</span>
<span class="sd">        Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; [[0, 1]]*a # exchange first two elements</span>
<span class="sd">        Permutation([0, 1, 2])</span>

<span class="sd">        You cannot use more than 1 cycle notation in a product of cycles</span>
<span class="sd">        since coercion can only handle one argument to the left. To handle</span>
<span class="sd">        multiple cycles it is convenient to use Cycle instead of Permutation:</span>

<span class="sd">        &gt;&gt;&gt; [[1, 2]]*[[2, 3]]*Permutation([]) # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Cycle</span>
<span class="sd">        &gt;&gt;&gt; Cycle(1, 2)(2, 3)</span>
<span class="sd">        Cycle(1, 3, 2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="c"># __rmul__ makes sure the other is a Permutation</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):]</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>

<div class="viewcode-block" id="Permutation.commutes_with"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.commutes_with">[docs]</a>    <span class="k">def</span> <span class="nf">commutes_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the elements are commuting.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1,4,3,0,2,5])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0,1,2,3,4,5])</span>
<span class="sd">        &gt;&gt;&gt; a.commutes_with(b)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([2,3,5,4,1,0])</span>
<span class="sd">        &gt;&gt;&gt; a.commutes_with(b)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">return</span> <span class="n">_af_commutes_with</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Routine for finding powers of a permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([2,0,3,1])</span>
<span class="sd">        &gt;&gt;&gt; p.order()</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; p**4</span>
<span class="sd">        Permutation([0, 1, 2, 3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">Perm</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s">&#39;p**p is not defined; do you mean p^p (conjugate)?&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">_af_pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return self(i) when ``i`` is an int.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation(1, 2, 9)</span>
<span class="sd">        &gt;&gt;&gt; 2^p == p(2) == 9</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s">&quot;i^p = p(i) when i is an integer, not </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the conjugate permutation ``~h*self*h` `.</span>

<span class="sd">        If ``a`` and ``b`` are conjugates, ``a = h*b*~h`` and</span>
<span class="sd">        ``b = ~h*a*h`` and both have the same cycle structure.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation(1, 2, 9)</span>
<span class="sd">        &gt;&gt;&gt; q = Permutation(6, 9, 8)</span>
<span class="sd">        &gt;&gt;&gt; p*q != q*p</span>
<span class="sd">        True</span>

<span class="sd">        Calculate and check properties of the conjugate:</span>

<span class="sd">        &gt;&gt;&gt; c = p^q</span>
<span class="sd">        &gt;&gt;&gt; c == ~q*p*q and p == q*c*~q</span>
<span class="sd">        True</span>

<span class="sd">        The expression q^p^r is equivalent to q^(p*r):</span>

<span class="sd">        &gt;&gt;&gt; r = Permutation(9)(4,6,8)</span>
<span class="sd">        &gt;&gt;&gt; q^p^r == q^(p*r)</span>
<span class="sd">        True</span>

<span class="sd">        If the term to the left of the conjugate operator, i, is an integer</span>
<span class="sd">        then this is interpreted as selecting the ith element from the</span>
<span class="sd">        permutation to the right:</span>

<span class="sd">        &gt;&gt;&gt; all(i^p == p(i) for i in range(p.size))</span>
<span class="sd">        True</span>

<span class="sd">        Note that the * operator as higher precedence than the ^ operator:</span>

<span class="sd">        &gt;&gt;&gt; q^r*p^r == q^(r*p)^r == Permutation(9)(1, 6, 4)</span>
<span class="sd">        True</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        In Python the precedence rule is p^q^r = (p^q)^r which differs</span>
<span class="sd">        in general from p^(q^r)</span>

<span class="sd">        &gt;&gt;&gt; q^p^r</span>
<span class="sd">        Permutation(9)(1, 4, 8)</span>
<span class="sd">        &gt;&gt;&gt; q^(p^r)</span>
<span class="sd">        Permutation(9)(1, 8, 6)</span>

<span class="sd">        For a given r and p, both of the following are conjugates of p:</span>
<span class="sd">        ~r*p*r and r*p*~r. But these are not necessarily the same:</span>

<span class="sd">        &gt;&gt;&gt; ~r*p*r == r*p*~r</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; p = Permutation(1, 2, 9)(5, 6)</span>
<span class="sd">        &gt;&gt;&gt; ~r*p*r == r*p*~r</span>
<span class="sd">        False</span>

<span class="sd">        The conjugate ~r*p*r was chosen so that ``p^q^r`` would be equivalent</span>
<span class="sd">        to ``p^(q*r)`` rather than ``p^(r*q)``. To obtain r*p*~r, pass ~r to</span>
<span class="sd">        this method:</span>

<span class="sd">        &gt;&gt;&gt; p^~r == r*p*~r</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">h</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The permutations must be of equal size.&quot;</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_array_form</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_form</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<div class="viewcode-block" id="Permutation.transpositions"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.transpositions">[docs]</a>    <span class="k">def</span> <span class="nf">transpositions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the permutation decomposed into a list of transpositions.</span>

<span class="sd">        It is always possible to express a permutation as the product of</span>
<span class="sd">        transpositions, see [1]</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([[1, 2, 3], [0, 4, 5, 6, 7]])</span>
<span class="sd">        &gt;&gt;&gt; t = p.transpositions()</span>
<span class="sd">        &gt;&gt;&gt; t</span>
<span class="sd">        [(0, 7), (0, 6), (0, 5), (0, 4), (1, 3), (1, 2)]</span>
<span class="sd">        &gt;&gt;&gt; print &#39;&#39;.join(str(c) for c in t)</span>
<span class="sd">        (0, 7)(0, 6)(0, 5)(0, 4)(1, 3)(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; Permutation.rmul(*[Permutation([ti], size=p.size) for ti in t]) == p</span>
<span class="sd">        True</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        1. http://en.wikipedia.org/wiki/Transposition_%28mathematics%29#Properties</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic_form</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">nx</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">first</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Permutation.from_sequence"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.from_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">from_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the permutation needed to obtain ``i`` from the sorted</span>
<span class="sd">        elements of ``i``. If custom sorting is desired, a key can be given.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>

<span class="sd">        &gt;&gt;&gt; Permutation.from_sequence(&#39;SymPy&#39;)</span>
<span class="sd">        Permutation(4)(0, 1, 3)</span>
<span class="sd">        &gt;&gt;&gt; _(sorted(&quot;SymPy&quot;))</span>
<span class="sd">        [&#39;S&#39;, &#39;y&#39;, &#39;m&#39;, &#39;P&#39;, &#39;y&#39;]</span>
<span class="sd">        &gt;&gt;&gt; Permutation.from_sequence(&#39;SymPy&#39;, key=lambda x: x.lower())</span>
<span class="sd">        Permutation(4)(0, 2)(1, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">ic</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ic</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="o">~</span><span class="n">Permutation</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ic</span><span class="p">])</span>
</div>
    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inverse of the permutation.</span>

<span class="sd">        A permutation multiplied by its inverse is the identity permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([[2,0], [3,1]])</span>
<span class="sd">        &gt;&gt;&gt; ~p</span>
<span class="sd">        Permutation([2, 3, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; _ == p**-1</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; p*~p == ~p*p == Permutation([0, 1, 2, 3])</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">_af_invert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_form</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield elements from array form.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; list(Permutation(range(3)))</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows applying a permutation instance as a bijective function.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([[2,0], [3,1]])</span>
<span class="sd">        &gt;&gt;&gt; p.array_form</span>
<span class="sd">        [2, 3, 0, 1]</span>
<span class="sd">        &gt;&gt;&gt; [p(i) for i in range(4)]</span>
<span class="sd">        [2, 3, 0, 1]</span>

<span class="sd">        If an array is given then the permutation selects the items</span>
<span class="sd">        from the array (i.e. the permutation is applied to the array):</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; p([x, 1, 0, x**2])</span>
<span class="sd">        [0, x**2, x, 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># list indices can be Integer or int; leave this</span>
        <span class="c"># as it is (don&#39;t test or convert it) because this</span>
        <span class="c"># gets called a lot and should be fast</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># P(1)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c"># P([a, b, c])</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_form</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;unrecognized argument&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># P(1, 2, 3)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">Permutation</span><span class="p">(</span><span class="n">Cycle</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<div class="viewcode-block" id="Permutation.atoms"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.atoms">[docs]</a>    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all the elements of a permutation</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation([0, 1, 2, 3, 4, 5]).atoms()</span>
<span class="sd">        set([0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; Permutation([[0, 1], [2, 3], [4, 5]]).atoms()</span>
<span class="sd">        set([0, 1, 2, 3, 4, 5])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation.next_lex"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.next_lex">[docs]</a>    <span class="k">def</span> <span class="nf">next_lex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next permutation in lexicographical order.</span>
<span class="sd">        If self is the last permutation in lexicographical order</span>
<span class="sd">        it returns None.</span>
<span class="sd">        See [4] section 2.4.</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([2, 3, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([2, 3, 1, 0]); p.rank()</span>
<span class="sd">        17</span>
<span class="sd">        &gt;&gt;&gt; p = p.next_lex(); p.rank()</span>
<span class="sd">        18</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        rank, unrank_lex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">[:]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">perm</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">perm</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">perm</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Permutation.unrank_nonlex"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.unrank_nonlex">[docs]</a>    <span class="k">def</span> <span class="nf">unrank_nonlex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a linear time unranking algorithm that does not</span>
<span class="sd">        respect lexicographic order [3].</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; Permutation.unrank_nonlex(4, 5)</span>
<span class="sd">        Permutation([2, 0, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; Permutation.unrank_nonlex(4, -1)</span>
<span class="sd">        Permutation([0, 1, 2, 3])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        next_nonlex, rank_nonlex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_unrank1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">r</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">r</span> <span class="o">%</span> <span class="n">n</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">_unrank1</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">//</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="n">id_perm</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="n">ifac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">_unrank1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">id_perm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">id_perm</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation.rank_nonlex"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.rank_nonlex">[docs]</a>    <span class="k">def</span> <span class="nf">rank_nonlex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inv_perm</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a linear time ranking algorithm that does not</span>
<span class="sd">        enforce lexicographic order [3].</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; p.rank_nonlex()</span>
<span class="sd">        23</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        next_nonlex, unrank_nonlex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_rank1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">inv_perm</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">inv_perm</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">perm</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">s</span>
            <span class="n">inv_perm</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">inv_perm</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_perm</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">t</span>
            <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">n</span><span class="o">*</span><span class="n">_rank1</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">perm</span><span class="p">,</span> <span class="n">inv_perm</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inv_perm</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">inv_perm</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inv_perm</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">[:]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_rank1</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">perm</span><span class="p">),</span> <span class="n">perm</span><span class="p">,</span> <span class="n">inv_perm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
</div>
<div class="viewcode-block" id="Permutation.next_nonlex"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.next_nonlex">[docs]</a>    <span class="k">def</span> <span class="nf">next_nonlex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next permutation in nonlex order [3].</span>
<span class="sd">        If self is the last permutation in this order it returns None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([2, 0, 3, 1]); p.rank_nonlex()</span>
<span class="sd">        5</span>
<span class="sd">        &gt;&gt;&gt; p = p.next_nonlex(); p</span>
<span class="sd">        Permutation([3, 0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; p.rank_nonlex()</span>
<span class="sd">        6</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        rank_nonlex, unrank_nonlex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank_nonlex</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">ifac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">Perm</span><span class="o">.</span><span class="n">unrank_nonlex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation.rank"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.rank">[docs]</a>    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the lexicographic rank of the permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0, 1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; p.rank()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([3, 2, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; p.rank()</span>
<span class="sd">        23</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        next_lex, unrank_lex, cardinality, length, order, size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">[:]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">psize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ifac</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">rank</span> <span class="o">+=</span> <span class="n">rho</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">psize</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rho</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">psize</span> <span class="o">//=</span> <span class="n">n</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="n">rank</span>
        <span class="k">return</span> <span class="n">rank</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.cardinality"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.cardinality">[docs]</a>    <span class="k">def</span> <span class="nf">cardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of all possible permutations.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; p.cardinality</span>
<span class="sd">        24</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        length, order, rank, size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">ifac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Permutation.parity"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.parity">[docs]</a>    <span class="k">def</span> <span class="nf">parity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the parity of a permutation.</span>

<span class="sd">        The parity of a permutation reflects the parity of the</span>
<span class="sd">        number of inversions in the permutation, i.e., the</span>
<span class="sd">        number of pairs of x and y such that ``x &gt; y`` but ``p[x] &lt; p[y]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; p.parity()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([3,2,0,1])</span>
<span class="sd">        &gt;&gt;&gt; p.parity()</span>
<span class="sd">        1</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _af_parity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cyclic_form</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycles</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">_af_parity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.is_even"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.is_even">[docs]</a>    <span class="k">def</span> <span class="nf">is_even</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a permutation is even.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; p.is_even</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([3,2,1,0])</span>
<span class="sd">        &gt;&gt;&gt; p.is_even</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_odd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_odd</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.is_odd"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.is_odd">[docs]</a>    <span class="k">def</span> <span class="nf">is_odd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a permutation is odd.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; p.is_odd</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([3,2,0,1])</span>
<span class="sd">        &gt;&gt;&gt; p.is_odd</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_even</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parity</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.is_Singleton"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.is_Singleton">[docs]</a>    <span class="k">def</span> <span class="nf">is_Singleton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks to see if the permutation contains only one number and is</span>
<span class="sd">        thus the only possible permutation of this set of numbers</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation([0]).is_Singleton</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Permutation([0, 1]).is_Singleton</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_Empty</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.is_Empty"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.is_Empty">[docs]</a>    <span class="k">def</span> <span class="nf">is_Empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks to see if the permutation is a set with zero elements</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation([]).is_Empty</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Permutation([0]).is_Empty</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_Singleton</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.is_Identity"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.is_Identity">[docs]</a>    <span class="k">def</span> <span class="nf">is_Identity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the Permutation is an identity permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([])</span>
<span class="sd">        &gt;&gt;&gt; p.is_Identity</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([[0], [1], [2]])</span>
<span class="sd">        &gt;&gt;&gt; p.is_Identity</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; p.is_Identity</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; p.is_Identity</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">af</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">af</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">af</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Permutation.ascents"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.ascents">[docs]</a>    <span class="k">def</span> <span class="nf">ascents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the positions of ascents in a permutation, ie, the location</span>
<span class="sd">        where p[i] &lt; p[i+1]</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([4,0,1,3,2])</span>
<span class="sd">        &gt;&gt;&gt; p.ascents()</span>
<span class="sd">        [1, 2]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        descents, inversions, min, max</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">pos</span>
</div>
<div class="viewcode-block" id="Permutation.descents"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.descents">[docs]</a>    <span class="k">def</span> <span class="nf">descents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the positions of descents in a permutation, ie, the location</span>
<span class="sd">        where p[i] &gt; p[i+1]</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([4,0,1,3,2])</span>
<span class="sd">        &gt;&gt;&gt; p.descents()</span>
<span class="sd">        [0, 3]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        ascents, inversions, min, max</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">pos</span>
</div>
<div class="viewcode-block" id="Permutation.max"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The maximum element moved by the permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([1,0,2,3,4])</span>
<span class="sd">        &gt;&gt;&gt; p.max()</span>
<span class="sd">        1</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        min, descents, ascents, inversions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">:</span>
                <span class="nb">max</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">max</span>
</div>
<div class="viewcode-block" id="Permutation.min"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The minimum element moved by the permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,4,3,2])</span>
<span class="sd">        &gt;&gt;&gt; p.min()</span>
<span class="sd">        2</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        max, descents, ascents, inversions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="nb">min</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">:</span>
                <span class="nb">min</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">min</span>
</div>
<div class="viewcode-block" id="Permutation.inversions"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.inversions">[docs]</a>    <span class="k">def</span> <span class="nf">inversions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the number of inversions of a permutation.</span>

<span class="sd">        An inversion is where i &gt; j but p[i] &lt; p[j].</span>

<span class="sd">        For small length of p, it iterates over all i and j</span>
<span class="sd">        values and calculates the number of inversions.</span>
<span class="sd">        For large length of p, it uses a variation of merge</span>
<span class="sd">        sort to calculate the number of inversions.</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        [1] http://www.cp.eng.chula.ac.th/~piak/teaching/algo/algo2008/count-inv.htm</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,2,3,4,5])</span>
<span class="sd">        &gt;&gt;&gt; p.inversions()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; Permutation([3,2,1,0]).inversions()</span>
<span class="sd">        6</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        descents, ascents, min, max</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inversions</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">130</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">:</span>
                        <span class="n">inversions</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:]</span>
            <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">right</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">inversions</span> <span class="o">+=</span> <span class="n">_merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="mi">2</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">inversions</span>
</div>
<div class="viewcode-block" id="Permutation.commutator"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.commutator">[docs]</a>    <span class="k">def</span> <span class="nf">commutator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the commutator of self and x: ``~x*~self*x*self``</span>

<span class="sd">        If f and g are part of a group, G, then the commutator of f and g</span>
<span class="sd">        is the group identity iff f and g commute, i.e. fg == gf.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; x = Permutation([2, 0, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; c = p.commutator(x); c</span>
<span class="sd">        Permutation([2, 1, 3, 0])</span>
<span class="sd">        &gt;&gt;&gt; c == ~x*~p*x*p</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; I = Permutation(3)</span>
<span class="sd">        &gt;&gt;&gt; p = [I + i for i in range(6)]</span>
<span class="sd">        &gt;&gt;&gt; for i in range(len(p)):</span>
<span class="sd">        ...     for j in range(len(p)):</span>
<span class="sd">        ...         c = p[i].commutator(p[j])</span>
<span class="sd">        ...         if p[i]*p[j] == p[j]*p[i]:</span>
<span class="sd">        ...             assert c == I</span>
<span class="sd">        ...         else:</span>
<span class="sd">        ...             assert c != I</span>
<span class="sd">        ...</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        http://en.wikipedia.org/wiki/Commutator</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The permutations must be of equal size.&quot;</span><span class="p">)</span>
        <span class="n">inva</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">inva</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">invb</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">invb</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">inva</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">invb</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Permutation.signature"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.signature">[docs]</a>    <span class="k">def</span> <span class="nf">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gives the signature of the permutation needed to place the</span>
<span class="sd">        elements of the permutation in canonical order.</span>

<span class="sd">        The signature is calculated as (-1)^&lt;number of inversions&gt;</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,2])</span>
<span class="sd">        &gt;&gt;&gt; p.inversions()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; p.signature()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; q = Permutation([0,2,1])</span>
<span class="sd">        &gt;&gt;&gt; q.inversions()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; q.signature()</span>
<span class="sd">        -1</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        inversions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_even</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</div>
<div class="viewcode-block" id="Permutation.order"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.order">[docs]</a>    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the order of a permutation.</span>

<span class="sd">        When the permutation is raised to the power of its</span>
<span class="sd">        order it equals the identity permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([3, 1, 5, 2, 4, 0])</span>
<span class="sd">        &gt;&gt;&gt; p.order()</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; (p**(p.order()))</span>
<span class="sd">        Permutation([], size=6)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        identity, cardinality, length, rank, size</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic_form</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation.length"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of integers moved by a permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation([0, 3, 2, 1]).length()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; Permutation([[0, 1], [2, 3]]).length()</span>
<span class="sd">        4</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        min, max, suppport, cardinality, order, rank, size</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">support</span><span class="p">())</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.cycle_structure"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.cycle_structure">[docs]</a>    <span class="k">def</span> <span class="nf">cycle_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the cycle structure of the permutation as a dictionary</span>
<span class="sd">        indicating the multiplicity of each cycle length.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; Permutation(3).cycle_structure</span>
<span class="sd">        {1: 4}</span>
<span class="sd">        &gt;&gt;&gt; Permutation(0, 4, 3)(1, 2)(5, 6).cycle_structure</span>
<span class="sd">        {2: 2, 3: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_structure</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_structure</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">singletons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic_form</span><span class="p">:</span>
                <span class="n">rv</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">singletons</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">singletons</span><span class="p">:</span>
                <span class="n">rv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">singletons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_structure</span> <span class="o">=</span> <span class="n">rv</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>  <span class="c"># make a copy</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="Permutation.cycles"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.cycles">[docs]</a>    <span class="k">def</span> <span class="nf">cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of cycles contained in the permutation</span>
<span class="sd">        (including singletons).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation([0, 1, 2]).cycles</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; Permutation([0, 1, 2]).full_cyclic_form</span>
<span class="sd">        [[0], [1], [2]]</span>
<span class="sd">        &gt;&gt;&gt; Permutation(0, 1)(2, 3).cycles</span>
<span class="sd">        2</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        sympy.functions.combinatorial.numbers.stirling</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_cyclic_form</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation.index"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of a permutation.</span>

<span class="sd">        The index of a permutation is the sum of all subscripts j such</span>
<span class="sd">        that p[j] is greater than p[j+1].</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([3, 0, 2, 1, 4])</span>
<span class="sd">        &gt;&gt;&gt; p.index()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
</div>
<div class="viewcode-block" id="Permutation.runs"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.runs">[docs]</a>    <span class="k">def</span> <span class="nf">runs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the runs of a permutation.</span>

<span class="sd">        An ascending sequence in a permutation is called a run [5].</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([2,5,7,3,6,0,1,4,8])</span>
<span class="sd">        &gt;&gt;&gt; p.runs()</span>
<span class="sd">        [[2, 5, 7], [3, 6], [0, 1, 4, 8]]</span>
<span class="sd">        &gt;&gt;&gt; q = Permutation([1,3,2,0])</span>
<span class="sd">        &gt;&gt;&gt; q.runs()</span>
<span class="sd">        [[1, 3], [2], [0]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">runs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation.inversion_vector"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.inversion_vector">[docs]</a>    <span class="k">def</span> <span class="nf">inversion_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the inversion vector of the permutation.</span>

<span class="sd">        The inversion vector consists of elements whose value</span>
<span class="sd">        indicates the number of elements in the permutation</span>
<span class="sd">        that are lesser than it and lie on its right hand side.</span>

<span class="sd">        The inversion vector is the same as the Lehmer encoding of a</span>
<span class="sd">        permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([4, 8, 0, 7, 1, 5, 3, 6, 2])</span>
<span class="sd">        &gt;&gt;&gt; p.inversion_vector()</span>
<span class="sd">        [4, 7, 0, 5, 0, 2, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([3, 2, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; p.inversion_vector()</span>
<span class="sd">        [3, 2, 1]</span>

<span class="sd">        The inversion vector increases lexicographically with the rank</span>
<span class="sd">        of the permutation, the -ith element cycling through 0..i.</span>

<span class="sd">        &gt;&gt;&gt; p = Permutation(2)</span>
<span class="sd">        &gt;&gt;&gt; while p:</span>
<span class="sd">        ...     print p, p.inversion_vector(), p.rank()</span>
<span class="sd">        ...     p = p.next_lex()</span>
<span class="sd">        ...</span>
<span class="sd">        Permutation([0, 1, 2]) [0, 0] 0</span>
<span class="sd">        Permutation([0, 2, 1]) [0, 1] 1</span>
<span class="sd">        Permutation([1, 0, 2]) [1, 0] 2</span>
<span class="sd">        Permutation([1, 2, 0]) [1, 1] 3</span>
<span class="sd">        Permutation([2, 0, 1]) [2, 0] 4</span>
<span class="sd">        Permutation([2, 1, 0]) [2, 1] 5</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        from_inversion_vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_array_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">self_array_form</span><span class="p">)</span>
        <span class="n">inversion_vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">self_array_form</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">self_array_form</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">val</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">inversion_vector</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">inversion_vector</span>
</div>
<div class="viewcode-block" id="Permutation.rank_trotterjohnson"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.rank_trotterjohnson">[docs]</a>    <span class="k">def</span> <span class="nf">rank_trotterjohnson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Trotter Johnson rank, which we get from the minimal</span>
<span class="sd">        change algorithm. See [4] section 2.4.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; p.rank_trotterjohnson()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0,2,1,3])</span>
<span class="sd">        &gt;&gt;&gt; p.rank_trotterjohnson()</span>
<span class="sd">        7</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        unrank_trotterjohnson, next_trotterjohnson</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Identity</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j1</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">j1</span><span class="o">*</span><span class="n">rank</span> <span class="o">+</span> <span class="n">j1</span> <span class="o">-</span> <span class="n">k</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rank</span> <span class="o">=</span> <span class="n">j1</span><span class="o">*</span><span class="n">rank</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">rank</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Permutation.unrank_trotterjohnson"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.unrank_trotterjohnson">[docs]</a>    <span class="k">def</span> <span class="nf">unrank_trotterjohnson</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trotter Johnson permutation unranking. See [4] section 2.4.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.unrank_trotterjohnson(5, 10)</span>
<span class="sd">        Permutation([0, 3, 1, 2, 4])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        rank_trotterjohnson, next_trotterjohnson</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">size</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ifac</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">pj</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">pj</span> <span class="o">*=</span> <span class="n">j</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="p">(</span><span class="n">rank</span> <span class="o">*</span> <span class="n">pj</span><span class="p">)</span> <span class="o">//</span> <span class="n">n</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="n">j</span><span class="o">*</span><span class="n">r2</span>
            <span class="k">if</span> <span class="n">r2</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">perm</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">perm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation.next_trotterjohnson"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.next_trotterjohnson">[docs]</a>    <span class="k">def</span> <span class="nf">next_trotterjohnson</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next permutation in Trotter-Johnson order.</span>
<span class="sd">        If self is the last permutation it returns None.</span>
<span class="sd">        See [4] section 2.4.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([3, 0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; p.rank_trotterjohnson()</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; p = p.next_trotterjohnson(); p</span>
<span class="sd">        Permutation([0, 3, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; p.rank_trotterjohnson()</span>
<span class="sd">        5</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        rank_trotterjohnson, unrank_trotterjohnson</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span><span class="p">[:]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[:]</span>
        <span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">rho</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">par</span> <span class="o">=</span> <span class="n">_af_parity</span><span class="p">(</span><span class="n">rho</span><span class="p">[:</span><span class="n">m</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">par</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pi</span><span class="p">[</span><span class="n">st</span> <span class="o">+</span> <span class="n">d</span><span class="p">],</span> <span class="n">pi</span><span class="p">[</span><span class="n">st</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">st</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pi</span><span class="p">[</span><span class="n">st</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">st</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pi</span><span class="p">[</span><span class="n">st</span> <span class="o">+</span> <span class="n">d</span><span class="p">],</span> <span class="n">pi</span><span class="p">[</span><span class="n">st</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pi</span><span class="p">[</span><span class="n">st</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pi</span><span class="p">[</span><span class="n">st</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span>
                    <span class="n">done</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Permutation.get_precedence_matrix"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.get_precedence_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_precedence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the precedence matrix. This is used for computing the</span>
<span class="sd">        distance between two permutations.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation.josephus(3,6,1)</span>
<span class="sd">        &gt;&gt;&gt; p</span>
<span class="sd">        Permutation([2, 5, 3, 1, 4, 0])</span>
<span class="sd">        &gt;&gt;&gt; p.get_precedence_matrix()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0, 0, 0, 0],</span>
<span class="sd">        [1, 0, 0, 0, 1, 0],</span>
<span class="sd">        [1, 1, 0, 1, 1, 1],</span>
<span class="sd">        [1, 1, 0, 0, 1, 0],</span>
<span class="sd">        [1, 0, 0, 0, 0, 0],</span>
<span class="sd">        [1, 1, 0, 1, 1, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        get_precedence_distance, get_adjacency_matrix, get_adjacency_distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">cols</span><span class="p">):</span>
                <span class="n">m</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">m</span>
</div>
<div class="viewcode-block" id="Permutation.get_precedence_distance"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.get_precedence_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_precedence_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the precedence distance between two permutations.</span>

<span class="sd">        Suppose p and p&#39; represent n jobs. The precedence metric</span>
<span class="sd">        counts the number of times a job j is prededed by job i</span>
<span class="sd">        in both p and p&#39;. This metric is commutative.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([2, 0, 4, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; q = Permutation([3, 1, 2, 4, 0])</span>
<span class="sd">        &gt;&gt;&gt; p.get_precedence_distance(q)</span>
<span class="sd">        7</span>
<span class="sd">        &gt;&gt;&gt; q.get_precedence_distance(p)</span>
<span class="sd">        7</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        get_precedence_matrix, get_adjacency_matrix, get_adjacency_distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The permutations must be of equal size.&quot;</span><span class="p">)</span>
        <span class="n">self_prec_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_precedence_matrix</span><span class="p">()</span>
        <span class="n">other_prec_mat</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_precedence_matrix</span><span class="p">()</span>
        <span class="n">n_prec</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">self_prec_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">other_prec_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">n_prec</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">-</span> <span class="n">n_prec</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="Permutation.get_adjacency_matrix"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.get_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the adjacency matrix of a permutation.</span>

<span class="sd">        If job i is adjacent to job j in a permutation p</span>
<span class="sd">        then we set m[i, j] = 1 where m is the adjacency</span>
<span class="sd">        matrix of p.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation.josephus(3,6,1)</span>
<span class="sd">        &gt;&gt;&gt; p.get_adjacency_matrix()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 0, 0, 0, 0, 0],</span>
<span class="sd">        [0, 0, 0, 0, 1, 0],</span>
<span class="sd">        [0, 0, 0, 0, 0, 1],</span>
<span class="sd">        [0, 1, 0, 0, 0, 0],</span>
<span class="sd">        [1, 0, 0, 0, 0, 0],</span>
<span class="sd">        [0, 0, 0, 1, 0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; q = Permutation([0, 1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; q.get_adjacency_matrix()</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [0, 1, 0, 0],</span>
<span class="sd">        [0, 0, 1, 0],</span>
<span class="sd">        [0, 0, 0, 1],</span>
<span class="sd">        [0, 0, 0, 0]])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        get_precedence_matrix, get_precedence_distance, get_adjacency_distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">m</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">m</span>
</div>
<div class="viewcode-block" id="Permutation.get_adjacency_distance"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.get_adjacency_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_adjacency_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the adjacency distance between two permutations.</span>

<span class="sd">        This metric counts the number of times a pair i,j of jobs is</span>
<span class="sd">        adjacent in both p and p&#39;. If n_adj is this quantity then</span>
<span class="sd">        the adjacency distance is n - n_adj - 1 [1]</span>

<span class="sd">        [1] Reeves, Colin R. Landscapes, Operators and Heuristic search, Annals</span>
<span class="sd">        of Operational Research, 86, pp 473-490. (1999)</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0, 3, 1, 2, 4])</span>
<span class="sd">        &gt;&gt;&gt; q = Permutation.josephus(4, 5, 2)</span>
<span class="sd">        &gt;&gt;&gt; p.get_adjacency_distance(q)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; r = Permutation([0, 2, 1, 4, 3])</span>
<span class="sd">        &gt;&gt;&gt; p.get_adjacency_distance(r)</span>
<span class="sd">        4</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        get_precedence_matrix, get_precedence_distance, get_adjacency_matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The permutations must be of the same size.&quot;</span><span class="p">)</span>
        <span class="n">self_adj_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">()</span>
        <span class="n">other_adj_mat</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_adjacency_matrix</span><span class="p">()</span>
        <span class="n">n_adj</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">self_adj_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">other_adj_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">n_adj</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">n_adj</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="Permutation.get_positional_distance"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.get_positional_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_positional_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the positional distance between two permutations.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation([0, 3, 1, 2, 4])</span>
<span class="sd">        &gt;&gt;&gt; q = Permutation.josephus(4, 5, 2)</span>
<span class="sd">        &gt;&gt;&gt; r = Permutation([3, 1, 4, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; p.get_positional_distance(q)</span>
<span class="sd">        12</span>
<span class="sd">        &gt;&gt;&gt; p.get_positional_distance(r)</span>
<span class="sd">        12</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        get_precedence_distance, get_adjacency_distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array_form</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">array_form</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The permutations must be of the same size.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))])</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Permutation.josephus"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.josephus">[docs]</a>    <span class="k">def</span> <span class="nf">josephus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return as a permutation the shuffling of range(n) using the Josephus</span>
<span class="sd">        scheme in which every m-th item is selected until all have been chosen.</span>
<span class="sd">        The returned permutation has elements listed by the order in which they</span>
<span class="sd">        were selected.</span>

<span class="sd">        The parameter ``s`` stops the selection process when there are ``s``</span>
<span class="sd">        items remaining and these are selected by countinuing the selection,</span>
<span class="sd">        counting by 1 rather than by ``m``.</span>

<span class="sd">        Consider selecting every 3rd item from 6 until only 2 remain::</span>

<span class="sd">            choices    chosen</span>
<span class="sd">            ========   ======</span>
<span class="sd">              012345</span>
<span class="sd">              01 345   2</span>
<span class="sd">              01 34    25</span>
<span class="sd">              01  4    253</span>
<span class="sd">              0   4    2531</span>
<span class="sd">              0        25314</span>
<span class="sd">                       253140</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.josephus(3, 6, 2).array_form</span>
<span class="sd">        [2, 5, 3, 1, 4, 0]</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        1. http://en.wikipedia.org/wiki/Flavius_Josephus</span>
<span class="sd">        2. http://en.wikipedia.org/wiki/Josephus_problem</span>
<span class="sd">        3. http://www.wou.edu/~burtonl/josephus.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
        <span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">popleft</span><span class="p">())</span>
            <span class="n">perm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">popleft</span><span class="p">())</span>
        <span class="n">perm</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Perm</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Permutation.from_inversion_vector"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.from_inversion_vector">[docs]</a>    <span class="k">def</span> <span class="nf">from_inversion_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inversion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the permutation from the inversion vector.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; Permutation.from_inversion_vector([3, 2, 1, 0, 0])</span>
<span class="sd">        Permutation([3, 2, 1, 0, 4, 5])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inversion</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">inversion</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                <span class="n">perm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">N</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;The inversion vector is not valid.&quot;</span><span class="p">)</span>
        <span class="n">perm</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Permutation.random"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.random">[docs]</a>    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random permutation of length ``n``.</span>

<span class="sd">        Uses the underlying Python psuedo-random number generator.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.random(2) in (Permutation([1, 0]), Permutation([0, 1]))</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">perm_array</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">perm_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">perm_array</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Permutation.unrank_lex"><a class="viewcode-back" href="../../../modules/combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation.unrank_lex">[docs]</a>    <span class="k">def</span> <span class="nf">unrank_lex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lexicographic permutation unranking.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = False</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation.unrank_lex(5, 10)</span>
<span class="sd">        &gt;&gt;&gt; a.rank()</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        Permutation([0, 2, 4, 1, 3])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        rank, next_lex</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">perm_array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>
        <span class="n">psize</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">new_psize</span> <span class="o">=</span> <span class="n">psize</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">rank</span> <span class="o">%</span> <span class="n">new_psize</span><span class="p">)</span> <span class="o">//</span> <span class="n">psize</span>
            <span class="n">rank</span> <span class="o">-=</span> <span class="n">d</span><span class="o">*</span><span class="n">psize</span>
            <span class="n">perm_array</span><span class="p">[</span><span class="n">size</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">perm_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">perm_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">psize</span> <span class="o">=</span> <span class="n">new_psize</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">perm_array</span><span class="p">)</span>

    <span class="c"># global flag to control how permutations are printed</span>
    <span class="c"># when True, Permutation([0, 2, 1, 3]) -&gt; Cycle(1, 2)</span>
    <span class="c"># when False, Permutation([0, 2, 1, 3]) -&gt; Permutation([0, 2, 1])</span></div>
    <span class="n">print_cyclic</span> <span class="o">=</span> <span class="bp">True</span>

</div>
<span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges two sorted arrays and calculates the inversion count.</span>

<span class="sd">    Helper function for calculating inversions. This method is</span>
<span class="sd">    for internal use only.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">mid</span>
    <span class="n">inv_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">inv_count</span> <span class="o">+=</span> <span class="p">(</span><span class="n">mid</span> <span class="o">-</span><span class="n">i</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">:</span>
        <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">+=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">inv_count</span>

<span class="n">Perm</span> <span class="o">=</span> <span class="n">Permutation</span>
<span class="n">_af_new</span> <span class="o">=</span> <span class="n">Perm</span><span class="o">.</span><span class="n">_af_new</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../combinatorics.html" >sympy.combinatorics</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Jun 29, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>