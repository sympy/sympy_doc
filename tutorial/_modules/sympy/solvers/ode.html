

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.solvers.ode &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.solvers.ode</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains dsolve() and different helper functions that it</span>
<span class="sd">uses.</span>

<span class="sd">dsolve() solves ordinary differential equations. See the docstring on</span>
<span class="sd">the various functions for their uses. Note that partial differential</span>
<span class="sd">equations support is in pde.py.  Note that ode_hint() functions have</span>
<span class="sd">docstrings describing their various methods, but they are intended for</span>
<span class="sd">internal use.  Use dsolve(ode, func, hint=hint) to solve an ode using a</span>
<span class="sd">specific hint.  See also the docstring on dsolve().</span>

<span class="sd">**Functions in this module**</span>

<span class="sd">    These are the user functions in this module:</span>

<span class="sd">    - dsolve() - Solves ODEs.</span>
<span class="sd">    - classify_ode() - Classifies ODEs into possible hints for dsolve().</span>
<span class="sd">    - checkodesol() - Checks if an equation is the solution to an ODE.</span>
<span class="sd">    - homogeneous_order() - Returns the homogeneous order of an</span>
<span class="sd">      expression.</span>

<span class="sd">    These are the non-solver helper functions that are for internal use.</span>
<span class="sd">    The user should use the various options to dsolve() to obtain the</span>
<span class="sd">    functionality provided by these functions:</span>

<span class="sd">    - odesimp() - Does all forms of ODE simplification.</span>
<span class="sd">    - ode_sol_simplicity() - A key function for comparing solutions by</span>
<span class="sd">      simplicity.</span>
<span class="sd">    - constantsimp() - Simplifies arbitrary constants.</span>
<span class="sd">    - constant_renumber() - Renumber arbitrary constants</span>
<span class="sd">    - _handle_Integral() - Evaluate unevaluated Integrals.</span>

<span class="sd">    See also the docstrings of these functions.</span>

<span class="sd">**Currently implemented solver methods**</span>

<span class="sd">The following methods are implemented for solving ordinary differential</span>
<span class="sd">equations.  See the docstrings of the various ode_hint() functions for</span>
<span class="sd">more information on each (run help(ode)):</span>

<span class="sd">  - 1st order separable differential equations</span>
<span class="sd">  - 1st order differential equations whose coefficients or dx and dy</span>
<span class="sd">    are functions homogeneous of the same order.</span>
<span class="sd">  - 1st order exact differential equations.</span>
<span class="sd">  - 1st order linear differential equations</span>
<span class="sd">  - 1st order Bernoulli differential equations.</span>
<span class="sd">  - 2nd order Liouville differential equations.</span>
<span class="sd">  - nth order linear homogeneous differential equation with constant</span>
<span class="sd">    coefficients.</span>
<span class="sd">  - nth order linear inhomogeneous differential equation with constant</span>
<span class="sd">    coefficients using the method of undetermined coefficients.</span>
<span class="sd">  - nth order linear inhomogeneous differential equation with constant</span>
<span class="sd">    coefficients using the method of variation of parameters.</span>

<span class="sd">**Philosophy behind this module**</span>

<span class="sd">This module is designed to make it easy to add new ODE solving methods</span>
<span class="sd">without having to mess with the solving code for other methods.  The</span>
<span class="sd">idea is that there is a classify_ode() function, which takes in an ODE</span>
<span class="sd">and tells you what hints, if any, will solve the ODE.  It does this</span>
<span class="sd">without attempting to solve the ODE, so it is fast.  Each solving method</span>
<span class="sd">is a hint, and it has its own function, named ode_hint.  That function</span>
<span class="sd">takes in the ODE and any match expression gathered by classify_ode and</span>
<span class="sd">returns a solved result.  If this result has any integrals in it, the</span>
<span class="sd">ode_hint function will return an unevaluated Integral class. dsolve(),</span>
<span class="sd">which is the user wrapper function around all of this, will then call</span>
<span class="sd">odesimp() on the result, which, among other things, will attempt to</span>
<span class="sd">solve the equation for the dependent variable (the function we are</span>
<span class="sd">solving for), simplify the arbitrary constants in the expression, and</span>
<span class="sd">evaluate any integrals, if the hint allows it.</span>

<span class="sd">**How to add new solution methods**</span>

<span class="sd">If you have an ODE that you want dsolve() to be able to solve, try to</span>
<span class="sd">avoid adding special case code here.  Instead, try finding a general</span>
<span class="sd">method that will solve your ODE, as well as others.  This way, the ode</span>
<span class="sd">module will become more robust, and unhindered by special case hacks.</span>
<span class="sd">WolphramAlpha and Maple&#39;s DETools[odeadvisor] function are two resources</span>
<span class="sd">you can use to classify a specific ODE.  It is also better for a method</span>
<span class="sd">to work with an nth order ODE instead of only with specific orders, if</span>
<span class="sd">possible.</span>

<span class="sd">To add a new method, there are a few things that you need to do.  First,</span>
<span class="sd">you need a hint name for your method.  Try to name your hint so that it</span>
<span class="sd">is unambiguous with all other methods, including ones that may not be</span>
<span class="sd">implemented yet.  If your method uses integrals, also include a</span>
<span class="sd">&quot;hint_Integral&quot; hint.  If there is more than one way to solve ODEs with</span>
<span class="sd">your method, include a hint for each one, as well as a &quot;hint_best&quot; hint.</span>
<span class="sd">Your ode_hint_best() function should choose the best using min with</span>
<span class="sd">ode_sol_simplicity as the key argument.  See</span>
<span class="sd">ode_1st_homogeneous_coeff_best(), for example. The function that uses</span>
<span class="sd">your method will be called ode_hint(), so the hint must only use</span>
<span class="sd">characters that are allowed in a Python function name (alphanumeric</span>
<span class="sd">characters and the underscore &#39;_&#39; character).  Include a function for</span>
<span class="sd">every hint, except for &quot;_Integral&quot; hints (dsolve() takes care of those</span>
<span class="sd">automatically).  Hint names should be all lowercase, unless a word is</span>
<span class="sd">commonly capitalized (such as Integral or Bernoulli). If you have a hint</span>
<span class="sd">that you do not want to run with &quot;all_Integral&quot; that doesn&#39;t have an</span>
<span class="sd">&quot;_Integral&quot; counterpart (such as a best hint that would defeat the</span>
<span class="sd">purpose of &quot;all_Integral&quot;), you will need to remove it manually in the</span>
<span class="sd">dsolve() code.  See also the classify_ode() docstring for guidelines on</span>
<span class="sd">writing a hint name.</span>

<span class="sd">Determine *in general* how the solutions returned by your method</span>
<span class="sd">compare with other methods that can potentially solve the same ODEs.</span>
<span class="sd">Then, put your hints in the allhints tuple in the order that they should</span>
<span class="sd">be called.  The ordering of this tuple determines which hints are</span>
<span class="sd">default. Note that exceptions are ok, because it is easy for the user to</span>
<span class="sd">choose individual hints with dsolve().  In general, &quot;_Integral&quot; variants</span>
<span class="sd">should go at the end of the list, and &quot;_best&quot; variants should go before</span>
<span class="sd">the various hints they apply to.  For example, the</span>
<span class="sd">&quot;undetermined_coefficients&quot; hint comes before the</span>
<span class="sd">&quot;variation_of_parameters&quot; hint because, even though variation of</span>
<span class="sd">parameters is more general than undetermined coefficients, undetermined</span>
<span class="sd">coefficients generally returns cleaner results for the ODEs that it can</span>
<span class="sd">solve than variation of parameters does, and it does not require</span>
<span class="sd">integration, so it is much faster.</span>

<span class="sd">Next, you need to have a match expression or a function that matches the</span>
<span class="sd">type of the ODE, which you should put in classify_ode() (if the match</span>
<span class="sd">function is more than just a few lines, like</span>
<span class="sd">_undetermined_coefficients_match(), it should go outside of</span>
<span class="sd">classify_ode()).  It should match the ODE without solving for it as much</span>
<span class="sd">as possible, so that classify_ode() remains fast and is not hindered by</span>
<span class="sd">bugs in solving code.  Be sure to consider corner cases. For example, if</span>
<span class="sd">your solution method involves dividing by something, make sure you</span>
<span class="sd">exclude the case where that division will be 0.</span>

<span class="sd">In most cases, the matching of the ODE will also give you the various</span>
<span class="sd">parts that you need to solve it. You should put that in a dictionary</span>
<span class="sd">(.match() will do this for you), and add that as matching_hints[&#39;hint&#39;]</span>
<span class="sd">= matchdict in the relevant part of classify_ode.  classify_ode will</span>
<span class="sd">then send this to dsolve(), which will send it to your function as the</span>
<span class="sd">match argument. Your function should be named ode_hint(eq, func, order,</span>
<span class="sd">match). If you need to send more information, put it in the match</span>
<span class="sd">dictionary.  For example, if you had to substitute in a dummy variable</span>
<span class="sd">in classify_ode to match the ODE, you will need to pass it to your</span>
<span class="sd">function using the match dict to access it.  You can access the</span>
<span class="sd">independent variable using func.args[0], and the dependent variable (the</span>
<span class="sd">function you are trying to solve for) as func.func.  If, while trying to</span>
<span class="sd">solve the ODE, you find that you cannot, raise NotImplementedError.</span>
<span class="sd">dsolve() will catch this error with the &quot;all&quot; meta-hint, rather than</span>
<span class="sd">causing the whole routine to fail.</span>

<span class="sd">Add a docstring to your function that describes the method employed.</span>
<span class="sd">Like with anything else in SymPy, you will need to add a doctest to the</span>
<span class="sd">docstring, in addition to real tests in test_ode.py.  Try to maintain</span>
<span class="sd">consistency with the other hint functions&#39; docstrings.  Add your method</span>
<span class="sd">to the list at the top of this docstring.  Also, add your method to</span>
<span class="sd">ode.rst in the docs/src directory, so that the Sphinx docs will pull its</span>
<span class="sd">docstring into the main SymPy documentation.  Be sure to make the Sphinx</span>
<span class="sd">documentation by running &quot;make html&quot; from within the doc directory to</span>
<span class="sd">verify that the docstring formats correctly.</span>

<span class="sd">If your solution method involves integrating, use C.Integral() instead</span>
<span class="sd">of integrate().  This allows the user to bypass hard/slow integration by</span>
<span class="sd">using the &quot;_Integral&quot; variant of your hint.  In most cases, calling</span>
<span class="sd">.doit() will integrate your solution.  If this is not the case, you will</span>
<span class="sd">need to write special code in _handle_Integral().  Arbitrary constants</span>
<span class="sd">should be symbols named C1, C2, and so on.  All solution methods should</span>
<span class="sd">return an equality instance.  If you need an arbitrary number of</span>
<span class="sd">arbitrary constants, you can use constants =</span>
<span class="sd">numbered_symbols(prefix=&#39;C&#39;, cls=Symbol, start=1).  If it is</span>
<span class="sd">possible to solve for the dependent function in a general way, do so.</span>
<span class="sd">Otherwise, do as best as you can, but do not call solve in your</span>
<span class="sd">ode_hint() function.  odesimp() will attempt to solve the solution for</span>
<span class="sd">you, so you do not need to do that. Lastly, if your ODE has a common</span>
<span class="sd">simplification that can be applied to your solutions, you can add a</span>
<span class="sd">special case in odesimp() for it.  For example, solutions returned from</span>
<span class="sd">the &quot;1st_homogeneous_coeff&quot; hints often have many log() terms, so</span>
<span class="sd">odesimp() calls logcombine() on them (it also helps to write the</span>
<span class="sd">arbitrary constant as log(C1) instead of C1 in this case).  Also</span>
<span class="sd">consider common ways that you can rearrange your solution to have</span>
<span class="sd">constantsimp() take better advantage of it.  It is better to put</span>
<span class="sd">simplification in odesimp() than in your method, because it can then be</span>
<span class="sd">turned off with the simplify flag in dsolve(). If you have any</span>
<span class="sd">extraneous simplification in your function, be sure to only run it using</span>
<span class="sd">&quot;if match.get(&#39;simplify&#39;, True):&quot;, especially if it can be slow or if it</span>
<span class="sd">can reduce the domain of the solution.</span>

<span class="sd">Finally, as with every contribution to SymPy, your method will need to</span>
<span class="sd">be tested. Add a test for each method in test_ode.py.  Follow the</span>
<span class="sd">conventions there, i.e., test the solver using dsolve(eq, f(x),</span>
<span class="sd">hint=your_hint), and also test the solution using checkodesol (you can</span>
<span class="sd">put these in a separate tests and skip/XFAIL if it runs too slow/doesn&#39;t</span>
<span class="sd">work).  Be sure to call your hint specifically in dsolve, that way the</span>
<span class="sd">test won&#39;t be broken simply by the introduction of another matching</span>
<span class="sd">hint. If your method works for higher order (&gt;1) ODEs, you will need to</span>
<span class="sd">run sol = constant_renumber(sol, &#39;C&#39;, 1, order), for each solution, where</span>
<span class="sd">order is the order of the ODE. This is because constant_renumber renumbers</span>
<span class="sd">the arbitrary constants by printing order, which is platform dependent.</span>
<span class="sd">Try to test every corner case of your solver, including a range of</span>
<span class="sd">orders if it is a nth order solver, but if your solver is slow, such as</span>
<span class="sd">if it involves hard integration, try to keep the test run time down.</span>

<span class="sd">Feel free to refactor existing hints to avoid duplicating code or</span>
<span class="sd">creating inconsistencies.  If you can show that your method exactly</span>
<span class="sd">duplicates an existing method, including in the simplicity and speed of</span>
<span class="sd">obtaining the solutions, then you can remove the old, less general</span>
<span class="sd">method. The existing code is tested extensively in test_ode.py, so if</span>
<span class="sd">anything is broken, one of those tests will surely fail.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Add</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">oo</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">set_union</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.exceptions</span> <span class="kn">import</span> <span class="n">SymPyDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">factor_terms</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span>
    <span class="n">expand_mul</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.multidimensional</span> <span class="kn">import</span> <span class="n">vectorize</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">Rational</span>
<span class="kn">from</span> <span class="nn">sympy.core.relational</span> <span class="kn">import</span> <span class="n">Equality</span><span class="p">,</span> <span class="n">Eq</span>
<span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="kn">import</span> <span class="n">sympify</span>

<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sign</span>
<span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">wronskian</span>
<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">,</span> <span class="n">terms_gcd</span>
<span class="kn">from</span> <span class="nn">sympy.series</span> <span class="kn">import</span> <span class="n">Order</span>
<span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">collect</span><span class="p">,</span> <span class="n">logcombine</span><span class="p">,</span> <span class="n">powsimp</span><span class="p">,</span> <span class="n">separatevars</span><span class="p">,</span> \
    <span class="n">simplify</span><span class="p">,</span> <span class="n">trigsimp</span><span class="p">,</span> <span class="n">denom</span><span class="p">,</span> <span class="n">fraction</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="kn">import</span> <span class="n">_mexpand</span>
<span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="kn">import</span> <span class="n">solve</span>

<span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">numbered_symbols</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">,</span> <span class="n">sift</span>
<span class="kn">from</span> <span class="nn">sympy.solvers.deutils</span> <span class="kn">import</span> <span class="n">_preprocess</span><span class="p">,</span> <span class="n">ode_order</span><span class="p">,</span> <span class="n">_desolve</span>

<span class="c"># This is a list of hints in the order that they should be applied.  That means</span>
<span class="c"># that, in general, hints earlier in the list should produce simpler results</span>
<span class="c"># than those later for ODEs that fit both.  This is just based on my own</span>
<span class="c"># empirical observations, so if you find that *in general*, a hint later in</span>
<span class="c"># the list is better than one before it, feel free to modify the list.  Note</span>
<span class="c"># however that you can easily override the hint used in dsolve() for a specific</span>
<span class="c"># ODE (see the docstring).  In general, &quot;_Integral&quot; hints should be grouped</span>
<span class="c"># at the end of the list, unless there is a method that returns an unevaluable</span>
<span class="c"># integral most of the time (which should surely go near the end of the list</span>
<span class="c"># anyway).</span>
<span class="c"># &quot;default&quot;, &quot;all&quot;, &quot;best&quot;, and &quot;all_Integral&quot; meta-hints should not be</span>
<span class="c"># included in this list, but &quot;_best&quot; and &quot;_Integral&quot; hints should be included.</span>
<span class="n">allhints</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s">&quot;separable&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_exact&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_linear&quot;</span><span class="p">,</span>
    <span class="s">&quot;Bernoulli&quot;</span><span class="p">,</span>
    <span class="s">&quot;Riccati_special_minus2&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_best&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_subs_indep_div_dep&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_subs_dep_div_indep&quot;</span><span class="p">,</span>
    <span class="s">&quot;almost_linear&quot;</span><span class="p">,</span>
    <span class="s">&quot;linear_coefficients&quot;</span><span class="p">,</span>
    <span class="s">&quot;separable_reduced&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_constant_coeff_homogeneous&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_euler_eq_homogeneous&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_constant_coeff_undetermined_coefficients&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_constant_coeff_variation_of_parameters&quot;</span><span class="p">,</span>
    <span class="s">&quot;Liouville&quot;</span><span class="p">,</span>
    <span class="s">&quot;separable_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_linear_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;Bernoulli_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_subs_indep_div_dep_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_subs_dep_div_indep_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;almost_linear_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;linear_coefficients_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;separable_reduced_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_constant_coeff_variation_of_parameters_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;Liouville_Integral&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">sub_func_doit</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;When replacing the func with something else, we usually</span>
<span class="sd">    want the derivative evaluated, so this function helps in</span>
<span class="sd">    making that happen.</span>

<span class="sd">    To keep subs from having to look through all derivatives, we</span>
<span class="sd">    mask them off with dummy variables, do the func sub, and then</span>
<span class="sd">    replace masked-off derivatives with their doit values.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Derivative, symbols, Function</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import sub_func_doit</span>
<span class="sd">    &gt;&gt;&gt; x, z = symbols(&#39;x, z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Function(&#39;y&#39;)</span>

<span class="sd">    &gt;&gt;&gt; sub_func_doit(3*Derivative(y(x), x) - 1, y(x), x)</span>
<span class="sd">    2</span>

<span class="sd">    &gt;&gt;&gt; sub_func_doit(x*Derivative(y(x), x) - y(x)**2 + y(x), y(x),</span>
<span class="sd">    ... 1/(x*(z + 1/x)))</span>
<span class="sd">    x*(-1/(x**2*(z + 1/x)) + 1/(x**3*(z + 1/x)**2)) + 1/(x*(z + 1/x))</span>
<span class="sd">    ...- 1/(x**2*(z + 1/x)**2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">repu</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Derivative</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
        <span class="n">repu</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
        <span class="n">reps</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">repu</span><span class="p">)</span>


<div class="viewcode-block" id="dsolve"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.dsolve">[docs]</a><span class="k">def</span> <span class="nf">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves any (supported) kind of ordinary differential equation.</span>

<span class="sd">    **Usage**</span>

<span class="sd">        dsolve(eq, f(x), hint) -&gt; Solve ordinary differential equation</span>
<span class="sd">        eq for function f(x), using method hint.</span>


<span class="sd">    **Details**</span>

<span class="sd">        ``eq`` can be any supported ordinary differential equation (see</span>
<span class="sd">            the ode docstring for supported methods).  This can either</span>
<span class="sd">            be an Equality, or an expression, which is assumed to be</span>
<span class="sd">            equal to 0.</span>

<span class="sd">        ``f(x)`` is a function of one variable whose derivatives in that</span>
<span class="sd">            variable make up the ordinary differential equation eq. In many</span>
<span class="sd">            cases it is not necessary to provide this; it will be autodetected</span>
<span class="sd">            (and an error raised if it couldn&#39;t be detected).</span>

<span class="sd">        ``hint`` is the solving method that you want dsolve to use.  Use</span>
<span class="sd">            classify_ode(eq, f(x)) to get all of the possible hints for</span>
<span class="sd">            an ODE.  The default hint, &#39;default&#39;, will use whatever hint</span>
<span class="sd">            is returned first by classify_ode().  See Hints below for</span>
<span class="sd">            more options that you can use for hint.</span>

<span class="sd">        ``simplify`` enables simplification by odesimp().  See its</span>
<span class="sd">            docstring for more information.  Turn this off, for example,</span>
<span class="sd">            to disable solving of solutions for func or simplification</span>
<span class="sd">            of arbitrary constants.  It will still integrate with this</span>
<span class="sd">            hint. Note that the solution may contain more arbitrary</span>
<span class="sd">            constants than the order of the ODE with this option</span>
<span class="sd">            enabled.</span>

<span class="sd">    **Hints**</span>

<span class="sd">        Aside from the various solving methods, there are also some</span>
<span class="sd">        meta-hints that you can pass to dsolve():</span>

<span class="sd">        &quot;default&quot;:</span>
<span class="sd">                This uses whatever hint is returned first by</span>
<span class="sd">                classify_ode(). This is the default argument to</span>
<span class="sd">                dsolve().</span>

<span class="sd">        &quot;all&quot;:</span>
<span class="sd">                To make dsolve apply all relevant classification hints,</span>
<span class="sd">                use dsolve(ODE, func, hint=&quot;all&quot;).  This will return a</span>
<span class="sd">                dictionary of hint:solution terms.  If a hint causes</span>
<span class="sd">                dsolve to raise the NotImplementedError, value of that</span>
<span class="sd">                hint&#39;s key will be the exception object raised.  The</span>
<span class="sd">                dictionary will also include some special keys:</span>

<span class="sd">                - order: The order of the ODE.  See also ode_order() in</span>
<span class="sd">                  deutils.py</span>
<span class="sd">                - best: The simplest hint; what would be returned by</span>
<span class="sd">                  &quot;best&quot; below.</span>
<span class="sd">                - best_hint: The hint that would produce the solution</span>
<span class="sd">                  given by &#39;best&#39;.  If more than one hint produces the</span>
<span class="sd">                  best solution, the first one in the tuple returned by</span>
<span class="sd">                  classify_ode() is chosen.</span>
<span class="sd">                - default: The solution that would be returned by</span>
<span class="sd">                  default.  This is the one produced by the hint that</span>
<span class="sd">                  appears first in the tuple returned by classify_ode().</span>

<span class="sd">        &quot;all_Integral&quot;:</span>
<span class="sd">                This is the same as &quot;all&quot;, except if a hint also has a</span>
<span class="sd">                corresponding &quot;_Integral&quot; hint, it only returns the</span>
<span class="sd">                &quot;_Integral&quot; hint.  This is useful if &quot;all&quot; causes</span>
<span class="sd">                dsolve() to hang because of a difficult or impossible</span>
<span class="sd">                integral.  This meta-hint will also be much faster than</span>
<span class="sd">                &quot;all&quot;, because integrate() is an expensive routine.</span>

<span class="sd">        &quot;best&quot;:</span>
<span class="sd">                To have dsolve() try all methods and return the simplest</span>
<span class="sd">                one.  This takes into account whether the solution is</span>
<span class="sd">                solvable in the function, whether it contains any</span>
<span class="sd">                Integral classes (i.e. unevaluatable integrals), and</span>
<span class="sd">                which one is the shortest in size.</span>

<span class="sd">        See also the classify_ode() docstring for more info on hints,</span>
<span class="sd">        and the ode docstring for a list of all supported hints.</span>


<span class="sd">    **Tips**</span>
<span class="sd">        - You can declare the derivative of an unknown function this way:</span>
<span class="sd">            &gt;&gt;&gt; from sympy import Function, Derivative</span>
<span class="sd">            &gt;&gt;&gt; from sympy.abc import x # x is the independent variable</span>
<span class="sd">            &gt;&gt;&gt; f = Function(&quot;f&quot;)(x) # f is a function of x</span>
<span class="sd">            &gt;&gt;&gt; # f_ will be the derivative of f with respect to x</span>
<span class="sd">            &gt;&gt;&gt; f_ = Derivative(f, x)</span>

<span class="sd">        - See test_ode.py for many tests, which serves also as a set of</span>
<span class="sd">          examples for how to use dsolve().</span>
<span class="sd">        - dsolve always returns an Equality class (except for the case</span>
<span class="sd">          when the hint is &quot;all&quot; or &quot;all_Integral&quot;).  If possible, it</span>
<span class="sd">          solves the solution explicitly for the function being solved</span>
<span class="sd">          for. Otherwise, it returns an implicit solution.</span>
<span class="sd">        - Arbitrary constants are symbols named C1, C2, and so on.</span>
<span class="sd">        - Because all solutions should be mathematically equivalent,</span>
<span class="sd">          some hints may return the exact same result for an ODE. Often,</span>
<span class="sd">          though, two different hints will return the same solution</span>
<span class="sd">          formatted differently.  The two should be equivalent. Also</span>
<span class="sd">          note that sometimes the values of the arbitrary constants in</span>
<span class="sd">          two different solutions may not be the same, because one</span>
<span class="sd">          constant may have &quot;absorbed&quot; other constants into it.</span>
<span class="sd">        - Do help(ode.ode_hintname) to get help more information on a</span>
<span class="sd">          specific hint, where hintname is the name of a hint without</span>
<span class="sd">          &quot;_Integral&quot;.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq, Derivative, sin, cos</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(Derivative(f(x),x,x)+9*f(x), f(x))</span>
<span class="sd">    f(x) == C1*sin(3*x) + C2*cos(3*x)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(sin(x)*cos(f(x)) + cos(x)*sin(f(x))*f(x).diff(x), f(x),</span>
<span class="sd">    ...     hint=&#39;separable&#39;, simplify=False)</span>
<span class="sd">    -log(sin(f(x))**2 - 1)/2 == C1 + log(sin(x)**2 - 1)/2</span>
<span class="sd">    &gt;&gt;&gt; dsolve(sin(x)*cos(f(x)) + cos(x)*sin(f(x))*f(x).diff(x), f(x),</span>
<span class="sd">    ...     hint=&#39;1st_exact&#39;)</span>
<span class="sd">    f(x) == acos(C1/cos(x))</span>
<span class="sd">    &gt;&gt;&gt; dsolve(sin(x)*cos(f(x)) + cos(x)*sin(f(x))*f(x).diff(x), f(x),</span>
<span class="sd">    ...     hint=&#39;almost_linear&#39;)</span>
<span class="sd">    [f(x) == acos(-sqrt(C1/cos(x)**2)), f(x) == acos(sqrt(C1/cos(x)**2))]</span>
<span class="sd">    &gt;&gt;&gt; dsolve(sin(x)*cos(f(x)) + cos(x)*sin(f(x))*f(x).diff(x), f(x),</span>
<span class="sd">    ... hint=&#39;best&#39;)</span>
<span class="sd">    f(x) == acos(C1/cos(x))</span>
<span class="sd">    &gt;&gt;&gt; # Note that even though separable is the default, 1st_exact produces</span>
<span class="sd">    &gt;&gt;&gt; # a simpler result in this case.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">given_hint</span> <span class="o">=</span> <span class="n">hint</span>  <span class="c"># hint given by the user</span>

    <span class="c"># See the docstring of _desolve for more details.</span>
    <span class="n">hints</span> <span class="o">=</span> <span class="n">_desolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
        <span class="n">hint</span><span class="o">=</span><span class="n">hint</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;ode&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;eq&#39;</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span>
    <span class="n">all_</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">all_</span><span class="p">:</span>
        <span class="n">retdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">failed_hints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">gethints</span> <span class="o">=</span> <span class="n">classify_ode</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">orderedhints</span> <span class="o">=</span> <span class="n">gethints</span><span class="p">[</span><span class="s">&#39;ordered_hints&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="n">hints</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">_helper_simplify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">hints</span><span class="p">[</span><span class="n">hint</span><span class="p">],</span> <span class="n">simplify</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">,</span> <span class="n">detail</span><span class="p">:</span>
                <span class="n">failed_hints</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span> <span class="o">=</span> <span class="n">detail</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retdict</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span> <span class="o">=</span> <span class="n">rv</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">hints</span><span class="p">[</span><span class="n">hint</span><span class="p">][</span><span class="s">&#39;func&#39;</span><span class="p">]</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;best&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">retdict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">trysolving</span><span class="o">=</span><span class="ow">not</span> <span class="n">simplify</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">given_hint</span> <span class="o">==</span> <span class="s">&#39;best&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;best&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">orderedhints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;best&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">retdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;best_hint&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gethints</span><span class="p">[</span><span class="s">&#39;default&#39;</span><span class="p">]</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gethints</span><span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">]</span>
        <span class="n">retdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">failed_hints</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retdict</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c"># The key &#39;hint&#39; stores the hint needed to be solved for.</span>
        <span class="n">hint</span> <span class="o">=</span> <span class="n">hints</span><span class="p">[</span><span class="s">&#39;hint&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_helper_simplify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">hints</span><span class="p">,</span> <span class="n">simplify</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">_helper_simplify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper function of dsolve that calls the respective</span>
<span class="sd">    ode functions to solve for the ordinary differential</span>
<span class="sd">    equations. This minimises the computation in</span>
<span class="sd">    calling _desolve multiple times.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>
    <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;_Integral&#39;</span><span class="p">):</span>
        <span class="n">solvefunc</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="s">&#39;ode_&#39;</span> <span class="o">+</span> <span class="n">hint</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s">&#39;_Integral&#39;</span><span class="p">)]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solvefunc</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="s">&#39;ode_&#39;</span> <span class="o">+</span> <span class="n">hint</span><span class="p">]</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;func&#39;</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">]</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
        <span class="c"># odesimp() will attempt to integrate, if necessary, apply constantsimp(),</span>
        <span class="c"># attempt to solve for func, and apply any other hint specific</span>
        <span class="c"># simplifications</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">odesimp</span><span class="p">(</span><span class="n">solvefunc</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># We still want to integrate (you can disable it separately with the hint)</span>
        <span class="n">match</span><span class="p">[</span><span class="s">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># Some hints can take advantage of this option</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">_handle_Integral</span><span class="p">(</span><span class="n">solvefunc</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">),</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>

<div class="viewcode-block" id="classify_ode"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.classify_ode">[docs]</a><span class="k">def</span> <span class="nf">classify_ode</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tuple of possible dsolve() classifications for an ODE.</span>

<span class="sd">    The tuple is ordered so that first item is the classification that</span>
<span class="sd">    dsolve() uses to solve the ODE by default.  In general,</span>
<span class="sd">    classifications at the near the beginning of the list will produce</span>
<span class="sd">    better solutions faster than those near the end, thought there are</span>
<span class="sd">    always exceptions.  To make dsolve use a different classification,</span>
<span class="sd">    use dsolve(ODE, func, hint=&lt;classification&gt;).  See also the dsolve()</span>
<span class="sd">    docstring for different meta-hints you can use.</span>

<span class="sd">    If ``dict`` is true, classify_ode() will return a dictionary of</span>
<span class="sd">    hint:match expression terms. This is intended for internal use by</span>
<span class="sd">    dsolve().  Note that because dictionaries are ordered arbitrarily,</span>
<span class="sd">    this will most likely not be in the same order as the tuple.</span>

<span class="sd">    You can get help on different hints by doing help(ode.ode_hintname),</span>
<span class="sd">    where hintname is the name of the hint without &quot;_Integral&quot;.</span>

<span class="sd">    See sympy.ode.allhints or the sympy.ode docstring for a list of all</span>
<span class="sd">    supported hints that can be returned from classify_ode.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    These are remarks on hint names.</span>

<span class="sd">    *&quot;_Integral&quot;*</span>

<span class="sd">        If a classification has &quot;_Integral&quot; at the end, it will return</span>
<span class="sd">        the expression with an unevaluated Integral class in it.  Note</span>
<span class="sd">        that a hint may do this anyway if integrate() cannot do the</span>
<span class="sd">        integral, though just using an &quot;_Integral&quot; will do so much</span>
<span class="sd">        faster.  Indeed, an &quot;_Integral&quot; hint will always be faster than</span>
<span class="sd">        its corresponding hint without &quot;_Integral&quot; because integrate()</span>
<span class="sd">        is an expensive routine.  If dsolve() hangs, it is probably</span>
<span class="sd">        because integrate() is hanging on a tough or impossible</span>
<span class="sd">        integral.  Try using an &quot;_Integral&quot; hint or &quot;all_Integral&quot; to</span>
<span class="sd">        get it return something.</span>

<span class="sd">        Note that some hints do not have &quot;_Integral&quot; counterparts.  This</span>
<span class="sd">        is because integrate() is not used in solving the ODE for those</span>
<span class="sd">        method. For example, nth order linear homogeneous ODEs with</span>
<span class="sd">        constant coefficients do not require integration to solve, so</span>
<span class="sd">        there is no &quot;nth_linear_homogeneous_constant_coeff_Integrate&quot;</span>
<span class="sd">        hint. You can easily evaluate any unevaluated Integrals in an</span>
<span class="sd">        expression by doing expr.doit().</span>

<span class="sd">    *Ordinals*</span>

<span class="sd">        Some hints contain an ordinal such as &quot;1st_linear&quot;.  This is to</span>
<span class="sd">        help differentiate them from other hints, as well as from other</span>
<span class="sd">        methods that may not be implemented yet. If a hint has &quot;nth&quot; in</span>
<span class="sd">        it, such as the &quot;nth_linear&quot; hints, this means that the method</span>
<span class="sd">        used to applies to ODEs of any order.</span>

<span class="sd">    *&quot;indep&quot; and &quot;dep&quot;*</span>

<span class="sd">        Some hints contain the words &quot;indep&quot; or &quot;dep&quot;.  These reference</span>
<span class="sd">        the independent variable and the dependent function,</span>
<span class="sd">        respectively. For example, if an ODE is in terms of f(x), then</span>
<span class="sd">        &quot;indep&quot; will refer to x and &quot;dep&quot; will refer to f.</span>

<span class="sd">    *&quot;subs&quot;*</span>

<span class="sd">        If a hints has the word &quot;subs&quot; in it, it means the the ODE is</span>
<span class="sd">        solved by substituting the expression given after the word</span>
<span class="sd">        &quot;subs&quot; for a single dummy variable.  This is usually in terms of</span>
<span class="sd">        &quot;indep&quot; and &quot;dep&quot; as above.  The substituted expression will be</span>
<span class="sd">        written only in characters allowed for names of Python objects,</span>
<span class="sd">        meaning operators will be spelled out.  For example, indep/dep</span>
<span class="sd">        will be written as indep_div_dep.</span>

<span class="sd">    *&quot;coeff&quot;*</span>

<span class="sd">        The word &quot;coeff&quot; in a hint refers to the coefficients of</span>
<span class="sd">        something in the ODE, usually of the derivative terms.  See the</span>
<span class="sd">        docstring for the individual methods for more info (help(ode)).</span>
<span class="sd">        This is contrast to &quot;coefficients&quot;, as in</span>
<span class="sd">        &quot;undetermined_coefficients&quot;, which refers to the common name of</span>
<span class="sd">        a method.</span>

<span class="sd">    *&quot;_best&quot;*</span>

<span class="sd">        Methods that have more than one fundamental way to solve will</span>
<span class="sd">        have a hint for each sub-method and a &quot;_best&quot;</span>
<span class="sd">        meta-classification. This will evaluate all hints and return the</span>
<span class="sd">        best, using the same considerations as the normal &quot;best&quot;</span>
<span class="sd">        meta-hint.</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, classify_ode, Eq</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; classify_ode(Eq(f(x).diff(x), 0), f(x))</span>
<span class="sd">    (&#39;separable&#39;, &#39;1st_linear&#39;, &#39;1st_homogeneous_coeff_best&#39;,</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;,</span>
<span class="sd">    &#39;nth_linear_constant_coeff_homogeneous&#39;, &#39;separable_Integral&#39;,</span>
<span class="sd">    &#39;1st_linear_Integral&#39;,</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;)</span>
<span class="sd">    &gt;&gt;&gt; classify_ode(f(x).diff(x, 2) + 3*f(x).diff(x) + 2*f(x) - 4)</span>
<span class="sd">    (&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;,</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters&#39;,</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prep</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;prep&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">expand</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;dsolve() and classify_ode() only &quot;</span>
        <span class="s">&quot;work with functions of one variable, not </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prep</span> <span class="ow">or</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">func_</span> <span class="o">=</span> <span class="n">_preprocess</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">func_</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">classify_ode</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">prep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">ode_order</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="c"># hint:matchdict or hint:(tuple of matchdicts)</span>
    <span class="c"># Also will contain &quot;default&quot;:&lt;default hint&gt; and &quot;order&quot;:order items.</span>
    <span class="n">matching_hints</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;order&quot;</span><span class="p">:</span> <span class="n">order</span><span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;default&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">matching_hints</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">df</span><span class="p">])</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">df</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;c1&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a2&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">])</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;b2&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">])</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;c2&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">])</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;d2&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">])</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="c"># Precondition to try remove f(x) from highest order derivative</span>
    <span class="n">reduced_eq</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">deriv_coef</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">deriv_coef</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">deriv_coef</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">c1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">c1</span><span class="p">]:</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">r</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span>
                <span class="n">reduced_eq</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">arg</span><span class="o">/</span><span class="n">den</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reduced_eq</span><span class="p">:</span>
        <span class="n">reduced_eq</span> <span class="o">=</span> <span class="n">eq</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c">## Linear case: a(x)*y&#39;+b(x)*y+c(x) == 0</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">reduced_eq</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">reduced_eq</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">dep</span><span class="p">]]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">dep</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
             <span class="n">b</span><span class="p">:</span> <span class="n">dep</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
             <span class="n">c</span><span class="p">:</span> <span class="n">ind</span><span class="p">}</span>
        <span class="c"># double check f[a] since the preconditioning may have failed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">-</span> <span class="n">reduced_eq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_linear&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_linear_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c">## Bernoulli case: a(x)*y&#39;+b(x)*y+c(x)*y**n == 0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span>
            <span class="n">reduced_eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># See issue 1577</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Bernoulli&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Bernoulli_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c">## Riccati special n == -2 case: a2*y&#39;+b2*y**2+c2*y/x+d2/x**2 == 0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">reduced_eq</span><span class="p">,</span>
            <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a2</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">b2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">d2</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">b2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">r</span><span class="p">[</span><span class="n">d2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;a2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;b2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b2</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;c2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;d2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Riccati_special_minus2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c"># NON-REDUCED FORM OF EQUATION matches</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">e</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>

            <span class="c">## Exact Differential Equation: P(x, y) + Q(x, y)*y&#39; = 0 where</span>
            <span class="c"># dP/dy == dQ/dx</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">numerator</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="c"># The following few conditions try to convert a non-exact</span>
                    <span class="c"># differential equation into an exact one.</span>
                    <span class="c"># References : Differential equations with applications</span>
                    <span class="c"># and historical notes - George E. Simmons</span>

                    <span class="k">if</span> <span class="n">numerator</span><span class="p">:</span>
                        <span class="c"># If (dP/dy - dQ/dx) / Q = f(x)</span>
                        <span class="c"># then exp(integral(f(x))*equation becomes exact</span>
                        <span class="n">factor</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">numerator</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
                        <span class="n">variables</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">free_symbols</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">==</span> <span class="n">variables</span><span class="o">.</span><span class="n">pop</span><span class="p">():</span>
                            <span class="n">factor</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
                            <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
                            <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
                            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c"># If (dP/dy - dQ/dx) / -P = f(y)</span>
                            <span class="c"># then exp(integral(f(y))*equation becomes exact</span>
                            <span class="n">factor</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="o">-</span><span class="n">numerator</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                            <span class="n">variables</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">free_symbols</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="n">variables</span><span class="o">.</span><span class="n">pop</span><span class="p">():</span>
                                <span class="n">factor</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
                                <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
                                <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
                                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="c"># Differentiating the coefficients might fail because of things</span>
                <span class="c"># like f(2*x).diff(x).  See issue 1525 and issue 1620.</span>
                <span class="k">pass</span>

        <span class="c"># This match is used for several cases below; we now collect on</span>
        <span class="c"># f(x) so the matching works.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">reduced_eq</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="c"># Using r[d] and r[e] without any modification for hints</span>
            <span class="c"># linear-coefficients and separable-reduced.</span>
            <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>  <span class="c"># ode = d/e + df</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">den</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>

            <span class="c">## Separable Case: y&#39; == P(y)*Q(x)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="c"># m1[coeff]*m1[x]*m1[y] + m2[coeff]*m2[x]*m2[y]*y&#39;</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">m1</span> <span class="ow">and</span> <span class="n">m2</span><span class="p">:</span>
                <span class="n">r1</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;m1&#39;</span><span class="p">:</span> <span class="n">m1</span><span class="p">,</span> <span class="s">&#39;m2&#39;</span><span class="p">:</span> <span class="n">m2</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;separable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;separable_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span>

            <span class="c">## First order equation with homogeneous coefficients:</span>
            <span class="c"># dy/dx == F(y/x) or dy/dx == F(x/y)</span>
            <span class="n">ordera</span> <span class="o">=</span> <span class="n">homogeneous_order</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ordera</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">orderb</span> <span class="o">=</span> <span class="n">homogeneous_order</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ordera</span> <span class="o">==</span> <span class="n">orderb</span><span class="p">:</span>
                    <span class="c"># u1=y/x and u2=x/y</span>
                    <span class="n">u1</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u1&#39;</span><span class="p">)</span>
                    <span class="n">u2</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u2&#39;</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;1st_homogeneous_coeff_subs&quot;</span>
                    <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;_dep_div_indep&quot;</span>
                    <span class="n">s2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;_indep_div_dep&quot;</span>
                    <span class="k">if</span> <span class="n">simplify</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="n">u1</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">u1</span><span class="p">}))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="n">s1</span> <span class="o">+</span> <span class="s">&quot;_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">simplify</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+</span> <span class="n">u2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">u2</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">}))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="n">s2</span> <span class="o">+</span> <span class="s">&quot;_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">matching_hints</span> <span class="ow">and</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">matching_hints</span><span class="p">:</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_homogeneous_coeff_best&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

            <span class="c">## Linear coefficients of the form</span>
            <span class="c"># y&#39;+ F((a*x + b*y + c)/(a&#39;*x + b&#39;y + c&#39;)) = 0</span>
            <span class="c"># that can be reduced to homogeneous form.</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">den</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">_linear_coeff_match</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
                <span class="n">xarg</span><span class="p">,</span> <span class="n">yarg</span> <span class="o">=</span> <span class="n">params</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
                <span class="c"># Dummy substitution for df and f(x).</span>
                <span class="n">dummy_eq</span> <span class="o">=</span> <span class="n">reduced_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(((</span><span class="n">df</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">u</span><span class="p">)))</span>
                <span class="n">reps</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xarg</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span> <span class="o">+</span> <span class="n">yarg</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
                <span class="n">dummy_eq</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">dummy_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
                <span class="c"># get the re-cast values for e and d</span>
                <span class="n">r2</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">dummy_eq</span><span class="p">),</span> <span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r2</span><span class="p">:</span>
                    <span class="n">orderd</span> <span class="o">=</span> <span class="n">homogeneous_order</span><span class="p">(</span><span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">orderd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">ordere</span> <span class="o">=</span> <span class="n">homogeneous_order</span><span class="p">(</span><span class="n">r2</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">orderd</span> <span class="o">==</span> <span class="n">ordere</span><span class="p">:</span>
                            <span class="c"># Match arguments are passed in such a way that it</span>
                            <span class="c"># is coherent with the already existing homogeneous</span>
                            <span class="c"># functions.</span>
                            <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">r2</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">r2</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;xarg&#39;</span><span class="p">:</span> <span class="n">xarg</span><span class="p">,</span> <span class="s">&#39;yarg&#39;</span><span class="p">:</span> <span class="n">yarg</span><span class="p">,</span>
                                <span class="s">&#39;d&#39;</span><span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
                            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;linear_coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>
                            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;linear_coefficients_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>

            <span class="c">## Equation of the form y&#39; + (y/x)*H(x^n*y) = 0</span>
            <span class="c"># that can be reduced to separable form</span>

            <span class="n">factor</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">)</span>

            <span class="c"># Try representing factor in terms of x^n*y</span>
            <span class="c"># where n is lowest power of x in factor;</span>
            <span class="c"># first remove terms like sqrt(2)*3 from factor.atoms(Mul)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">mul</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">mul</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">u</span> <span class="ow">and</span> <span class="n">u</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
                <span class="n">r2</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;t&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">}</span>
                <span class="n">xpart</span><span class="p">,</span> <span class="n">ypart</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">test</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">subs</span><span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">t</span><span class="p">)))</span>
                <span class="n">free</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">free_symbols</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">free</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">r2</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;power&#39;</span><span class="p">:</span> <span class="n">xpart</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;u&#39;</span><span class="p">:</span> <span class="n">test</span><span class="p">})</span>
                    <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;separable_reduced&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>
                    <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;separable_reduced_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>

        <span class="c">## Almost-linear equation of the form f(x)*g(y)*y&#39; + k(x)*l(y) + m(x) = 0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">r2</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c"># Separate the terms having f(x) to r[d] and</span>
                <span class="c"># remaining to r[c]</span>
                <span class="n">no_f</span><span class="p">,</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">no_f</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">factor</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">factor</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">as_Add</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">r2</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="s">&#39;u&#39;</span><span class="p">:</span> <span class="n">u</span><span class="p">})</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">/=</span> <span class="n">u</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">/=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;almost_linear&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;almost_linear_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c"># Liouville ODE in the form</span>
        <span class="c"># f(x).diff(x, 2) + g(f(x))*(f(x).diff(x))**2 + h(x)*f(x).diff(x)</span>
        <span class="c"># See Goldstein and Braun, &quot;Advanced Methods for the Solution of</span>
        <span class="c"># Differential Equations&quot;, pg. 98</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">d</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">df</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">df</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">reduced_eq</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;g&#39;</span><span class="p">:</span> <span class="n">g</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">:</span> <span class="n">h</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Liouville&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Liouville_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># nth order linear ODE</span>
        <span class="c"># a_n(x)y^(n) + ... + a_1(x)y&#39; + a_0(x)y = F(x) = b</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">_nth_linear_match</span><span class="p">(</span><span class="n">reduced_eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="c"># Constant coefficient case (a_i is constant for all i)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c"># Inhomogeneous case: F(x) is not identically 0</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">undetcoeff</span> <span class="o">=</span> <span class="n">_undetermined_coefficients_match</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;nth_linear_constant_coeff_variation_of_parameters&quot;</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="n">s</span> <span class="o">+</span> <span class="s">&quot;_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">if</span> <span class="n">undetcoeff</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]:</span>
                    <span class="n">r</span><span class="p">[</span><span class="s">&#39;trialset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">undetcoeff</span><span class="p">[</span><span class="s">&#39;trialset&#39;</span><span class="p">]</span>
                    <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;nth_linear_constant_coeff_undetermined_&quot;</span>
                        <span class="s">&quot;coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="c"># Homogeneous case: F(x) is identically 0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;nth_linear_constant_coeff_homogeneous&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c"># Euler equation case (a_i * x**i for all i)</span>
        <span class="k">def</span> <span class="nf">_test_term</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Linear Euler ODEs have the form  K*x**order*diff(y(x),x,order),</span>
<span class="sd">            where K is independent of x and y(x), order&gt;= 0.</span>
<span class="sd">            So we need to check that for each term, coeff == K*x**order from</span>
<span class="sd">            some K.  We have a few cases, since coeff may have several</span>
<span class="sd">            different types.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="n">order</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="n">order</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">args</span>
            <span class="k">elif</span> <span class="n">coeff</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coeff</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">coeff</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">_test_term</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;nth_linear_euler_eq_homogeneous&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="c"># Order keys based on allhints.</span>
    <span class="n">retlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">allhints</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matching_hints</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c"># Dictionaries are ordered arbitrarily, so make note of which</span>
        <span class="c"># hint would come first for dsolve().  Use an ordered dict in Py 3.</span>
        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;default&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">retlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">retlist</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;ordered_hints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">retlist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matching_hints</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">retlist</span><span class="p">)</span>

</div>
<span class="nd">@vectorize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<div class="viewcode-block" id="odesimp"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.odesimp">[docs]</a><span class="k">def</span> <span class="nf">odesimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Simplifies ODEs, including trying to solve for func and running</span>
<span class="sd">    constantsimp().</span>

<span class="sd">    It may use knowledge of the type of solution that that hint returns</span>
<span class="sd">    to apply additional simplifications.</span>

<span class="sd">    It also attempts to integrate any Integrals in the expression, if</span>
<span class="sd">    the hint is not an &quot;_Integral&quot; hint.</span>

<span class="sd">    This function should have no effect on expressions returned by</span>
<span class="sd">    dsolve(), as dsolve already calls odesimp(), but the individual hint</span>
<span class="sd">    functions do not call odesimp (because the dsolve() wrapper does).</span>
<span class="sd">    Therefore, this function is designed for mainly internal use.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sin, symbols, dsolve, pprint, Function</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import odesimp</span>
<span class="sd">    &gt;&gt;&gt; x , u2, C1= symbols(&#39;x,u2,C1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    &gt;&gt;&gt; eq = dsolve(x*f(x).diff(x) - f(x) - x*sin(f(x)/x), f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="sd">    ... simplify=False)</span>
<span class="sd">    &gt;&gt;&gt; pprint(eq)</span>
<span class="sd">                            x</span>
<span class="sd">                           ----</span>
<span class="sd">                           f(x)</span>
<span class="sd">                             /</span>
<span class="sd">                            |</span>
<span class="sd">                            |   /        1   \</span>
<span class="sd">                            |  -|u2 + -------|</span>
<span class="sd">                            |   |        /1 \|</span>
<span class="sd">                            |   |     sin|--||</span>
<span class="sd">                            |   \        \u2//</span>
<span class="sd">    log(f(x)) = log(C1) +   |  --------------- d(u2)</span>
<span class="sd">                            |          2</span>
<span class="sd">                            |        u2</span>
<span class="sd">                            |</span>
<span class="sd">                           /</span>

<span class="sd">    &gt;&gt;&gt; pprint(odesimp(eq, f(x), 1,</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span>
<span class="sd">    ... )) #doctest: +SKIP</span>
<span class="sd">        x</span>
<span class="sd">    --------- = C1</span>
<span class="sd">       /f(x)\</span>
<span class="sd">    tan|----|</span>
<span class="sd">       \2*x /</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>

    <span class="c"># First, integrate if the hint allows it.</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">_handle_Integral</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Equality</span><span class="p">)</span>

    <span class="c"># Second, clean up the arbitrary constants.</span>
    <span class="c"># Right now, nth linear hints can put as many as 2*order constants in an</span>
    <span class="c"># expression.  If that number grows with another hint, the third argument</span>
    <span class="c"># here should be raised accordingly, or constantsimp() rewritten to handle</span>
    <span class="c"># an arbitrary number of constants.</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">)</span>

    <span class="c"># Lastly, now that we have cleaned up the expression, try solving for func.</span>
    <span class="c"># When RootOf is implemented in solve(), we will want to return a RootOf</span>
    <span class="c"># everytime instead of an Equality.</span>

    <span class="c"># Get the f(x) on the left if possible.</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span><span class="p">)]</span>

    <span class="c"># make sure we are working with lists of solutions in simplified form.</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="c"># The solution is already solved</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq</span><span class="p">]</span>

        <span class="c"># special simplification of the rhs</span>
        <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;nth_linear_constant_coeff&quot;</span><span class="p">):</span>
            <span class="c"># Collect terms to make the solution look nice.</span>
            <span class="c"># This is also necessary for constantsimp to remove unnecessary</span>
            <span class="c"># terms from the particular solution from variation of parameters</span>
            <span class="k">global</span> <span class="n">collectterms</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rhs</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">collectterms</span>
            <span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sol</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c"># The solution is not solved, so try to solve it</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">eqsol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">eqsol</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">denom</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">expr</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># XXX: the rest of odesimp() expects each ``t`` to be in a</span>
            <span class="c"># specific normal form: rational expression with numerator</span>
            <span class="c"># expanded, but with combined exponential functions (at</span>
            <span class="c"># least in this setup all tests pass).</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_expand</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">eqsol</span><span class="p">]</span>

        <span class="c"># special simplification of the lhs.</span>
        <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;1st_homogeneous_coeff&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">eqi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
                <span class="n">newi</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">eqi</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newi</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span> <span class="ow">and</span> <span class="n">newi</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">newi</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">newi</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span>
                <span class="n">eq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">newi</span>

    <span class="c"># We cleaned up the costants before solving to help the solve engine with</span>
    <span class="c"># a simpler expression, but the solved expression could have introduced</span>
    <span class="c"># things like -C1, so rerun constantsimp() one last time before returning.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eqi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="n">eq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">constant_renumber</span><span class="p">(</span>
            <span class="n">constantsimp</span><span class="p">(</span><span class="n">eqi</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">),</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">)</span>

    <span class="c"># If there is only 1 solution, return it;</span>
    <span class="c"># otherwise return the list of solutions.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">eq</span>

</div>
<div class="viewcode-block" id="checkodesol"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.checkodesol">[docs]</a><span class="k">def</span> <span class="nf">checkodesol</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span> <span class="n">solve_for_func</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Substitutes sol into the ode and checks that the result is 0.</span>

<span class="sd">    This only works when func is one function, like f(x).  sol can be a</span>
<span class="sd">    single solution or a list of solutions.  Each solution may be an Equality</span>
<span class="sd">    that the solution satisfies, e.g. Eq(f(x), C1), Eq(f(x) + C1, 0); or simply</span>
<span class="sd">    an Expr, e.g. f(x) - C1. In most cases it will not be necessary to</span>
<span class="sd">    explicitly identify the function, but if the function cannot be inferred</span>
<span class="sd">    from the original equation it can be supplied through the &#39;func&#39; argument.</span>

<span class="sd">    If a sequence of solutions is passed, the same sort of container will be</span>
<span class="sd">    used to return the result for each solution.</span>

<span class="sd">    It tries the following methods, in order, until it finds zero</span>
<span class="sd">    equivalence:</span>

<span class="sd">        1. Substitute the solution for f in the original equation.  This</span>
<span class="sd">           only works if the ode is solved for f.  It will attempt to solve</span>
<span class="sd">           it first unless solve_for_func == False</span>
<span class="sd">        2. Take n derivatives of the solution, where n is the order of</span>
<span class="sd">           ode, and check to see if that is equal to the solution.  This</span>
<span class="sd">           only works on exact odes.</span>
<span class="sd">        3. Take the 1st, 2nd, ..., nth derivatives of the solution, each</span>
<span class="sd">           time solving for the derivative of f of that order (this will</span>
<span class="sd">           always be possible because f is a linear operator).  Then back</span>
<span class="sd">           substitute each derivative into ode in reverse order.</span>

<span class="sd">    This function returns a tuple.  The first item in the tuple is True</span>
<span class="sd">    if the substitution results in 0, and False otherwise. The second</span>
<span class="sd">    item in the tuple is what the substitution results in.  It should</span>
<span class="sd">    always be 0 if the first item is True. Note that sometimes this</span>
<span class="sd">    function will False, but with an expression that is identically</span>
<span class="sd">    equal to 0, instead of returning True.  This is because simplify()</span>
<span class="sd">    cannot reduce the expression to 0.  If an expression returned by</span>
<span class="sd">    this function vanishes identically, then sol really is a solution to</span>
<span class="sd">    ode.</span>

<span class="sd">    If this function seems to hang, it is probably because of a hard</span>
<span class="sd">    simplification.</span>

<span class="sd">    To use this function to test, test the first item of the tuple.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Eq, Function, checkodesol, symbols</span>
<span class="sd">    &gt;&gt;&gt; x, C1 = symbols(&#39;x,C1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; checkodesol(f(x).diff(x), Eq(f(x), C1))</span>
<span class="sd">    (True, 0)</span>
<span class="sd">    &gt;&gt;&gt; assert checkodesol(f(x).diff(x), C1)[0]</span>
<span class="sd">    &gt;&gt;&gt; assert not checkodesol(f(x).diff(x), x)[0]</span>
<span class="sd">    &gt;&gt;&gt; checkodesol(f(x).diff(x, 2), x**2)</span>
<span class="sd">    (False, 2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">ode</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">_preprocess</span><span class="p">(</span><span class="n">ode</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">sol</span> <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">sol</span><span class="p">])]</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;must pass func arg to checkodesol for this case.&#39;</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">funcs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="c"># ========== deprecation handling</span>
    <span class="c"># After the deprecation period this handling section becomes:</span>
    <span class="c"># ----------</span>
    <span class="c"># if not is_unfunc(func) or len(func.args) != 1:</span>
    <span class="c">#     raise ValueError(</span>
    <span class="c">#         &quot;func must be a function of one variable, not %s&quot; % func)</span>
    <span class="c"># ----------</span>
    <span class="c"># assume, during deprecation, that sol and func are reversed</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;If you really do want sol to be just </span><span class="si">%s</span><span class="s">, use Eq(</span><span class="si">%s</span><span class="s">, 0) &quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;instead.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="n">SymPyDeprecationWarning</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">feature</span><span class="o">=</span><span class="s">&quot;The order of the &quot;</span>
            <span class="s">&quot;arguments sol and func to checkodesol()&quot;</span><span class="p">,</span>
            <span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;checkodesol(ode, sol, func)&quot;</span><span class="p">,</span> <span class="n">issue</span><span class="o">=</span><span class="mi">3384</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
        <span class="n">sol</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">,</span> <span class="n">sol</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">filldedent</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">        func (or sol, during deprecation) must be a function</span>
<span class="s">        of one variable. Got sol = </span><span class="si">%s</span><span class="s">, func = </span><span class="si">%s</span><span class="s">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="p">)))</span>
    <span class="c"># ========== end of deprecation handling</span>
    <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">sol</span><span class="p">)(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">solve_for_func</span><span class="o">=</span><span class="n">solve_for_func</span><span class="p">),</span> <span class="n">sol</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">testnum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">ode_order</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_for_func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">solved</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">solved</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">solved</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">Eq</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">solved</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">solve_for_func</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">solved</span><span class="p">],</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">solve_for_func</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

    <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">testnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># First pass, try substituting a solved solution directly into the</span>
            <span class="c"># ODE. This has the highest chance of succeeding.</span>
            <span class="n">ode_diff</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">ode</span><span class="o">.</span><span class="n">rhs</span>

            <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">ode_diff</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">ode_diff</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ss</span><span class="p">:</span>
                <span class="c"># with the new numer_denom in power.py, if we do a simple</span>
                <span class="c"># expansion then testnum == 0 verifies all solutions.</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">testnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Second pass. If we cannot substitute f, try seeing if the nth</span>
            <span class="c"># derivative is equal, this will only work for odes that are exact,</span>
            <span class="c"># by definition.</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span>
                <span class="n">trigsimp</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="n">diff</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span> <span class="o">-</span>
                <span class="n">trigsimp</span><span class="p">(</span><span class="n">ode</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span> <span class="o">+</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">ode</span><span class="o">.</span><span class="n">rhs</span><span class="p">))</span>
            <span class="c"># s2 = simplify(</span>
            <span class="c">#     diff(sol.lhs, x, order) - diff(sol.rhs, x, order) - \</span>
            <span class="c">#     ode.lhs + ode.rhs)</span>
            <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">testnum</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># Third pass. Try solving for df/dx and substituting that into the</span>
            <span class="c"># ODE. Thanks to Chris Smith for suggesting this method.  Many of</span>
            <span class="c"># the comments below are his too.</span>
            <span class="c"># The method:</span>
            <span class="c"># - Take each of 1..n derivatives of the solution.</span>
            <span class="c"># - Solve each nth derivative for d^(n)f/dx^(n)</span>
            <span class="c">#   (the differential of that order)</span>
            <span class="c"># - Back substitute into the ode in decreasing order</span>
            <span class="c">#   (i.e., n, n-1, ...)</span>
            <span class="c"># - Check the result for zero equivalence</span>
            <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">diffsols</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="p">}</span>
            <span class="k">elif</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">diffsols</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diffsols</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c"># Differentiation is a linear operator, so there should always</span>
                <span class="c"># be 1 solution. Nonetheless, we test just to make sure.</span>
                <span class="c"># We only need to solve once.  After that, we automatically</span>
                <span class="c"># have the solution to the differential in the order we want.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ds</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">sdf</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">sdf</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># This is what the solution says df/dx should be.</span>
                    <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="c"># Make sure the above didn&#39;t fail.</span>
            <span class="k">if</span> <span class="n">testnum</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Substitute it into ode to check for self consistency.</span>
                <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">ode</span><span class="o">.</span><span class="n">rhs</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">diffsols</span><span class="p">:</span>
                        <span class="c"># We can only substitute f(x) if the solution was</span>
                        <span class="c"># solved for f(x).</span>
                        <span class="k">break</span>
                    <span class="n">lhs</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ode_or_bool</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
                    <span class="n">ode_or_bool</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">ode_or_bool</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ode_or_bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ode_or_bool</span><span class="p">:</span>
                            <span class="n">lhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lhs</span> <span class="o">=</span> <span class="n">ode_or_bool</span><span class="o">.</span><span class="n">lhs</span>
                        <span class="n">rhs</span> <span class="o">=</span> <span class="n">ode_or_bool</span><span class="o">.</span><span class="n">rhs</span>
                <span class="c"># No sense in overworking simplify -- just prove that the</span>
                <span class="c"># numerator goes to zero</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">trigsimp</span><span class="p">((</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>  <span class="c"># The code above never was able to change s</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Unable to test if &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">+</span>
            <span class="s">&quot; is a solution to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ode</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_sol_simplicity"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_sol_simplicity">[docs]</a><span class="k">def</span> <span class="nf">ode_sol_simplicity</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">trysolving</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an extended integer representing how simple a solution to an</span>
<span class="sd">    ODE is.</span>

<span class="sd">    The following things are considered, in order from most simple to</span>
<span class="sd">    least:</span>
<span class="sd">    - sol is solved for func.</span>
<span class="sd">    - sol is not solved for func, but can be if passed to solve (e.g.,</span>
<span class="sd">    a solution returned by dsolve(ode, func, simplify=False)</span>
<span class="sd">    - If sol is not solved for func, then base the result on the length</span>
<span class="sd">    of sol, as computed by len(str(sol)).</span>
<span class="sd">    - If sol has any unevaluated Integrals, this will automatically be</span>
<span class="sd">    considered less simple than any of the above.</span>

<span class="sd">    This function returns an integer such that if solution A is simpler</span>
<span class="sd">    than solution B by above metric, then ode_sol_simplicity(sola, func)</span>
<span class="sd">    &lt; ode_sol_simplicity(solb, func).</span>

<span class="sd">    Currently, the following are the numbers returned, but if the</span>
<span class="sd">    heuristic is ever improved, this may change.  Only the ordering is</span>
<span class="sd">    guaranteed.</span>

<span class="sd">    sol solved for func                        -2</span>
<span class="sd">    sol not solved for func but can be         -1</span>
<span class="sd">    sol is not solved or solvable for func     len(str(sol))</span>
<span class="sd">    sol contains an Integral                   oo</span>

<span class="sd">    oo here means the SymPy infinity, which should compare greater than</span>
<span class="sd">    any integer.</span>

<span class="sd">    If you already know solve() cannot solve sol, you can use</span>
<span class="sd">    trysolving=False to skip that step, which is the only potentially</span>
<span class="sd">    slow step.  For example, dsolve with the simplify=False flag should</span>
<span class="sd">    do this.</span>

<span class="sd">    If sol is a list of solutions, if the worst solution in the list</span>
<span class="sd">    returns oo it returns that, otherwise it returns len(str(sol)), that</span>
<span class="sd">    is, the length of the string representation of the whole list.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    This function is designed to be passed to min as the key argument,</span>
<span class="sd">    such as min(listofsolutions, key=lambda i: ode_sol_simplicity(i, f(x))).</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Function, Eq, tan, cos, sqrt, Integral</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import ode_sol_simplicity</span>
<span class="sd">    &gt;&gt;&gt; x, C1, C2 = symbols(&#39;x, C1, C2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ode_sol_simplicity(Eq(f(x), C1*x**2), f(x))</span>
<span class="sd">    -2</span>
<span class="sd">    &gt;&gt;&gt; ode_sol_simplicity(Eq(x**2 + f(x), C1), f(x))</span>
<span class="sd">    -1</span>
<span class="sd">    &gt;&gt;&gt; ode_sol_simplicity(Eq(f(x), C1*Integral(2*x, x)), f(x))</span>
<span class="sd">    oo</span>
<span class="sd">    &gt;&gt;&gt; eq1 = Eq(f(x)/tan(f(x)/(2*x)), C1)</span>
<span class="sd">    &gt;&gt;&gt; eq2 = Eq(f(x)/tan(f(x)/(2*x) + f(x)), C2)</span>
<span class="sd">    &gt;&gt;&gt; [ode_sol_simplicity(eq, f(x)) for eq in [eq1, eq2]]</span>
<span class="sd">    [26, 33]</span>
<span class="sd">    &gt;&gt;&gt; min([eq1, eq2], key=lambda i: ode_sol_simplicity(i, f(x)))</span>
<span class="sd">    f(x)/tan(f(x)/(2*x)) == C1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: if two solutions are solved for f(x), we still want to be</span>
    <span class="c"># able to get the simpler of the two</span>

    <span class="c"># See the docstring for the coercion rules.  We check easier (faster)</span>
    <span class="c"># things here first, to save time.</span>

    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">sol</span><span class="p">):</span>
        <span class="c"># See if there are Integrals</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">trysolving</span><span class="o">=</span><span class="n">trysolving</span><span class="p">)</span> <span class="o">==</span> <span class="n">oo</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">oo</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sol</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">oo</span>

    <span class="c"># Next, try to solve for func.  This code will change slightly when RootOf</span>
    <span class="c"># is implemented in solve().  Probably a RootOf solution should fall</span>
    <span class="c"># somewhere between a normal solution and an unsolvable expression.</span>

    <span class="c"># First, see if they are already solved</span>
    <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span>
    <span class="c"># We are not so lucky, try solving manually</span>
    <span class="k">if</span> <span class="n">trysolving</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sols</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c"># Finally, a naive computation based on the length of the string version</span>
    <span class="c"># of the expression.  This may favor combined fractions because they</span>
    <span class="c"># will not have duplicate denominators, and may slightly favor expressions</span>
    <span class="c"># with fewer additions and subtractions, as those are separated by spaces</span>
    <span class="c"># by the printer.</span>

    <span class="c"># Additional ideas for simplicity heuristics are welcome, like maybe</span>
    <span class="c"># checking if a equation has a larger domain, or if constantsimp has</span>
    <span class="c"># introduced arbitrary constants numbered higher than the order of a</span>
    <span class="c"># given ode that sol is a solution of.</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sol</span><span class="p">))</span>

</div>
<span class="nd">@vectorize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<div class="viewcode-block" id="constantsimp"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.constantsimp">[docs]</a><span class="k">def</span> <span class="nf">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">independentsymbol</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span> <span class="n">startnumber</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">symbolname</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies an expression with arbitrary constants in it.</span>

<span class="sd">    This function is written specifically to work with dsolve(), and is</span>
<span class="sd">    not intended for general use.</span>

<span class="sd">    Simplification is done by &quot;absorbing&quot; the arbitrary constants in to</span>
<span class="sd">    other arbitrary constants, numbers, and symbols that they are not</span>
<span class="sd">    independent of.</span>

<span class="sd">    The symbols must all have the same name with numbers after it, for</span>
<span class="sd">    example, C1, C2, C3.  The symbolname here would be &#39;C&#39;, the</span>
<span class="sd">    startnumber would be 1, and the end number would be 3.  If the</span>
<span class="sd">    arbitrary constants are independent of the variable x, then the</span>
<span class="sd">    independent symbol would be x.  There is no need to specify the</span>
<span class="sd">    dependent function, such as f(x), because it already has the</span>
<span class="sd">    independent symbol, x, in it.</span>

<span class="sd">    Because terms are &quot;absorbed&quot; into arbitrary constants and because</span>
<span class="sd">    constants are renumbered after simplifying, the arbitrary constants</span>
<span class="sd">    in expr are not necessarily equal to the ones of the same name in</span>
<span class="sd">    the returned result.</span>

<span class="sd">    If two or more arbitrary constants are added, multiplied, or raised</span>
<span class="sd">    to the power of each other, they are first absorbed together into a</span>
<span class="sd">    single arbitrary constant.  Then the new constant is combined into</span>
<span class="sd">    other terms if necessary.</span>

<span class="sd">    Absorption is done with limited assistance: terms of Adds are collected</span>
<span class="sd">    to try join constants and powers with exponents that are Adds are expanded</span>
<span class="sd">    so (C1*cos(x) + C2*cos(x))*exp(x) will simplify to C1*cos(x)*exp(x) and</span>
<span class="sd">    exp(C1 + x) will be simplified to C1*exp(x).</span>

<span class="sd">    Use constant_renumber() to renumber constants after simplification or else</span>
<span class="sd">    arbitrary numbers on constants may appear, e.g. C1 + C3*x.</span>

<span class="sd">    In rare cases, a single constant can be &quot;simplified&quot; into two</span>
<span class="sd">    constants.  Every differential equation solution should have as many</span>
<span class="sd">    arbitrary constants as the order of the differential equation.  The</span>
<span class="sd">    result here will be technically correct, but it may, for example,</span>
<span class="sd">    have C1 and C2 in an expression, when C1 is actually equal to C2.</span>
<span class="sd">    Use your discretion in such situations, and also take advantage of</span>
<span class="sd">    the ability to use hints in dsolve().</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import constantsimp</span>
<span class="sd">    &gt;&gt;&gt; C1, C2, C3, x, y = symbols(&#39;C1,C2,C3,x,y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; constantsimp(2*C1*x, x, 3)</span>
<span class="sd">    C1*x</span>
<span class="sd">    &gt;&gt;&gt; constantsimp(C1 + 2 + x + y, x, 3)</span>
<span class="sd">    C1 + x</span>
<span class="sd">    &gt;&gt;&gt; constantsimp(C1*C2 + 2 + x + y + C3*x, x, 3)</span>
<span class="sd">    C1 + C3*x</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># This function works recursively.  The idea is that, for Mul,</span>
    <span class="c"># Add, Pow, and Function, if the class has a constant in it, then</span>
    <span class="c"># we can simplify it, which we do by recursing down and</span>
    <span class="c"># simplifying up.  Otherwise, we can skip that part of the</span>
    <span class="c"># expression.</span>

    <span class="n">constant_iter</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">startnumber</span><span class="p">)</span>
    <span class="n">constantsymbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">constant_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startnumber</span><span class="p">,</span>
                                          <span class="n">endnumber</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">constantsymbols_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">constantsymbols</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">independentsymbol</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="c"># For now, only treat the special case where one side of the equation</span>
        <span class="c"># is a constant</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span> <span class="ow">in</span> <span class="n">constantsymbols_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rhs</span> <span class="o">+</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span>
            <span class="n">startnumber</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">)</span> <span class="o">-</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
            <span class="c"># this could break if expr.lhs is absorbed into another constant,</span>
            <span class="c"># but for now, the only solutions that return Eq&#39;s with a constant</span>
            <span class="c"># on one side are first order.  At any rate, it will still be</span>
            <span class="c"># technically correct.  The expression will just have too many</span>
            <span class="c"># constants in it</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span> <span class="ow">in</span> <span class="n">constantsymbols_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span>
            <span class="n">startnumber</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">)</span> <span class="o">-</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span>
                <span class="n">symbolname</span><span class="p">),</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span>
                <span class="n">startnumber</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">constantsymbols</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># ================ pre-processing ================</span>
        <span class="c"># collect terms to get constants together</span>
        <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
            <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">constantsymbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_expr</span> <span class="o">=</span> <span class="n">terms_gcd</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="c"># don&#39;t let C1*exp(x) + C2*exp(2*x) become exp(x)*(C1 + C2*exp(x))</span>
            <span class="n">infac</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">asfac</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">:</span>
                    <span class="n">asfac</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="n">infac</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">args</span>
                        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">asfac</span> <span class="ow">and</span> <span class="n">infac</span><span class="p">:</span>
                    <span class="n">new_expr</span> <span class="o">=</span> <span class="n">expr</span>
                    <span class="k">break</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">new_expr</span>
        <span class="c"># don&#39;t allow a number to be factored out of an expression</span>
        <span class="c"># that has no denominator</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">h</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">denom</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">a</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="c"># let numbers absorb into constants of an Add, perhaps</span>
            <span class="c"># in the base of a power, if all its terms have a constant</span>
            <span class="c"># symbol in them, e.g. sqrt(2)*(C1 + C2*x) -&gt; C1 + C2*x</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">sift</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">)</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="bp">True</span><span class="p">]</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="bp">False</span><span class="p">]</span>
                <span class="n">con_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">constantsymbols</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">num</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                        <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> \
                            <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span>
                        <span class="n">con_set</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                            <span class="n">expr</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="p">))</span><span class="o">*</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                            <span class="k">break</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>  <span class="c"># check again that it&#39;s still a Mul</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">newi</span> <span class="o">=</span> <span class="n">_take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newi</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">newi</span><span class="o">*</span><span class="n">d</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">_take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="c"># handle powers like exp(C0 + g(x)) -&gt; C0*exp(g(x))</span>
        <span class="n">pows</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Function</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Pow</span><span class="p">)</span> <span class="k">if</span>
                <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">p</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span>
                <span class="n">p</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">pows</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pows</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="n">ei</span><span class="p">,</span> <span class="n">ed</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">_take</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">ei</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">:</span>
                    <span class="n">reps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="n">ed</span><span class="p">))</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
            <span class="c"># a C1*C2 may have been introduced and the code below won&#39;t</span>
            <span class="c"># handle that so handle it now: once to handle the C1*C2</span>
            <span class="c"># and once to handle any C0*f(x) + C0*f(x)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">muls</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">constantsymbols</span><span class="p">)]</span>
                <span class="n">reps</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">muls</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">newi</span> <span class="o">=</span> <span class="n">_take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">newi</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">reps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">_take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">))</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="c"># ================ end of pre-processing ================</span>
        <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hasconst</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">isPowExp</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">reeval</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">:</span>
                <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newconst</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">hasconst</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">:</span>
                    <span class="n">isPowExp</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)):</span>
            <span class="n">isimp</span> <span class="o">=</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">newargs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span>
            <span class="n">symbolname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isimp</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">:</span>
                <span class="n">reeval</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">hasconst</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">newconst</span> <span class="o">=</span> <span class="n">isimp</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">isPowExp</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">newargs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">isimp</span>
        <span class="k">if</span> <span class="n">hasconst</span><span class="p">:</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">newargs</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">isPowExp</span><span class="p">:</span>
                <span class="n">newargs</span> <span class="o">=</span> <span class="n">newargs</span> <span class="o">+</span> <span class="p">[</span><span class="n">newconst</span><span class="p">]</span>  <span class="c"># Order matters in this case</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">newconst</span><span class="p">]</span> <span class="o">+</span> <span class="n">newargs</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hasconst</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">newconst</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newfuncargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">constantsimp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span>
                <span class="n">symbolname</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">newfuncargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reeval</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">newexpr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span>
                <span class="n">symbolname</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">newexpr</span>

</div>
<div class="viewcode-block" id="constant_renumber"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.constant_renumber">[docs]</a><span class="k">def</span> <span class="nf">constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Renumber arbitrary constants in expr to have numbers 1 through N</span>
<span class="sd">    where N is ``endnumber`` - ``startnumber`` + 1 at most.</span>

<span class="sd">    This is a simple function that goes through and renumbers any Symbol</span>
<span class="sd">    with a name in the form symbolname + num where num is in the range</span>
<span class="sd">    from startnumber to endnumber.</span>

<span class="sd">    Symbols are renumbered based on ``.sort_key()``, so they should be</span>
<span class="sd">    numbered roughly in the order that they appear in the final, printed</span>
<span class="sd">    expression.  Note that this ordering is based in part on hashes, so</span>
<span class="sd">    it can produce different results on different machines.</span>

<span class="sd">    The structure of this function is very similar to that of</span>
<span class="sd">    constantsimp().</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Eq, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import constant_renumber</span>
<span class="sd">    &gt;&gt;&gt; x, C0, C1, C2, C3, C4 = symbols(&#39;x,C:5&#39;)</span>

<span class="sd">    Only constants in the given range (inclusive) are renumbered;</span>
<span class="sd">    the renumbering always starts from 1:</span>

<span class="sd">    &gt;&gt;&gt; constant_renumber(C1 + C3 + C4, &#39;C&#39;, 1, 3)</span>
<span class="sd">    C1 + C2 + C4</span>
<span class="sd">    &gt;&gt;&gt; constant_renumber(C0 + C1 + C3 + C4, &#39;C&#39;, 2, 4)</span>
<span class="sd">    C0 + 2*C1 + C2</span>
<span class="sd">    &gt;&gt;&gt; constant_renumber(C0 + 2*C1 + C2, &#39;C&#39;, 0, 1)</span>
<span class="sd">    C1 + 3*C2</span>
<span class="sd">    &gt;&gt;&gt; pprint(C2 + C1*x + C3*x**2)</span>
<span class="sd">                    2</span>
<span class="sd">    C1*x + C2 + C3*x</span>
<span class="sd">    &gt;&gt;&gt; pprint(constant_renumber(C2 + C1*x + C3*x**2, &#39;C&#39;, 1, 3))</span>
<span class="sd">                    2</span>
<span class="sd">    C1 + C2*x + C3*x</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">)(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">constant_renumber</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">symbolname</span><span class="o">=</span><span class="n">symbolname</span><span class="p">,</span>
            <span class="n">startnumber</span><span class="o">=</span><span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="o">=</span><span class="n">endnumber</span><span class="p">),</span> <span class="n">expr</span><span class="p">))</span>
    <span class="k">global</span> <span class="n">newstartnumber</span>
    <span class="n">newstartnumber</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We need to have an internal recursive function so that</span>
<span class="sd">        newstartnumber maintains its values throughout recursive calls.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constantsymbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">Symbol</span><span class="p">(</span>
            <span class="n">symbolname</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startnumber</span><span class="p">,</span>
        <span class="n">endnumber</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">global</span> <span class="n">newstartnumber</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span>
                <span class="n">_constant_renumber</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">),</span>
                <span class="n">_constant_renumber</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Pow</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">constantsymbols</span><span class="p">):</span>
            <span class="c"># Base case, as above.  Hope there aren&#39;t constants inside</span>
            <span class="c"># of some other class, because they won&#39;t be renumbered.</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">elif</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">:</span>
            <span class="c"># Renumbering happens here</span>
            <span class="n">newconst</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">symbolname</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">newstartnumber</span><span class="p">))</span>
            <span class="n">newstartnumber</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">newconst</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">[</span><span class="n">_constant_renumber</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span>
                <span class="n">endnumber</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sortedargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="c"># make a mapping to send all constantsymbols to S.One and use</span>
                <span class="c"># that to make sure that term ordering is not dependent on</span>
                <span class="c"># the indexed value of C</span>
                <span class="n">C_1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ci</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">]</span>
                <span class="n">sortedargs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C_1</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">[</span><span class="n">_constant_renumber</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span>
                    <span class="n">endnumber</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sortedargs</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">_constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_handle_Integral</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a solution with Integrals in it into an actual solution.</span>

<span class="sd">    For most hints, this simply runs expr.doit()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">y</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="k">if</span> <span class="n">hint</span> <span class="o">==</span> <span class="s">&quot;1st_exact&quot;</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">y</span>
    <span class="k">elif</span> <span class="n">hint</span> <span class="o">==</span> <span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">y</span>
    <span class="k">elif</span> <span class="n">hint</span> <span class="o">==</span> <span class="s">&quot;nth_linear_constant_coeff_homogeneous&quot;</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">hint</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;_Integral&quot;</span><span class="p">):</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">sol</span>


<span class="c"># FIXME: replace the general solution in the docstring with</span>
<span class="c"># dsolve(equation, hint=&#39;1st_exact_Integral&#39;).  You will need to be able</span>
<span class="c"># to have assumptions on P and Q that dP/dy = dQ/dx.</span>
<div class="viewcode-block" id="ode_1st_exact"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_exact">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_exact</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves 1st order exact ordinary differential equations.</span>

<span class="sd">    A 1st order differential equation is called exact if it is the total</span>
<span class="sd">    differential of a function. That is, the differential equation</span>
<span class="sd">    P(x, y)dx + Q(x, y)dy = 0 is exact if there is some function F(x, y)</span>
<span class="sd">    such that P(x, y) = dF/dx and Q(x, y) = dF/dy (d here refers to the</span>
<span class="sd">    partial derivative).  It can be shown that a necessary and</span>
<span class="sd">    sufficient condition for a first order ODE to be exact is that</span>
<span class="sd">    dP/dy = dQ/dx.  Then, the solution will be as given below::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, Eq, Integral, symbols, pprint</span>
<span class="sd">        &gt;&gt;&gt; x, y, t, x0, y0, C1= symbols(&#39;x,y,t,x0,y0,C1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; P, Q, F= map(Function, [&#39;P&#39;, &#39;Q&#39;, &#39;F&#39;])</span>
<span class="sd">        &gt;&gt;&gt; pprint(Eq(Eq(F(x, y), Integral(P(t, y), (t, x0, x)) +</span>
<span class="sd">        ... Integral(Q(x0, t), (t, y0, y))), C1))</span>
<span class="sd">                    x                y</span>
<span class="sd">                    /                /</span>
<span class="sd">                   |                |</span>
<span class="sd">        F(x, y) =  |  P(t, y) dt +  |  Q(x0, t) dt = C1</span>
<span class="sd">                   |                |</span>
<span class="sd">                  /                /</span>
<span class="sd">                  x0               y0</span>

<span class="sd">    Where the first partials of P and Q exist and are continuous in a</span>
<span class="sd">    simply connected region.</span>

<span class="sd">    A note: SymPy currently has no way to represent inert substitution on</span>
<span class="sd">    an expression, so the hint &#39;1st_exact_Integral&#39; will return an integral</span>
<span class="sd">    with dy.  This is supposed to represent the function that you are</span>
<span class="sd">    solving for.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, cos, sin</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(cos(f(x)) - (x*sin(f(x)) - f(x)**2)*f(x).diff(x),</span>
<span class="sd">    ... f(x), hint=&#39;1st_exact&#39;)</span>
<span class="sd">    x*cos(f(x)) + f(x)**3/3 == C1</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Exact_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 73</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># d+e*diff(f(x),x)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]]</span>
    <span class="k">global</span> <span class="n">y</span>  <span class="c"># This is the only way to pass dummy y to _handle_Integral</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="c"># Refer Joel Moses, &quot;Symbolic Integration - The Stormy Decade&quot;,</span>
    <span class="c"># Communications of the ACM, Volume 14, Number 8, August 1971, pp. 558</span>
    <span class="c"># which gives the method to solve an exact differential equation.</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">((</span><span class="n">e</span> <span class="o">-</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))),</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_1st_homogeneous_coeff_best"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_homogeneous_coeff_best">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_homogeneous_coeff_best</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Returns the best solution to an ODE from the two hints</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_dep_div_indep&#39; and</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;.</span>

<span class="sd">    This is as determined by ode_sol_simplicity().</span>

<span class="sd">    See the ode_1st_homogeneous_coeff_subs_indep_div_dep() and</span>
<span class="sd">    ode_1st_homogeneous_coeff_subs_dep_div_indep() docstrings for more</span>
<span class="sd">    information on these hints.  Note that there is no</span>
<span class="sd">    &#39;1st_homogeneous_coeff_best_Integral&#39; hint.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(2*x*f(x) + (x**2 + f(x)**2)*f(x).diff(x), f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_best&#39;, simplify=False))</span>
<span class="sd">                             /    2    \</span>
<span class="sd">                             | 3*x     |</span>
<span class="sd">                          log|----- + 1|</span>
<span class="sd">                             | 2       |</span>
<span class="sd">                             \f (x)    /</span>
<span class="sd">    log(f(x)) = log(C1) - --------------</span>
<span class="sd">                                3</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Homogeneous_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 59</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># There are two substitutions that solve the equation, u1=y/x and u2=x/y</span>
    <span class="c"># They produce different integrals, so try them both and see which</span>
    <span class="c"># one is easier.</span>
    <span class="n">sol1</span> <span class="o">=</span> <span class="n">ode_1st_homogeneous_coeff_subs_indep_div_dep</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
    <span class="n">sol2</span> <span class="o">=</span> <span class="n">ode_1st_homogeneous_coeff_subs_dep_div_indep</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
    <span class="n">simplify</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
        <span class="n">sol1</span> <span class="o">=</span> <span class="n">odesimp</span><span class="p">(</span>
            <span class="n">sol1</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="s">&quot;1st_homogeneous_coeff_subs_indep_div_dep&quot;</span><span class="p">)</span>
        <span class="n">sol2</span> <span class="o">=</span> <span class="n">odesimp</span><span class="p">(</span>
            <span class="n">sol2</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="s">&quot;1st_homogeneous_coeff_subs_dep_div_indep&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="n">sol1</span><span class="p">,</span> <span class="n">sol2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span>
        <span class="n">trysolving</span><span class="o">=</span><span class="ow">not</span> <span class="n">simplify</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="ode_1st_homogeneous_coeff_subs_dep_div_indep"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_homogeneous_coeff_subs_dep_div_indep</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves a 1st order differential equation with homogeneous coefficients</span>
<span class="sd">    using the substitution</span>
<span class="sd">    u1 = &lt;dependent variable&gt;/&lt;independent variable&gt;.</span>

<span class="sd">    This is a differential equation P(x, y) + Q(x, y)dy/dx = 0, that P</span>
<span class="sd">    and Q are homogeneous of the same order.  A function F(x, y) is</span>
<span class="sd">    homogeneous of order n if F(xt, yt) = t**n*F(x, y).  Equivalently,</span>
<span class="sd">    F(x, y) can be rewritten as G(y/x) or H(x/y).  See also the</span>
<span class="sd">    docstring of homogeneous_order().</span>

<span class="sd">    If the coefficients P and Q in the differential equation above are</span>
<span class="sd">    homogeneous functions of the same order, then it can be shown that</span>
<span class="sd">    the substitution y = u1*x (u1 = y/x) will turn the differential</span>
<span class="sd">    equation into an equation separable in the variables x and u.  If</span>
<span class="sd">    h(u1) is the function that results from making the substitution</span>
<span class="sd">    u1 = f(x)/x on P(x, f(x)) and g(u2) is the function that results</span>
<span class="sd">    from the substitution on Q(x, f(x)) in the differential equation</span>
<span class="sd">    P(x, f(x)) + Q(x, f(x))*diff(f(x), x) = 0, then the general solution</span>
<span class="sd">    is::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; f, g, h = map(Function, [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = g(f(x)/x) + h(f(x)/x)*f(x).diff(x)</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">         /f(x)\    /f(x)\ d</span>
<span class="sd">        g|----| + h|----|*--(f(x))</span>
<span class="sd">         \ x  /    \ x  / dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x),</span>
<span class="sd">        ... hint=&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;))</span>
<span class="sd">                       f(x)</span>
<span class="sd">                       ----</span>
<span class="sd">                        x</span>
<span class="sd">                         /</span>
<span class="sd">                        |</span>
<span class="sd">                        |       -h(u1)</span>
<span class="sd">        log(x) = C1 +   |  ---------------- d(u1)</span>
<span class="sd">                        |  u1*h(u1) + g(u1)</span>
<span class="sd">                        |</span>
<span class="sd">                       /</span>

<span class="sd">    Where u1*h(u1) + g(u1) != 0 and x != 0.</span>

<span class="sd">    See also the docstrings of ode_1st_homogeneous_coeff_best() and</span>
<span class="sd">    ode_1st_homogeneous_coeff_subs_indep_div_dep().</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(2*x*f(x) + (x**2 + f(x)**2)*f(x).diff(x), f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;, simplify=False))</span>
<span class="sd">                          /          3   \</span>
<span class="sd">                          |3*f(x)   f (x)|</span>
<span class="sd">                       log|------ + -----|</span>
<span class="sd">                          |  x         3 |</span>
<span class="sd">                          \           x  /</span>
<span class="sd">    log(x) = log(C1) - -------------------</span>
<span class="sd">                                3</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Homogeneous_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 59</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">u1</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u1&#39;</span><span class="p">)</span>  <span class="c"># u1 == f(x)/x</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># d+e*diff(f(x),x)</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">xarg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;xarg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">yarg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;yarg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">int</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span>
        <span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">u1</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]]))</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]:</span> <span class="n">u1</span><span class="p">}),</span>
        <span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">))</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">C1</span><span class="p">)),</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span> <span class="o">-</span> <span class="n">yarg</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xarg</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">sol</span>

</div>
<div class="viewcode-block" id="ode_1st_homogeneous_coeff_subs_indep_div_dep"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_homogeneous_coeff_subs_indep_div_dep</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves a 1st order differential equation with homogeneous coefficients</span>
<span class="sd">    using the substitution</span>
<span class="sd">    u2 = &lt;independent variable&gt;/&lt;dependent variable&gt;.</span>

<span class="sd">    This is a differential equation P(x, y) + Q(x, y)dy/dx = 0, that P</span>
<span class="sd">    and Q are homogeneous of the same order.  A function F(x, y) is</span>
<span class="sd">    homogeneous of order n if F(xt, yt) = t**n*F(x, y).  Equivalently,</span>
<span class="sd">    F(x, y) can be rewritten as G(y/x) or H(x/y).  See also the</span>
<span class="sd">    docstring of homogeneous_order().</span>

<span class="sd">    If the coefficients P and Q in the differential equation above are</span>
<span class="sd">    homogeneous functions of the same order, then it can be shown that</span>
<span class="sd">    the substitution x = u2*y (u2 = x/y) will turn the differential</span>
<span class="sd">    equation into an equation separable in the variables y and u2.  If</span>
<span class="sd">    h(u2) is the function that results from making the substitution</span>
<span class="sd">    u2 = x/f(x) on P(x, f(x)) and g(u2) is the function that results</span>
<span class="sd">    from the substitution on Q(x, f(x)) in the differential equation</span>
<span class="sd">    P(x, f(x)) + Q(x, f(x))*diff(f(x), x) = 0, then the general solution</span>
<span class="sd">    is:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f, g, h = map(Function, [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;])</span>
<span class="sd">    &gt;&gt;&gt; genform = g(x/f(x)) + h(x/f(x))*f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">     / x  \    / x  \ d</span>
<span class="sd">    g|----| + h|----|*--(f(x))</span>
<span class="sd">     \f(x)/    \f(x)/ dx</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(genform, f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;))</span>
<span class="sd">                 x</span>
<span class="sd">                ----</span>
<span class="sd">                f(x)</span>
<span class="sd">                  /</span>
<span class="sd">                 |</span>
<span class="sd">                 |       -g(u2)</span>
<span class="sd">                 |  ---------------- d(u2)</span>
<span class="sd">                 |  u2*g(u2) + h(u2)</span>
<span class="sd">                 |</span>
<span class="sd">                /</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    f(x) = C1*e</span>

<span class="sd">    Where u2*g(u2) + h(u2) != 0 and f(x) != 0.</span>

<span class="sd">    See also the docstrings of ode_1st_homogeneous_coeff_best() and</span>
<span class="sd">    ode_1st_homogeneous_coeff_subs_dep_div_indep().</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(2*x*f(x) + (x**2 + f(x)**2)*f(x).diff(x), f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;))</span>
<span class="sd">                        /      ___________\</span>
<span class="sd">                        |     /     2     |</span>
<span class="sd">                        |    /   3*x      |</span>
<span class="sd">    log(f(x)) = C1 - log|   /   ----- + 1 |</span>
<span class="sd">                        |3 /     2        |</span>
<span class="sd">                        \\/     f (x)     /</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Homogeneous_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 59</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u2&#39;</span><span class="p">)</span>  <span class="c"># u2 == x/f(x)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># d+e*diff(f(x),x)</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">xarg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;xarg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># If xarg present take xarg, else zero</span>
    <span class="n">yarg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;yarg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># If yarg present take yarg, else zero</span>
    <span class="nb">int</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span>
        <span class="n">simplify</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">u2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]]))</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">u2</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]:</span> <span class="mi">1</span><span class="p">})),</span>
        <span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="nb">int</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">C1</span><span class="p">)),</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span> <span class="o">-</span> <span class="n">yarg</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xarg</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">sol</span>

<span class="c"># XXX: Should this function maybe go somewhere else?</span>

</div>
<div class="viewcode-block" id="homogeneous_order"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.homogeneous_order">[docs]</a><span class="k">def</span> <span class="nf">homogeneous_order</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the order n if g is homogeneous and None if it is not</span>
<span class="sd">    homogeneous.</span>

<span class="sd">    Determines if a function is homogeneous and if so of what order.</span>
<span class="sd">    A function f(x,y,...) is homogeneous of order n if</span>
<span class="sd">    f(t*x,t*y,t*...) == t**n*f(x,y,...).</span>

<span class="sd">    If the function is of two variables, F(x, y), then f being</span>
<span class="sd">    homogeneous of any order is equivalent to being able to rewrite</span>
<span class="sd">    F(x, y) as G(x/y) or H(y/x).  This fact is used to solve 1st order</span>
<span class="sd">    ordinary differential equations whose coefficients are homogeneous</span>
<span class="sd">    of the same order (see the docstrings of</span>
<span class="sd">    ode.ode_1st_homogeneous_coeff_subs_indep_div_dep() and</span>
<span class="sd">    ode.ode_1st_homogeneous_coeff_subs_indep_div_dep()</span>

<span class="sd">    Symbols can be functions, but every argument of the function must be</span>
<span class="sd">    a symbol, and the arguments of the function that appear in the</span>
<span class="sd">    expression must match those given in the list of symbols.  If a</span>
<span class="sd">    declared function appears with different arguments than given in the</span>
<span class="sd">    list of symbols, None is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, homogeneous_order, sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(f(x), f(x)) is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(f(x,y), f(y, x), x, y) is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(f(x), f(x), x)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(x**2*f(x)/sqrt(x**2+f(x)**2), x, f(x))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(x**2+f(x), x, f(x)) is None</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="kn">import</span> <span class="n">separatevars</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;homogeneous_order: no symbols were given.&quot;</span><span class="p">)</span>
    <span class="n">symset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="c"># The following are not supported</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Order</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># These are all constants</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">is_NumberSymbol</span> <span class="ow">or</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">is_number</span>
            <span class="p">):</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="c"># Replace all functions with dummy variables</span>
    <span class="n">dum</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
    <span class="n">newsyms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">symset</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s">&#39;is_Function&#39;</span><span class="p">)]:</span>
        <span class="n">iargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iargs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">symset</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dummyvar</span> <span class="o">=</span> <span class="n">dum</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dummyvar</span><span class="p">)</span>
            <span class="n">symset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">newsyms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dummyvar</span><span class="p">)</span>
    <span class="n">symset</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newsyms</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">symset</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># assuming order of a nested function can only be equal to zero</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span> <span class="k">if</span> <span class="n">homogeneous_order</span><span class="p">(</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">symset</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="c"># make the replacement of x with x*t and see if t can be factored out</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># It is sufficient that t &gt; 0</span>
    <span class="n">eqs</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symset</span><span class="p">]),</span> <span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="n">t</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">eqs</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>  <span class="c"># there was no term with only t</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">eqs</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>

</div>
<div class="viewcode-block" id="ode_1st_linear"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_linear">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves 1st order linear differential equations.</span>

<span class="sd">    These are differential equations of the form dy/dx _ P(x)*y = Q(x).</span>
<span class="sd">    These kinds of differential equations can be solved in a general</span>
<span class="sd">    way.  The integrating factor exp(Integral(P(x), x)) will turn the</span>
<span class="sd">    equation into a separable equation.  The general solution is::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint, diff, sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; f, P, Q = map(Function, [&#39;f&#39;, &#39;P&#39;, &#39;Q&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(f(x).diff(x) + P(x)*f(x), Q(x))</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                    d</span>
<span class="sd">        P(x)*f(x) + --(f(x)) = Q(x)</span>
<span class="sd">                    dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x), hint=&#39;1st_linear_Integral&#39;))</span>
<span class="sd">               /       /                   \</span>
<span class="sd">               |      |                    |</span>
<span class="sd">               |      |         /          |     /</span>
<span class="sd">               |      |        |           |    |</span>
<span class="sd">               |      |        | P(x) dx   |  - | P(x) dx</span>
<span class="sd">               |      |        |           |    |</span>
<span class="sd">               |      |       /            |   /</span>
<span class="sd">        f(x) = |C1 +  | Q(x)*e           dx|*e</span>
<span class="sd">               |      |                    |</span>
<span class="sd">               \     /                     /</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(Eq(x*diff(f(x), x) - f(x), x**2*sin(x)),</span>
<span class="sd">    ... f(x), &#39;1st_linear&#39;))</span>
<span class="sd">    f(x) = x*(C1 - cos(x))</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 92</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># a*diff(f(x),x) + b*f(x) + c</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]],</span> <span class="n">x</span><span class="p">))</span>
    <span class="n">tt</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]]),</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c"># take almost-linear u if present, else f(x)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">tt</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span><span class="o">/</span><span class="n">t</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_Bernoulli"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_Bernoulli">[docs]</a><span class="k">def</span> <span class="nf">ode_Bernoulli</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves Bernoulli differential equations.</span>

<span class="sd">    These are equations of the form dy/dx + P(x)*y = Q(x)*y**n, n != 1.</span>
<span class="sd">    The substitution w = 1/y**(1-n) will transform an equation of this</span>
<span class="sd">    form into one that is linear (see the docstring of</span>
<span class="sd">    ode_1st_linear()).  The general solution is::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, n</span>
<span class="sd">        &gt;&gt;&gt; f, P, Q = map(Function, [&#39;f&#39;, &#39;P&#39;, &#39;Q&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(f(x).diff(x) + P(x)*f(x), Q(x)*f(x)**n)</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                    d                n</span>
<span class="sd">        P(x)*f(x) + --(f(x)) = Q(x)*f (x)</span>
<span class="sd">                    dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x), hint=&#39;Bernoulli_Integral&#39;)) #doctest: +SKIP</span>
<span class="sd">                                                                                       1</span>
<span class="sd">                                                                                      ----</span>
<span class="sd">                                                                                     1 - n</span>
<span class="sd">               //                /                            \                     \</span>
<span class="sd">               ||               |                             |                     |</span>
<span class="sd">               ||               |                  /          |             /       |</span>
<span class="sd">               ||               |                 |           |            |        |</span>
<span class="sd">               ||               |        (1 - n)* | P(x) dx   |  (-1 + n)* | P(x) dx|</span>
<span class="sd">               ||               |                 |           |            |        |</span>
<span class="sd">               ||               |                /            |           /         |</span>
<span class="sd">        f(x) = ||C1 + (-1 + n)* | -Q(x)*e                   dx|*e                   |</span>
<span class="sd">               ||               |                             |                     |</span>
<span class="sd">               \\               /                            /                     /</span>


<span class="sd">    Note that when n = 1, then the equation is separable (see the</span>
<span class="sd">    docstring of ode_separable()).</span>

<span class="sd">    &gt;&gt;&gt; pprint(dsolve(Eq(f(x).diff(x) + P(x)*f(x), Q(x)*f(x)), f(x),</span>
<span class="sd">    ... hint=&#39;separable_Integral&#39;))</span>
<span class="sd">     f(x)</span>
<span class="sd">       /</span>
<span class="sd">      |                /</span>
<span class="sd">      |  1            |</span>
<span class="sd">      |  - dy = C1 +  | (-P(x) + Q(x)) dx</span>
<span class="sd">      |  y            |</span>
<span class="sd">      |              /</span>
<span class="sd">     /</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint, log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    &gt;&gt;&gt; pprint(dsolve(Eq(x*f(x).diff(x) + f(x), log(x)*f(x)**2),</span>
<span class="sd">    ... f(x), hint=&#39;Bernoulli&#39;))</span>
<span class="sd">                    1</span>
<span class="sd">    f(x) = -------------------</span>
<span class="sd">             /     log(x)   1\</span>
<span class="sd">           x*|C1 + ------ + -|</span>
<span class="sd">             \       x      x/</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Bernoulli_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 95</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># a*diff(f(x),x) + b*f(x) + c*f(x)**n, n != 1</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">exp</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]])</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]],</span> <span class="n">x</span><span class="p">))</span>
    <span class="n">tt</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]],</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">((</span><span class="n">tt</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span><span class="o">/</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]])))</span>

</div>
<div class="viewcode-block" id="ode_Riccati_special_minus2"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_Riccati_special_minus2">[docs]</a><span class="k">def</span> <span class="nf">ode_Riccati_special_minus2</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The general Riccati equation has the form dy/dx = f(x)*y**2 + g(x)*y + h(x).</span>
<span class="sd">    While it does not have a general solution [1], the &quot;special&quot; form,</span>
<span class="sd">    dy/dx = a*y**2 - b*x**c, does have solutions in many cases [2]. This routine</span>
<span class="sd">    returns a solution for a*dy/dx = b*y**2 + c*y/x + d/x**2 that is obtained by</span>
<span class="sd">    using a suitable change of variables to reduce it to the special form and is</span>
<span class="sd">    valid when neither a nor b are zero and either c or d is zero.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, a, b, c, d</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import dsolve, checkodesol</span>
<span class="sd">    &gt;&gt;&gt; from sympy import pprint, Function</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = f(x)</span>
<span class="sd">    &gt;&gt;&gt; genform = a*y.diff(x) - (b*y**2 + c*y/x + d/x**2)</span>
<span class="sd">    &gt;&gt;&gt; sol = dsolve(genform, y)</span>
<span class="sd">    &gt;&gt;&gt; pprint(sol)</span>
<span class="sd">             /                                 /        __________________      \\</span>
<span class="sd">            |           __________________    |       /                2        ||</span>
<span class="sd">            |          /                2     |     \/  4*b*d - (a + c)  *log(x)||</span>
<span class="sd">           -|a + c - \/  4*b*d - (a + c)  *tan|C1 + ----------------------------||</span>
<span class="sd">            \                                 \                 2*a             //</span>
<span class="sd">    f(x) = -----------------------------------------------------------------------</span>
<span class="sd">                                            2*b*x</span>

<span class="sd">    &gt;&gt;&gt; checkodesol(genform, sol, order=1)[0]</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati</span>
<span class="sd">    2. http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf -</span>
<span class="sd">       http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># a2*diff(f(x),x) + b2*f(x) + c2*f(x)/x + d2/x**2</span>
    <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="s">&#39;a2 b2 c2 d2&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">d2</span><span class="o">*</span><span class="n">b2</span> <span class="o">-</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">c2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">mu</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a2</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">b2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="ode_Liouville"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_Liouville">[docs]</a><span class="k">def</span> <span class="nf">ode_Liouville</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves 2nd order Liouville differential equations.</span>

<span class="sd">    The general form of a Liouville ODE is</span>
<span class="sd">    d^2y/dx^2 + g(y)*(dy/dx)**2 + h(x)*dy/dx.  The general solution is:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint, diff</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; f, g, h = map(Function, [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(diff(f(x),x,x) + g(f(x))*diff(f(x),x)**2 +</span>
<span class="sd">        ... h(x)*diff(f(x),x), 0)</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                          2                    2</span>
<span class="sd">                /d       \         d          d</span>
<span class="sd">        g(f(x))*|--(f(x))|  + h(x)*--(f(x)) + ---(f(x)) = 0</span>
<span class="sd">                \dx      /         dx           2</span>
<span class="sd">                                              dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x), hint=&#39;Liouville_Integral&#39;))</span>
<span class="sd">                                          f(x)</span>
<span class="sd">                  /                     /</span>
<span class="sd">                 |                     |</span>
<span class="sd">                 |     /               |     /</span>
<span class="sd">                 |    |                |    |</span>
<span class="sd">                 |  - | h(x) dx        |    | g(y) dy</span>
<span class="sd">                 |    |                |    |</span>
<span class="sd">                 |   /                 |   /</span>
<span class="sd">        C1 + C2* | e            dx +   |  e           dy = 0</span>
<span class="sd">                 |                     |</span>
<span class="sd">                /                     /</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(diff(f(x), x, x) + diff(f(x), x)**2/f(x) +</span>
<span class="sd">    ... diff(f(x), x)/x, f(x), hint=&#39;Liouville&#39;))</span>
<span class="sd">               ________________           ________________</span>
<span class="sd">    [f(x) = -\/ C1 + C2*log(x) , f(x) = \/ C1 + C2*log(x) ]</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Goldstein and Braun, &quot;Advanced Methods for the Solution of</span>
<span class="sd">      Differential Equations&quot;, pp. 98</span>
<span class="sd">    - http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Liouville ODE:</span>
    <span class="c">#  f(x).diff(x, 2) + g(f(x))*(f(x).diff(x, 2))**2 + h(x)*f(x).diff(x)</span>
    <span class="c"># See Goldstein and Braun, &quot;Advanced Methods for the Solution of</span>
    <span class="c"># Differential Equations&quot;, pg. 98, as well as</span>
    <span class="c"># http://www.maplesoft.com/support/help/view.aspx?path=odeadvisor/Liouville</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># f(x).diff(x, 2) + g*f(x).diff(x)**2 + h*f(x).diff(x)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C2&#39;</span><span class="p">)</span>
    <span class="nb">int</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">],</span> <span class="n">y</span><span class="p">)),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="nb">int</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sol</span>

</div>
<span class="k">def</span> <span class="nf">_nth_linear_match</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matches a differential equation to the linear form:</span>

<span class="sd">    a_n(x)y^(n) + ... + a_1(x)y&#39; + a_0(x)y + B(x) = 0</span>

<span class="sd">    Returns a dict of order:coeff terms, where order is the order of the</span>
<span class="sd">    derivative on each term, and coeff is the coefficient of that</span>
<span class="sd">    derivative.  The key -1 holds the function B(x). Returns None if</span>
<span class="sd">    the ode is not linear.  This function assumes that func has already</span>
<span class="sd">    been checked to be good.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, cos, sin</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import _nth_linear_match</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _nth_linear_match(f(x).diff(x, 3) + 2*f(x).diff(x) +</span>
<span class="sd">    ... x*f(x).diff(x, 2) + cos(x)*f(x).diff(x) + x - f(x) -</span>
<span class="sd">    ... sin(x), f(x), 3)</span>
<span class="sd">    {-1: x - sin(x), 0: -1, 1: cos(x) + 2, 2: x, 3: 1}</span>
<span class="sd">    &gt;&gt;&gt; _nth_linear_match(f(x).diff(x, 3) + 2*f(x).diff(x) +</span>
<span class="sd">    ... x*f(x).diff(x, 2) + cos(x)*f(x).diff(x) + x - f(x) -</span>
<span class="sd">    ... sin(f(x)), f(x), 3) == None</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">one_x</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>
    <span class="n">terms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">terms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="n">one_x</span><span class="p">)</span> \
                    <span class="ow">or</span> <span class="n">f</span> <span class="o">==</span> <span class="n">func</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">terms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span> <span class="o">+=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">terms</span>


<span class="k">def</span> <span class="nf">ode_nth_linear_euler_eq_homogeneous</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">returns</span><span class="o">=</span><span class="s">&#39;sol&#39;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an nth order linear homogeneous variable-coefficient</span>
<span class="sd">    Cauchy-Euler equidimensional ordinary differential equation.</span>

<span class="sd">    This is an equation with form 0 = a0*f(x) + a1*x*f&#39;(x) + a2*x**2*f&quot;(x)...</span>

<span class="sd">    These equations can be solved in a general manner, by substituting</span>
<span class="sd">    solutions of the form f(x) = x**r, and deriving a characteristic equation</span>
<span class="sd">    for r.  When there are repeated roots, we include extra terms of the form</span>
<span class="sd">    Crk*ln(x)**k*x**r, where Cnk is an arbitrary integration constant, r is a</span>
<span class="sd">    root of the characteristic equation, and k ranges over the multiplicity of</span>
<span class="sd">    r.  In the cases where the roots are complex, solutions of the form</span>
<span class="sd">    C1*x**a*sin(b*log(x)) + C2*x**a*cos(b*log(x)) are returned, based on</span>
<span class="sd">    expansions with Eulers formula.  The general solution is the sum of the</span>
<span class="sd">    terms found.  If SymPy cannot find exact roots to the characteristic</span>
<span class="sd">    equation, a RootOf instance will be return in its stead.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(4*x**2*f(x).diff(x, 2) + f(x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_euler_eq_homogeneous&#39;)</span>
<span class="sd">    ... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    f(x) == sqrt(x)*(C1 + C2*log(x))</span>

<span class="sd">    Note that because this method does not involve integration, there is</span>
<span class="sd">    no &#39;nth_linear_euler_eq_homogeneous_Integral&#39; hint.</span>

<span class="sd">    The following is for internal use:</span>

<span class="sd">    - returns = &#39;sol&#39; returns the solution to the ODE.</span>
<span class="sd">    - returns = &#39;list&#39; returns a list of linearly independent</span>
<span class="sd">      solutions, corresponding to the fundamental solution set, for use with</span>
<span class="sd">      non homogeneous solution methods like variation of parameters and</span>
<span class="sd">      undetermined coefficients.  Note that, though the solutions should be</span>
<span class="sd">      linearly independent, this function does not explicitly check that.  You</span>
<span class="sd">      can do &quot;assert simplify(wronskian(sollist)) != 0&quot; to check for linear</span>
<span class="sd">      independence.  Also, &quot;assert len(sollist) == order&quot; will need to pass.</span>
<span class="sd">    - returns = &#39;both&#39;, return a dictionary {&#39;sol&#39;:solution to ODE,</span>
<span class="sd">      &#39;list&#39;: list of linearly independent solutions}.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; eq = f(x).diff(x, 2)*x**2 - 4*f(x).diff(x)*x + 6*f(x)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(eq, f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_euler_eq_homogeneous&#39;))</span>
<span class="sd">            2</span>
<span class="sd">    f(x) = x *(C1 + C2*x)</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation</span>
<span class="sd">    - C. Bender &amp; S. Orszag, &quot;Advanced Mathematical Methods for</span>
<span class="sd">        Scientists and Engineers&quot;, Springer 1999, pp. 12</span>
<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">collectterms</span>
    <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>

    <span class="c"># A generator of constants</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># First, set up characteristic equation.</span>
    <span class="n">chareq</span><span class="p">,</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">chareq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">symbol</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**-</span><span class="n">symbol</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>

    <span class="n">chareq</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">chareq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
    <span class="n">chareqroots</span> <span class="o">=</span> <span class="p">[</span><span class="n">RootOf</span><span class="p">(</span><span class="n">chareq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">chareq</span><span class="o">.</span><span class="n">degree</span><span class="p">())]</span>

    <span class="c"># Create a dict root: multiplicity or charroots</span>
    <span class="n">charroots</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">chareqroots</span><span class="p">:</span>
        <span class="n">charroots</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">gsol</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c"># We need keep track of terms so we can run collect() at the end.</span>
    <span class="c"># This is necessary for constantsimp to work properly.</span>
    <span class="n">ln</span> <span class="o">=</span> <span class="n">log</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="ow">in</span> <span class="n">charroots</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">):</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">root</span><span class="p">)</span><span class="o">*</span><span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">multiplicity</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
            <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">root</span><span class="p">)</span><span class="o">*</span><span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reroot</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">imroot</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">reroot</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>
                    <span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="o">+</span> <span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
                <span class="c"># Preserve ordering (multiplicity, real part, imaginary part)</span>
                <span class="c"># It will be assumed implicitly when constructing</span>
                <span class="c"># fundamental solution sets.</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
    <span class="k">if</span> <span class="n">returns</span> <span class="o">==</span> <span class="s">&#39;sol&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">returns</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;list&#39;</span> <span class="s">&#39;both&#39;</span><span class="p">):</span>
        <span class="c"># HOW TO TEST THIS CODE? (dsolve does not pass &#39;returns&#39; through)</span>
        <span class="c"># Create a list of (hopefully) linearly independent solutions</span>
        <span class="n">gensols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Keep track of when to use sin or cos for nonzero imroot</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">imroot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">reroot</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sin_form</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">reroot</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">sin_form</span> <span class="ow">in</span> <span class="n">gensols</span><span class="p">:</span>
                    <span class="n">cos_form</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">reroot</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cos_form</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sin_form</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">returns</span> <span class="o">==</span> <span class="s">&#39;list&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gensols</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s">&#39;sol&#39;</span><span class="p">:</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="p">),</span> <span class="s">&#39;list&#39;</span><span class="p">:</span> <span class="n">gensols</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown value for key &quot;returns&quot;.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ode_almost_linear"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_almost_linear">[docs]</a><span class="k">def</span> <span class="nf">ode_almost_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an almost-linear differential equation.</span>

<span class="sd">    The general form of an almost linear differential equation is</span>
<span class="sd">    f(x)*g(y)y&#39; + k(x)*l(y) + m(x) = 0 where l&#39;(y) = g(y)</span>

<span class="sd">    This can be solved by substituting l(y) = u(y). Making the given</span>
<span class="sd">    substitution reduces it to a linear differential equation</span>
<span class="sd">    of the form u&#39; + P(x)*u + Q(x) = 0.</span>

<span class="sd">    The general solution is</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, n</span>
<span class="sd">        &gt;&gt;&gt; f, g, k, l = map(Function, [&#39;f&#39;, &#39;g&#39;, &#39;k&#39;, &#39;l&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(f(x)*(l(y).diff(y)) + k(x)*l(y) + g(x))</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">             d</span>
<span class="sd">        f(x)*--(l(y)) + g(x) + k(x)*l(y) = 0</span>
<span class="sd">             dy</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, hint = &#39;almost_linear&#39;))</span>
<span class="sd">               /     //      y        for k(x) = 0\\</span>
<span class="sd">               |     ||                           ||  -y*k(x)</span>
<span class="sd">               |     ||       y*k(x)              ||  -------</span>
<span class="sd">               |     ||       ------              ||    f(x)</span>
<span class="sd">        l(y) = |C1 + |&lt;        f(x)               ||*e</span>
<span class="sd">               |     ||-g(x)*e                    ||</span>
<span class="sd">               |     ||-------------   otherwise  ||</span>
<span class="sd">               |     ||     k(x)                  ||</span>
<span class="sd">               \     \\                           //</span>


<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    ode_1st_linear</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, Derivative, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import dsolve, classify_ode</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d = f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; eq = x*d + x*f(x) + 1</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, f(x), hint=&#39;almost_linear&#39;)</span>
<span class="sd">    f(x) == (C1 - Ei(x))*exp(-x)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(eq, f(x), hint=&#39;almost_linear&#39;))</span>
<span class="sd">                         -x</span>
<span class="sd">    f(x) = (C1 - Ei(x))*e</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Joel Moses, &quot;Symbolic Integration - The Stormy Decade&quot;,</span>
<span class="sd">        Communications of the ACM, Volume 14, Number 8, August 1971, pp. 558</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Since ode_1st_linear has already been implemented, and the</span>
    <span class="c"># coefficients have been modified to the required form in</span>
    <span class="c"># classify_ode, just passing eq, func, order and match to</span>
    <span class="c"># ode_1st_linear will give the required output.</span>
    <span class="k">return</span> <span class="n">ode_1st_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">_linear_coeff_match</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Helper function to match hint linear-coefficients.</span>
<span class="sd">    Matches the expression to the form</span>
<span class="sd">    expr = (a1*x + b1*f(x) + c1)/(a2*x + b2*f(x) + c2)</span>
<span class="sd">    where the following conditions hold:</span>

<span class="sd">    1. a1, b1, c1, a2, b2, c2 are Rationals</span>
<span class="sd">    2. c1 or c2 are not equal to zero</span>
<span class="sd">    3. a2*b1 - a1*b2 is not equal to zero</span>

<span class="sd">    Return xarg, yarg where</span>

<span class="sd">    1. xarg = (b2*c1 - b1*c2)/(a2*b1 - a1*b2)</span>
<span class="sd">    2. yarg = (a1*c2 - a2*c1)/(a2*b1 - a1*b2)</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import _linear_coeff_match</span>
<span class="sd">    &gt;&gt;&gt; from sympy.functions.elementary.trigonometric import sin</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _linear_coeff_match((</span>
<span class="sd">    ... (-25*f(x) - 8*x + 62)/(4*f(x) + 11*x - 11)), f(x))</span>
<span class="sd">    (1/9, 22/9)</span>
<span class="sd">    &gt;&gt;&gt; _linear_coeff_match(</span>
<span class="sd">    ... sin((-5*f(x) - 8*x + 6)/(4*f(x) + x - 1)), f(x))</span>
<span class="sd">    (19/27, 2/27)</span>
<span class="sd">    &gt;&gt;&gt; _linear_coeff_match(sin(f(x)/x), f(x))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">abc</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">        Internal function of _linear_coeff_match</span>
<span class="sd">        that returns Rationals a, b, c</span>
<span class="sd">        if eq is a*x + b*f(x) + c, else None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">as_Add</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">eq</span> <span class="o">==</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">        Internal function of _linear_coeff_match</span>
<span class="sd">        that returns Rationals a1, b1, c1, a2, b2, c2 and a2*b1 - a1*b2</span>
<span class="sd">        of the expression (a1*x + b1*f(x) + c1)/(a2*x + b2*f(x) + c2)</span>
<span class="sd">        if one of c1 or c2 and a2*b1 - a1*b2 is non-zero, else None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">together</span><span class="p">()</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">abc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">abc</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">a2</span><span class="o">*</span><span class="n">b1</span> <span class="o">-</span> <span class="n">a1</span><span class="o">*</span><span class="n">b2</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="ow">or</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">d</span>

    <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span> <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">func</span> <span class="o">!=</span> <span class="n">f</span> <span class="ow">and</span>
         <span class="n">fi</span><span class="o">.</span><span class="n">nargs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fi</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Function</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">([</span><span class="n">expr</span><span class="p">])</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">m1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span> <span class="o">==</span> <span class="n">m1</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">m1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">b2</span><span class="o">*</span><span class="n">c1</span> <span class="o">-</span> <span class="n">b1</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">c2</span> <span class="o">-</span> <span class="n">a2</span><span class="o">*</span><span class="n">c1</span><span class="p">)</span><span class="o">/</span><span class="n">denom</span>

<div class="viewcode-block" id="ode_linear_coefficients"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_linear_coefficients">[docs]</a><span class="k">def</span> <span class="nf">ode_linear_coefficients</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves a differential equation with linear-coefficients.</span>

<span class="sd">    The general form of a differential equation with linear-coefficients is</span>
<span class="sd">    y&#39; + F((a1*x + b1*y + c1)/(a2*x + b2*y + c2)) = 0,</span>
<span class="sd">    where a1, b1, c1, a2, b2, c2 are constants and (a1*b2 - a2*b1) != 0</span>

<span class="sd">    This can be solved by substituting::</span>

<span class="sd">        x = x&#39; + ((b2*c1 - b1*c2)/(a2*b1 - a1*b2))</span>
<span class="sd">        y = y&#39; + ((a1*c2 - a2*c1)/(a2*b1 - a1*b2)).</span>

<span class="sd">    This substitution reduces the equation to a homogeneous</span>
<span class="sd">    differential equation</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    ode_1st_homogeneous_coeff_best</span>
<span class="sd">    ode_1st_homogeneous_coeff_subs_indep_div_dep</span>
<span class="sd">    ode_1st_homogeneous_coeff_subs_dep_div_indep</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, Derivative, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import dsolve, classify_ode</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; df = f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; eq = (x + f(x) + 1)*df + (f(x) - 6*x + 1)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, hint=&#39;linear_coefficients&#39;)</span>
<span class="sd">    [f(x) == -x - sqrt(C1 + 7*x**2) - 1, f(x) == -x + sqrt(C1 + 7*x**2) - 1]</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(eq, hint=&#39;linear_coefficients&#39;))</span>
<span class="sd">                      ___________                     ___________</span>
<span class="sd">                   /         2                     /         2</span>
<span class="sd">    [f(x) = -x - \/  C1 + 7*x   - 1, f(x) = -x + \/  C1 + 7*x   - 1]</span>


<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Joel Moses, &quot;Symbolic Integration - The Stormy Decade&quot;,</span>
<span class="sd">        Communications of the ACM, Volume 14, Number 8, August 1971, pp. 558</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">ode_1st_homogeneous_coeff_best</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_separable_reduced"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_separable_reduced">[docs]</a><span class="k">def</span> <span class="nf">ode_separable_reduced</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves a differential equation that can be reduced to the separable form.</span>

<span class="sd">    The general form of this equation is y&#39; + (y/x)*H(x^n*y) = 0.</span>
<span class="sd">    This can be solved by substituting u(y) = (x^n * y).</span>

<span class="sd">    The equation then reduces to the separable form</span>
<span class="sd">    ``u&#39;*(1/(u*(power - H(u))))`` - (1/x) = 0.</span>

<span class="sd">    The general solution is:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, n</span>
<span class="sd">        &gt;&gt;&gt; f, g = map(Function, [&#39;f&#39;, &#39;g&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = f(x).diff(x) + (f(x)/x)*g(x**n*f(x))</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                         / n     \</span>
<span class="sd">        d          f(x)*g\x *f(x)/</span>
<span class="sd">        --(f(x)) + ---------------</span>
<span class="sd">        dx                x</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, hint=&#39;separable_reduced&#39;))</span>
<span class="sd">         n</span>
<span class="sd">        x *f(x)</span>
<span class="sd">          /</span>
<span class="sd">         |</span>
<span class="sd">         |         1</span>
<span class="sd">         |    ------------ dy = C1 + log(x)</span>
<span class="sd">         |    y*(n - g(y))</span>
<span class="sd">         |</span>
<span class="sd">         /</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    ode_separable</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, Derivative, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import dsolve, classify_ode</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d = f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; eq = (x - x**2*f(x))*d - f(x)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, hint=&#39;separable_reduced&#39;)</span>
<span class="sd">    [f(x) == (-sqrt(C1*x**2 + 1) + 1)/x, f(x) == (sqrt(C1*x**2 + 1) + 1)/x]</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(eq, hint=&#39;separable_reduced&#39;))</span>
<span class="sd">                 ___________                ___________</span>
<span class="sd">                /     2                    /     2</span>
<span class="sd">            - \/  C1*x  + 1  + 1         \/  C1*x  + 1  + 1</span>
<span class="sd">    [f(x) = --------------------, f(x) = ------------------]</span>
<span class="sd">                     x                           x</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Joel Moses, &quot;Symbolic Integration - The Stormy Decade&quot;,</span>
<span class="sd">        Communications of the ACM, Volume 14, Number 8, August 1971, pp. 558</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Arguments are passed in a way so that they are coherent with the</span>
    <span class="c"># ode_separable function</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="s">&#39;u&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">ycoeff</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="s">&#39;power&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;coeff&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span> <span class="n">ycoeff</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;coeff&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;m1&#39;</span><span class="p">:</span> <span class="n">m1</span><span class="p">,</span> <span class="s">&#39;m2&#39;</span><span class="p">:</span> <span class="n">m2</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="s">&#39;hint&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="n">match</span><span class="p">[</span><span class="s">&#39;power&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">ode_separable</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ode_nth_linear_constant_coeff_homogeneous"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous">[docs]</a><span class="k">def</span> <span class="nf">ode_nth_linear_constant_coeff_homogeneous</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
        <span class="n">returns</span><span class="o">=</span><span class="s">&#39;sol&#39;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an nth order linear homogeneous differential equation with</span>
<span class="sd">    constant coefficients.</span>

<span class="sd">    This is an equation of the form a_n*f(x)^(n) + a_(n-1)*f(x)^(n-1) +</span>
<span class="sd">    ... + a1*f&#39;(x) + a0*f(x) = 0</span>

<span class="sd">    These equations can be solved in a general manner, by taking the</span>
<span class="sd">    roots of the characteristic equation a_n*m**n + a_(n-1)*m**(n-1) +</span>
<span class="sd">    ... + a1*m + a0 = 0.  The solution will then be the sum of</span>
<span class="sd">    Cn*x**i*exp(r*x) terms, for each where Cn is an arbitrary constant,</span>
<span class="sd">    r is a root of the characteristic equation and i is is one of each</span>
<span class="sd">    from 0 to the multiplicity of the root - 1 (for example, a root 3 of</span>
<span class="sd">    multiplicity 2 would create the terms C1*exp(3*x) + C2*x*exp(3*x)).</span>
<span class="sd">    The exponential is usually expanded for complex roots using Euler&#39;s</span>
<span class="sd">    equation exp(I*x) = cos(x) + I*sin(x).  Complex roots always come in</span>
<span class="sd">    conjugate pars in polynomials with real coefficients, so the two</span>
<span class="sd">    roots will be represented (after simplifying the constants) as</span>
<span class="sd">    exp(a*x)*(C1*cos(b*x) + C2*sin(b*x)).</span>

<span class="sd">    If SymPy cannot find exact roots to the characteristic equation, a</span>
<span class="sd">    RootOf instance will be return in its stead.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(f(x).diff(x, 5) + 10*f(x).diff(x) - 2*f(x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_constant_coeff_homogeneous&#39;)</span>
<span class="sd">    ... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    f(x) == C1*exp(x*RootOf(_x**5 + 10*_x - 2, 0)) +</span>
<span class="sd">    C2*exp(x*RootOf(_x**5 + 10*_x - 2, 1)) +</span>
<span class="sd">    C3*exp(x*RootOf(_x**5 + 10*_x - 2, 2)) +</span>
<span class="sd">    C4*exp(x*RootOf(_x**5 + 10*_x - 2, 3)) +</span>
<span class="sd">    C5*exp(x*RootOf(_x**5 + 10*_x - 2, 4))</span>

<span class="sd">    Note that because this method does not involve integration, there is</span>
<span class="sd">    no &#39;nth_linear_constant_coeff_homogeneous_Integral&#39; hint.</span>

<span class="sd">    The following is for internal use:</span>

<span class="sd">    - returns = &#39;sol&#39; returns the solution to the ODE.</span>
<span class="sd">    - returns = &#39;list&#39; returns a list of linearly independent</span>
<span class="sd">      solutions, for use with non homogeneous solution methods like</span>
<span class="sd">      variation of parameters and undetermined coefficients.  Note that,</span>
<span class="sd">      though the solutions should be linearly independent, this function</span>
<span class="sd">      does not explicitly check that.  You can do &quot;assert</span>
<span class="sd">      simplify(wronskian(sollist)) != 0&quot; to check for linear independence.</span>
<span class="sd">      Also, &quot;assert len(sollist) == order&quot; will need to pass.</span>
<span class="sd">    - returns = &#39;both&#39;, return a dictionary {&#39;sol&#39;:solution to ODE,</span>
<span class="sd">      &#39;list&#39;: list of linearly independent solutions}.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(f(x).diff(x, 4) + 2*f(x).diff(x, 3) -</span>
<span class="sd">    ... 2*f(x).diff(x, 2) - 6*f(x).diff(x) + 5*f(x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_constant_coeff_homogeneous&#39;))</span>
<span class="sd">                        x                            -2*x</span>
<span class="sd">    f(x) = (C1 + C2*x)*e  + (C3*sin(x) + C4*cos(x))*e</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Linear_differential_equation</span>
<span class="sd">        section: Nonhomogeneous_equation_with_constant_coefficients</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 211</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>

    <span class="c"># A generator of constants</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># First, set up characteristic equation.</span>
    <span class="n">chareq</span><span class="p">,</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chareq</span> <span class="o">+=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">symbol</span><span class="o">**</span><span class="n">i</span>

    <span class="n">chareq</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">chareq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
    <span class="n">chareqroots</span> <span class="o">=</span> <span class="p">[</span> <span class="n">RootOf</span><span class="p">(</span><span class="n">chareq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">chareq</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span> <span class="p">]</span>

    <span class="c"># Create a dict root: multiplicity or charroots</span>
    <span class="n">charroots</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">chareqroots</span><span class="p">:</span>
        <span class="n">charroots</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">gsol</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c"># We need keep track of terms so we can run collect() at the end.</span>
    <span class="c"># This is necessary for constantsimp to work properly.</span>
    <span class="k">global</span> <span class="n">collectterms</span>
    <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="ow">in</span> <span class="n">charroots</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">):</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">(</span><span class="n">root</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">multiplicity</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reroot</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">imroot</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
                <span class="c"># This ordering is important</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
    <span class="k">if</span> <span class="n">returns</span> <span class="o">==</span> <span class="s">&#39;sol&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">returns</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;list&#39;</span> <span class="s">&#39;both&#39;</span><span class="p">):</span>
        <span class="c"># Create a list of (hopefully) linearly independent solutions</span>
        <span class="n">gensols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Keep track of when to use sin or cos for nonzero imroot</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">imroot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">gensols</span><span class="p">:</span>
                    <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">returns</span> <span class="o">==</span> <span class="s">&#39;list&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gensols</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s">&#39;sol&#39;</span><span class="p">:</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="p">),</span> <span class="s">&#39;list&#39;</span><span class="p">:</span> <span class="n">gensols</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown value for key &quot;returns&quot;.&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_nth_linear_constant_coeff_undetermined_coefficients"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients">[docs]</a><span class="k">def</span> <span class="nf">ode_nth_linear_constant_coeff_undetermined_coefficients</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an nth order linear differential equation with constant</span>
<span class="sd">    coefficients using the method of undetermined coefficients.</span>

<span class="sd">    This method works on differential equations of the form a_n*f(x)^(n)</span>
<span class="sd">    + a_(n-1)*f(x)^(n-1) + ... + a1*f&#39;(x) + a0*f(x) = P(x), where P(x)</span>
<span class="sd">    is a function that has a finite number of linearly independent</span>
<span class="sd">    derivatives.</span>

<span class="sd">    Functions that fit this requirement are finite sums functions of the</span>
<span class="sd">    form a*x**i*exp(b*x)*sin(c*x + d) or a*x**i*exp(b*x)*cos(c*x + d),</span>
<span class="sd">    where i is a non-negative integer and a, b, c, and d are constants.</span>
<span class="sd">    For example any polynomial in x, functions like x**2*exp(2*x),</span>
<span class="sd">    x*sin(x), and exp(x)*cos(x) can all be used.  Products of sin&#39;s and</span>
<span class="sd">    cos&#39;s have a finite number of derivatives, because they can be</span>
<span class="sd">    expanded into sin(a*x) and cos(b*x) terms.  However, SymPy currently</span>
<span class="sd">    cannot do that expansion, so you will need to manually rewrite the</span>
<span class="sd">    expression in terms of the above to use this method.  So, for example,</span>
<span class="sd">    you will need to manually convert sin(x)**2 into (1 + cos(2*x))/2 to</span>
<span class="sd">    properly apply the method of undetermined coefficients on it.</span>

<span class="sd">    This method works by creating a trial function from the expression</span>
<span class="sd">    and all of its linear independent derivatives and substituting them</span>
<span class="sd">    into the original ODE.  The coefficients for each term will be a</span>
<span class="sd">    system of linear equations, which are be solved for and substituted,</span>
<span class="sd">    giving the solution.  If any of the trial functions are linearly</span>
<span class="sd">    dependent on the solution to the homogeneous equation, they are</span>
<span class="sd">    multiplied by sufficient x to make them linearly independent.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint, exp, cos</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(f(x).diff(x, 2) + 2*f(x).diff(x) + f(x) -</span>
<span class="sd">    ... 4*exp(-x)*x**2 + cos(2*x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;))</span>
<span class="sd">           /             4\</span>
<span class="sd">           |            x |  -x   4*sin(2*x)   3*cos(2*x)</span>
<span class="sd">    f(x) = |C1 + C2*x + --|*e   - ---------- + ----------</span>
<span class="sd">           \            3 /           25           25</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 221</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gensol</span> <span class="o">=</span> <span class="n">ode_nth_linear_constant_coeff_homogeneous</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
        <span class="n">returns</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">)</span>
    <span class="n">match</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gensol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_solve_undetermined_coefficients</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_solve_undetermined_coefficients</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for the method of undetermined coefficients.</span>

<span class="sd">    See the ode_nth_linear_constant_coeff_undetermined_coefficients()</span>
<span class="sd">    docstring for more information on this method.</span>

<span class="sd">    match should be a dictionary that has the following keys:</span>
<span class="sd">    &#39;list&#39; - A list of solutions to the homogeneous equation, such as</span>
<span class="sd">         the list returned by</span>
<span class="sd">         ode_nth_linear_constant_coeff_homogeneous(returns=&#39;list&#39;)</span>
<span class="sd">    &#39;sol&#39; - The general solution, such as the solution returned by</span>
<span class="sd">        ode_nth_linear_constant_coeff_homogeneous(returns=&#39;sol&#39;)</span>
<span class="sd">    &#39;trialset&#39; - The set of trial functions as returned by</span>
<span class="sd">        _undetermined_coefficients_match()[&#39;trialset&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
    <span class="n">coefflist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gensols</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;list&#39;</span><span class="p">]</span>
    <span class="n">gsol</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;sol&#39;</span><span class="p">]</span>
    <span class="n">trialset</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;trialset&#39;</span><span class="p">]</span>
    <span class="n">notneedset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="n">newtrialset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="k">global</span> <span class="n">collectterms</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gensols</span><span class="p">)</span> <span class="o">!=</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Cannot find &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">+</span>
        <span class="s">&quot; solutions to the homogeneous equation nessesary to apply&quot;</span> <span class="o">+</span>
        <span class="s">&quot; undetermined coefficients to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">+</span>
        <span class="s">&quot; (number of terms != order)&quot;</span><span class="p">)</span>
    <span class="n">usedsin</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># The multiplicity of the root</span>
    <span class="n">getmult</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">getmult</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">getmult</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">getmult</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">imroot</span><span class="p">:</span>
            <span class="c"># Alternate between sin and cos</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">)</span> <span class="ow">in</span> <span class="n">usedsin</span><span class="p">:</span>
                <span class="n">check</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">check</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
                <span class="n">usedsin</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check</span> <span class="ow">in</span> <span class="n">trialset</span><span class="p">:</span>
            <span class="c"># If an element of the trial function is already part of the</span>
            <span class="c"># homogeneous solution, we need to multiply by sufficient x to</span>
            <span class="c"># make it linearly independent.  We also don&#39;t need to bother</span>
            <span class="c"># checking for the coefficients on those elements, since we</span>
            <span class="c"># already know it will be 0.</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">check</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">mult</span> <span class="ow">in</span> <span class="n">trialset</span><span class="p">:</span>
                    <span class="n">mult</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">trialset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">check</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">mult</span><span class="p">)</span>
            <span class="n">notneedset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>

    <span class="n">newtrialset</span> <span class="o">=</span> <span class="n">trialset</span> <span class="o">-</span> <span class="n">notneedset</span>

    <span class="n">trialfunc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">newtrialset</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">coefflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">trialfunc</span> <span class="o">+=</span> <span class="n">c</span><span class="o">*</span><span class="n">i</span>

    <span class="n">eqs</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">trialfunc</span><span class="p">)</span>

    <span class="n">coeffsdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">trialset</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trialset</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="n">eqs</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">eqs</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">coeffsdict</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span>

    <span class="n">coeffvals</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">coeffsdict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">coefflist</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffvals</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s">&quot;Could not solve `</span><span class="si">%s</span><span class="s">` using the &quot;</span>
            <span class="s">&quot;method of undetermined coefficients &quot;</span>
            <span class="s">&quot;(unable to solve for coefficients).&quot;</span> <span class="o">%</span> <span class="n">eq</span><span class="p">)</span>

    <span class="n">psol</span> <span class="o">=</span> <span class="n">trialfunc</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">coeffvals</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">+</span> <span class="n">psol</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_undetermined_coefficients_match</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a trial function match if undetermined coefficients can be</span>
<span class="sd">    applied to expr, and None otherwise.</span>

<span class="sd">    A trial expression can be found for an expression for use with the</span>
<span class="sd">    method of undetermined coefficients if the expression is an</span>
<span class="sd">    additive/multiplicative combination of constants, polynomials in x</span>
<span class="sd">    (the independent variable of expr), sin(a*x + b), cos(a*x + b), and</span>
<span class="sd">    exp(a*x) terms (in other words, it has a finite number of linearly</span>
<span class="sd">    independent derivatives).</span>

<span class="sd">    Note that you may still need to multiply each term returned here by</span>
<span class="sd">    sufficient x to make it linearly independent with the solutions to</span>
<span class="sd">    the homogeneous equation.</span>

<span class="sd">    This is intended for internal use by undetermined_coefficients</span>
<span class="sd">    hints.</span>

<span class="sd">    SymPy currently has no way to convert sin(x)**n*cos(y)**m into a sum</span>
<span class="sd">    of only sin(a*x) and cos(b*x) terms, so these are not implemented.</span>
<span class="sd">    So, for example, you will need to manually convert sin(x)**2 into</span>
<span class="sd">    (1 + cos(2*x))/2 to properly apply the method of undetermined</span>
<span class="sd">    coefficients on it.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import log, exp</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import _undetermined_coefficients_match</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; _undetermined_coefficients_match(9*x*exp(x) + exp(-x), x)</span>
<span class="sd">    {&#39;test&#39;: True, &#39;trialset&#39;: set([x*exp(x), exp(-x), exp(x)])}</span>
<span class="sd">    &gt;&gt;&gt; _undetermined_coefficients_match(log(x), x)</span>
<span class="sd">    {&#39;test&#39;: False}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">)</span>  <span class="c"># exp(x)*exp(2*x + 1) =&gt; exp(3*x + 1)</span>
    <span class="n">retdict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_test_term</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if expr fits the proper form for undetermined coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">_test_term</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">):</span>
                <span class="n">foundtrig</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="c"># Make sure that there is only one trig function in the args.</span>
                <span class="c"># See the docstring.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">foundtrig</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">foundtrig</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">_test_term</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span> <span class="ow">in</span> <span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> \
                <span class="n">expr</span><span class="o">.</span><span class="n">exp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_get_trial_set</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">exprs</span><span class="o">=</span><span class="nb">set</span><span class="p">([])):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a set of trial terms for undetermined coefficients.</span>

<span class="sd">        The idea behind undetermined coefficients is that the terms</span>
<span class="sd">        expression repeat themselves after a finite number of</span>
<span class="sd">        derivatives, except for the coefficients (they are linearly</span>
<span class="sd">        dependent).  So if we collect these, we should have the terms of</span>
<span class="sd">        our trial function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_remove_coefficient</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the expression without a coefficient.</span>

<span class="sd">            Similar to expr.as_independent(x)[1], except it only works</span>
<span class="sd">            multiplicatively.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c"># I was using the below match, but it doesn&#39;t always put all of the</span>
            <span class="c"># coefficient in c.  c.f. 2**x*6*exp(x)*log(2)</span>
            <span class="c"># The below code is probably cleaner anyway.</span>
<span class="c">#            c = Wild(&#39;c&#39;, exclude=[x])</span>
<span class="c">#            t = Wild(&#39;t&#39;)</span>
<span class="c">#            r = expr.match(c*t)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                        <span class="n">term</span> <span class="o">*=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="k">return</span> <span class="n">term</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_remove_coefficient</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exprs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_remove_coefficient</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                    <span class="n">exprs</span> <span class="o">=</span> <span class="n">exprs</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">_get_trial_set</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">exprs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">_remove_coefficient</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">tmpset</span> <span class="o">=</span> <span class="n">exprs</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">term</span><span class="p">]))</span>
            <span class="n">oldset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">while</span> <span class="n">tmpset</span> <span class="o">!=</span> <span class="n">oldset</span><span class="p">:</span>
                <span class="c"># If you get stuck in this loop, then _test_term is probably</span>
                <span class="c"># broken</span>
                <span class="n">oldset</span> <span class="o">=</span> <span class="n">tmpset</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">_remove_coefficient</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="n">tmpset</span> <span class="o">=</span> <span class="n">tmpset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">_get_trial_set</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">tmpset</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmpset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="n">tmpset</span>
        <span class="k">return</span> <span class="n">exprs</span>

    <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_test_term</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]:</span>
        <span class="c"># Try to generate a list of trial solutions that will have the</span>
        <span class="c"># undetermined coefficients. Note that if any of these are not linearly</span>
        <span class="c"># independent with any of the solutions to the homogeneous equation,</span>
        <span class="c"># then they will need to be multiplied by sufficient x to make them so.</span>
        <span class="c"># This function DOES NOT do that (it doesn&#39;t even look at the</span>
        <span class="c"># homogeneous equation).</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;trialset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_trial_set</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">retdict</span>


<div class="viewcode-block" id="ode_nth_linear_constant_coeff_variation_of_parameters"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters">[docs]</a><span class="k">def</span> <span class="nf">ode_nth_linear_constant_coeff_variation_of_parameters</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an nth order linear differential equation with constant</span>
<span class="sd">    coefficients using the method of variation of parameters.</span>

<span class="sd">    This method works on any differential equations of the form</span>
<span class="sd">    f(x)^(n) + a_(n-1)*f(x)^(n-1) + ... + a1*f&#39;(x) + a0*f(x) = P(x).</span>

<span class="sd">    This method works by assuming that the particular solution takes the</span>
<span class="sd">    form Sum(c_i(x)*y_i(x), (x, 1, n)), where y_i is the ith solution to</span>
<span class="sd">    the homogeneous equation.  The solution is then solved using</span>
<span class="sd">    Wronskian&#39;s and Cramer&#39;s Rule.  The particular solution is given by</span>
<span class="sd">    Sum(Integral(W_i(x)/W(x), x)*y_i(x), (x, 1, n)), where W(x) is the</span>
<span class="sd">    Wronskian of the fundamental system (the system of n linearly</span>
<span class="sd">    independent solutions to the homogeneous equation), and W_i(x) is</span>
<span class="sd">    the Wronskian of the fundamental system with the ith column replaced</span>
<span class="sd">    with [0, 0, ..., 0, P(x)].</span>

<span class="sd">    This method is general enough to solve any nth order inhomogeneous</span>
<span class="sd">    linear differential equation with constant coefficients, but</span>
<span class="sd">    sometimes SymPy cannot simplify the Wronskian well enough to</span>
<span class="sd">    integrate it.  If this method hangs, try using the</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39; hint</span>
<span class="sd">    and simplifying the integrals manually.  Also, prefer using</span>
<span class="sd">    &#39;nth_linear_constant_coeff_undetermined_coefficients&#39; when it</span>
<span class="sd">    applies, because it doesn&#39;t use integration, making it faster and</span>
<span class="sd">    more reliable.</span>

<span class="sd">    Warning, using simplify=False with</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters&#39; in dsolve()</span>
<span class="sd">    may cause it to hang, because it will not attempt to simplify</span>
<span class="sd">    the Wronskian before integrating.  It is recommended that you only</span>
<span class="sd">    use simplify=False with</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39; for</span>
<span class="sd">    this method, especially if the solution to the homogeneous</span>
<span class="sd">    equation has trigonometric functions in it.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint, exp, log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(f(x).diff(x, 3) - 3*f(x).diff(x, 2) +</span>
<span class="sd">    ... 3*f(x).diff(x) - f(x) - exp(x)*log(x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_constant_coeff_variation_of_parameters&#39;))</span>
<span class="sd">           /                     3                \</span>
<span class="sd">           |                2   x *(6*log(x) - 11)|  x</span>
<span class="sd">    f(x) = |C1 + C2*x + C3*x  + ------------------|*e</span>
<span class="sd">           \                            36        /</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Variation_of_parameters</span>
<span class="sd">    - http://planetmath.org/encyclopedia/VariationOfParameters.html</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 233</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gensol</span> <span class="o">=</span> <span class="n">ode_nth_linear_constant_coeff_homogeneous</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
        <span class="n">returns</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">)</span>
    <span class="n">match</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gensol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_solve_variation_of_parameters</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_solve_variation_of_parameters</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for the method of variation of parameters.</span>

<span class="sd">    See the ode_nth_linear_constant_coeff_variation_of_parameters()</span>
<span class="sd">    docstring for more information on this method.</span>

<span class="sd">    match should be a dictionary that has the following keys:</span>
<span class="sd">    &#39;list&#39; - A list of solutions to the homogeneous equation, such as</span>
<span class="sd">         the list returned by</span>
<span class="sd">         ode_nth_linear_constant_coeff_homogeneous(returns=&#39;list&#39;)</span>
<span class="sd">    &#39;sol&#39; - The general solution, such as the solution returned by</span>
<span class="sd">        ode_nth_linear_constant_coeff_homogeneous(returns=&#39;sol&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>
    <span class="n">psol</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">gensols</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;list&#39;</span><span class="p">]</span>
    <span class="n">gsol</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;sol&#39;</span><span class="p">]</span>
    <span class="n">wr</span> <span class="o">=</span> <span class="n">wronskian</span><span class="p">(</span><span class="n">gensols</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">wr</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">wr</span><span class="p">)</span>  <span class="c"># We need much better simplification for some ODEs.</span>
        <span class="c">#                   See issue 1563, for example.</span>

        <span class="c"># To reduce commonly occuring sin(x)**2 + cos(x)**2 to 1</span>
        <span class="n">wr</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">wr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">wr</span><span class="p">:</span>
        <span class="c"># The wronskian will be 0 iff the solutions are not linearly</span>
        <span class="c"># independent.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Cannot find &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">+</span>
        <span class="s">&quot; solutions to the homogeneous equation nessesary to apply &quot;</span> <span class="o">+</span>
        <span class="s">&quot;variation of parameters to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; (Wronskian == 0)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gensols</span><span class="p">)</span> <span class="o">!=</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Cannot find &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">+</span>
        <span class="s">&quot; solutions to the homogeneous equation nessesary to apply &quot;</span> <span class="o">+</span>
        <span class="s">&quot;variation of parameters to &quot;</span> <span class="o">+</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; (number of terms != order)&quot;</span><span class="p">)</span>
    <span class="n">negoneterm</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gensols</span><span class="p">:</span>
        <span class="n">psol</span> <span class="o">+=</span> <span class="n">negoneterm</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">wronskian</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">i</span><span class="p">,</span>
        <span class="n">gensols</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">wr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">negoneterm</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">psol</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">psol</span><span class="p">)</span>
        <span class="n">psol</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">psol</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">+</span> <span class="n">psol</span><span class="p">)</span>


<div class="viewcode-block" id="ode_separable"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_separable">[docs]</a><span class="k">def</span> <span class="nf">ode_separable</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>

<span class="sd">    Solves separable 1st order differential equations.</span>

<span class="sd">    This is any differential equation that can be written as</span>
<span class="sd">    P(y)*dy/dx = Q(x). The solution can then just be found by</span>
<span class="sd">    rearranging terms and integrating:</span>
<span class="sd">    Integral(P(y), y) = Integral(Q(x), x). This hint uses separatevars()</span>
<span class="sd">    as its back end, so if a separable equation is not caught by this</span>
<span class="sd">    solver, it is most likely the fault of that function. separatevars()</span>
<span class="sd">    is smart enough to do most expansion and factoring necessary to</span>
<span class="sd">    convert a separable equation F(x, y) into the proper form P(x)*Q(y).</span>
<span class="sd">    The general solution is::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; a, b, c, d, f = map(Function, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;f&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(a(x)*b(f(x))*f(x).diff(x), c(x)*d(f(x)))</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                     d</span>
<span class="sd">        a(x)*b(f(x))*--(f(x)) = c(x)*d(f(x))</span>
<span class="sd">                     dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x), hint=&#39;separable_Integral&#39;))</span>
<span class="sd">             f(x)</span>
<span class="sd">           /                  /</span>
<span class="sd">          |                  |</span>
<span class="sd">          |  b(y)            | c(x)</span>
<span class="sd">          |  ---- dy = C1 +  | ---- dx</span>
<span class="sd">          |  d(y)            | a(x)</span>
<span class="sd">          |                  |</span>
<span class="sd">         /                  /</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(Eq(f(x)*f(x).diff(x) + x, 3*x*f(x)**2), f(x),</span>
<span class="sd">    ... hint=&#39;separable&#39;, simplify=False))</span>
<span class="sd">       /   2       \         2</span>
<span class="sd">    log\3*f (x) - 1/        x</span>
<span class="sd">    ---------------- = C1 + --</span>
<span class="sd">           6                2</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 52</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># {&#39;m1&#39;:m1, &#39;m2&#39;:m2, &#39;y&#39;:y}</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;hint&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c"># get u from separable_reduced else get f(x)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m2&#39;</span><span class="p">][</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m2&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m1&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]],</span>
        <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="n">u</span><span class="p">)),</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m1&#39;</span><span class="p">][</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m1&#39;</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">/</span>
        <span class="n">r</span><span class="p">[</span><span class="s">&#39;m2&#39;</span><span class="p">][</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on May 17, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>