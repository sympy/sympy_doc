
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scalar and Vector Field Functionality &#8212; SymPy 1.6.1 documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/vector/fields.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="General examples of usage" href="examples.html" />
    <link rel="prev" title="More about Coordinate Systems" href="coordsys.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="examples.html" title="General examples of usage"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="coordsys.html" title="More about Coordinate Systems"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.6.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">Vector</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Scalar and Vector Field Functionality</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="scalar-and-vector-field-functionality">
<h1>Scalar and Vector Field Functionality<a class="headerlink" href="#scalar-and-vector-field-functionality" title="Permalink to this headline">¶</a></h1>
<div class="section" id="implementation-in-sympy-vector">
<h2>Implementation in sympy.vector<a class="headerlink" href="#implementation-in-sympy-vector" title="Permalink to this headline">¶</a></h2>
<div class="section" id="scalar-and-vector-fields">
<h3>Scalar and vector fields<a class="headerlink" href="#scalar-and-vector-fields" title="Permalink to this headline">¶</a></h3>
<p>In <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a>, every <code class="docutils literal notranslate"><span class="pre">CoordSysCartesian</span></code> instance is assigned basis
vectors corresponding to the <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and
<span class="math notranslate nohighlight">\(Z\)</span> axes. These can be accessed using the properties
named <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code> and <code class="docutils literal notranslate"><span class="pre">k</span></code> respectively. Hence, to define a vector
<span class="math notranslate nohighlight">\(\mathbf{v}\)</span> of the form
<span class="math notranslate nohighlight">\(3\mathbf{\hat{i}} + 4\mathbf{\hat{j}} + 5\mathbf{\hat{k}}\)</span> with
respect to a given frame <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>, you would do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">k</span>
</pre></div>
</div>
<p>Vector math and basic calculus operations with respect to vectors have
already been elaborated upon in the earlier section of this module’s
documentation.</p>
<p>On the other hand, base scalars (or coordinate variables) are implemented
in a special class called <code class="docutils literal notranslate"><span class="pre">BaseScalar</span></code>, and are assigned to every
coordinate system, one for each axis from <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and
<span class="math notranslate nohighlight">\(Z\)</span>. These coordinate variables are used to form the expressions of
vector or scalar fields in 3D space.
For a system <code class="docutils literal notranslate"><span class="pre">R</span></code>, the <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>
<code class="docutils literal notranslate"><span class="pre">BaseScalars</span></code> instances can be accessed using the <code class="docutils literal notranslate"><span class="pre">R.x</span></code>, <code class="docutils literal notranslate"><span class="pre">R.y</span></code>
and <code class="docutils literal notranslate"><span class="pre">R.z</span></code> expressions respectively.</p>
<p>Therefore, to generate the expression for the aforementioned electric
potential field <span class="math notranslate nohighlight">\(2{x}^{2}y\)</span>, you would have to do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span>
<span class="go">2*R.x**2*R.y</span>
</pre></div>
</div>
<p>It is to be noted that <code class="docutils literal notranslate"><span class="pre">BaseScalar</span></code> instances can be used just
like any other SymPy <code class="docutils literal notranslate"><span class="pre">Symbol</span></code>, except that they store the information
about the coordinate system and axis they correspond to.</p>
<p>Scalar fields can be treated just as any other SymPy expression,
for any math/calculus functionality. Hence, to differentiate the above
electric potential with respect to <span class="math notranslate nohighlight">\(x\)</span> (i.e. <code class="docutils literal notranslate"><span class="pre">R.x</span></code>), you would
use the <code class="docutils literal notranslate"><span class="pre">diff</span></code> method.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="go">4*R.x*R.y</span>
</pre></div>
</div>
<p>It is worth noting that having a <code class="docutils literal notranslate"><span class="pre">BaseScalar</span></code> in the expression implies
that a ‘field’ changes with position, in 3D space. Technically speaking, a
simple <code class="docutils literal notranslate"><span class="pre">Expr</span></code> with no <code class="docutils literal notranslate"><span class="pre">BaseScalar</span></code> s is still a field, though
constant.</p>
<p>Like scalar fields, vector fields that vary with position can also be
constructed using <code class="docutils literal notranslate"><span class="pre">BaseScalar</span></code> s in the measure-number expressions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">k</span>
</pre></div>
</div>
</div>
<div class="section" id="the-del-operator">
<h3>The Del operator<a class="headerlink" href="#the-del-operator" title="Permalink to this headline">¶</a></h3>
<p>The Del, or ‘Nabla’ operator - written as <span class="math notranslate nohighlight">\(\mathbf{\nabla}\)</span> is
commonly known as the vector differential operator. Depending on its
usage in a mathematical expression, it may denote the gradient of a
scalar field, the divergence of a vector field, or the curl of a
vector field.</p>
<p>Essentially, <span class="math notranslate nohighlight">\(\mathbf{\nabla}\)</span> is not technically an ‘operator’,
but a convenient mathematical notation to denote any one of the
aforementioned field operations.</p>
<p>In <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a>, <span class="math notranslate nohighlight">\(\mathbf{\nabla}\)</span> has been implemented
as the <code class="docutils literal notranslate"><span class="pre">Del()</span></code>  class. The instance of this class is independent of
coordinate system. Hence, the <span class="math notranslate nohighlight">\(\mathbf{\nabla}\)</span> operator would
be accessible as <code class="docutils literal notranslate"><span class="pre">Del()</span></code>.</p>
<p>Given below is an example of usage of the <code class="docutils literal notranslate"><span class="pre">Del()</span></code> class.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">Del</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span> <span class="o">=</span> <span class="n">Del</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient_field</span> <span class="o">=</span> <span class="n">delop</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient_field</span>
<span class="go">(Derivative(C.x*C.y*C.z, C.x))*C.i + (Derivative(C.x*C.y*C.z, C.y))*C.j</span>
<span class="go">+ (Derivative(C.x*C.y*C.z, C.z))*C.k</span>
</pre></div>
</div>
<p>The above expression can be evaluated using the SymPy <code class="docutils literal notranslate"><span class="pre">doit()</span></code>
routine.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gradient_field</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">C.y*C.z*C.i + C.x*C.z*C.j + C.x*C.y*C.k</span>
</pre></div>
</div>
<p>Usage of the <span class="math notranslate nohighlight">\(\mathbf{\nabla}\)</span> notation in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a>
has been described in greater detail in the subsequent subsections.</p>
</div>
</div>
<div class="section" id="field-operators-and-related-functions">
<h2>Field operators and related functions<a class="headerlink" href="#field-operators-and-related-functions" title="Permalink to this headline">¶</a></h2>
<p>Here we describe some basic field-related functionality implemented in
<a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a>.</p>
<div class="section" id="curl">
<h3>Curl<a class="headerlink" href="#curl" title="Permalink to this headline">¶</a></h3>
<p>A curl is a mathematical operator that describes an infinitesimal rotation of a
vector in 3D space. The direction is determined by the right-hand rule (along the
axis of rotation), and the magnitude is given by the magnitude of rotation.</p>
<p>In the 3D Cartesian system, the curl of a 3D vector <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> ,
denoted by <span class="math notranslate nohighlight">\(\nabla \times \mathbf{F}\)</span> is given by:</p>
<p><span class="math notranslate nohighlight">\(\nabla \times \mathbf{F} = \left(\frac{\partial F_z}{\partial y}  -
\frac{\partial F_y}{\partial z}\right) \mathbf{\hat{i}} +
\left(\frac{\partial F_x}{\partial z} -
\frac{\partial F_z}{\partial x}\right) \mathbf{\hat{j}} +
\left(\frac{\partial F_y}{\partial x} -
\frac{\partial F_x}{\partial y}\right) \mathbf{\hat{k}}\)</span></p>
<p>where <span class="math notranslate nohighlight">\(F_x\)</span> denotes the <span class="math notranslate nohighlight">\(X\)</span> component of vector <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>.</p>
<p>Computing the curl of a vector field in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a> can be
accomplished in two ways.</p>
<p>One, by using the <code class="docutils literal notranslate"><span class="pre">Del()</span></code> class</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">Del</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span> <span class="o">=</span> <span class="n">Del</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">C.x*C.y*C.j + (-C.x*C.z)*C.k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">delop</span> <span class="o">^</span> <span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">C.x*C.y*C.j + (-C.x*C.z)*C.k</span>
</pre></div>
</div>
<p>Or by using the dedicated function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">curl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curl</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>
<span class="go">C.x*C.y*C.j + (-C.x*C.z)*C.k</span>
</pre></div>
</div>
</div>
<div class="section" id="divergence">
<h3>Divergence<a class="headerlink" href="#divergence" title="Permalink to this headline">¶</a></h3>
<p>Divergence is a vector operator that measures the magnitude of a vector field’s
source or sink at a given point, in terms of a signed scalar.</p>
<p>The divergence operator always returns a scalar after operating on a vector.</p>
<p>In the 3D Cartesian system, the divergence of a 3D vector <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>,
denoted by <span class="math notranslate nohighlight">\(\nabla\cdot\mathbf{F}\)</span> is given by:</p>
<p><span class="math notranslate nohighlight">\(\nabla\cdot\mathbf{F} =\frac{\partial U}{\partial x}
+\frac{\partial V}{\partial y}
+\frac{\partial W}{\partial z
}\)</span></p>
<p>where <span class="math notranslate nohighlight">\(U\)</span>, <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(W\)</span> denote the <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and
<span class="math notranslate nohighlight">\(Z\)</span> components of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> respectively.</p>
<p>Computing the divergence of a vector field in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a> can be
accomplished in two ways.</p>
<p>One, by using the <code class="docutils literal notranslate"><span class="pre">Del()</span></code> class</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">Del</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span> <span class="o">=</span> <span class="n">Del</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">C.x*C.y + C.x*C.z + C.y*C.z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">delop</span> <span class="o">&amp;</span> <span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">k</span><span class="p">))</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">C.x*C.y + C.x*C.z + C.y*C.z</span>
</pre></div>
</div>
<p>Or by using the dedicated function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">divergence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>
<span class="go">C.x*C.y + C.x*C.z + C.y*C.z</span>
</pre></div>
</div>
</div>
<div class="section" id="gradient">
<h3>Gradient<a class="headerlink" href="#gradient" title="Permalink to this headline">¶</a></h3>
<p>Consider a scalar field <span class="math notranslate nohighlight">\(f(x, y, z)\)</span> in 3D space. The gradient of this field
is defined as the vector of the 3 partial derivatives of <span class="math notranslate nohighlight">\(f\)</span> with respect to
<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> in the <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>
axes respectively.</p>
<p>In the 3D Cartesian system, the divergence of a scalar field <span class="math notranslate nohighlight">\(f\)</span>,
denoted by <span class="math notranslate nohighlight">\(\nabla f\)</span> is given by -</p>
<p><span class="math notranslate nohighlight">\(\nabla f = \frac{\partial f}{\partial x} \mathbf{\hat{i}} +
\frac{\partial f}{\partial y}  \mathbf{\hat{j}} +
\frac{\partial f}{\partial z} \mathbf{\hat{k}}\)</span></p>
<p>Computing the divergence of a vector field in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a> can be
accomplished in two ways.</p>
<p>One, by using the <code class="docutils literal notranslate"><span class="pre">Del()</span></code> class</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">Del</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span> <span class="o">=</span> <span class="n">Del</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">C.y*C.z*C.i + C.x*C.z*C.j + C.x*C.y*C.k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">C.y*C.z*C.i + C.x*C.z*C.j + C.x*C.y*C.k</span>
</pre></div>
</div>
<p>Or by using the dedicated function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">gradient</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="go">C.y*C.z*C.i + C.x*C.z*C.j + C.x*C.y*C.k</span>
</pre></div>
</div>
</div>
<div class="section" id="directional-derivative">
<h3>Directional Derivative<a class="headerlink" href="#directional-derivative" title="Permalink to this headline">¶</a></h3>
<p>Apart from the above three common applications of <span class="math notranslate nohighlight">\(\mathbf{\nabla}\)</span>,
it is also possible to compute the directional derivative of a field wrt
a <code class="docutils literal notranslate"><span class="pre">Vector</span></code> in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a>.</p>
<p>By definition, the directional derivative of a field <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>
along a vector <span class="math notranslate nohighlight">\(v\)</span> at point <span class="math notranslate nohighlight">\(x\)</span> represents the instantaneous
rate of change of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> moving through <span class="math notranslate nohighlight">\(x\)</span> with the
velocity <span class="math notranslate nohighlight">\(v\)</span>. It is represented mathematically as:
<span class="math notranslate nohighlight">\((\vec v \cdot \nabla) \, \mathbf{F}(x)\)</span>.</p>
<p>Directional derivatives of vector and scalar fields can be computed in
<a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a> using the <code class="docutils literal notranslate"><span class="pre">Del()</span></code> class</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">Del</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">delop</span> <span class="o">=</span> <span class="n">Del</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vel</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_field</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vector_field</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">i</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vel</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delop</span><span class="p">))(</span><span class="n">scalar_field</span><span class="p">)</span>
<span class="go">C.x*C.y + C.x*C.z + C.y*C.z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">vel</span> <span class="o">&amp;</span> <span class="n">delop</span><span class="p">)(</span><span class="n">vector_field</span><span class="p">)</span>
<span class="go">(C.x*C.y + C.x*C.z + C.y*C.z)*C.i</span>
</pre></div>
</div>
<dl>
<dt>Or by using the dedicated function</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">directional_derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">directional_derivative</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
<span class="go">C.x*C.y + 4*C.x*C.z + 3*C.y*C.z</span>
</pre></div>
</div>
</dd>
</dl>
</div>
</div>
<div class="section" id="field-operator-in-orthogonal-curvilinear-coordinate-system">
<h2>Field operator in orthogonal curvilinear coordinate system<a class="headerlink" href="#field-operator-in-orthogonal-curvilinear-coordinate-system" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">vector</span></code> package supports calculation in different kind of orthogonal
curvilinear coordinate system. To do that, scaling factor (also known as
Lame coefficients) are used to express <code class="docutils literal notranslate"><span class="pre">curl</span></code>, <code class="docutils literal notranslate"><span class="pre">divergence</span></code> or <code class="docutils literal notranslate"><span class="pre">gradient</span></code>
in desired type of coordinate system.</p>
<p>For example if we want to calculate <code class="docutils literal notranslate"><span class="pre">gradient</span></code> in cylindrical coordinate
system all we need to do is to create proper coordinate system</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">transformation</span><span class="o">=</span><span class="s1">&#39;cylindrical&#39;</span><span class="p">,</span> <span class="n">variable_names</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">r</span><span class="o">*</span><span class="n">c</span><span class="o">.</span><span class="n">theta</span><span class="o">*</span><span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="go">    c.theta*c.z*c.i + c.z*c.j + c.r*c.theta*c.k</span>
</pre></div>
</div>
</div>
<div class="section" id="conservative-and-solenoidal-fields">
<h2>Conservative and Solenoidal fields<a class="headerlink" href="#conservative-and-solenoidal-fields" title="Permalink to this headline">¶</a></h2>
<p>In vector calculus, a conservative field is a field that is the gradient of
some scalar field. Conservative fields have the property that their line
integral over any path depends only on the end-points, and is independent
of the path travelled.
A conservative vector field is also said to be ‘irrotational’, since the
curl of a conservative field is always zero.</p>
<p>In physics, conservative fields represent forces in physical systems where
energy is conserved.</p>
<p>To check if a vector field is conservative in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a>, the
<code class="docutils literal notranslate"><span class="pre">is_conservative</span></code> function can be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">is_conservative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_conservative</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curl</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>A solenoidal field, on the other hand, is a vector field whose divergence
is zero at all points in space.</p>
<p>To check if a vector field is solenoidal in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a>, the
<code class="docutils literal notranslate"><span class="pre">is_solenoidal</span></code> function can be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">is_solenoidal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_solenoidal</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</div>
<div class="section" id="scalar-potential-functions">
<h2>Scalar potential functions<a class="headerlink" href="#scalar-potential-functions" title="Permalink to this headline">¶</a></h2>
<p>We have previously mentioned that every conservative field can be defined as
the gradient of some scalar field. This scalar field is also called the ‘scalar
potential field’ corresponding to the aforementioned conservative field.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">scalar_potential</span></code> function in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a> calculates the
scalar potential field corresponding to a given conservative vector field in
3D space - minus the extra constant of integration, of course.</p>
<p>Example of usage -</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">scalar_potential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conservative_field</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_potential</span><span class="p">(</span><span class="n">conservative_field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">2*R.x**2*R.y*R.z</span>
</pre></div>
</div>
<p>Providing a non-conservative vector field as an argument to
<code class="docutils literal notranslate"><span class="pre">scalar_potential</span></code> raises a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<p>The scalar potential difference, or simply ‘potential difference’,
corresponding to a conservative vector field can be defined as the difference
between the values of its scalar potential function at two points in space.
This is useful in calculating a line integral with respect to a conservative
function, since it depends only on the endpoints of the path.</p>
<p>This computation is performed as follows in <a class="reference internal" href="index.html#module-sympy.vector" title="sympy.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.vector</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">CoordSys3D</span><span class="p">,</span> <span class="n">Point</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.vector</span> <span class="kn">import</span> <span class="n">scalar_potential_difference</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">CoordSys3D</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">locate_new</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">j</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectfield</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_potential_difference</span><span class="p">(</span><span class="n">vectfield</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>If provided with a scalar expression instead of a vector field,
<code class="docutils literal notranslate"><span class="pre">scalar_potential_difference</span></code> returns the difference between the values
of that scalar field at the two given points in space.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Scalar and Vector Field Functionality</a><ul>
<li><a class="reference internal" href="#implementation-in-sympy-vector">Implementation in sympy.vector</a><ul>
<li><a class="reference internal" href="#scalar-and-vector-fields">Scalar and vector fields</a></li>
<li><a class="reference internal" href="#the-del-operator">The Del operator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#field-operators-and-related-functions">Field operators and related functions</a><ul>
<li><a class="reference internal" href="#curl">Curl</a></li>
<li><a class="reference internal" href="#divergence">Divergence</a></li>
<li><a class="reference internal" href="#gradient">Gradient</a></li>
<li><a class="reference internal" href="#directional-derivative">Directional Derivative</a></li>
</ul>
</li>
<li><a class="reference internal" href="#field-operator-in-orthogonal-curvilinear-coordinate-system">Field operator in orthogonal curvilinear coordinate system</a></li>
<li><a class="reference internal" href="#conservative-and-solenoidal-fields">Conservative and Solenoidal fields</a></li>
<li><a class="reference internal" href="#scalar-potential-functions">Scalar potential functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="coordsys.html"
                        title="previous chapter">More about Coordinate Systems</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="examples.html"
                        title="next chapter">General examples of usage</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/vector/fields.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="examples.html" title="General examples of usage"
             >next</a> |</li>
        <li class="right" >
          <a href="coordsys.html" title="More about Coordinate Systems"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.6.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >Vector</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Scalar and Vector Field Functionality</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 SymPy Development Team.
      Last updated on Jul 02, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.1.1.
    </div>
  </body>
</html>