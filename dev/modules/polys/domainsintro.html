
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Introducing the Domains of the poly module &#8212; SymPy 1.10.dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/default.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}}</script>
    
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/polys/domainsintro.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Reference docs for the Poly Domains" href="domainsref.html" />
    <link rel="prev" title="AGCA - Algebraic Geometry and Commutative Algebra Module" href="agca.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="domainsref.html" title="Reference docs for the Poly Domains"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="agca.html" title="AGCA - Algebraic Geometry and Commutative Algebra Module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.10.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../reference/index.html" >Reference Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../reference/public/topics/index.html" >Topics</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="index.html" accesskey="U">Polynomial Manipulation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Introducing the Domains of the poly module</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="introducing-the-domains-of-the-poly-module">
<span id="polys-domainsintro"></span><h1>Introducing the Domains of the poly module<a class="headerlink" href="#introducing-the-domains-of-the-poly-module" title="Permalink to this headline">¶</a></h1>
<p>This page introduces the idea of the “domains” that are used in SymPy’s
<a class="reference internal" href="reference.html#module-sympy.polys" title="sympy.polys"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.polys</span></code></a> module. The emphasis is on introducing how to use the domains
directly and on understanding how they are used internally as part of the
<a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> class. This is a relatively advanced topic so for a more
introductory understanding of the <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> class and the <a class="reference internal" href="reference.html#module-sympy.polys" title="sympy.polys"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.polys</span></code></a>
module it is recommended to read <a class="reference internal" href="basics.html#polys-basics"><span class="std std-ref">Basic functionality of the module</span></a> instead. The reference
documentation for the domain classes is in <a class="reference internal" href="domainsref.html#polys-domainsref"><span class="std std-ref">Reference docs for the Poly Domains</span></a>. Internal
functions that make use of the domains are documented in
<a class="reference internal" href="internals.html#polys-internals"><span class="std std-ref">Internals of the Polynomial Manipulation Module</span></a>.</p>
<section id="what-are-the-domains">
<h2>What are the domains?<a class="headerlink" href="#what-are-the-domains" title="Permalink to this headline">¶</a></h2>
<p>For most users the domains are only really noticeable in the printed output of
a <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Poly(x**2 + x, x, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Poly(x**2 + 1/2*x, x, domain=&#39;QQ&#39;)</span>
</pre></div>
</div>
<p>We see here that one <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> has domain <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> representing the
integers and the other has domain <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> representing the rationals. These
indicate the “domain” from which the coefficients of the polynomial are drawn.</p>
<p>From a high-level the domains represent formal concepts such as the set of
integers <span class="math notranslate nohighlight">\(\mathbb{Z}\)</span> or rationals <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>. The word “domain” here is a
reference to the mathematical concept of an <a class="reference external" href="https://en.wikipedia.org/wiki/Integral_domain">integral domain</a>.</p>
<p>Internally the domains correspond to different computational implementations
and representations of the expressions that the polynomials correspond to.
The <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> object itself has an internal representation as a
<code class="docutils literal notranslate"><span class="pre">list</span></code> of coefficients and a <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly.domain" title="sympy.polys.polytools.Poly.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">domain</span></code></a> attribute
representing the implementation of those coefficients:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">Poly(x**2 + 1/2*x, x, domain=&#39;QQ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">domain</span>
<span class="go">QQ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span>
<span class="go">DMP([1, 1/2, 0], QQ, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span>
<span class="go">[1, 1/2, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">&lt;class &#39;sympy.external.pythonmpq.PythonMPQ&#39;&gt;</span>
</pre></div>
</div>
<p>Here the domain is <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> which represents the implementation of the
rational numbers in the domain system. The <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> instance itself
has a <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly.domain" title="sympy.polys.polytools.Poly.domain"><code class="xref py py-attr docutils literal notranslate"><span class="pre">Poly.domain</span></code></a> attribute <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> and then a list of
<a class="reference internal" href="domainsref.html#sympy.external.pythonmpq.PythonMPQ" title="sympy.external.pythonmpq.PythonMPQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">PythonMPQ</span></code></a> coefficients where <a class="reference internal" href="domainsref.html#sympy.external.pythonmpq.PythonMPQ" title="sympy.external.pythonmpq.PythonMPQ"><code class="xref py py-class docutils literal notranslate"><span class="pre">PythonMPQ</span></code></a>
is the class that implements the elements of the <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> domain. The list of
coefficients <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1/2,</span> <span class="pre">0]</span></code> gives a standardised low-level representation of
the polynomial expression <code class="docutils literal notranslate"><span class="pre">(1)*x**2</span> <span class="pre">+</span> <span class="pre">(1/2)*x</span> <span class="pre">+</span> <span class="pre">(0)</span></code>.</p>
<p>This page looks at the different domains that are defined in SymPy, how they
are implemented and how they can be used. It introduces how to use the domains
and domain elements directly and explains how they are used internally as part
of <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> objects. This information is more relevant for
development in SymPy than it is for users of the <a class="reference internal" href="reference.html#module-sympy.polys" title="sympy.polys"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.polys</span></code></a> module.</p>
</section>
<section id="representing-expressions-symbolically">
<h2>Representing expressions symbolically<a class="headerlink" href="#representing-expressions-symbolically" title="Permalink to this headline">¶</a></h2>
<p>There are many different ways that a mathematical expression can be
represented symbolically. The purpose of the polynomial domains is to provide
suitable implementations for different classes of expressions. This section
considers the basic approaches to the symbolic representation of mathematical
expressions: “tree”, “dense polynomial”  and “sparse polynomial”.</p>
<section id="tree-representation">
<h3>Tree representation<a class="headerlink" href="#tree-representation" title="Permalink to this headline">¶</a></h3>
<p>The most general representation of symbolic expressions is as a <a class="reference external" href="https://en.wikipedia.org/wiki/Tree_(data_structure)">tree</a> and
this is the representation used for most ordinary SymPy expressions which are
instances of <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> (a subclass of <a class="reference internal" href="../core.html#sympy.core.basic.Basic" title="sympy.core.basic.Basic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Basic</span></code></a>). We can see
this representation using the <a class="reference internal" href="../printing.html#sympy.printing.repr.srepr" title="sympy.printing.repr.srepr"><code class="xref py py-func docutils literal notranslate"><span class="pre">srepr()</span></code></a> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">srepr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">1 + 1/(x**2 + 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">srepr</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="go">Add(Integer(1), Pow(Add(Pow(Symbol(&#39;x&#39;), Integer(2)), Integer(2)), Integer(-1)))</span>
</pre></div>
</div>
<p>Here the expression <code class="docutils literal notranslate"><span class="pre">e</span></code> is represented as an <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code></a> node which
has two children <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">1/(x**2</span> <span class="pre">+</span> <span class="pre">2)</span></code>. The child <code class="docutils literal notranslate"><span class="pre">1</span></code> is represented as
an <a class="reference internal" href="../core.html#sympy.core.numbers.Integer" title="sympy.core.numbers.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> and the other child is represented as a <a class="reference internal" href="../core.html#sympy.core.power.Pow" title="sympy.core.power.Pow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pow</span></code></a> with
base <code class="docutils literal notranslate"><span class="pre">x**2</span> <span class="pre">+</span> <span class="pre">2</span></code> and exponent <code class="docutils literal notranslate"><span class="pre">1</span></code>. Then <code class="docutils literal notranslate"><span class="pre">x**2</span> <span class="pre">+</span> <span class="pre">2</span></code> is represented as an
<a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code></a> with children <code class="docutils literal notranslate"><span class="pre">x**2</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code> and so on. In this way the
expression is represented as a tree where the internal nodes are operations
like <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code></a>, <a class="reference internal" href="../core.html#sympy.core.mul.Mul" title="sympy.core.mul.Mul"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mul</span></code></a>, <a class="reference internal" href="../core.html#sympy.core.power.Pow" title="sympy.core.power.Pow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pow</span></code></a> and so on and the
leaf nodes are atomic expression types like <a class="reference internal" href="../core.html#sympy.core.numbers.Integer" title="sympy.core.numbers.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a> and
<a class="reference internal" href="../core.html#sympy.core.symbol.Symbol" title="sympy.core.symbol.Symbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symbol</span></code></a>. See <a class="reference internal" href="../../tutorial/manipulation.html#tutorial-manipulation"><span class="std std-ref">Advanced Expression Manipulation</span></a> for more about this
representation.</p>
<p>The tree representation is core to the architecture of <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> in
SymPy. It is a highly flexible representation that can represent a very wide
range of possible expressions. It can also represent equivalent expressions in
different ways e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">x*(x + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="go">x**2 + x</span>
</pre></div>
</div>
<p>These two expression although equivalent have different tree representations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">srepr</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
<span class="go">Mul(Symbol(&#39;x&#39;), Add(Symbol(&#39;x&#39;), Integer(1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">srepr</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>
<span class="go">Add(Pow(Symbol(&#39;x&#39;), Integer(2)), Symbol(&#39;x&#39;))</span>
</pre></div>
</div>
<p>Being able to represent the same expression in different ways is both a
strength and a weakness. It is useful to be able to convert an
expression in to different forms for different tasks but having non-unique
representations makes it hard to tell when two expressions are equivalent
which is in fact very important for many computational algorithms. The most
important task is being able to tell when an expression is equal to zero which
is undecidable in general (<a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">Richardon’s theorem</a>) but is decidable in many
important special cases.</p>
</section>
<section id="dup-representation">
<span id="id1"></span><h3>DUP representation<a class="headerlink" href="#dup-representation" title="Permalink to this headline">¶</a></h3>
<p>Restricting the set of allowed expressions to special cases allows for much
more efficient symbolic representations. As we already saw <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a>
can represent a polynomial as a list of coefficients. This means that an
expression like <code class="docutils literal notranslate"><span class="pre">x**4</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> could be represented simply as <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">1,</span>
<span class="pre">1]</span></code>. This list of coefficients representation of a polynomial expression is
known as the “dense univariate polynomial” (DUP) representation. Working
within that representation algorithms for multiplication, addition and
crucially zero-testing can be much more efficient than with the corresponding
tree representations. We can see this representation from a <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a>
instance by looking it its <code class="docutils literal notranslate"><span class="pre">rep.rep</span></code> attribute:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span>
<span class="go">[1, 0, 0, 1, 1]</span>
</pre></div>
</div>
<p>In the DUP representation it is not possible to represent the same expression
in different ways. There is no distinction between <code class="docutils literal notranslate"><span class="pre">x*(x</span> <span class="pre">+</span> <span class="pre">1)</span></code> and <code class="docutils literal notranslate"><span class="pre">x**2</span> <span class="pre">+</span>
<span class="pre">x</span></code> because both are just <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">0]</span></code>. This means that comparing two
expressions is easy: they are equal if and only if all of their coefficients
are equal. Zero-testing is particularly easy: the polynomial is zero if and
only if all coefficients are zero (of course we need to have easy zero-testing
for the coefficients themselves).</p>
<p>We can make functions that operate on the DUP representation much more
efficiently than functions that operate on the tree representation. Many
operations with standard sympy expressions are in fact computed by converting
to a polynomial representation and then performing the calculation. An example
is the <a class="reference internal" href="reference.html#sympy.polys.polytools.factor" title="sympy.polys.polytools.factor"><code class="xref py py-func docutils literal notranslate"><span class="pre">factor()</span></code></a> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">factor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">16</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">2*x**3 + 10*x**2 + 16*x + 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">factor</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="go">2*(x + 1)*(x + 2)**2</span>
</pre></div>
</div>
<p>Internally <a class="reference internal" href="reference.html#sympy.polys.polytools.factor" title="sympy.polys.polytools.factor"><code class="xref py py-func docutils literal notranslate"><span class="pre">factor()</span></code></a> will convert the expression from the tree
representation into the DUP representation and then use the function
<code class="docutils literal notranslate"><span class="pre">dup_factor_list</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ZZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.polys.factortools</span> <span class="kn">import</span> <span class="n">dup_factor_list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">8</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">[2, 10, 16, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dup_factor_list</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="go">(2, [([1, 1], 1), ([1, 2], 2)])</span>
</pre></div>
</div>
<p>There are many more examples of functions with <code class="docutils literal notranslate"><span class="pre">dup_*</span></code> names for operating
on the DUP representation that are documented in <a class="reference internal" href="internals.html#polys-internals"><span class="std std-ref">Internals of the Polynomial Manipulation Module</span></a>. There
are also functions with the <code class="docutils literal notranslate"><span class="pre">dmp_*</span></code> prefix for operating on multivariate
polynomials.</p>
</section>
<section id="dmp-representation">
<span id="id2"></span><h3>DMP representation<a class="headerlink" href="#dmp-representation" title="Permalink to this headline">¶</a></h3>
<p>A multivariate polynomial (a polynomial in multiple variables) can be
represented as a polynomial with coefficients that are themselves polynomials.
For example <code class="docutils literal notranslate"><span class="pre">x**2*y</span> <span class="pre">+</span> <span class="pre">x**2</span> <span class="pre">+</span> <span class="pre">x*y</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">1</span></code> can be represented as polynomial
in <code class="docutils literal notranslate"><span class="pre">x</span></code> where the coefficients are themselves polynomials in <code class="docutils literal notranslate"><span class="pre">y</span></code> i.e.: <code class="docutils literal notranslate"><span class="pre">(y</span>
<span class="pre">+</span> <span class="pre">1)*x**2</span> <span class="pre">+</span> <span class="pre">(y)*x</span> <span class="pre">+</span> <span class="pre">(y+1)</span></code>. Since we can represent a polynomial with a list
of coefficients a multivariate polynomial can be represented with a list of
lists of coefficients:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">Poly(x**2*y + x**2 + x*y + y + 1, x, y, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span>
<span class="go">[[1, 1], [1, 0], [1, 1]]</span>
</pre></div>
</div>
<p>This list of lists of (lists of…) coefficients representation is known as
the “dense multivariate polynomial” (DMP) representation.</p>
</section>
<section id="sparse-polynomial-representation">
<span id="sparse-poly-representation"></span><h3>Sparse polynomial representation<a class="headerlink" href="#sparse-polynomial-representation" title="Permalink to this headline">¶</a></h3>
<p>Instead of lists we can use a dict mapping nonzero monomial terms to their
coefficients. This is known as the “sparse polynomial” representation. We can
see what this would look like using the <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly.as_dict" title="sympy.polys.polytools.Poly.as_dict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">as_dict()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">20</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span>
<span class="go">[7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">20</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">9</span><span class="p">)</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
<span class="go">{(0,): 9, (1,): 8, (20,): 7}</span>
</pre></div>
</div>
<p>The keys of this dict are the exponents of the powers of <code class="docutils literal notranslate"><span class="pre">x</span></code> and the values
are the coefficients so e.g. <code class="docutils literal notranslate"><span class="pre">7*x**20</span></code> becomes <code class="docutils literal notranslate"><span class="pre">(20,):</span> <span class="pre">7</span></code> in the dict. The
key is a tuple so that in the multivariate case something like <code class="docutils literal notranslate"><span class="pre">4*x**2*y**3</span></code>
can be represented as <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3):</span> <span class="pre">4</span></code>. The sparse representation can be more
efficient as it avoids the need to store and manipulate the zero coefficients.
With a large number of generators (variables) the dense representation becomes
particularly inefficient and it is better to use the sparse representation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gens</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x:10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gens</span>
<span class="go">(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">gens</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">Poly(x0*x1*x2*x3*x4*x5*x6*x7*x8*x9, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span>
<span class="go">[[[[[[[[[[1, 0], []], [[]]], [[[]]]], [[[[]]]]], [[[[[]]]]]], [[[[[[]]]]]]], [[[[[[[]]]]]]]], [[[[[[[[]]]]]]]]], [[[[[[[[[]]]]]]]]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">as_dict</span><span class="p">()</span>
<span class="go">{(1, 1, 1, 1, 1, 1, 1, 1, 1, 1): 1}</span>
</pre></div>
</div>
<p>The dict representation shown in the last output maps from the monomial which
is represented as a tuple of powers (<code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1,</span> <span class="pre">...)</span></code> i.e. <code class="docutils literal notranslate"><span class="pre">x0**1</span> <span class="pre">*</span> <span class="pre">x1**1,</span>
<span class="pre">...</span></code>) to the coefficient <code class="docutils literal notranslate"><span class="pre">1</span></code>. Compared to the <a class="reference internal" href="#dmp-representation"><span class="std std-ref">DMP representation</span></a> we
have a much more flattened data structure: it is a <code class="docutils literal notranslate"><span class="pre">dict</span></code> with only one key
and value. Algorithms for working with sparse representations would likely be
much more efficient than dense algorithms for this particular example
polynomial.</p>
<p>SymPy’s polynomial module has implementations of polynomial expressions based
on both the dense and sparse representations. There are also other
implementations of different special classes of expressions that can be used
as the coefficients of those polynomials. The rest of this page discusses what
those representations are and how to use them.</p>
</section>
</section>
<section id="basic-usage-of-domains">
<h2>Basic usage of domains<a class="headerlink" href="#basic-usage-of-domains" title="Permalink to this headline">¶</a></h2>
<p>Several domains are predefined and ready to be used such as <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> and <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>
which represent the ring of integers <span class="math notranslate nohighlight">\(\mathbb{Z}\)</span> and the field of rationals
<span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>. The <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain" title="sympy.polys.domains.domain.Domain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Domain</span></code></a> object is used to construct elements
which can then be used in ordinary arithmetic operations.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ZZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="o">+</span> <span class="n">z1</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span>  
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="ow">in</span> <span class="n">ZZ</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The basic operations <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, and <code class="docutils literal notranslate"><span class="pre">*</span></code> for addition, subtraction and
multiplication will work for the elements of any domain and will produce new
domain elements. Division with <code class="docutils literal notranslate"><span class="pre">/</span></code> (Python’s “true division” operator) is not
possible for all domains and should not be used with domain elements unless
the domain is known to be a field. For example dividing two elements of <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a>
gives a <code class="docutils literal notranslate"><span class="pre">float</span></code> which is not an element of <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="o">/</span> <span class="n">z1</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">z1</span> <span class="o">/</span> <span class="n">z1</span><span class="p">)</span>  
<span class="go">&lt;class &#39;float&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Most domains representing non-field rings allow floor and modulo division
(remainder) with Python’s floor division <code class="docutils literal notranslate"><span class="pre">//</span></code> and modulo division <code class="docutils literal notranslate"><span class="pre">%</span></code>
operators. For example with <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="o">//</span> <span class="n">z1</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="o">%</span> <span class="n">z1</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> domain represents the field of rational numbers and does allow
division:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">QQ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span>
<span class="go">1/2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q2</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q2</span>
<span class="go">2/3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q1</span> <span class="o">/</span> <span class="n">q2</span>
<span class="go">3/4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>  
<span class="go">&lt;class &#39;sympy.external.pythonmpq.PythonMPQ&#39;&gt;</span>
</pre></div>
</div>
<p>In general code that is expected to work with elements of an arbitrary domain
should not use the division operators <code class="docutils literal notranslate"><span class="pre">/</span></code>, <code class="docutils literal notranslate"><span class="pre">//</span></code> and <code class="docutils literal notranslate"><span class="pre">%</span></code>. Only the operators
<code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code> and <code class="docutils literal notranslate"><span class="pre">**</span></code> (with nonnegative integer exponent) should be
assumed to work with arbitrary domain elements. All other operations should be
accessed as functions from the <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain" title="sympy.polys.domains.domain.Domain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Domain</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">quo</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 5 // 3</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">rem</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># 5 % 3</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># divmod(5, 3)</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">QQ</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">QQ</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">(5/3, 0)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.exquo" title="sympy.polys.domains.domain.Domain.exquo"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exquo()</span></code></a> function is used to compute an exact quotient.
This is the analogue of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">/</span> <span class="pre">b</span></code> but where the division is expected to be exact
(with no remainder) or an error will be raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">exquo</span><span class="p">(</span><span class="n">QQ</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">QQ</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">5/3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">exquo</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">exquo</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ExactQuotientFailed</span>: <span class="n">3 does not divide 5 in ZZ</span>
</pre></div>
</div>
<p>The exact methods and attributes of the domain elements are not guaranteed in
general beyond the basic arithmetic operations. It should not be presumed that
e.g. <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> will always be of type <code class="docutils literal notranslate"><span class="pre">int</span></code>. If <code class="docutils literal notranslate"><span class="pre">gmpy</span></code> or <code class="docutils literal notranslate"><span class="pre">gmpy2</span></code> is
installed then the <code class="docutils literal notranslate"><span class="pre">mpz</span></code> or <code class="docutils literal notranslate"><span class="pre">mpq</span></code> types are used instead for <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> and
<a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">QQ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">mpz(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
<span class="go">mpq(2, 3)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">mpz</span></code> type is faster than Python’s standard <code class="docutils literal notranslate"><span class="pre">int</span></code> type for operations
with large integers although for smaller integers the difference is not so
significant. The <code class="docutils literal notranslate"><span class="pre">mpq</span></code> type representing rational numbers is implemented in
C rather than Python and is many times faster than the pure Python
implementation of <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> that is used when gmpy is not installed.</p>
<p>In general the Python type used for the elements of a domain can be checked
from the <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.dtype" title="sympy.polys.domains.domain.Domain.dtype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code></a> attribute of the domain. When gmpy is
installed the dtype for <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> is <span class="math notranslate nohighlight">\(mpz\)</span> which is not an actual type and can
not be used with <span class="math notranslate nohighlight">\(isinstance\)</span>. For this reason the <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.of_type" title="sympy.polys.domains.domain.Domain.of_type"><code class="xref py py-meth docutils literal notranslate"><span class="pre">of_type()</span></code></a>
method can be used to check if an object is an element of
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.dtype" title="sympy.polys.domains.domain.Domain.dtype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code></a>.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">dtype</span>  
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="domain-elements-vs-sympy-expressions">
<h2>Domain elements vs sympy expressions<a class="headerlink" href="#domain-elements-vs-sympy-expressions" title="Permalink to this headline">¶</a></h2>
<p>Note that domain elements are not of the same type as ordinary sympy
expressions which are subclasses of <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> such as
<a class="reference internal" href="../core.html#sympy.core.numbers.Integer" title="sympy.core.numbers.Integer"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integer</span></code></a>. Ordinary sympy expressions are
created with the <a class="reference internal" href="../core.html#sympy.core.sympify.sympify" title="sympy.core.sympify.sympify"><code class="xref py py-func docutils literal notranslate"><span class="pre">sympify()</span></code></a> function.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1_sympy</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Normal sympy object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1_sympy</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">z1_sympy</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.core.numbers.Integer&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Expr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">z1_sympy</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is important when working with the domains not to mix sympy expressions
with domain elements even though it will sometimes work in simple cases. Each
domain object has the methods <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.to_sympy" title="sympy.polys.domains.domain.Domain.to_sympy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_sympy()</span></code></a> and
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.from_sympy" title="sympy.polys.domains.domain.Domain.from_sympy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_sympy()</span></code></a> for converting back and forth between sympy
expressions and domain elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z_sympy</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_zz</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="n">z_sympy</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z_zz</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">z_sympy</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.core.numbers.Integer&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">z_zz</span><span class="p">)</span>  
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">to_sympy</span><span class="p">(</span><span class="n">z_zz</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">ZZ</span><span class="o">.</span><span class="n">to_sympy</span><span class="p">(</span><span class="n">z_zz</span><span class="p">))</span>
<span class="go">&lt;class &#39;sympy.core.numbers.Integer&#39;&gt;</span>
</pre></div>
</div>
<p>Any particular domain will only be able to represent some sympy expressions so
conversion will fail if the expression can not be represented in the domain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span>
<span class="go">sqrt(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">CoercionFailed</span>: <span class="n">expected an integer, got sqrt(2)</span>
</pre></div>
</div>
<p>We have already seen that in some cases we can use the domain object itself as
a constructor e.g. <code class="docutils literal notranslate"><span class="pre">QQ(2)</span></code>. This will generally work provided the arguments
given are valid for the <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.dtype" title="sympy.polys.domains.domain.Domain.dtype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code></a> of the domain. Although it is
convenient to use this in interactive sessions and in demonstrations it is
generally better to use the <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.from_sympy" title="sympy.polys.domains.domain.Domain.from_sympy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_sympy()</span></code></a> method for
constructing domain elements from sympy expressions (or from objects that can
be sympified to sympy expressions).</p>
<p>It is important not to mix domain elements with other Python types such as
<code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, as well as standard sympy <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> expressions.
When working in a domain, care should be taken as some Python operations will
do this implicitly. for example the <code class="docutils literal notranslate"><span class="pre">sum</span></code> function will use the regular
<code class="docutils literal notranslate"><span class="pre">int</span></code> value of zero so that <code class="docutils literal notranslate"><span class="pre">sum([a,</span> <span class="pre">b])</span></code> is effectively evaluated as <code class="docutils literal notranslate"><span class="pre">(0</span>
<span class="pre">+</span> <span class="pre">a)</span> <span class="pre">+</span> <span class="pre">b</span></code> where <code class="docutils literal notranslate"><span class="pre">0</span></code> is of type <code class="docutils literal notranslate"><span class="pre">int</span></code>.</p>
<p>Every domain is at least a ring if not a field and as such is guaranteed to
have two elements in particular corresponding to <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(0\)</span>.  The domain
object provides domain elements for these as the attributes
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.one" title="sympy.polys.domains.domain.Domain.one"><code class="xref py py-attr docutils literal notranslate"><span class="pre">one</span></code></a> and <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.zero" title="sympy.polys.domains.domain.Domain.zero"><code class="xref py py-attr docutils literal notranslate"><span class="pre">zero</span></code></a>. These are useful for
something like Python’s <code class="docutils literal notranslate"><span class="pre">sum</span></code> function which allows to provide an
alternative object as the “zero”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">one</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">([</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>  <span class="c1"># don&#39;t do this (even it sometimes works)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">([</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span><span class="p">)</span> <span class="c1"># provide the zero from the domain</span>
<span class="go">3</span>
</pre></div>
</div>
<p>A standard pattern then for performing calculations in a domain is:</p>
<ol class="arabic simple">
<li><p>Start with sympy <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> instances representing expressions.</p></li>
<li><p>Choose an appropriate domain that can represent the expressions.</p></li>
<li><p>Convert all expressions to domain elements using
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.from_sympy" title="sympy.polys.domains.domain.Domain.from_sympy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_sympy()</span></code></a>.</p></li>
<li><p>Perform the calculation with the domain elements.</p></li>
<li><p>Convert back to <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> with <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.to_sympy" title="sympy.polys.domains.domain.Domain.to_sympy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_sympy()</span></code></a>.</p></li>
</ol>
<p>Here is an implementation of the <code class="docutils literal notranslate"><span class="pre">sum</span></code> function that illustrates these
steps and sums some integers but performs the calculation using the domain
elements rather than standard sympy expressions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sum_domain</span><span class="p">(</span><span class="n">expressions_sympy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sum sympy expressions but performing calculations in domain ZZ&quot;&quot;&quot;</span>

    <span class="c1"># Convert to domain</span>
    <span class="n">expressions_dom</span> <span class="o">=</span> <span class="p">[</span><span class="n">ZZ</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expressions_sympy</span><span class="p">]</span>

    <span class="c1"># Perform calculations in the domain</span>
    <span class="n">result_dom</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">for</span> <span class="n">e_dom</span> <span class="ow">in</span> <span class="n">expressions_dom</span><span class="p">:</span>
        <span class="n">result_dom</span> <span class="o">+=</span> <span class="n">e_dom</span>

    <span class="c1"># Convert the result back to Expr</span>
    <span class="n">result_sympy</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">to_sympy</span><span class="p">(</span><span class="n">result_dom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_sympy</span>
</pre></div>
</div>
</section>
<section id="gaussian-integers-and-gaussian-rationals">
<h2>Gaussian integers and Gaussian rationals<a class="headerlink" href="#gaussian-integers-and-gaussian-rationals" title="Permalink to this headline">¶</a></h2>
<p>The two example domains that we have seen so far are <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> and <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>
representing the integers and the rationals respectively. There are other
simple domains such as <a class="reference internal" href="domainsref.html#zz-i"><span class="std std-ref">ZZ_I</span></a> and <a class="reference internal" href="domainsref.html#qq-i"><span class="std std-ref">QQ_I</span></a> representing the
<a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_integer">Gaussian integers</a> and <a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_rational">Gaussian rationals</a>. The Gaussian integers are
numbers of the form <span class="math notranslate nohighlight">\(a\sqrt{-1} + b\)</span> where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are integers. The
Gaussian rationals are defined similarly except that <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> can be
rationals. We can use the Gaussian domains like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ZZ_I</span><span class="p">,</span> <span class="n">QQ_I</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">ZZ_I</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span>
<span class="go">(1 + 2*I)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">**</span><span class="mi">2</span>
<span class="go">(-3 + 4*I)</span>
</pre></div>
</div>
<p>Note the contrast with the way this calculation works in the tree
representation where <a class="reference internal" href="../core.html#sympy.core.function.expand" title="sympy.core.function.expand"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand()</span></code></a> is needed to get the reduced form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">expand</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="o">**</span><span class="mi">2</span>
<span class="go">(1 + 2*I)**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expand</span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">-3 + 4*I</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="domainsref.html#zz-i"><span class="std std-ref">ZZ_I</span></a> and <a class="reference internal" href="domainsref.html#qq-i"><span class="std std-ref">QQ_I</span></a> domains are implemented by the classes
<a class="reference internal" href="domainsref.html#sympy.polys.domains.gaussiandomains.GaussianIntegerRing" title="sympy.polys.domains.gaussiandomains.GaussianIntegerRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianIntegerRing</span></code></a> and <a class="reference internal" href="domainsref.html#sympy.polys.domains.gaussiandomains.GaussianRationalField" title="sympy.polys.domains.gaussiandomains.GaussianRationalField"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianRationalField</span></code></a> and
their elements by <a class="reference internal" href="domainsref.html#sympy.polys.domains.gaussiandomains.GaussianInteger" title="sympy.polys.domains.gaussiandomains.GaussianInteger"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianInteger</span></code></a> and
<a class="reference internal" href="domainsref.html#sympy.polys.domains.gaussiandomains.GaussianRational" title="sympy.polys.domains.gaussiandomains.GaussianRational"><code class="xref py py-class docutils literal notranslate"><span class="pre">GaussianRational</span></code></a> respectively. The internal representation for
an element of <a class="reference internal" href="domainsref.html#zz-i"><span class="std std-ref">ZZ_I</span></a> or <a class="reference internal" href="domainsref.html#qq-i"><span class="std std-ref">QQ_I</span></a> is simply as a pair <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> of
elements of <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> or <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> respectively. The domain <a class="reference internal" href="domainsref.html#zz-i"><span class="std std-ref">ZZ_I</span></a> is a
ring with similar properties to <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> whereas <a class="reference internal" href="domainsref.html#qq-i"><span class="std std-ref">QQ_I</span></a> is a field much
like <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ_I</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ_I</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Since <a class="reference internal" href="domainsref.html#qq-i"><span class="std std-ref">QQ_I</span></a> is a field division by nonzero elements is always possible
whereas in <a class="reference internal" href="domainsref.html#zz-i"><span class="std std-ref">ZZ_I</span></a> we have the important concept of the greatest common
divisor (GCD):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span> <span class="o">=</span> <span class="n">QQ_I</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">I</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e2</span> <span class="o">=</span> <span class="n">QQ_I</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="n">I</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e1</span><span class="o">/</span><span class="n">e2</span>
<span class="go">(6/17 + 10/17*I)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ_I</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">ZZ_I</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">ZZ_I</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="p">))</span>
<span class="go">(1 + 2*I)</span>
</pre></div>
</div>
</section>
<section id="finite-fields">
<h2>Finite fields<a class="headerlink" href="#finite-fields" title="Permalink to this headline">¶</a></h2>
<p>So far we have seen the domains <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a>, <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>, <a class="reference internal" href="domainsref.html#zz-i"><span class="std std-ref">ZZ_I</span></a>, and
<a class="reference internal" href="domainsref.html#qq-i"><span class="std std-ref">QQ_I</span></a>. There are also domains representing the <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_field">Finite fields</a> although
the implementation of these is incomplete. A finite field <a class="reference internal" href="domainsref.html#gf-p"><span class="std std-ref">GF(p)</span></a> of
<em>prime</em> order can be constructed with <code class="docutils literal notranslate"><span class="pre">FF</span></code> or <code class="docutils literal notranslate"><span class="pre">GF</span></code>. A domain for the
finite field of prime order <span class="math notranslate nohighlight">\(p\)</span> can be constructed with <a class="reference internal" href="domainsref.html#gf-p"><span class="std std-ref">GF(p)</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">GF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">two</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">two</span>
<span class="go">2 mod 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">two</span> <span class="o">**</span> <span class="mi">2</span>
<span class="go">4 mod 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">two</span> <span class="o">**</span> <span class="mi">3</span>
<span class="go">3 mod 5</span>
</pre></div>
</div>
<p>There is also <code class="docutils literal notranslate"><span class="pre">FF</span></code> as an alias for <code class="docutils literal notranslate"><span class="pre">GF</span></code> (standing for “finite field” and
“Galois field” respectively). These are equivalent and both <code class="docutils literal notranslate"><span class="pre">FF(n)</span></code> and
<code class="docutils literal notranslate"><span class="pre">GF(n)</span></code> will create a domain which is an instance of
<a class="reference internal" href="domainsref.html#sympy.polys.domains.FiniteField" title="sympy.polys.domains.FiniteField"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteField</span></code></a>. The associated domain elements will be instances of
<a class="reference internal" href="domainsref.html#sympy.polys.domains.PythonFiniteField" title="sympy.polys.domains.PythonFiniteField"><code class="xref py py-class docutils literal notranslate"><span class="pre">PythonFiniteField</span></code></a> or <a class="reference internal" href="domainsref.html#sympy.polys.domains.GMPYFiniteField" title="sympy.polys.domains.GMPYFiniteField"><code class="xref py py-class docutils literal notranslate"><span class="pre">GMPYFiniteField</span></code></a> depending on
whether or not <code class="docutils literal notranslate"><span class="pre">gmpy</span></code> is installed.</p>
<p>Finite fields of order <span class="math notranslate nohighlight">\(p^n\)</span> where <span class="math notranslate nohighlight">\(n \ne 1\)</span> are not implemented. It is
possible to use e.g. <code class="docutils literal notranslate"><span class="pre">GF(6)</span></code> or <code class="docutils literal notranslate"><span class="pre">GF(9)</span></code> but the resulting domain is <em>not</em>
a field. It is just the integers modulo <code class="docutils literal notranslate"><span class="pre">6</span></code> or <code class="docutils literal notranslate"><span class="pre">9</span></code> and therefore has zero
divisors and non-invertible elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">GF</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">K</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0 mod 6</span>
</pre></div>
</div>
<p>It would be good to have a proper implementation of prime-power order finite
fields but this is not yet available in SymPy (contributions welcome!).</p>
</section>
<section id="real-and-complex-fields">
<h2>Real and complex fields<a class="headerlink" href="#real-and-complex-fields" title="Permalink to this headline">¶</a></h2>
<p>The fields <a class="reference internal" href="domainsref.html#rr"><span class="std std-ref">RR</span></a> and <a class="reference internal" href="domainsref.html#cc"><span class="std std-ref">CC</span></a> are intended mathematically to correspond
to the <a class="reference external" href="https://en.wikipedia.org/wiki/Real_number">reals</a> and the <a class="reference external" href="https://en.wikipedia.org/wiki/Complex_number">complex numbers</a>, <span class="math notranslate nohighlight">\(\mathbb{R}\)</span> and <span class="math notranslate nohighlight">\(\mathbb{C}\)</span>
respectively. The implementation of these uses floating point arithmetic. In
practice this means that these are the domains that are used to represent
expressions containing floats. Elements of <a class="reference internal" href="domainsref.html#rr"><span class="std std-ref">RR</span></a> are instances of the
class <a class="reference internal" href="domainsref.html#sympy.polys.domains.mpelements.RealElement" title="sympy.polys.domains.mpelements.RealElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">RealElement</span></code></a> and have an <code class="docutils literal notranslate"><span class="pre">mpf</span></code> tuple which is used to
represent a float in <code class="docutils literal notranslate"><span class="pre">mpmath</span></code>. Elements of <a class="reference internal" href="domainsref.html#cc"><span class="std std-ref">CC</span></a> are instances of
<a class="reference internal" href="domainsref.html#sympy.polys.domains.mpelements.ComplexElement" title="sympy.polys.domains.mpelements.ComplexElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComplexElement</span></code></a> and have an <code class="docutils literal notranslate"><span class="pre">mpc</span></code> tuple which is a pair of
<code class="docutils literal notranslate"><span class="pre">mpf</span></code> tuples representing the real and imaginary parts. See the
<a class="reference external" href="https://mpmath.org/doc/current/technical.html#representation-of-numbers">mpmath docs</a> for more about how floating point numbers are represented:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">RR</span><span class="p">,</span> <span class="n">CC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xr</span> <span class="o">=</span> <span class="n">RR</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xr</span>
<span class="go">3.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xr</span><span class="o">.</span><span class="n">_mpf_</span>
<span class="go">(0, 3, 0, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zc</span> <span class="o">=</span> <span class="n">CC</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zc</span>
<span class="go">(3.0 + 1.0j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zc</span><span class="o">.</span><span class="n">_mpc_</span>
<span class="go">((0, 3, 0, 2), (0, 1, 0, 1))</span>
</pre></div>
</div>
<p>The use of approximate floating point arithmetic in these domains comes with
all of the usual pitfalls. Many algorithms in the <a class="reference internal" href="reference.html#module-sympy.polys" title="sympy.polys"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.polys</span></code></a> module are
fundamentally designed for exact arithmetic making the use of these domains
potentially problematic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">RR</span><span class="p">(</span><span class="s1">&#39;0.1&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">RR</span><span class="p">(</span><span class="s1">&#39;0.2&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">RR</span><span class="p">(</span><span class="s1">&#39;0.3&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Since these are implemented using <code class="docutils literal notranslate"><span class="pre">mpmath</span></code> which is a multiprecision library
it is possible to create different domains with different working precisions.
The default domains <a class="reference internal" href="domainsref.html#rr"><span class="std std-ref">RR</span></a> and <a class="reference internal" href="domainsref.html#cc"><span class="std std-ref">CC</span></a> use 53 binary digits of precision
much like standard <a class="reference external" href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">double precision</a> floating point which corresponds to
approximately 15 decimal digits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.polys.domains.realfield</span> <span class="kn">import</span> <span class="n">RealField</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RR</span><span class="o">.</span><span class="n">precision</span>
<span class="go">53</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RR</span><span class="o">.</span><span class="n">dps</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">RR</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RR100</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RR100</span><span class="o">.</span><span class="n">precision</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RR100</span><span class="o">.</span><span class="n">dps</span>
<span class="go">29</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RR100</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">RR100</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0.33333333333333333333333333333</span>
</pre></div>
</div>
<p>There is however a bug in the implementation of this so that actually a global
precision setting is used by all <a class="reference internal" href="domainsref.html#sympy.polys.domains.mpelements.RealElement" title="sympy.polys.domains.mpelements.RealElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">RealElement</span></code></a>. This means that
just creating <code class="docutils literal notranslate"><span class="pre">RR100</span></code> above has altered the global precision and we will
need to restore it in the doctest here:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">RR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">RR</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># wrong result!</span>
<span class="go">0.33333333333333333333333333333</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dummy</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">53</span><span class="p">)</span>  <span class="c1"># hack to restore precision</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">RR</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># restored</span>
<span class="go">0.333333333333333</span>
</pre></div>
</div>
<p>(Obviously that should be fixed!)</p>
</section>
<section id="algebraic-number-fields">
<h2>Algebraic number fields<a class="headerlink" href="#algebraic-number-fields" title="Permalink to this headline">¶</a></h2>
<p>An <a class="reference external" href="https://en.wikipedia.org/wiki/Algebraic_extension">algebraic extension</a> of the rationals <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span> is known as an
<a class="reference external" href="https://en.wikipedia.org/wiki/Algebraic_number_field">algebraic number field</a> and these are implemented in sympy as <a class="reference internal" href="domainsref.html#qq-a"><span class="std std-ref">QQ&lt;a&gt;</span></a>.
The natural syntax for these would be something like <code class="docutils literal notranslate"><span class="pre">QQ(sqrt(2))</span></code> however
<code class="docutils literal notranslate"><span class="pre">QQ()</span></code> is already overloaded as the constructor for elements of <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>.
These domains are instead created using the
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.algebraic_field" title="sympy.polys.domains.domain.Domain.algebraic_field"><code class="xref py py-meth docutils literal notranslate"><span class="pre">algebraic_field()</span></code></a> method e.g.
<code class="docutils literal notranslate"><span class="pre">QQ.algebraic_field(sqrt(2))</span></code>. The resulting domain will be an instance of
<a class="reference internal" href="domainsref.html#sympy.polys.domains.AlgebraicField" title="sympy.polys.domains.AlgebraicField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgebraicField</span></code></a> with elements that are instances of
<a class="reference internal" href="domainsref.html#sympy.polys.polyclasses.ANP" title="sympy.polys.polyclasses.ANP"><code class="xref py py-class docutils literal notranslate"><span class="pre">ANP</span></code></a>.</p>
<p>The printing support for these is less developed but we can use
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.to_sympy" title="sympy.polys.domains.domain.Domain.to_sympy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_sympy()</span></code></a> to take advantage of the corresponding
<a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> printing support:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">algebraic_field</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span>
<span class="go">QQ&lt;sqrt(2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">one</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>  
<span class="go">ANP([1, 1], [1, 0, -2], QQ)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">to_sympy</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">1 + sqrt(2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">**</span> <span class="mi">2</span>  
<span class="go">ANP([2, 3], [1, 0, -2], QQ)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">to_sympy</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2*sqrt(2) + 3</span>
</pre></div>
</div>
<p>The raw printed display immediately shows the internal representation of the
elements as <a class="reference internal" href="domainsref.html#sympy.polys.polyclasses.ANP" title="sympy.polys.polyclasses.ANP"><code class="xref py py-class docutils literal notranslate"><span class="pre">ANP</span></code></a> instances. The field <span class="math notranslate nohighlight">\(\mathbb{Q}(\sqrt{2})\)</span>
consists of numbers of the form <span class="math notranslate nohighlight">\(a\sqrt{2}+b\)</span> where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are rational
numbers. Consequently every number in this field can be represented as a pair
<code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b)</span></code> of elements of <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>. The domain element stores these two in a
list and also stores a list representation of the <em>minimal polynomial</em> for the
extension element <span class="math notranslate nohighlight">\(\sqrt{2}\)</span>. There is a sympy function <a class="reference internal" href="numberfields.html#sympy.polys.numberfields.minpoly.minpoly" title="sympy.polys.numberfields.minpoly.minpoly"><code class="xref py py-func docutils literal notranslate"><span class="pre">minpoly()</span></code></a>
that can compute the minimal polynomial of any algebraic expression over the
rationals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minpoly</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">x**2 - 2</span>
</pre></div>
</div>
<p>In the dense polynomial representation as a list of coefficients this
polynomial is represented as <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">-2]</span></code> as seen in the <a class="reference internal" href="domainsref.html#sympy.polys.polyclasses.ANP" title="sympy.polys.polyclasses.ANP"><code class="xref py py-class docutils literal notranslate"><span class="pre">ANP</span></code></a>
display for the elements of <code class="docutils literal notranslate"><span class="pre">QQ&lt;sqrt(2)&gt;</span></code> above.</p>
<p>It is also possible to create an algebraic number field with multiple
generators such as <span class="math notranslate nohighlight">\(\mathbb{Q}(\sqrt{2},\sqrt{3})\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">algebraic_field</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span>
<span class="go">QQ&lt;sqrt(2) + sqrt(3)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt2</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt3</span> <span class="o">=</span> <span class="n">K</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">one</span> <span class="o">+</span> <span class="n">sqrt2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">one</span> <span class="o">+</span> <span class="n">sqrt3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>  
<span class="go">ANP([1/2, 1, -3/2], [1, 0, -10, 0, 1], QQ)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">to_sympy</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">1 + sqrt(2) + sqrt(3) + sqrt(6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">to_sympy</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4*sqrt(6) + 6*sqrt(3) + 8*sqrt(2) + 12</span>
</pre></div>
</div>
<p>Here the algebraic extension <span class="math notranslate nohighlight">\(\mathbb{Q}(\sqrt{2},\sqrt{3})\)</span> is converted to
the (isomorphic) <span class="math notranslate nohighlight">\(\mathbb{Q}(\sqrt{2}+\sqrt{3})\)</span> with a single generator
<span class="math notranslate nohighlight">\(\sqrt{2}+\sqrt{3}\)</span>. It is always possible to find a single generator like
this due to the <a class="reference external" href="https://en.wikipedia.org/wiki/Primitive_element_theorem">primitive element theorem</a>. There is a sympy function
<a class="reference internal" href="numberfields.html#sympy.polys.numberfields.subfield.primitive_element" title="sympy.polys.numberfields.subfield.primitive_element"><code class="xref py py-func docutils literal notranslate"><span class="pre">primitive_element()</span></code></a> that can compute the minimal polynomial for a
primitive element of an extension:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">primitive_element</span><span class="p">,</span> <span class="n">minpoly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="n">primitive_element</span><span class="p">([</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x**4 - 10*x**2 + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The minimal polynomial <code class="docutils literal notranslate"><span class="pre">x**4</span> <span class="pre">-</span> <span class="pre">10*x**2</span> <span class="pre">+</span> <span class="pre">1</span></code> has the dense list representation
<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0,</span> <span class="pre">-10,</span> <span class="pre">0,</span> <span class="pre">1]</span></code> as seen in the <a class="reference internal" href="domainsref.html#sympy.polys.polyclasses.ANP" title="sympy.polys.polyclasses.ANP"><code class="xref py py-class docutils literal notranslate"><span class="pre">ANP</span></code></a> output above. What the
primitive element theorem means is that all algebraic number fields can be
represented as an extension of the rationals by a single generator with some
minimal polynomial. Calculations over the algebraic number field only need to
take advantage of the minimal polynomial and that makes it possible to compute
all arithmetic operations and also to carry out higher level operations like
factorisation of polynomials.</p>
</section>
<section id="polynomial-ring-domains">
<h2>Polynomial ring domains<a class="headerlink" href="#polynomial-ring-domains" title="Permalink to this headline">¶</a></h2>
<p>There are also domains implemented to represent a polynomial ring like
<a class="reference internal" href="domainsref.html#k-x"><span class="std std-ref">K[x]</span></a> which is the domain of polynomials in the generator <code class="docutils literal notranslate"><span class="pre">x</span></code> with
coefficients over another domain <code class="docutils literal notranslate"><span class="pre">K</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span>
<span class="go">ZZ[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_dom</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_dom</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">one</span>
<span class="go">x + 1</span>
</pre></div>
</div>
<p>All the operations discussed before will work with elements of a polynomial
ring:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">x_dom</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">+</span> <span class="n">p</span>
<span class="go">2*x + 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">-</span> <span class="n">p</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">*</span> <span class="n">p</span>
<span class="go">x**2 + 2*x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">**</span> <span class="mi">3</span>
<span class="go">x**3 + 3*x**2 + 3*x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="o">.</span><span class="n">exquo</span><span class="p">(</span><span class="n">x_dom</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="n">x_dom</span> <span class="o">-</span> <span class="n">K</span><span class="o">.</span><span class="n">one</span><span class="p">)</span>
<span class="go">x + 1</span>
</pre></div>
</div>
<p>The internal representation of elements of <code class="docutils literal notranslate"><span class="pre">K[x]</span></code> is different from the way
that ordinary sympy (<a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a>) expressions are represented. The
<a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> representation of any expression is as a tree e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">srepr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_expr</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_expr</span>
<span class="go">x**2 + 2*x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">srepr</span><span class="p">(</span><span class="n">p_expr</span><span class="p">)</span>
<span class="go">&quot;Add(Pow(Symbol(&#39;x&#39;), Integer(2)), Mul(Integer(2), Symbol(&#39;x&#39;)), Integer(1))&quot;</span>
</pre></div>
</div>
<p>Here the expression is a tree where the top node is an <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code></a> and
its children nodes are <a class="reference internal" href="../core.html#sympy.core.power.Pow" title="sympy.core.power.Pow"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pow</span></code></a> etc. This tree representation makes
it possible to represent equivalent expressions in different ways e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_expr</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_expr</span>
<span class="go">x*(x + 1) + x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_expr</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="go">x**2 + 2*x</span>
</pre></div>
</div>
<p>By contrast the domain <code class="docutils literal notranslate"><span class="pre">ZZ[x]</span></code> represents only polynomials and does so by
simply storing the non-zero coefficients of the expanded polynomial (the
“sparse” polynomial representation). In particular elements of <code class="docutils literal notranslate"><span class="pre">ZZ[x]</span></code> are
represented as a Python <code class="docutils literal notranslate"><span class="pre">dict</span></code>. Their type is <a class="reference internal" href="domainsref.html#sympy.polys.rings.PolyElement" title="sympy.polys.rings.PolyElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyElement</span></code></a>
which is a subclass of <code class="docutils literal notranslate"><span class="pre">dict</span></code>. Converting to a normal dict shows the
internal representation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_dom</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_dom</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">x_dom</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">K</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x_dom</span> <span class="o">+</span> <span class="n">K</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_dom</span>
<span class="go">3*x**2 + 2*x + 7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">p_dom</span><span class="p">)</span>
<span class="go">{(0,): 7, (1,): 2, (2,): 3}</span>
</pre></div>
</div>
<p>This internal form makes it impossible to represent unexpanded multiplications
so any multiplication of elements of <code class="docutils literal notranslate"><span class="pre">ZZ[x]</span></code> will always be
expanded:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_dom</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_expr</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_expr</span>
<span class="go">x*(x + 1) + x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_dom</span> <span class="o">=</span> <span class="n">x_dom</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_dom</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">one</span><span class="p">)</span> <span class="o">+</span> <span class="n">x_dom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p_dom</span>
<span class="go">x**2 + 2*x</span>
</pre></div>
</div>
<p>These same considerations apply to powers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="go">(x + 1)**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x_dom</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">one</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="go">x**2 + 2*x + 1</span>
</pre></div>
</div>
<p>We can also construct multivariate polynomial rings:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xk</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yk</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xk</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">yk</span> <span class="o">+</span> <span class="n">xk</span> <span class="o">+</span> <span class="n">yk</span>
<span class="go">x**2*y + x + y</span>
</pre></div>
</div>
<p>It is also possible to construct nested polynomial rings (although it is less
efficient). The ring <code class="docutils literal notranslate"><span class="pre">K[x][y]</span></code> is formally equivalent to <code class="docutils literal notranslate"><span class="pre">K[x,y]</span></code> although
their implementations in sympy are different:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">y**2 + x*y + x**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">{(0,): x**2, (1,): x, (2,): 1}</span>
</pre></div>
</div>
<p>Here the coefficients like <code class="docutils literal notranslate"><span class="pre">x**2</span></code> are instances of <a class="reference internal" href="domainsref.html#sympy.polys.rings.PolyElement" title="sympy.polys.rings.PolyElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyElement</span></code></a>
as well so this is a <code class="docutils literal notranslate"><span class="pre">dict</span></code> where the values are also dicts. The full
representation is more like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
<span class="go">{(0,): {(2,): 1}, (1,): {(1,): 1}, (2,): {(0,): 1}}</span>
</pre></div>
</div>
<p>The multivariate ring domain <code class="docutils literal notranslate"><span class="pre">ZZ[x,y]</span></code> has a more efficient representation
as a single flattened <code class="docutils literal notranslate"><span class="pre">dict</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">x**2 + x*y + y**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">{(0, 2): 1, (1, 1): 1, (2, 0): 1}</span>
</pre></div>
</div>
<p>The difference in efficiency between these representations grows as the number
of generators increases i.e. <code class="docutils literal notranslate"><span class="pre">ZZ[x,y,z,t,...]</span></code> vs <code class="docutils literal notranslate"><span class="pre">ZZ[x][y][z][t]...</span></code>.</p>
</section>
<section id="old-dense-polynomial-rings">
<h2>Old (dense) polynomial rings<a class="headerlink" href="#old-dense-polynomial-rings" title="Permalink to this headline">¶</a></h2>
<p>In the last section we saw that the domain representation of a polynomial ring
like <a class="reference internal" href="domainsref.html#k-x"><span class="std std-ref">K[x]</span></a> uses a sparse representation of a polynomial as a dict
mapping monomial exponents to coefficients. There is also an older version of
<a class="reference internal" href="domainsref.html#k-x"><span class="std std-ref">K[x]</span></a> that uses the dense <a class="reference internal" href="#dmp-representation"><span class="std std-ref">DMP representation</span></a>. We can create these
two versions of <a class="reference internal" href="domainsref.html#k-x"><span class="std std-ref">K[x]</span></a> using <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.poly_ring" title="sympy.polys.domains.domain.Domain.poly_ring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">poly_ring()</span></code></a> and
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.old_poly_ring" title="sympy.polys.domains.domain.Domain.old_poly_ring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">old_poly_ring()</span></code></a> where the syntax <code class="docutils literal notranslate"><span class="pre">K[x]</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">K.poly_ring(x)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">poly_ring</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span> <span class="o">=</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">old_poly_ring</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span>
<span class="go">ZZ[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span>
<span class="go">ZZ[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span> <span class="o">==</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span> <span class="o">==</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">K1</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">K2</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span>
<span class="go">x**2 + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">x**2 + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.polys.domains.polynomialring.PolynomialRing&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.polys.rings.PolyElement&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">K2</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.polys.domains.old_polynomialring.GlobalPolynomialRing&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.polys.polyclasses.DMP&#39;&gt;</span>
</pre></div>
</div>
<p>The internal representation of the old polynomial ring domain is the
<a class="reference internal" href="domainsref.html#sympy.polys.polyclasses.DMP" title="sympy.polys.polyclasses.DMP"><code class="xref py py-class docutils literal notranslate"><span class="pre">DMP</span></code></a> representation as a list of (lists of) coefficients:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>  
<span class="go">&#39;DMP([1, 0, 1], ZZ, ZZ[x])&#39;</span>
</pre></div>
</div>
<p>The most notable use of the <a class="reference internal" href="domainsref.html#sympy.polys.polyclasses.DMP" title="sympy.polys.polyclasses.DMP"><code class="xref py py-class docutils literal notranslate"><span class="pre">DMP</span></code></a> representation of polynomials is
as the internal representation used by <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> (this is discussed
later in this page of the docs).</p>
</section>
<section id="polyring-vs-polynomialring">
<h2>PolyRing vs PolynomialRing<a class="headerlink" href="#polyring-vs-polynomialring" title="Permalink to this headline">¶</a></h2>
<p>You might just want to perform calculations in some particular polynomial ring
without being concerned with implementing something that works for arbitrary
domains. In that case you can construct the ring more directly with the
<a class="reference internal" href="domainsref.html#sympy.polys.rings.ring" title="sympy.polys.rings.ring"><code class="xref py py-func docutils literal notranslate"><span class="pre">ring()</span></code></a> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ring</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span> <span class="o">=</span> <span class="n">ring</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span>
<span class="go">Polynomial ring in x, y over ZZ with lex order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xr</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">yr</span><span class="o">**</span><span class="mi">2</span>
<span class="go">x**2 - y**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">xr</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">yr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">xr</span> <span class="o">-</span> <span class="n">yr</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
<p>The object <code class="docutils literal notranslate"><span class="pre">K</span></code> here represents the ring and is an instance of
<a class="reference internal" href="domainsref.html#sympy.polys.rings.PolyRing" title="sympy.polys.rings.PolyRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyRing</span></code></a> but is not a <strong>polys domain</strong> (it is not an instance of
a subclass of <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain" title="sympy.polys.domains.domain.Domain"><code class="xref py py-class docutils literal notranslate"><span class="pre">Domain</span></code></a> so it can not be used with
<a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a>). In this way the implementation of polynomial rings that
is used in the domain system can be used independently of the domain system.</p>
<p>The purpose of the domain system is to provide a unified interface for working
with and converting between different representations of expressions. To make
the <a class="reference internal" href="domainsref.html#sympy.polys.rings.PolyRing" title="sympy.polys.rings.PolyRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyRing</span></code></a> implementation usable in that context the
<a class="reference internal" href="domainsref.html#sympy.polys.domains.PolynomialRing" title="sympy.polys.domains.PolynomialRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialRing</span></code></a> class is a wrapper around the
<a class="reference internal" href="domainsref.html#sympy.polys.rings.PolyRing" title="sympy.polys.rings.PolyRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyRing</span></code></a> class that provides the interface expected in the
domain system. That makes this implementation of polynomial rings usable as
part of the broader codebase that is designed to work with expressions from
different domains. The domain for polynomial rings is a distinct object from
the ring returned by <a class="reference internal" href="domainsref.html#sympy.polys.rings.ring" title="sympy.polys.rings.ring"><code class="xref py py-func docutils literal notranslate"><span class="pre">ring()</span></code></a> although both have the same elements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span> <span class="o">=</span> <span class="n">ring</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span>
<span class="go">Polynomial ring in x, y over ZZ with lex order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span>
<span class="go">ZZ[x,y]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span><span class="o">.</span><span class="n">ring</span>
<span class="go">Polynomial ring in x, y over ZZ with lex order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span><span class="o">.</span><span class="n">ring</span> <span class="o">==</span> <span class="n">K</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="go">x + y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="go">x + y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">))</span>
<span class="go">&lt;class &#39;sympy.polys.rings.PolyElement&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">K2</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">))</span>
<span class="go">&lt;class &#39;sympy.polys.rings.PolyElement&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="n">K2</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="rational-function-fields">
<h2>Rational function fields<a class="headerlink" href="#rational-function-fields" title="Permalink to this headline">¶</a></h2>
<p>Some domains are classified as fields and others are not. The principal
difference between a field and a non-field domain is that in a field it is
always possible to divide any element by any nonzero element. It is usually
possible to convert any domain to a field that contains that domain with the
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.get_field" title="sympy.polys.domains.domain.Domain.get_field"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_field()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">QQ</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="go">QQ[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">get_field</span><span class="p">()</span>
<span class="go">QQ(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">get_field</span><span class="p">()</span><span class="o">.</span><span class="n">is_Field</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">frac_field</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">QQ(x)</span>
</pre></div>
</div>
<p>This introduces a new kind of domain <a class="reference internal" href="domainsref.html#id11"><span class="std std-ref">K(x)</span></a> representing a rational
function field in the generator <code class="docutils literal notranslate"><span class="pre">x</span></code> over another domain <code class="docutils literal notranslate"><span class="pre">K</span></code>. It is not
possible to construct the domain <code class="docutils literal notranslate"><span class="pre">QQ(x)</span></code> with the <code class="docutils literal notranslate"><span class="pre">()</span></code> syntax so the
easiest ways to create it are using the domain methods
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.frac_field" title="sympy.polys.domains.domain.Domain.frac_field"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frac_field()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">QQ.frac_field(x)</span></code>) or
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.get_field" title="sympy.polys.domains.domain.Domain.get_field"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_field()</span></code></a> (<code class="docutils literal notranslate"><span class="pre">QQ[x].get_field()</span></code>). The
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.frac_field" title="sympy.polys.domains.domain.Domain.frac_field"><code class="xref py py-meth docutils literal notranslate"><span class="pre">frac_field()</span></code></a> method is the more direct approach.</p>
<p>The rational function field <a class="reference internal" href="domainsref.html#id11"><span class="std std-ref">K(x)</span></a> is an instance of
<a class="reference internal" href="domainsref.html#sympy.polys.domains.RationalField" title="sympy.polys.domains.RationalField"><code class="xref py py-class docutils literal notranslate"><span class="pre">RationalField</span></code></a>. This domain represents functions of the form
<span class="math notranslate nohighlight">\(p(x) / q(x)\)</span> for polynomials <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>. The domain elements are
represented as a pair of polynomials in <a class="reference internal" href="domainsref.html#k-x"><span class="std std-ref">K[x]</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">frac_field</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xk</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">/</span> <span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">one</span> <span class="o">+</span> <span class="n">xk</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span>
<span class="go">x/(x**2 + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">numer</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">denom</span>
<span class="go">x**2 + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">numer</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">denom</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Cancellation between the numerator and denominator is automatic in this
field:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">xk</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">xk</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span>
<span class="go">x**2 - 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">x - 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">/</span> <span class="n">p2</span>
<span class="go">x + 1</span>
</pre></div>
</div>
<p>Computing this cancellation can be slow which makes rational function fields
potentially slower than polynomial rings or algebraic fields.</p>
<p>Just like in the case of polynomial rings there is both a new (sparse) and old
(dense) version of fraction fields:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">frac_field</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">old_frac_field</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span>
<span class="go">QQ(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span>
<span class="go">QQ(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">K1</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.polys.domains.fractionfield.FractionField&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">K2</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.polys.domains.old_fractionfield.FractionField&#39;&gt;</span>
</pre></div>
</div>
<p>Also just like in the case of polynomials rings the implementation of rational
function fields can be used independently of the domain system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">field</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">,</span> <span class="n">xf</span><span class="p">,</span> <span class="n">yf</span> <span class="o">=</span> <span class="n">field</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xf</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">yf</span><span class="p">)</span>
<span class="go">-x/(y - 1)</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">K</span></code> is an instance of <a class="reference internal" href="domainsref.html#sympy.polys.fields.FracField" title="sympy.polys.fields.FracField"><code class="xref py py-class docutils literal notranslate"><span class="pre">FracField</span></code></a> rather than
<a class="reference internal" href="domainsref.html#sympy.polys.domains.RationalField" title="sympy.polys.domains.RationalField"><code class="xref py py-class docutils literal notranslate"><span class="pre">RationalField</span></code></a> as it would be for the domain <code class="docutils literal notranslate"><span class="pre">ZZ(x,y)</span></code>.</p>
</section>
<section id="expression-domain">
<h2>Expression domain<a class="headerlink" href="#expression-domain" title="Permalink to this headline">¶</a></h2>
<p>The final domain to consider is the “expression domain” which is known as
<a class="reference internal" href="domainsref.html#ex"><span class="std std-ref">EX</span></a>. Expressions that can not be represented using the other domains can
be always represented using the expression domain. An element of <a class="reference internal" href="domainsref.html#ex"><span class="std std-ref">EX</span></a> is
actually just a wrapper around a <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">EX</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">EX</span><span class="o">.</span><span class="n">from_sympy</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">EX(x + 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.polys.domains.expressiondomain.ExpressionDomain.Expression&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">ex</span>
<span class="go">x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ex</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.core.add.Add&#39;&gt;</span>
</pre></div>
</div>
<p>For other domains the domain representation of expressions is usually more
efficient than the tree representation used by <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a>. In
<a class="reference internal" href="domainsref.html#ex"><span class="std std-ref">EX</span></a> the internal representation is <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> so it is clearly
not more efficient. The purpose of the <a class="reference internal" href="domainsref.html#ex"><span class="std std-ref">EX</span></a> domain is to be able to wrap
up arbitrary expressions in an interface that is consistent with the other
domains. The <a class="reference internal" href="domainsref.html#ex"><span class="std std-ref">EX</span></a> domain is used as a fallback when an appropriate domain
can not be found. Although this does not offer any particular efficiency it
does allow the algorithms that are implemented to work over arbitrary domains
to be usable when working with expressions that do not have an appropriate
domain representation.</p>
</section>
<section id="choosing-a-domain">
<h2>Choosing a domain<a class="headerlink" href="#choosing-a-domain" title="Permalink to this headline">¶</a></h2>
<p>In the workflow described above the idea is to start with some sympy
expressions, choose a domain and convert all the expressions into that domain
in order to perform some calculation. The obvious question that arises is how
to choose an appropriate domain to represent some sympy expressions. For this
there is a function <a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a> which takes a list of
expressions and will choose a domain and convert all of the expressions to
that domain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">construct_domain</span><span class="p">,</span> <span class="n">Integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elements_sympy</span> <span class="o">=</span> <span class="p">[</span><span class="n">Integer</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>  <span class="c1"># elements as Expr instances</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elements_sympy</span>
<span class="go">[3, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">,</span> <span class="n">elements_K</span> <span class="o">=</span> <span class="n">construct_domain</span><span class="p">(</span><span class="n">elements_sympy</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span>
<span class="go">ZZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elements_K</span>
<span class="go">[3, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">elements_sympy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;sympy.core.numbers.Integer&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">elements_K</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>In this example we see that the two integers <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code> can be
represented in the domain <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a>. The expressions have been converted to
elements of that domain which in this case means the <code class="docutils literal notranslate"><span class="pre">int</span></code> type rather than
instances of <a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a>. It is not necessary to explicitly create
<a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a> instances when the inputs can be sympified so e.g.
<code class="docutils literal notranslate"><span class="pre">construct_domain([3,</span> <span class="pre">2])</span></code> would give the same output as above.</p>
<p>Given more complicated inputs <a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a> will choose more
complicated domains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">3</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">QQ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">QQ[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ[x,y]</span>
</pre></div>
</div>
<p>If any noninteger rational numbers are found in the inputs then the ground
domain will be <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> rather than <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a>. If any symbol is found in the
inputs then a <a class="reference internal" href="domainsref.html#sympy.polys.domains.PolynomialRing" title="sympy.polys.domains.PolynomialRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialRing</span></code></a> will be created. A multivariate
polynomial ring such as <code class="docutils literal notranslate"><span class="pre">QQ[x,y]</span></code> can also be created if there are multiple
symbols in the inputs. If any symbols appear in the denominators then a
<a class="reference internal" href="domainsref.html#sympy.polys.domains.RationalField" title="sympy.polys.domains.RationalField"><code class="xref py py-class docutils literal notranslate"><span class="pre">RationalField</span></code></a> like <code class="docutils literal notranslate"><span class="pre">QQ(x)</span></code> will be created instead.</p>
<p>Some of the domains above are fields and others are (non-field) rings. In some
contexts it is necessary to have a field domain so that division is possible
and for this <a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a> has an option <code class="docutils literal notranslate"><span class="pre">field=True</span></code> which
will force the construction of a field domain even if the expressions can all
be represented in a non-field ring:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">QQ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ(x,y)</span>
</pre></div>
</div>
<p>By default <a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a> will not construct an algebraic
extension field and will instead use the <a class="reference internal" href="domainsref.html#ex"><span class="std std-ref">EX</span></a> domain
(<a class="reference internal" href="domainsref.html#sympy.polys.domains.ExpressionDomain" title="sympy.polys.domains.ExpressionDomain"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExpressionDomain</span></code></a>). The keyword argument <code class="docutils literal notranslate"><span class="pre">extension=True</span></code> can
be used to construct an <a class="reference internal" href="domainsref.html#sympy.polys.domains.AlgebraicField" title="sympy.polys.domains.AlgebraicField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgebraicField</span></code></a> if the inputs are
irrational but algebraic:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">EX</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="n">extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">QQ&lt;sqrt(2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span> <span class="n">extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">QQ&lt;sqrt(2) + sqrt(3)&gt;</span>
</pre></div>
</div>
<p>When there are algebraically independent transcendentals in the inputs a
<a class="reference internal" href="domainsref.html#sympy.polys.domains.PolynomialRing" title="sympy.polys.domains.PolynomialRing"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolynomialRing</span></code></a> or <a class="reference internal" href="domainsref.html#sympy.polys.domains.RationalField" title="sympy.polys.domains.RationalField"><code class="xref py py-class docutils literal notranslate"><span class="pre">RationalField</span></code></a> will be
constructed treating those transcendentals as generators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ[y,sin(x)]</span>
</pre></div>
</div>
<p>However if there is a possibility that the inputs are not algebraically
independent then the domain will be <a class="reference internal" href="domainsref.html#ex"><span class="std std-ref">EX</span></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">EX</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code> and <code class="docutils literal notranslate"><span class="pre">cos(x)</span></code> are not algebraically independent since
<code class="docutils literal notranslate"><span class="pre">sin(x)**2</span> <span class="pre">+</span> <span class="pre">cos(x)**2</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</section>
<section id="converting-elements-between-different-domains">
<h2>Converting elements between different domains<a class="headerlink" href="#converting-elements-between-different-domains" title="Permalink to this headline">¶</a></h2>
<p>It is often useful to combine calculations performed over different domains.
However just as it is important to avoid mixing domain elements with normal
sympy expressions and other Python types it is also important to avoid mixing
elements from different domains. The <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.convert_from" title="sympy.polys.domains.domain.Domain.convert_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">convert_from()</span></code></a> method
is used to convert elements from one domain into elements of another domain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num_zz</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">num_zz</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_qq</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">convert_from</span><span class="p">(</span><span class="n">num_zz</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">num_qq</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">of_type</span><span class="p">(</span><span class="n">num_qq</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.convert" title="sympy.polys.domains.domain.Domain.convert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">convert()</span></code></a> method can be called without specifying the
source domain as the second argument e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">2</span>
</pre></div>
</div>
<p>This works because <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.convert" title="sympy.polys.domains.domain.Domain.convert"><code class="xref py py-meth docutils literal notranslate"><span class="pre">convert()</span></code></a> can check the type of <code class="docutils literal notranslate"><span class="pre">ZZ(2)</span></code>
and can try to work out what domain (<a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a>) it is an element of. Certain
domains like <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> and <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> are treated as special cases to make this work.
Elements of more complicated domains are instances of subclasses of
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domainelement.DomainElement" title="sympy.polys.domains.domainelement.DomainElement"><code class="xref py py-class docutils literal notranslate"><span class="pre">DomainElement</span></code></a> which has a <a class="reference internal" href="domainsref.html#sympy.polys.domains.domainelement.DomainElement.parent" title="sympy.polys.domains.domainelement.DomainElement.parent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">parent()</span></code></a>
method that can identify the domain that the element belongs to. For example
in the polynomial ring <code class="docutils literal notranslate"><span class="pre">ZZ[x]</span></code> we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ZZ</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span>
<span class="go">ZZ[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">K</span><span class="o">.</span><span class="n">one</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">&lt;class &#39;sympy.polys.rings.PolyElement&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span>
<span class="go">ZZ[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span>
<span class="go">True</span>
</pre></div>
</div>
<p>It is more efficient though to call <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.convert_from" title="sympy.polys.domains.domain.Domain.convert_from"><code class="xref py py-meth docutils literal notranslate"><span class="pre">convert_from()</span></code></a> with the
source domain specified as the second argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">convert_from</span><span class="p">(</span><span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">ZZ</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</section>
<section id="unifying-domains">
<h2>Unifying domains<a class="headerlink" href="#unifying-domains" title="Permalink to this headline">¶</a></h2>
<p>When we want to combine elements from two different domains and perform mixed
calculations with them we need to</p>
<ol class="arabic simple">
<li><p>Choose a new domain that can represent all elements of both.</p></li>
<li><p>Convert all elements to the new domain.</p></li>
<li><p>Perform the calculation in the new domain.</p></li>
</ol>
<p>The key question arising from point 1. is how to choose a domain that can
represent the elements of both domains. For this there is the
<a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.unify" title="sympy.polys.domains.domain.Domain.unify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unify()</span></code></a> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span><span class="p">,</span> <span class="n">K1</span> <span class="o">=</span> <span class="n">ZZ</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">ZZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y2</span><span class="p">,</span> <span class="n">K2</span> <span class="o">=</span> <span class="n">QQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">QQ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span>
<span class="go">ZZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span>
<span class="go">QQ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span> <span class="o">=</span> <span class="n">K1</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">K2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K3</span>
<span class="go">QQ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x3</span> <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">convert_from</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">K1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y3</span> <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">convert_from</span><span class="p">(</span><span class="n">y2</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x3</span> <span class="o">+</span> <span class="n">y3</span>
<span class="go">7/2</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.unify" title="sympy.polys.domains.domain.Domain.unify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unify()</span></code></a> method will find a domain that encompasses both
domains so in this example <code class="docutils literal notranslate"><span class="pre">ZZ.unify(QQ)</span></code> gives <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a> because every element
of <a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> can be represented as an element of <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>. This means that all
inputs (<code class="docutils literal notranslate"><span class="pre">x1</span></code> and <code class="docutils literal notranslate"><span class="pre">y2</span></code>) can be converted to the elements of the common
domain <code class="docutils literal notranslate"><span class="pre">K3</span></code> (as <code class="docutils literal notranslate"><span class="pre">x3</span></code> and <code class="docutils literal notranslate"><span class="pre">y3</span></code>). Once in the common domain we can safely
use arithmetic operations like <code class="docutils literal notranslate"><span class="pre">+</span></code>. In this example one domain is a superset
of the other and we see that <code class="docutils literal notranslate"><span class="pre">K1.unify(K2)</span> <span class="pre">==</span> <span class="pre">K2</span></code> so it is not actually
necessary to convert <code class="docutils literal notranslate"><span class="pre">y2</span></code>. In general though <code class="docutils literal notranslate"><span class="pre">K1.unify(K2)</span></code> can give a new
domain that is not equal to either <code class="docutils literal notranslate"><span class="pre">K1</span></code> or <code class="docutils literal notranslate"><span class="pre">K2</span></code>.</p>
<p>The <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.unify" title="sympy.polys.domains.domain.Domain.unify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unify()</span></code></a> method understands how to combine different
polynomial ring domains and how to unify the base domain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>
<span class="go">ZZ[x,y]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>
<span class="go">ZZ[x,y]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ZZ</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">QQ</span><span class="p">)</span>
<span class="go">QQ[x]</span>
</pre></div>
</div>
<p>It is also possible to unify algebraic fields and rational function fields as
well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">algebraic_field</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))[</span><span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span> <span class="o">=</span> <span class="n">QQ</span><span class="o">.</span><span class="n">algebraic_field</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))[</span><span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span>
<span class="go">QQ&lt;sqrt(2)&gt;[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K2</span>
<span class="go">QQ&lt;sqrt(3)&gt;[y]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K1</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">K2</span><span class="p">)</span>
<span class="go">QQ&lt;sqrt(2) + sqrt(3)&gt;[x,y]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">QQ</span><span class="o">.</span><span class="n">frac_field</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">unify</span><span class="p">(</span><span class="n">ZZ</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>
<span class="go">ZZ(x,y)</span>
</pre></div>
</div>
</section>
<section id="internals-of-a-poly">
<h2>Internals of a Poly<a class="headerlink" href="#internals-of-a-poly" title="Permalink to this headline">¶</a></h2>
<p>We are now in a position to understand how the <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> class works
internally. This is the public interface of <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">ZZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y, z, t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">ZZ</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">Poly(x**2 + 1, x, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">gens</span>
<span class="go">(x,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">domain</span>
<span class="go">ZZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
<span class="go">x**2 + 1</span>
</pre></div>
</div>
<p>This is the internal implementation of <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">rep</span>  <span class="c1"># internal representation of Poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">DMP([1, 0, 1], ZZ, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">rep</span>      <span class="c1"># internal representation of DMP</span>
<span class="go">[1, 0, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">rep</span><span class="p">)</span>
<span class="go">&lt;class &#39;list&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">&lt;class &#39;int&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">dom</span>
<span class="go">ZZ</span>
</pre></div>
</div>
<p>The internal representation of a <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> instance is an instance of
<a class="reference internal" href="domainsref.html#sympy.polys.polyclasses.DMP" title="sympy.polys.polyclasses.DMP"><code class="xref py py-class docutils literal notranslate"><span class="pre">DMP</span></code></a> which is the class used for domain elements in the old
polynomial ring domain <a class="reference internal" href="domainsref.html#sympy.polys.domains.domain.Domain.old_poly_ring" title="sympy.polys.domains.domain.Domain.old_poly_ring"><code class="xref py py-meth docutils literal notranslate"><span class="pre">old_poly_ring()</span></code></a>. This represents the
polynomial as a list of coefficients which are themselves elements of a domain
and keeps a reference to their domain (<a class="reference internal" href="domainsref.html#zz"><span class="std std-ref">ZZ</span></a> in this example).</p>
</section>
<section id="choosing-a-domain-for-a-poly">
<h2>Choosing a domain for a Poly<a class="headerlink" href="#choosing-a-domain-for-a-poly" title="Permalink to this headline">¶</a></h2>
<p>If the domain is not specified for the <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> constructor then it
is inferred using <a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a>. Arguments like <code class="docutils literal notranslate"><span class="pre">field=True</span></code>
are passed along to <a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Poly(x**2 + 1, x, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Poly(x**2 + 1, x, domain=&#39;QQ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Poly(1/2*x**2 + 1, x, domain=&#39;QQ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Poly(x**2 + sqrt(2), x, domain=&#39;EX&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Poly(x**2 + sqrt(2), x, domain=&#39;QQ&lt;sqrt(2)&gt;&#39;)</span>
</pre></div>
</div>
<p>It is also possible to use the extension argument to specify generators of an
extension even if no extension is required to represent the coefficients
although this does not work when using <a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a> directly.
A list of extension elements will be passed to <a class="reference internal" href="numberfields.html#sympy.polys.numberfields.subfield.primitive_element" title="sympy.polys.numberfields.subfield.primitive_element"><code class="xref py py-func docutils literal notranslate"><span class="pre">primitive_element()</span></code></a>
to create an appropriate <a class="reference internal" href="domainsref.html#sympy.polys.domains.AlgebraicField" title="sympy.polys.domains.AlgebraicField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgebraicField</span></code></a> domain:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">construct_domain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Poly(x**2 + 1, x, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Poly(x**2 + 1, x, domain=&#39;QQ&lt;sqrt(2)&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>
<span class="go">Poly(x**2 + 1, x, domain=&#39;QQ&lt;sqrt(2) + sqrt(3)&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">construct_domain</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">extension</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">ZZ</span>
</pre></div>
</div>
<p>(Perhaps <a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a> should do the same as
<a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> here…)</p>
</section>
<section id="choosing-generators">
<h2>Choosing generators<a class="headerlink" href="#choosing-generators" title="Permalink to this headline">¶</a></h2>
<p>If there are symbols other than the generators then a polynomial ring or
rational function field domain will be created. The domain used for the
coefficients in this case is the sparse (“new”) polynomial ring:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">Poly(y*x**2 + z, x, domain=&#39;ZZ[y,z]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">gens</span>
<span class="go">(x,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">domain</span>
<span class="go">ZZ[y,z]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">ZZ</span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">poly_ring</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">ZZ</span><span class="o">.</span><span class="n">old_poly_ring</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span>
<span class="go">[y, 0, z]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;sympy.polys.rings.PolyElement&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">{(1, 0): 1}</span>
</pre></div>
</div>
<p>What we have here is a strange hybrid of dense and sparse implementations. The
<a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> instance considers itself to be an univariate polynomial in
the generator <code class="docutils literal notranslate"><span class="pre">x</span></code> but with coefficients from the domain <code class="docutils literal notranslate"><span class="pre">ZZ[y,z]</span></code>. The
internal representation of the <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> is a list of coefficients in
the “dense univariate polynomial” (DUP) format. However each coefficient is
implemented as a sparse polynomial in <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<p>If we make <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> all be generators for the <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a>
then we get a fully dense DMP list of lists of lists representation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">Poly(x**2*y + z, x, y, z, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span>
<span class="go">DMP([[[1], []], [[]], [[1, 0]]], ZZ, None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span>
<span class="go">[[[1], []], [[]], [[1, 0]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  
<span class="go">&lt;class &#39;int&#39;&gt;</span>
</pre></div>
</div>
<p>On the other hand we can make a <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> with a fully sparse
representation by choosing a generator that is not in the expression at all:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span>
<span class="go">Poly(x**2*y + z, t, domain=&#39;ZZ[x,y,z]&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span>
<span class="go">DMP([x**2*y + z], ZZ[x,y,z], None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x**2*y + z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&lt;class &#39;sympy.polys.rings.PolyElement&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dict</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">rep</span><span class="o">.</span><span class="n">rep</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">{(0, 0, 1): 1, (2, 1, 0): 1}</span>
</pre></div>
</div>
<p>If no generators are provided to the <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> constructor then it
will attempt to choose generators so that the expression is polynomial in
those. In the common case that the expression is a polynomial expression in
some symbols then those symbols will be taken as generators. However other
non-symbol expressions can also be taken as generators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="go">Poly(x**2*y + z, x, y, z, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Poly((exp(x))**2 + (exp(x)) + 1, exp(x), domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">Poly(x*pi, x, pi, domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">Poly(pi*x, x, domain=&#39;ZZ[pi]&#39;)</span>
</pre></div>
</div>
</section>
<section id="algebraically-dependent-generators">
<h2>Algebraically dependent generators<a class="headerlink" href="#algebraically-dependent-generators" title="Permalink to this headline">¶</a></h2>
<p>Taking <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code> or <code class="docutils literal notranslate"><span class="pre">pi</span></code> as generators for a <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> or for its
polynomial ring domain is mathematically valid because these objects are
transcendental and so the ring extension containing them is isomorphic to a
polynomial ring. Since <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">exp(x)</span></code> are algebraically independent it
is also valid to use both as generators for the same <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a>.
However some other combinations of generators are invalid such as <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">sqrt(x)</span></code> or <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code> and <code class="docutils literal notranslate"><span class="pre">cos(x)</span></code>. These examples are invalid  because
the generators are not algebraically independent (e.g. <code class="docutils literal notranslate"><span class="pre">sqrt(x)**2</span> <span class="pre">=</span> <span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">sin(x)**2</span> <span class="pre">+</span> <span class="pre">cos(x)**2</span> <span class="pre">=</span> <span class="pre">1</span></code>). The implementation is not able to detect these
algebraic relationships though:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>      <span class="c1"># fine</span>
<span class="go">Poly(x*(exp(x)), x, exp(x), domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># not fine</span>
<span class="go">Poly((cos(x)) + (sin(x)), cos(x), sin(x), domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>   <span class="c1"># not fine</span>
<span class="go">Poly(x + (sqrt(x)), x, sqrt(x), domain=&#39;ZZ&#39;)</span>
</pre></div>
</div>
<p>Calculations with a <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> such as this are unreliable because
zero-testing will not work properly in this implementation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p1</span>
<span class="go">Poly(x, x, sqrt(x), domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span>
<span class="go">Poly((sqrt(x)), x, sqrt(x), domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p3</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p3</span>                  <span class="c1"># should be zero...</span>
<span class="go">Poly(x - (sqrt(x))**2, x, sqrt(x), domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p3</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>This aspect of <a class="reference internal" href="reference.html#sympy.polys.polytools.Poly" title="sympy.polys.polytools.Poly"><code class="xref py py-class docutils literal notranslate"><span class="pre">Poly</span></code></a> could be improved by:</p>
<ol class="arabic simple">
<li><p>Expanding the domain system with new domains that can represent more
classes of algebraic extension.</p></li>
<li><p>Improving the detection of algebraic dependencies in
<a class="reference internal" href="reference.html#sympy.polys.constructor.construct_domain" title="sympy.polys.constructor.construct_domain"><code class="xref py py-func docutils literal notranslate"><span class="pre">construct_domain()</span></code></a>.</p></li>
<li><p>Improving the automatic selection of generators.</p></li>
</ol>
<p>Examples of the above are that it would be useful to have a domain that can
represent more general algebraic extensions (<a class="reference internal" href="domainsref.html#sympy.polys.domains.AlgebraicField" title="sympy.polys.domains.AlgebraicField"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgebraicField</span></code></a> is
only for extensions of <a class="reference internal" href="domainsref.html#qq"><span class="std std-ref">QQ</span></a>). Improving the detection of algebraic
dependencies is harder but at least common cases like <code class="docutils literal notranslate"><span class="pre">sin(x)</span></code> and
<code class="docutils literal notranslate"><span class="pre">cos(x)</span></code> could be handled. When choosing generators it should be possible to
recognise that <code class="docutils literal notranslate"><span class="pre">sqrt(x)</span></code> can be the only generator for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">sqrt(x)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>            <span class="c1"># this could be improved!</span>
<span class="go">Poly(x + (sqrt(x)), x, sqrt(x), domain=&#39;ZZ&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>   <span class="c1"># this could be improved!</span>
<span class="go">Poly((sqrt(x)) + x, sqrt(x), domain=&#39;ZZ[x]&#39;)</span>
</pre></div>
</div>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introducing the Domains of the poly module</a><ul>
<li><a class="reference internal" href="#what-are-the-domains">What are the domains?</a></li>
<li><a class="reference internal" href="#representing-expressions-symbolically">Representing expressions symbolically</a><ul>
<li><a class="reference internal" href="#tree-representation">Tree representation</a></li>
<li><a class="reference internal" href="#dup-representation">DUP representation</a></li>
<li><a class="reference internal" href="#dmp-representation">DMP representation</a></li>
<li><a class="reference internal" href="#sparse-polynomial-representation">Sparse polynomial representation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#basic-usage-of-domains">Basic usage of domains</a></li>
<li><a class="reference internal" href="#domain-elements-vs-sympy-expressions">Domain elements vs sympy expressions</a></li>
<li><a class="reference internal" href="#gaussian-integers-and-gaussian-rationals">Gaussian integers and Gaussian rationals</a></li>
<li><a class="reference internal" href="#finite-fields">Finite fields</a></li>
<li><a class="reference internal" href="#real-and-complex-fields">Real and complex fields</a></li>
<li><a class="reference internal" href="#algebraic-number-fields">Algebraic number fields</a></li>
<li><a class="reference internal" href="#polynomial-ring-domains">Polynomial ring domains</a></li>
<li><a class="reference internal" href="#old-dense-polynomial-rings">Old (dense) polynomial rings</a></li>
<li><a class="reference internal" href="#polyring-vs-polynomialring">PolyRing vs PolynomialRing</a></li>
<li><a class="reference internal" href="#rational-function-fields">Rational function fields</a></li>
<li><a class="reference internal" href="#expression-domain">Expression domain</a></li>
<li><a class="reference internal" href="#choosing-a-domain">Choosing a domain</a></li>
<li><a class="reference internal" href="#converting-elements-between-different-domains">Converting elements between different domains</a></li>
<li><a class="reference internal" href="#unifying-domains">Unifying domains</a></li>
<li><a class="reference internal" href="#internals-of-a-poly">Internals of a Poly</a></li>
<li><a class="reference internal" href="#choosing-a-domain-for-a-poly">Choosing a domain for a Poly</a></li>
<li><a class="reference internal" href="#choosing-generators">Choosing generators</a></li>
<li><a class="reference internal" href="#algebraically-dependent-generators">Algebraically dependent generators</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="agca.html"
                        title="previous chapter">AGCA - Algebraic Geometry and Commutative Algebra Module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="domainsref.html"
                        title="next chapter">Reference docs for the Poly Domains</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/polys/domainsintro.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="domainsref.html" title="Reference docs for the Poly Domains"
             >next</a> |</li>
        <li class="right" >
          <a href="agca.html" title="AGCA - Algebraic Geometry and Commutative Algebra Module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.10.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../reference/index.html" >Reference Documentation</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../reference/public/topics/index.html" >Topics</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="index.html" >Polynomial Manipulation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Introducing the Domains of the poly module</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021 SymPy Development Team.
      Last updated on Dec 10, 2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.1.
    </div>
  </body>
</html>