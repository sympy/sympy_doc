
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Represent &#8212; SymPy 1.10.dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/default.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/physics/quantum/represent.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Spin" href="spin.html" />
    <link rel="prev" title="Qapply" href="qapply.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="spin.html" title="Spin"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="qapply.html" title="Qapply"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.10.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../reference/index.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >Physics</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" accesskey="U">Quantum Mechanics</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Represent</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-sympy.physics.quantum.represent">
<span id="represent"></span><h1>Represent<a class="headerlink" href="#module-sympy.physics.quantum.represent" title="Permalink to this headline">¶</a></h1>
<p>Logic for representing operators in state in various bases.</p>
<p>TODO:</p>
<ul class="simple">
<li><p>Get represent working with continuous hilbert spaces.</p></li>
<li><p>Document default basis functionality.</p></li>
</ul>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.physics.quantum.represent.enumerate_states">
<span class="sig-prename descclassname"><span class="pre">sympy.physics.quantum.represent.</span></span><span class="sig-name descname"><span class="pre">enumerate_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/physics/quantum/represent.py#L510-L565"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.physics.quantum.represent.enumerate_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns instances of the given state with dummy indices appended</p>
<p>Operates in two different modes:</p>
<ol class="arabic simple">
<li><p>Two arguments are passed to it. The first is the base state which is to
be indexed, and the second argument is a list of indices to append.</p></li>
<li><p>Three arguments are passed. The first is again the base state to be
indexed. The second is the start index for counting.  The final argument
is the number of kets you wish to receive.</p></li>
</ol>
<p>Tries to call state._enumerate_state. If this fails, returns an empty list</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> : list</p>
<blockquote>
<div><p>See list of operation modes above for explanation</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.cartesian</span> <span class="kn">import</span> <span class="n">XBra</span><span class="p">,</span> <span class="n">XKet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.represent</span> <span class="kn">import</span> <span class="n">enumerate_states</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test</span> <span class="o">=</span> <span class="n">XKet</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enumerate_states</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[|foo_1&gt;, |foo_2&gt;, |foo_3&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test2</span> <span class="o">=</span> <span class="n">XBra</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enumerate_states</span><span class="p">(</span><span class="n">test2</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="go">[&lt;bar_4|, &lt;bar_5|, &lt;bar_10|]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.physics.quantum.represent.get_basis">
<span class="sig-prename descclassname"><span class="pre">sympy.physics.quantum.represent.</span></span><span class="sig-name descname"><span class="pre">get_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace_none</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/physics/quantum/represent.py#L417-L495"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.physics.quantum.represent.get_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a basis state instance corresponding to the basis specified in
options=s. If no basis is specified, the function tries to form a default
basis state of the given expression.</p>
<p>There are three behaviors:</p>
<ol class="arabic simple">
<li><p>The basis specified in options is already an instance of StateBase. If
this is the case, it is simply returned. If the class is specified but
not an instance, a default instance is returned.</p></li>
<li><p>The basis specified is an operator or set of operators. If this
is the case, the operator_to_state mapping method is used.</p></li>
<li><p>No basis is specified. If expr is a state, then a default instance of
its class is returned.  If expr is an operator, then it is mapped to the
corresponding state.  If it is neither, then we cannot obtain the basis
state.</p></li>
</ol>
<p>If the basis cannot be mapped, then it is not changed.</p>
<p>This will be called from within represent, and represent will
only pass QExpr’s.</p>
<p>TODO (?): Support for Muls and other types of expressions?</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> : Operator or StateBase</p>
<blockquote>
<div><p>Expression whose basis is sought</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.represent</span> <span class="kn">import</span> <span class="n">get_basis</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.cartesian</span> <span class="kn">import</span> <span class="n">XOp</span><span class="p">,</span> <span class="n">XKet</span><span class="p">,</span> <span class="n">PxOp</span><span class="p">,</span> <span class="n">PxKet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">XKet</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">XOp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_basis</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">|x&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_basis</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">|x&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_basis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">PxOp</span><span class="p">())</span>
<span class="go">|px&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_basis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">PxKet</span><span class="p">)</span>
<span class="go">|px&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.physics.quantum.represent.integrate_result">
<span class="sig-prename descclassname"><span class="pre">sympy.physics.quantum.represent.</span></span><span class="sig-name descname"><span class="pre">integrate_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orig_expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/physics/quantum/represent.py#L342-L414"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.physics.quantum.represent.integrate_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of integrating over any unities <code class="docutils literal notranslate"><span class="pre">(|x&gt;&lt;x|)</span></code> in
the given expression. Intended for integrating over the result of
representations in continuous bases.</p>
<p>This function integrates over any unities that may have been
inserted into the quantum expression and returns the result.
It uses the interval of the Hilbert space of the basis state
passed to it in order to figure out the limits of integration.
The unities option must be
specified for this to work.</p>
<p>Note: This is mostly used internally by represent(). Examples are
given merely to show the use cases.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>orig_expr</strong> : quantum expression</p>
<blockquote>
<div><p>The original expression which was to be represented</p>
</div></blockquote>
<p><strong>result: Expr</strong></p>
<blockquote>
<div><p>The resulting representation that we wish to integrate over</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">DiracDelta</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.represent</span> <span class="kn">import</span> <span class="n">integrate_result</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.cartesian</span> <span class="kn">import</span> <span class="n">XOp</span><span class="p">,</span> <span class="n">XKet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_ket</span> <span class="o">=</span> <span class="n">XKet</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_op</span> <span class="o">=</span> <span class="n">XOp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">x_1</span><span class="p">,</span> <span class="n">x_2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, x_1, x_2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate_result</span><span class="p">(</span><span class="n">X_op</span><span class="o">*</span><span class="n">x_ket</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">DiracDelta</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_1</span><span class="p">)</span><span class="o">*</span><span class="n">DiracDelta</span><span class="p">(</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_2</span><span class="p">))</span>
<span class="go">x*DiracDelta(x - x_1)*DiracDelta(x_1 - x_2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate_result</span><span class="p">(</span><span class="n">X_op</span><span class="o">*</span><span class="n">x_ket</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">DiracDelta</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x_1</span><span class="p">)</span><span class="o">*</span><span class="n">DiracDelta</span><span class="p">(</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_2</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">unities</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">x*DiracDelta(x - x_2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.physics.quantum.represent.rep_expectation">
<span class="sig-prename descclassname"><span class="pre">sympy.physics.quantum.represent.</span></span><span class="sig-name descname"><span class="pre">rep_expectation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/physics/quantum/represent.py#L299-L339"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.physics.quantum.represent.rep_expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an <code class="docutils literal notranslate"><span class="pre">&lt;x'|A|x&gt;</span></code> type representation for the given operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> : Operator</p>
<blockquote>
<div><p>Operator to be represented in the specified basis</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.cartesian</span> <span class="kn">import</span> <span class="n">XOp</span><span class="p">,</span> <span class="n">PxOp</span><span class="p">,</span> <span class="n">PxKet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.represent</span> <span class="kn">import</span> <span class="n">rep_expectation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rep_expectation</span><span class="p">(</span><span class="n">XOp</span><span class="p">())</span>
<span class="go">x_1*DiracDelta(x_1 - x_2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rep_expectation</span><span class="p">(</span><span class="n">XOp</span><span class="p">(),</span> <span class="n">basis</span><span class="o">=</span><span class="n">PxOp</span><span class="p">())</span>
<span class="go">&lt;px_2|*X*|px_1&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rep_expectation</span><span class="p">(</span><span class="n">XOp</span><span class="p">(),</span> <span class="n">basis</span><span class="o">=</span><span class="n">PxKet</span><span class="p">())</span>
<span class="go">&lt;px_2|*X*|px_1&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.physics.quantum.represent.rep_innerproduct">
<span class="sig-prename descclassname"><span class="pre">sympy.physics.quantum.represent.</span></span><span class="sig-name descname"><span class="pre">rep_innerproduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/physics/quantum/represent.py#L243-L296"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.physics.quantum.represent.rep_innerproduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an innerproduct like representation (e.g. <code class="docutils literal notranslate"><span class="pre">&lt;x'|x&gt;</span></code>) for the
given state.</p>
<p>Attempts to calculate inner product with a bra from the specified
basis. Should only be passed an instance of KetBase or BraBase</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> : KetBase or BraBase</p>
<blockquote>
<div><p>The expression to be represented</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.represent</span> <span class="kn">import</span> <span class="n">rep_innerproduct</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.cartesian</span> <span class="kn">import</span> <span class="n">XOp</span><span class="p">,</span> <span class="n">XKet</span><span class="p">,</span> <span class="n">PxOp</span><span class="p">,</span> <span class="n">PxKet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rep_innerproduct</span><span class="p">(</span><span class="n">XKet</span><span class="p">())</span>
<span class="go">DiracDelta(x - x_1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rep_innerproduct</span><span class="p">(</span><span class="n">XKet</span><span class="p">(),</span> <span class="n">basis</span><span class="o">=</span><span class="n">PxOp</span><span class="p">())</span>
<span class="go">sqrt(2)*exp(-I*px_1*x/hbar)/(2*sqrt(hbar)*sqrt(pi))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rep_innerproduct</span><span class="p">(</span><span class="n">PxKet</span><span class="p">(),</span> <span class="n">basis</span><span class="o">=</span><span class="n">XOp</span><span class="p">())</span>
<span class="go">sqrt(2)*exp(I*px*x_1/hbar)/(2*sqrt(hbar)*sqrt(pi))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.physics.quantum.represent.represent">
<span class="sig-prename descclassname"><span class="pre">sympy.physics.quantum.represent.</span></span><span class="sig-name descname"><span class="pre">represent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/physics/quantum/represent.py#L55-L240"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.physics.quantum.represent.represent" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the quantum expression in the given basis.</p>
<p>In quantum mechanics abstract states and operators can be represented in
various basis sets. Under this operation the follow transforms happen:</p>
<ul class="simple">
<li><p>Ket -&gt; column vector or function</p></li>
<li><p>Bra -&gt; row vector of function</p></li>
<li><p>Operator -&gt; matrix or differential operator</p></li>
</ul>
<p>This function is the top-level interface for this action.</p>
<p>This function walks the SymPy expression tree looking for <code class="docutils literal notranslate"><span class="pre">QExpr</span></code>
instances that have a <code class="docutils literal notranslate"><span class="pre">_represent</span></code> method. This method is then called
and the object is replaced by the representation returned by this method.
By default, the <code class="docutils literal notranslate"><span class="pre">_represent</span></code> method will dispatch to other methods
that handle the representation logic for a particular basis set. The
naming convention for these methods is the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">_represent_FooBasis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
</pre></div>
</div>
<p>This function will have the logic for representing instances of its class
in the basis set having a class named <code class="docutils literal notranslate"><span class="pre">FooBasis</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> : Expr</p>
<blockquote>
<div><p>The expression to represent.</p>
</div></blockquote>
<p><strong>basis</strong> : Operator, basis set</p>
<blockquote>
<div><p>An object that contains the information about the basis set. If an
operator is used, the basis is assumed to be the orthonormal
eigenvectors of that operator. In general though, the basis argument
can be any object that contains the basis set information.</p>
</div></blockquote>
<p><strong>options</strong> : dict</p>
<blockquote>
<div><p>Key/value pairs of options that are passed to the underlying method
that finds the representation. These options can be used to
control how the representation is done. For example, this is where
the size of the basis set would be set.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>e</strong> : Expr</p>
<blockquote>
<div><p>The SymPy expression of the represented quantum expression.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Here we subclass <code class="docutils literal notranslate"><span class="pre">Operator</span></code> and <code class="docutils literal notranslate"><span class="pre">Ket</span></code> to create the z-spin operator
and its spin 1/2 up eigenstate. By defining the <code class="docutils literal notranslate"><span class="pre">_represent_SzOp</span></code>
method, the ket can be represented in the z-spin basis.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum</span> <span class="kn">import</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">represent</span><span class="p">,</span> <span class="n">Ket</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">SzUpKet</span><span class="p">(</span><span class="n">Ket</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_represent_SzOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">SzOp</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span> <span class="o">=</span> <span class="n">SzOp</span><span class="p">(</span><span class="s1">&#39;Sz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">up</span> <span class="o">=</span> <span class="n">SzUpKet</span><span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">represent</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">sz</span><span class="p">)</span>
<span class="go">Matrix([</span>
<span class="go">[1],</span>
<span class="go">[0]])</span>
</pre></div>
</div>
<p>Here we see an example of representations in a continuous
basis. We see that the result of representing various combinations
of cartesian position operators and kets give us continuous
expressions involving DiracDelta functions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.quantum.cartesian</span> <span class="kn">import</span> <span class="n">XOp</span><span class="p">,</span> <span class="n">XKet</span><span class="p">,</span> <span class="n">XBra</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">XOp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">XKet</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">XBra</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">represent</span><span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="go">x*DiracDelta(x - x_2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">represent</span><span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="go">x*DiracDelta(x - x_3)*DiracDelta(x_1 - y)</span>
</pre></div>
</div>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="qapply.html"
                        title="previous chapter">Qapply</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="spin.html"
                        title="next chapter">Spin</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/physics/quantum/represent.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="spin.html" title="Spin"
             >next</a> |</li>
        <li class="right" >
          <a href="qapply.html" title="Qapply"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.10.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../reference/index.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >Physics</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" >Quantum Mechanics</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Represent</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021 SymPy Development Team.
      Last updated on Nov 09, 2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>