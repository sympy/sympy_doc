
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scalar and Vector Field Functionality &#8212; SymPy 1.7.dev documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/physics/vector/fields.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Essential Classes" href="api/classes.html" />
    <link rel="prev" title="Potential Issues/Advanced Topics/Future Features in Physics/Vector Module" href="advanced.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api/classes.html" title="Essential Classes"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Potential Issues/Advanced Topics/Future Features in Physics/Vector Module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" >Physics</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="index.html" accesskey="U">The Physics Vector Module</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Scalar and Vector Field Functionality</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="scalar-and-vector-field-functionality">
<h1>Scalar and Vector Field Functionality<a class="headerlink" href="#scalar-and-vector-field-functionality" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="vectors-and-scalars">
<h3>Vectors and Scalars<a class="headerlink" href="#vectors-and-scalars" title="Permalink to this headline">¶</a></h3>
<p>In physics, we deal with two kinds of quantities – scalars and vectors.</p>
<p>A scalar is an entity which only has a magnitude – no direction. Examples of
scalar quantities include mass, electric charge, temperature, distance, etc.</p>
<p>A vector, on the other hand, is an entity that is characterized by a
magnitude and a direction. Examples of vector quantities are displacement,
velocity, magnetic field, etc.</p>
<p>A scalar can be depicted just by a number, for e.g. a temperature of 300 K.
On the other hand, vectorial quantities like acceleration are usually denoted
by a vector. Given a vector <span class="math notranslate nohighlight">\(\mathbf{V}\)</span>, the magnitude of the
corresponding quantity can be calculated as the magnitude of the vector
itself <span class="math notranslate nohighlight">\(\Vert \mathbf{V} \Vert\)</span>, while the direction would be specified
by a unit vector in the direction of the original vector,
<span class="math notranslate nohighlight">\(\mathbf{\hat{V}} = \frac{\mathbf{V}}{\Vert \mathbf{V} \Vert}\)</span>.</p>
<p>For example, consider a displacement of
<span class="math notranslate nohighlight">\((3\mathbf{\hat{i}} + 4\mathbf{\hat{j}} + 5\mathbf{\hat{k}})\)</span> m,
where , as per standard convention, <span class="math notranslate nohighlight">\(\mathbf{\hat{i}}\)</span>,
<span class="math notranslate nohighlight">\(\mathbf{\hat{j}}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{\hat{k}}\)</span> represent unit vectors
in the <span class="math notranslate nohighlight">\(\mathbf{X}\)</span>, <span class="math notranslate nohighlight">\(\mathbf{Y}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>
directions respectively. Therefore, it can be concluded that the distance
traveled is
<span class="math notranslate nohighlight">\(\Vert 3\mathbf{\hat{i}} + 4\mathbf{\hat{j}} + 5\mathbf{\hat{k}} \Vert\)</span>
m = <span class="math notranslate nohighlight">\(5\sqrt{2}\)</span> m. The direction of travel is given by the unit vector
<span class="math notranslate nohighlight">\(\frac{3}{5\sqrt{2}}\mathbf{\hat{i}} +
\frac{4}{5\sqrt{2}}\mathbf{\hat{j}} + \frac{5}{5\sqrt{2}}\mathbf{\hat{k}}\)</span>.</p>
</div>
<div class="section" id="fields">
<h3>Fields<a class="headerlink" href="#fields" title="Permalink to this headline">¶</a></h3>
<p>In general, a <span class="math notranslate nohighlight">\(field\)</span> is a vector or scalar quantity that can be
specified everywhere in space as a function of position (Note that in general
a field may also be dependent on time and other custom variables). In this
module, we deal with 3-dimensional spaces only. Hence, a field is defined as
a function of the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> coordinates corresponding
to a location in 3D space.</p>
<p>For example, temperate in 3 dimensional space (a temperature field) can be
written as <span class="math notranslate nohighlight">\(T(x, y, z)\)</span> – a scalar function of the position.
An example of a scalar field in electromagnetism is the electric potential.</p>
<p>In a similar manner, a vector field can be defined as a vectorial function
of the location <span class="math notranslate nohighlight">\((x, y, z)\)</span> of any point in space.</p>
<p>For instance, every point on the earth may be considered to be in the
gravitational force field of the earth. We may specify the field by the
magnitude and the direction of acceleration due to gravity
(i.e. force per unit mass ) <span class="math notranslate nohighlight">\(g(x, y, z)\)</span> at every point in space.</p>
<p>To give an example from electromagnetism, consider an electric potential
of form <span class="math notranslate nohighlight">\(2{x}^{2}y\)</span>, a scalar field in 3D space. The corresponding
conservative electric field can be computed as the gradient of the electric
potential function, and expressed as <span class="math notranslate nohighlight">\(4xy\mathbf{\hat{i}} +
2{x}^{2}\mathbf{\hat{j}}\)</span>.
The magnitude of this electric field can in turn be expressed
as a scalar field of the form
<span class="math notranslate nohighlight">\(\sqrt{4{x}^{4} + 16{x}^{2}{y}^{2}}\)</span>.</p>
</div>
</div>
<div class="section" id="implementation-of-fields-in-sympy-physics-vector">
<h2>Implementation of fields in sympy.physics.vector<a class="headerlink" href="#implementation-of-fields-in-sympy-physics-vector" title="Permalink to this headline">¶</a></h2>
<p>In <a class="reference internal" href="index.html#module-sympy.physics.vector" title="sympy.physics.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.physics.vector</span></code></a>, every <a class="reference internal" href="api/classes.html#sympy.physics.vector.frame.ReferenceFrame" title="sympy.physics.vector.frame.ReferenceFrame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceFrame</span></code></a> instance is
assigned basis vectors corresponding to the <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>
directions. These can be accessed using the attributes named <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> and
<code class="docutils literal notranslate"><span class="pre">z</span></code> respectively. Hence, to define a vector <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> of the form
<span class="math notranslate nohighlight">\(3\mathbf{\hat{i}} + 4\mathbf{\hat{j}} + 5\mathbf{\hat{k}}\)</span> with respect
to a given frame <span class="math notranslate nohighlight">\(\mathbf{R}\)</span>, you would do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span>
</pre></div>
</div>
<p>Vector math and basic calculus operations with respect to vectors have
already been elaborated upon in other sections of this module’s
documentation.</p>
<p>On the other hand, base scalars (or coordinate variables) are implemented
as special SymPy <a class="reference internal" href="../../core.html#sympy.core.symbol.Symbol" title="sympy.core.symbol.Symbol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Symbol</span></code></a>s assigned to every frame, one for each
direction from <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>. For a frame
<code class="docutils literal notranslate"><span class="pre">R</span></code>, the <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>
base scalar <a class="reference internal" href="../../core.html#sympy.core.symbol.Symbol" title="sympy.core.symbol.Symbol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Symbol</span></code></a>s can be accessed using the <code class="docutils literal notranslate"><span class="pre">R[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">R[1]</span></code>
and <code class="docutils literal notranslate"><span class="pre">R[2]</span></code> expressions respectively.</p>
<p>Therefore, to generate the expression for the aforementioned electric
potential field <span class="math notranslate nohighlight">\(2{x}^{2}y\)</span>, you would have to do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span>
<span class="go">2*R_x**2*R_y</span>
</pre></div>
</div>
<p>In string representation, <code class="docutils literal notranslate"><span class="pre">R_x</span></code> denotes the <span class="math notranslate nohighlight">\(X\)</span> base
scalar assigned to <a class="reference internal" href="api/classes.html#sympy.physics.vector.frame.ReferenceFrame" title="sympy.physics.vector.frame.ReferenceFrame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceFrame</span></code></a> <code class="docutils literal notranslate"><span class="pre">R</span></code>. Essentially, <code class="docutils literal notranslate"><span class="pre">R_x</span></code> is
the string representation of <code class="docutils literal notranslate"><span class="pre">R[0]</span></code>.</p>
<p>Scalar fields can be treated just as any other SymPy expression, for any
math/calculus functionality. Hence, to differentiate the above electric
potential with respect to <span class="math notranslate nohighlight">\(x\)</span> (i.e. <code class="docutils literal notranslate"><span class="pre">R[0]</span></code>), you would have to use the
<a class="reference internal" href="../../core.html#sympy.core.function.diff" title="sympy.core.function.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a> function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">4*R_x*R_y</span>
</pre></div>
</div>
<p>Like vectors (and vector fields), scalar fields can also be re-expressed in
other frames of reference, apart from the one they were defined in – assuming
that an orientation relationship exists between the concerned frames. This can
be done using the <a class="reference internal" href="api/classes.html#sympy.physics.vector.vector.Vector.express" title="sympy.physics.vector.vector.Vector.express"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.physics.vector.vector.Vector.express</span></code></a> method, in a way
similar to vectors - but with the <code class="docutils literal notranslate"><span class="pre">variables</span></code> parameter set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">dynamicsymbols</span><span class="p">,</span> <span class="n">express</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">dynamicsymbols</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">orientnew</span><span class="p">(</span><span class="s1">&#39;R1&#39;</span><span class="p">,</span> <span class="n">rot_type</span> <span class="o">=</span> <span class="s1">&#39;Axis&#39;</span><span class="p">,</span> <span class="n">amounts</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">express</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">2*(R1_x*sin(q(t)) + R1_y*cos(q(t)))*(R1_x*cos(q(t)) - R1_y*sin(q(t)))**2</span>
</pre></div>
</div>
<p>Moreover, considering scalars can also be functions of time just as vectors,
differentiation with respect to time is also possible. Depending on the
<a class="reference internal" href="../../core.html#sympy.core.symbol.Symbol" title="sympy.core.symbol.Symbol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Symbol</span></code></a>s present in the expression and the frame
with respect to which the time differentiation is being done, the output will
change/remain the same.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">electric_potential</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="n">dynamicsymbols</span><span class="p">(</span><span class="s1">&#39;q&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R1</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">orientnew</span><span class="p">(</span><span class="s1">&#39;R1&#39;</span><span class="p">,</span> <span class="n">rot_type</span> <span class="o">=</span> <span class="s1">&#39;Axis&#39;</span><span class="p">,</span> <span class="n">amounts</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="p">,</span> <span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">time_derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time_derivative</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time_derivative</span><span class="p">(</span><span class="n">electric_potential</span><span class="p">,</span> <span class="n">R1</span><span class="p">)</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
<span class="go">2*(R1_x*cos(q(t)) - R1_y*sin(q(t)))*(3*R1_x**2*cos(2*q(t))/2 -</span>
<span class="go">R1_x**2/2 - 3*R1_x*R1_y*sin(2*q(t)) - 3*R1_y**2*cos(2*q(t))/2 -</span>
<span class="go">R1_y**2/2)*Derivative(q(t), t)</span>
</pre></div>
</div>
</div>
<div class="section" id="field-operators-and-other-related-functions">
<h2>Field operators and other related functions<a class="headerlink" href="#field-operators-and-other-related-functions" title="Permalink to this headline">¶</a></h2>
<p>Here we describe some basic field-related functionality implemented in
sympy.physics.vector</p>
<div class="section" id="curl">
<h3>Curl<a class="headerlink" href="#curl" title="Permalink to this headline">¶</a></h3>
<p>A curl is a mathematical operator that describes an infinitesimal rotation of a
vector in 3D space. The direction is determined by the right-hand rule (along the
axis of rotation), and the magnitude is given by the magnitude of rotation.</p>
<p>In the 3D Cartesian system, the curl of a 3D vector <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> ,
denoted by <span class="math notranslate nohighlight">\(\nabla \times \mathbf{F}\)</span> is given by -</p>
<p><span class="math notranslate nohighlight">\(\nabla \times \mathbf{F} = \left(\frac{\partial F_z}{\partial y}  -
\frac{\partial F_y}{\partial z}\right) \mathbf{\hat{i}} +
\left(\frac{\partial F_x}{\partial z} -
\frac{\partial F_z}{\partial x}\right) \mathbf{\hat{j}} +
\left(\frac{\partial F_y}{\partial x} -
\frac{\partial F_x}{\partial y}\right) \mathbf{\hat{k}}\)</span></p>
<p>where <span class="math notranslate nohighlight">\(F_x\)</span> denotes the <span class="math notranslate nohighlight">\(X\)</span> component of vector <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>.</p>
<p>To compute the curl of a vector field in <a class="reference internal" href="index.html#module-sympy.physics.vector" title="sympy.physics.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.physics.vector</span></code></a>, you would do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">curl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curl</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">R_x*R_y*R.y - R_x*R_z*R.z</span>
</pre></div>
</div>
</div>
<div class="section" id="divergence">
<h3>Divergence<a class="headerlink" href="#divergence" title="Permalink to this headline">¶</a></h3>
<p>Divergence is a vector operator that measures the magnitude of a vector field’s
source or sink at a given point, in terms of a signed scalar.</p>
<p>The divergence operator always returns a scalar after operating on a vector.</p>
<p>In the 3D Cartesian system, the divergence of a 3D vector <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>,
denoted by <span class="math notranslate nohighlight">\(\nabla\cdot\mathbf{F}\)</span> is given by -</p>
<p><span class="math notranslate nohighlight">\(\nabla\cdot\mathbf{F} =\frac{\partial U}{\partial x}
+\frac{\partial V}{\partial y}
+\frac{\partial W}{\partial z
}\)</span></p>
<p>where <span class="math notranslate nohighlight">\(U\)</span>, <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(W\)</span> denote the <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and
<span class="math notranslate nohighlight">\(Z\)</span> components of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> respectively.</p>
<p>To compute the divergence of a vector field in <a class="reference internal" href="index.html#module-sympy.physics.vector" title="sympy.physics.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.physics.vector</span></code></a>, you
would do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">divergence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">x</span><span class="o">+</span><span class="n">R</span><span class="o">.</span><span class="n">y</span><span class="o">+</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">R_x*R_y + R_x*R_z + R_y*R_z</span>
</pre></div>
</div>
</div>
<div class="section" id="gradient">
<h3>Gradient<a class="headerlink" href="#gradient" title="Permalink to this headline">¶</a></h3>
<p>Consider a scalar field <span class="math notranslate nohighlight">\(f(x, y, z)\)</span> in 3D space. The gradient of this field
is defined as the vector of the 3 partial derivatives of <span class="math notranslate nohighlight">\(f\)</span> with respect to
<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> in the <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> and <span class="math notranslate nohighlight">\(Z\)</span>
directions respectively.</p>
<p>In the 3D Cartesian system, the gradient of a scalar field <span class="math notranslate nohighlight">\(f\)</span>,
denoted by <span class="math notranslate nohighlight">\(\nabla f\)</span> is given by -</p>
<p><span class="math notranslate nohighlight">\(\nabla f = \frac{\partial f}{\partial x} \mathbf{\hat{i}} +
\frac{\partial f}{\partial y}  \mathbf{\hat{j}} +
\frac{\partial f}{\partial z} \mathbf{\hat{k}}\)</span></p>
<p>To compute the gradient of a scalar field in <a class="reference internal" href="index.html#module-sympy.physics.vector" title="sympy.physics.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.physics.vector</span></code></a>, you
would do</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">gradient</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gradient</span><span class="p">(</span><span class="n">scalar_field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">R_y*R_z*R.x + R_x*R_z*R.y + R_x*R_y*R.z</span>
</pre></div>
</div>
</div>
<div class="section" id="conservative-and-solenoidal-fields">
<h3>Conservative and Solenoidal fields<a class="headerlink" href="#conservative-and-solenoidal-fields" title="Permalink to this headline">¶</a></h3>
<p>In vector calculus, a conservative field is a field that is the gradient of
some scalar field. Conservative fields have the property that their line
integral over any path depends only on the end-points, and is independent
of the path between them.
A conservative vector field is also said to be ‘irrotational’, since the
curl of a conservative field is always zero.</p>
<p>In physics, conservative fields represent forces in physical systems where
energy is conserved.</p>
<p>To check if a vector field is conservative in <a class="reference internal" href="index.html#module-sympy.physics.vector" title="sympy.physics.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.physics.vector</span></code></a>, use
the <a class="reference internal" href="api/fieldfunctions.html#sympy.physics.vector.fieldfunctions.is_conservative" title="sympy.physics.vector.fieldfunctions.is_conservative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.physics.vector.fieldfunctions.is_conservative</span></code></a> function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">is_conservative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_conservative</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">curl</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>A solenoidal field, on the other hand, is a vector field whose divergence
is zero at all points in space.</p>
<p>To check if a vector field is solenoidal in <a class="reference internal" href="index.html#module-sympy.physics.vector" title="sympy.physics.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.physics.vector</span></code></a>, use
the <a class="reference internal" href="api/fieldfunctions.html#sympy.physics.vector.fieldfunctions.is_solenoidal" title="sympy.physics.vector.fieldfunctions.is_solenoidal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.physics.vector.fieldfunctions.is_solenoidal</span></code></a> function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">is_solenoidal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_solenoidal</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">divergence</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</div>
<div class="section" id="scalar-potential-functions">
<h3>Scalar potential functions<a class="headerlink" href="#scalar-potential-functions" title="Permalink to this headline">¶</a></h3>
<p>We have previously mentioned that every conservative field can be defined as
the gradient of some scalar field. This scalar field is also called the ‘scalar
potential field’ corresponding to the aforementioned conservative field.</p>
<p>The <a class="reference internal" href="api/fieldfunctions.html#sympy.physics.vector.fieldfunctions.scalar_potential" title="sympy.physics.vector.fieldfunctions.scalar_potential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.physics.vector.fieldfunctions.scalar_potential</span></code></a> function in
<a class="reference internal" href="index.html#module-sympy.physics.vector" title="sympy.physics.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.physics.vector</span></code></a> calculates the scalar potential field
corresponding to a given conservative vector field in 3D space - minus the
extra constant of integration, of course.</p>
<p>Example of usage -</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">scalar_potential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conservative_field</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_potential</span><span class="p">(</span><span class="n">conservative_field</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">2*R_x**2*R_y*R_z</span>
</pre></div>
</div>
<p>Providing a non-conservative vector field as an argument to
<a class="reference internal" href="api/fieldfunctions.html#sympy.physics.vector.fieldfunctions.scalar_potential" title="sympy.physics.vector.fieldfunctions.scalar_potential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.physics.vector.fieldfunctions.scalar_potential</span></code></a> raises a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<p>The scalar potential difference, or simply ‘potential difference’,
corresponding to a conservative vector field can be defined as the difference
between the values of its scalar potential function at two points in space.
This is useful in calculating a line integral with respect to a conservative
function, since it depends only on the endpoints of the path.</p>
<p>This computation is performed as follows in <a class="reference internal" href="index.html#module-sympy.physics.vector" title="sympy.physics.vector"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.physics.vector</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">ReferenceFrame</span><span class="p">,</span> <span class="n">Point</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.physics.vector</span> <span class="kn">import</span> <span class="n">scalar_potential_difference</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">ReferenceFrame</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">O</span><span class="o">.</span><span class="n">locatenew</span><span class="p">(</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vectfield</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scalar_potential_difference</span><span class="p">(</span><span class="n">vectfield</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">O</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
<p>If provided with a scalar expression instead of a vector field,
<a class="reference internal" href="api/fieldfunctions.html#sympy.physics.vector.fieldfunctions.scalar_potential_difference" title="sympy.physics.vector.fieldfunctions.scalar_potential_difference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.physics.vector.fieldfunctions.scalar_potential_difference</span></code></a> returns
the difference between the values of that scalar field at the two given points
in space.</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Scalar and Vector Field Functionality</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#vectors-and-scalars">Vectors and Scalars</a></li>
<li><a class="reference internal" href="#fields">Fields</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-fields-in-sympy-physics-vector">Implementation of fields in sympy.physics.vector</a></li>
<li><a class="reference internal" href="#field-operators-and-other-related-functions">Field operators and other related functions</a><ul>
<li><a class="reference internal" href="#curl">Curl</a></li>
<li><a class="reference internal" href="#divergence">Divergence</a></li>
<li><a class="reference internal" href="#gradient">Gradient</a></li>
<li><a class="reference internal" href="#conservative-and-solenoidal-fields">Conservative and Solenoidal fields</a></li>
<li><a class="reference internal" href="#scalar-potential-functions">Scalar potential functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="advanced.html"
                        title="previous chapter">Potential Issues/Advanced Topics/Future Features in Physics/Vector Module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api/classes.html"
                        title="next chapter">Essential Classes</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/modules/physics/vector/fields.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api/classes.html" title="Essential Classes"
             >next</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Potential Issues/Advanced Topics/Future Features in Physics/Vector Module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" >Physics</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="index.html" >The Physics Vector Module</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Scalar and Vector Field Functionality</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 SymPy Development Team.
      Last updated on Oct 01, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>