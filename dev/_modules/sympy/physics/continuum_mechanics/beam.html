
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sympy.physics.continuum_mechanics.beam &#8212; SymPy 1.4.dev documentation</title>
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    
    <link rel="shortcut icon" href="../../../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/_modules/sympy/physics/continuum_mechanics/beam.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SymPy 1.4.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.physics.continuum_mechanics.beam</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module can be used to solve 2D beam bending problems with</span>
<span class="sd">singularity functions in mechanics.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="k">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="k">import</span> <span class="n">linsolve</span>
<span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="k">import</span> <span class="n">sstr</span>
<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="k">import</span> <span class="n">SingularityFunction</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">,</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="k">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">sympy.integrals</span> <span class="k">import</span> <span class="n">integrate</span>
<span class="kn">from</span> <span class="nn">sympy.series</span> <span class="k">import</span> <span class="n">limit</span>
<span class="kn">from</span> <span class="nn">sympy.plotting</span> <span class="k">import</span> <span class="n">plot</span>
<span class="kn">from</span> <span class="nn">sympy.external</span> <span class="k">import</span> <span class="n">import_module</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.decorator</span> <span class="k">import</span> <span class="n">doctest_depends_on</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">lambdify</span>

<span class="n">matplotlib</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;matplotlib&#39;</span><span class="p">,</span> <span class="n">__import__kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fromlist&#39;</span><span class="p">:[</span><span class="s1">&#39;pyplot&#39;</span><span class="p">]})</span>
<span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">__import__kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fromlist&#39;</span><span class="p">:[</span><span class="s1">&#39;linspace&#39;</span><span class="p">]})</span>


<span class="n">__doctest_requires__</span> <span class="o">=</span> <span class="p">{(</span><span class="s1">&#39;Beam.plot_loading_results&#39;</span><span class="p">,):</span> <span class="p">[</span><span class="s1">&#39;matplotlib&#39;</span><span class="p">]}</span>


<div class="viewcode-block" id="Beam"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam">[docs]</a><span class="k">class</span> <span class="nc">Beam</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Beam is a structural element that is capable of withstanding load</span>
<span class="sd">    primarily by resisting against bending. Beams are characterized by</span>
<span class="sd">    their cross sectional profile(Second moment of area), their length</span>
<span class="sd">    and their material.</span>

<span class="sd">    .. note::</span>
<span class="sd">       While solving a beam bending problem, a user should choose its</span>
<span class="sd">       own sign convention and should stick to it. The results will</span>
<span class="sd">       automatically follow the chosen sign convention.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    There is a beam of length 4 meters. A constant distributed load of 6 N/m</span>
<span class="sd">    is applied from half of the beam till the end. There are two simple supports</span>
<span class="sd">    below the beam, one at the starting point and another at the ending point</span>
<span class="sd">    of the beam. The deflection of the beam at the end is restricted.</span>

<span class="sd">    Using the sign convention of downwards forces being positive.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Piecewise</span>
<span class="sd">    &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">    &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; b = Beam(4, E, I)</span>
<span class="sd">    &gt;&gt;&gt; b.apply_load(R1, 0, -1)</span>
<span class="sd">    &gt;&gt;&gt; b.apply_load(6, 2, 0)</span>
<span class="sd">    &gt;&gt;&gt; b.apply_load(R2, 4, -1)</span>
<span class="sd">    &gt;&gt;&gt; b.bc_deflection = [(0, 0), (4, 0)]</span>
<span class="sd">    &gt;&gt;&gt; b.boundary_conditions</span>
<span class="sd">    {&#39;deflection&#39;: [(0, 0), (4, 0)], &#39;slope&#39;: []}</span>
<span class="sd">    &gt;&gt;&gt; b.load</span>
<span class="sd">    R1*SingularityFunction(x, 0, -1) + R2*SingularityFunction(x, 4, -1) + 6*SingularityFunction(x, 2, 0)</span>
<span class="sd">    &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">    &gt;&gt;&gt; b.load</span>
<span class="sd">    -3*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 2, 0) - 9*SingularityFunction(x, 4, -1)</span>
<span class="sd">    &gt;&gt;&gt; b.shear_force()</span>
<span class="sd">    -3*SingularityFunction(x, 0, 0) + 6*SingularityFunction(x, 2, 1) - 9*SingularityFunction(x, 4, 0)</span>
<span class="sd">    &gt;&gt;&gt; b.bending_moment()</span>
<span class="sd">    -3*SingularityFunction(x, 0, 1) + 3*SingularityFunction(x, 2, 2) - 9*SingularityFunction(x, 4, 1)</span>
<span class="sd">    &gt;&gt;&gt; b.slope()</span>
<span class="sd">    (-3*SingularityFunction(x, 0, 2)/2 + SingularityFunction(x, 2, 3) - 9*SingularityFunction(x, 4, 2)/2 + 7)/(E*I)</span>
<span class="sd">    &gt;&gt;&gt; b.deflection()</span>
<span class="sd">    (7*x - SingularityFunction(x, 0, 3)/2 + SingularityFunction(x, 2, 4)/4 - 3*SingularityFunction(x, 4, 3)/2)/(E*I)</span>
<span class="sd">    &gt;&gt;&gt; b.deflection().rewrite(Piecewise)</span>
<span class="sd">    (7*x - Piecewise((x**3, x &gt; 0), (0, True))/2</span>
<span class="sd">         - 3*Piecewise(((x - 4)**3, x - 4 &gt; 0), (0, True))/2</span>
<span class="sd">         + Piecewise(((x - 2)**4, x - 2 &gt; 0), (0, True))/4)/(E*I)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">elastic_modulus</span><span class="p">,</span> <span class="n">second_moment</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">base_char</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        length : Sympifyable</span>
<span class="sd">            A Symbol or value representing the Beam&#39;s length.</span>
<span class="sd">        elastic_modulus : Sympifyable</span>
<span class="sd">            A SymPy expression representing the Beam&#39;s Modulus of Elasticity.</span>
<span class="sd">            It is a measure of the stiffness of the Beam material. It can</span>
<span class="sd">            also be a continuous function of position along the beam.</span>
<span class="sd">        second_moment : Sympifyable</span>
<span class="sd">            A SymPy expression representing the Beam&#39;s Second moment of area.</span>
<span class="sd">            It is a geometrical property of an area which reflects how its</span>
<span class="sd">            points are distributed with respect to its neutral axis. It can</span>
<span class="sd">            also be a continuous function of position along the beam.</span>
<span class="sd">        variable : Symbol, optional</span>
<span class="sd">            A Symbol object that will be used as the variable along the beam</span>
<span class="sd">            while representing the load, shear, moment, slope and deflection</span>
<span class="sd">            curve. By default, it is set to ``Symbol(&#39;x&#39;)``.</span>
<span class="sd">        base_char : String, optional</span>
<span class="sd">            A String that will be used as base character to generate sequential</span>
<span class="sd">            symbols for integration constants in cases where boundary conditions</span>
<span class="sd">            are not sufficient to solve them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elastic_modulus</span> <span class="o">=</span> <span class="n">elastic_modulus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_moment</span> <span class="o">=</span> <span class="n">second_moment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_char</span> <span class="o">=</span> <span class="n">base_char</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;deflection&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;slope&#39;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_loads</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hinge_position</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">str_sol</span> <span class="o">=</span> <span class="s1">&#39;Beam(</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_length</span><span class="p">),</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elastic_modulus</span><span class="p">),</span> <span class="n">sstr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_second_moment</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">str_sol</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reaction_loads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the reaction forces in a dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of the Beam.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span>

    <span class="nd">@length</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A symbol that can be used as a variable along the length of the beam</span>
<span class="sd">        while representing load distribution, shear force curve, bending</span>
<span class="sd">        moment, slope curve and the deflection curve. By default, it is set</span>
<span class="sd">        to ``Symbol(&#39;x&#39;)``, but this property is mutable.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x, y, z = symbols(&#39;x, y, z&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(4, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.variable</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; b.variable = y</span>
<span class="sd">        &gt;&gt;&gt; b.variable</span>
<span class="sd">        y</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(4, E, I, z)</span>
<span class="sd">        &gt;&gt;&gt; b.variable</span>
<span class="sd">        z</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span>

    <span class="nd">@variable</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;The variable should be a Symbol object.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">elastic_modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Young&#39;s Modulus of the Beam. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elastic_modulus</span>

    <span class="nd">@elastic_modulus</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">elastic_modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elastic_modulus</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">second_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Second moment of area of the Beam. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_moment</span>

    <span class="nd">@second_moment</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">second_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_second_moment</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary of boundary conditions applied on the beam.</span>
<span class="sd">        The dictionary has three kewwords namely moment, slope and deflection.</span>
<span class="sd">        The value of each keyword is a list of tuple, where each tuple</span>
<span class="sd">        contains loaction and value of a boundary condition in the format</span>
<span class="sd">        (location, value).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 4 meters. The bending moment at 0 should be 4</span>
<span class="sd">        and at 4 it should be 0. The slope of the beam should be 1 at 0. The</span>
<span class="sd">        deflection should be 2 at 0.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(4, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(0, 2)]</span>
<span class="sd">        &gt;&gt;&gt; b.bc_slope = [(0, 1)]</span>
<span class="sd">        &gt;&gt;&gt; b.boundary_conditions</span>
<span class="sd">        {&#39;deflection&#39;: [(0, 2)], &#39;slope&#39;: [(0, 1)]}</span>

<span class="sd">        Here the deflection of the beam should be ``2`` at ``0``.</span>
<span class="sd">        Similarly, the slope of the beam should be ``1`` at ``0``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bc_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;slope&#39;</span><span class="p">]</span>

    <span class="nd">@bc_slope</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bc_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_bcs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;slope&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_bcs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bc_deflection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;deflection&#39;</span><span class="p">]</span>

    <span class="nd">@bc_deflection</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bc_deflection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_bcs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;deflection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_bcs</span>

<div class="viewcode-block" id="Beam.join"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam</span><span class="p">,</span> <span class="n">via</span><span class="o">=</span><span class="s2">&quot;fixed&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method joins two beams to make a new composite beam system.</span>
<span class="sd">        Passed Beam class instance is attached to the right end of calling</span>
<span class="sd">        object. This method can be used to form beams having Discontinuous</span>
<span class="sd">        values of Elastic modulus or Second moment.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        beam : Beam class object</span>
<span class="sd">            The Beam object which would be connected to the right of calling</span>
<span class="sd">            object.</span>
<span class="sd">        via : String</span>
<span class="sd">            States the way two Beam object would get connected</span>
<span class="sd">            - For axially fixed Beams, via=&quot;fixed&quot;</span>
<span class="sd">            - For Beams connected via hinge, via=&quot;hinge&quot;</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a cantilever beam of length 4 meters. For first 2 meters</span>
<span class="sd">        its moment of inertia is `1.5*I` and `I` for the other end.</span>
<span class="sd">        A pointload of magnitude 4 N is applied from the top at its free end.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b1 = Beam(2, E, 1.5*I)</span>
<span class="sd">        &gt;&gt;&gt; b2 = Beam(2, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b = b1.join(b2, &quot;fixed&quot;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(20, 4, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 0, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_slope = [(0, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(0, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        80*SingularityFunction(x, 0, -2) - 20*SingularityFunction(x, 0, -1) + 20*SingularityFunction(x, 4, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.slope()</span>
<span class="sd">        (((80*SingularityFunction(x, 0, 1) - 10*SingularityFunction(x, 0, 2) + 10*SingularityFunction(x, 4, 2))/I - 120/I)/E + 80.0/(E*I))*SingularityFunction(x, 2, 0)</span>
<span class="sd">        + 0.666666666666667*(80*SingularityFunction(x, 0, 1) - 10*SingularityFunction(x, 0, 2) + 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 0, 0)/(E*I)</span>
<span class="sd">        - 0.666666666666667*(80*SingularityFunction(x, 0, 1) - 10*SingularityFunction(x, 0, 2) + 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 2, 0)/(E*I)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_modulus</span>
        <span class="n">new_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">beam</span><span class="o">.</span><span class="n">length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_moment</span> <span class="o">!=</span> <span class="n">beam</span><span class="o">.</span><span class="n">second_moment</span><span class="p">:</span>
            <span class="n">new_second_moment</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">second_moment</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
                                    <span class="p">(</span><span class="n">beam</span><span class="o">.</span><span class="n">second_moment</span><span class="p">,</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">new_length</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_second_moment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_moment</span>

        <span class="k">if</span> <span class="n">via</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
            <span class="n">new_beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">new_length</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">new_second_moment</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">new_beam</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">=</span> <span class="s2">&quot;fixed&quot;</span>
            <span class="k">return</span> <span class="n">new_beam</span>

        <span class="k">if</span> <span class="n">via</span> <span class="o">==</span> <span class="s2">&quot;hinge&quot;</span><span class="p">:</span>
            <span class="n">new_beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span><span class="n">new_length</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">new_second_moment</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">new_beam</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">=</span> <span class="s2">&quot;hinge&quot;</span>
            <span class="n">new_beam</span><span class="o">.</span><span class="n">_hinge_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
            <span class="k">return</span> <span class="n">new_beam</span></div>

<div class="viewcode-block" id="Beam.apply_support"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.apply_support">[docs]</a>    <span class="k">def</span> <span class="nf">apply_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;fixed&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method applies support to a particular beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        loc : Sympifyable</span>
<span class="sd">            Location of point at which support is applied.</span>
<span class="sd">        type : String</span>
<span class="sd">            Determines type of Beam support applied. To apply support structure</span>
<span class="sd">            with</span>
<span class="sd">            - zero degree of freedom, type = &quot;fixed&quot;</span>
<span class="sd">            - one degree of freedom, type = &quot;pin&quot;</span>
<span class="sd">            - two degrees of freedom, type = &quot;roller&quot;</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 30 meters. A moment of magnitude 120 Nm is</span>
<span class="sd">        applied in the clockwise direction at the end of the beam. A pointload</span>
<span class="sd">        of magnitude 8 N is applied from the top of the beam at the starting</span>
<span class="sd">        point. There are two simple supports below the beam. One at the end</span>
<span class="sd">        and another one at a distance of 10 meters from the start. The</span>
<span class="sd">        deflection is restricted at both the supports.</span>

<span class="sd">        Using the sign convention of upward forces and clockwise moment</span>
<span class="sd">        being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(30, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_support(10, &#39;roller&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_support(30, &#39;roller&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-8, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(120, 30, -2)</span>
<span class="sd">        &gt;&gt;&gt; R_10, R_30 = symbols(&#39;R_10, R_30&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R_10, R_30)</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        -8*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 10, -1)</span>
<span class="sd">        + 120*SingularityFunction(x, 30, -2) + 2*SingularityFunction(x, 30, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.slope()</span>
<span class="sd">        (-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)</span>
<span class="sd">            + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;pin&quot;</span> <span class="ow">or</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;roller&quot;</span><span class="p">:</span>
            <span class="n">reaction_load</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;R_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_load</span><span class="p">(</span><span class="n">reaction_load</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_deflection</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reaction_load</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;R_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
            <span class="n">reaction_moment</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;M_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_load</span><span class="p">(</span><span class="n">reaction_load</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_load</span><span class="p">(</span><span class="n">reaction_moment</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_deflection</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_slope</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="Beam.apply_load"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.apply_load">[docs]</a>    <span class="k">def</span> <span class="nf">apply_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method adds up the loads given to a particular beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        value : Sympifyable</span>
<span class="sd">            The magnitude of an applied load.</span>
<span class="sd">        start : Sympifyable</span>
<span class="sd">            The starting point of the applied load. For point moments and</span>
<span class="sd">            point forces this is the location of application.</span>
<span class="sd">        order : Integer</span>
<span class="sd">            The order of the applied load.</span>

<span class="sd">               - For moments, order = -2</span>
<span class="sd">               - For point loads, order =-1</span>
<span class="sd">               - For constant distributed load, order = 0</span>
<span class="sd">               - For ramp loads, order = 1</span>
<span class="sd">               - For parabolic ramp loads, order = 2</span>
<span class="sd">               - ... so on.</span>

<span class="sd">        end : Sympifyable, optional</span>
<span class="sd">            An optional argument that can be used if the load has an end point</span>
<span class="sd">            within the length of the beam.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 4 meters. A moment of magnitude 3 Nm is</span>
<span class="sd">        applied in the clockwise direction at the starting point of the beam.</span>
<span class="sd">        A point load of magnitude 4 N is applied from the top of the beam at</span>
<span class="sd">        2 meters from the starting point and a parabolic ramp load of magnitude</span>
<span class="sd">        2 N/m is applied below the beam starting from 2 meters to 3 meters</span>
<span class="sd">        away from the starting point of the beam.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(4, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-3, 0, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(4, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-2, 2, 2, end=3)</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_loads</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">+=</span> <span class="n">value</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;If &#39;end&#39; is provided the &#39;order&#39; of the load cannot &quot;</span>
                       <span class="s2">&quot;be negative, i.e. &#39;end&#39; is only valid for distributed &quot;</span>
                       <span class="s2">&quot;loads.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># NOTE : A Taylor series can be used to define the summation of</span>
            <span class="c1"># singularity functions that subtract from the load past the end</span>
            <span class="c1"># point such that it evaluates to zero past &#39;end&#39;.</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">order</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">-=</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span>
                               <span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">))</span></div>

<div class="viewcode-block" id="Beam.remove_load"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.remove_load">[docs]</a>    <span class="k">def</span> <span class="nf">remove_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method removes a particular load present on the beam object.</span>
<span class="sd">        Returns a ValueError if the load passed as an argument is not</span>
<span class="sd">        present on the beam.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        value : Sympifyable</span>
<span class="sd">            The magnitude of an applied load.</span>
<span class="sd">        start : Sympifyable</span>
<span class="sd">            The starting point of the applied load. For point moments and</span>
<span class="sd">            point forces this is the location of application.</span>
<span class="sd">        order : Integer</span>
<span class="sd">            The order of the applied load.</span>
<span class="sd">            - For moments, order= -2</span>
<span class="sd">            - For point loads, order=-1</span>
<span class="sd">            - For constant distributed load, order=0</span>
<span class="sd">            - For ramp loads, order=1</span>
<span class="sd">            - For parabolic ramp loads, order=2</span>
<span class="sd">            - ... so on.</span>
<span class="sd">        end : Sympifyable, optional</span>
<span class="sd">            An optional argument that can be used if the load has an end point</span>
<span class="sd">            within the length of the beam.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 4 meters. A moment of magnitude 3 Nm is</span>
<span class="sd">        applied in the clockwise direction at the starting point of the beam.</span>
<span class="sd">        A pointload of magnitude 4 N is applied from the top of the beam at</span>
<span class="sd">        2 meters from the starting point and a parabolic ramp load of magnitude</span>
<span class="sd">        2 N/m is applied below the beam starting from 2 meters to 3 meters</span>
<span class="sd">        away from the starting point of the beam.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(4, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-3, 0, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(4, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-2, 2, 2, end=3)</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2)</span>
<span class="sd">        &gt;&gt;&gt; b.remove_load(-2, 2, 2, end = 3)</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applied_loads</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">-=</span> <span class="n">value</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_applied_loads</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;No such load distribution exists on the beam object.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
            <span class="c1"># TODO : This is essentially duplicate code wrt to apply_load,</span>
            <span class="c1"># would be better to move it to one location and both methods use</span>
            <span class="c1"># it.</span>
            <span class="k">if</span> <span class="n">order</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;If &#39;end&#39; is provided the &#39;order&#39; of the load cannot &quot;</span>
                       <span class="s2">&quot;be negative, i.e. &#39;end&#39; is only valid for distributed &quot;</span>
                       <span class="s2">&quot;loads.&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># NOTE : A Taylor series can be used to define the summation of</span>
            <span class="c1"># singularity functions that subtract from the load past the end</span>
            <span class="c1"># point such that it evaluates to zero past &#39;end&#39;.</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="n">order</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">+=</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span>
                               <span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">factorial</span><span class="p">(</span><span class="n">i</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Singularity Function expression which represents</span>
<span class="sd">        the load distribution curve of the Beam object.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 4 meters. A moment of magnitude 3 Nm is</span>
<span class="sd">        applied in the clockwise direction at the starting point of the beam.</span>
<span class="sd">        A point load of magnitude 4 N is applied from the top of the beam at</span>
<span class="sd">        2 meters from the starting point and a parabolic ramp load of magnitude</span>
<span class="sd">        2 N/m is applied below the beam starting from 3 meters away from the</span>
<span class="sd">        starting point of the beam.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(4, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-3, 0, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(4, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-2, 3, 2)</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        -3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 3, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">applied_loads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of all loads applied on the beam object.</span>
<span class="sd">        Each load in the list is a tuple of form (value, start, order, end).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 4 meters. A moment of magnitude 3 Nm is</span>
<span class="sd">        applied in the clockwise direction at the starting point of the beam.</span>
<span class="sd">        A pointload of magnitude 4 N is applied from the top of the beam at</span>
<span class="sd">        2 meters from the starting point. Another pointload of magnitude 5 N</span>
<span class="sd">        is applied at same position.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(4, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-3, 0, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(4, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(5, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        -3*SingularityFunction(x, 0, -2) + 9*SingularityFunction(x, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.applied_loads</span>
<span class="sd">        [(-3, 0, -2, None), (4, 2, -1, None), (5, 2, -1, None)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_applied_loads</span>

    <span class="k">def</span> <span class="nf">_solve_hinge_beams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">reactions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to find integration constants and reactional variables in a</span>
<span class="sd">        composite beam connected via hinge.</span>
<span class="sd">        This method resolves the composite Beam into its sub-beams and then</span>
<span class="sd">        equations of shear force, bending moment, slope and deflection are</span>
<span class="sd">        evaluated for both of them separately. These equations are then solved</span>
<span class="sd">        for unknown reactions and integration constants using the boundary</span>
<span class="sd">        conditions applied on the Beam. Equal deflection of both sub-beams</span>
<span class="sd">        at the hinge joint gives us another equation to solve the system.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        A combined beam, with constant fkexural rigidity E*I, is formed by joining</span>
<span class="sd">        a Beam of length 2*l to the right of another Beam of length l. The whole beam</span>
<span class="sd">        is fixed at both of its both end. A point load of magnitude P is also applied</span>
<span class="sd">        from the top at a distance of 2*l from starting point.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; l=symbols(&#39;l&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; b1=Beam(l ,E,I)</span>
<span class="sd">        &gt;&gt;&gt; b2=Beam(2*l ,E,I)</span>
<span class="sd">        &gt;&gt;&gt; b=b1.join(b2,&quot;hinge&quot;)</span>
<span class="sd">        &gt;&gt;&gt; M1, A1, M2, A2, P = symbols(&#39;M1 A1 M2 A2 P&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(A1,0,-1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(M1,0,-2)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(P,2*l,-1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(A2,3*l,-1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(M2,3*l,-2)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_slope=[(0,0), (3*l, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection=[(0,0), (3*l, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(M1, A1, M2, A2)</span>
<span class="sd">        &gt;&gt;&gt; b.reaction_loads</span>
<span class="sd">        {A1: -5*P/18, A2: -13*P/18, M1: 5*P*l/18, M2: -4*P*l/9}</span>
<span class="sd">        &gt;&gt;&gt; b.slope()</span>
<span class="sd">        (5*P*l*SingularityFunction(x, 0, 1)/18 - 5*P*SingularityFunction(x, 0, 2)/36 + 5*P*SingularityFunction(x, l, 2)/36)*SingularityFunction(x, 0, 0)/(E*I)</span>
<span class="sd">        - (5*P*l*SingularityFunction(x, 0, 1)/18 - 5*P*SingularityFunction(x, 0, 2)/36 + 5*P*SingularityFunction(x, l, 2)/36)*SingularityFunction(x, l, 0)/(E*I)</span>
<span class="sd">        + (P*l**2/18 - 4*P*l*SingularityFunction(-l + x, 2*l, 1)/9 - 5*P*SingularityFunction(-l + x, 0, 2)/36 + P*SingularityFunction(-l + x, l, 2)/2</span>
<span class="sd">        - 13*P*SingularityFunction(-l + x, 2*l, 2)/36)*SingularityFunction(x, l, 0)/(E*I)</span>
<span class="sd">        &gt;&gt;&gt; b.deflection()</span>
<span class="sd">        (5*P*l*SingularityFunction(x, 0, 2)/36 - 5*P*SingularityFunction(x, 0, 3)/108 + 5*P*SingularityFunction(x, l, 3)/108)*SingularityFunction(x, 0, 0)/(E*I)</span>
<span class="sd">        - (5*P*l*SingularityFunction(x, 0, 2)/36 - 5*P*SingularityFunction(x, 0, 3)/108 + 5*P*SingularityFunction(x, l, 3)/108)*SingularityFunction(x, l, 0)/(E*I)</span>
<span class="sd">        + (5*P*l**3/54 + P*l**2*(-l + x)/18 - 2*P*l*SingularityFunction(-l + x, 2*l, 2)/9 - 5*P*SingularityFunction(-l + x, 0, 3)/108 + P*SingularityFunction(-l + x, l, 3)/6</span>
<span class="sd">        - 13*P*SingularityFunction(-l + x, 2*l, 3)/108)*SingularityFunction(x, l, 0)/(E*I)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hinge_position</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elastic_modulus</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_moment</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">):</span>
            <span class="n">I1</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">I2</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">I1</span> <span class="o">=</span> <span class="n">I2</span> <span class="o">=</span> <span class="n">I</span>

        <span class="n">load_1</span> <span class="o">=</span> <span class="mi">0</span>       <span class="c1"># Load equation on first segment of composite beam</span>
        <span class="n">load_2</span> <span class="o">=</span> <span class="mi">0</span>       <span class="c1"># Load equation on second segment of composite beam</span>

        <span class="c1"># Distributing load on both segments</span>
        <span class="k">for</span> <span class="n">load</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">applied_loads</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">load_1</span> <span class="o">+=</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">load_1</span> <span class="o">-=</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">load_1</span> <span class="o">-=</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">load_1</span> <span class="o">+=</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">load_2</span> <span class="o">+=</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">load_2</span> <span class="o">+=</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">load_2</span> <span class="o">-=</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">load_2</span> <span class="o">-=</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">load</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">)</span>     <span class="c1"># Force due to hinge</span>
        <span class="n">load_1</span> <span class="o">+=</span> <span class="n">h</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">load_2</span> <span class="o">-=</span> <span class="n">h</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">eq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">shear_1</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">load_1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">shear_curve_1</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">shear_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shear_curve_1</span><span class="p">)</span>
        <span class="n">bending_1</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">shear_1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">moment_curve_1</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">bending_1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moment_curve_1</span><span class="p">)</span>

        <span class="n">shear_2</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">load_2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">shear_curve_2</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">shear_2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shear_curve_2</span><span class="p">)</span>
        <span class="n">bending_2</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">shear_2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">moment_curve_2</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">bending_2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moment_curve_2</span><span class="p">)</span>

        <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C1&#39;</span><span class="p">)</span>
        <span class="n">C2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C2&#39;</span><span class="p">)</span>
        <span class="n">C3</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C3&#39;</span><span class="p">)</span>
        <span class="n">C4</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C4&#39;</span><span class="p">)</span>
        <span class="n">slope_1</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">bending_1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span>
        <span class="n">def_1</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">integrate</span><span class="p">((</span><span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">slope_1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C2</span><span class="p">)</span>
        <span class="n">slope_2</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">load_2</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C3</span><span class="p">)</span>
        <span class="n">def_2</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">integrate</span><span class="p">((</span><span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">slope_2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C4</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_slope</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">position</span><span class="o">&lt;</span><span class="n">l</span><span class="p">:</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope_2</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc_deflection</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">position</span><span class="o">&lt;</span><span class="n">l</span><span class="p">:</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">def_1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">def_2</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="p">)</span>

        <span class="n">eq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">def_1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">def_2</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1"># Deflection of both the segments at hinge would be equal</span>

        <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="o">*</span><span class="n">reactions</span><span class="p">))</span>
        <span class="n">reaction_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">5</span><span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">reactions</span><span class="p">,</span> <span class="n">reaction_values</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="p">)</span>

        <span class="c1"># Substituting constants and reactional load and moments with their corresponding values</span>
        <span class="n">slope_1</span> <span class="o">=</span> <span class="n">slope_1</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C1</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]})</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="p">)</span>
        <span class="n">def_1</span> <span class="o">=</span> <span class="n">def_1</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C1</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">C2</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]})</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="p">)</span>
        <span class="n">slope_2</span> <span class="o">=</span> <span class="n">slope_2</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">C3</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">h</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]})</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="p">)</span>
        <span class="n">def_2</span> <span class="o">=</span> <span class="n">def_2</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">-</span><span class="n">l</span><span class="p">,</span><span class="n">C3</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">C4</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="n">h</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">4</span><span class="p">]})</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_hinge_beam_slope</span> <span class="o">=</span> <span class="n">slope_1</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">slope_1</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">slope_2</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hinge_beam_deflection</span> <span class="o">=</span> <span class="n">def_1</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">def_1</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">def_2</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="Beam.solve_for_reaction_loads"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.solve_for_reaction_loads">[docs]</a>    <span class="k">def</span> <span class="nf">solve_for_reaction_loads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">reactions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves for the reaction forces.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 30 meters. A moment of magnitude 120 Nm is</span>
<span class="sd">        applied in the clockwise direction at the end of the beam. A pointload</span>
<span class="sd">        of magnitude 8 N is applied from the top of the beam at the starting</span>
<span class="sd">        point. There are two simple supports below the beam. One at the end</span>
<span class="sd">        and another one at a distance of 10 meters from the start. The</span>
<span class="sd">        deflection is restricted at both the supports.</span>

<span class="sd">        Using the sign convention of upward forces and clockwise moment</span>
<span class="sd">        being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols, linsolve, limit</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(30, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-8, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 10, -1)  # Reaction force at x = 10</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 30, -1)  # Reaction force at x = 30</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(120, 30, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(10, 0), (30, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        R1*SingularityFunction(x, 10, -1) + R2*SingularityFunction(x, 30, -1)</span>
<span class="sd">            - 8*SingularityFunction(x, 0, -1) + 120*SingularityFunction(x, 30, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.reaction_loads</span>
<span class="sd">        {R1: 6, R2: 2}</span>
<span class="sd">        &gt;&gt;&gt; b.load</span>
<span class="sd">        -8*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 10, -1)</span>
<span class="sd">            + 120*SingularityFunction(x, 30, -2) + 2*SingularityFunction(x, 30, -1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">==</span> <span class="s2">&quot;hinge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_hinge_beams</span><span class="p">(</span><span class="o">*</span><span class="n">reactions</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="n">C3</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C3&#39;</span><span class="p">)</span>
        <span class="n">C4</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C4&#39;</span><span class="p">)</span>

        <span class="n">shear_curve</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear_force</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">moment_curve</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

        <span class="n">slope_eqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deflection_eqs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">slope_curve</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C3</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;slope&#39;</span><span class="p">]:</span>
            <span class="n">eqs</span> <span class="o">=</span> <span class="n">slope_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span>
            <span class="n">slope_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>

        <span class="n">deflection_curve</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">slope_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C4</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;deflection&#39;</span><span class="p">]:</span>
            <span class="n">eqs</span> <span class="o">=</span> <span class="n">deflection_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span>
            <span class="n">deflection_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>

        <span class="n">solution</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">linsolve</span><span class="p">([</span><span class="n">shear_curve</span><span class="p">,</span> <span class="n">moment_curve</span><span class="p">]</span> <span class="o">+</span> <span class="n">slope_eqs</span>
                            <span class="o">+</span> <span class="n">deflection_eqs</span><span class="p">,</span> <span class="p">(</span><span class="n">C3</span><span class="p">,</span> <span class="n">C4</span><span class="p">)</span> <span class="o">+</span> <span class="n">reactions</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">reactions</span><span class="p">,</span> <span class="n">solution</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.shear_force"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.shear_force">[docs]</a>    <span class="k">def</span> <span class="nf">shear_force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Singularity Function expression which represents</span>
<span class="sd">        the shear force curve of the Beam object.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 30 meters. A moment of magnitude 120 Nm is</span>
<span class="sd">        applied in the clockwise direction at the end of the beam. A pointload</span>
<span class="sd">        of magnitude 8 N is applied from the top of the beam at the starting</span>
<span class="sd">        point. There are two simple supports below the beam. One at the end</span>
<span class="sd">        and another one at a distance of 10 meters from the start. The</span>
<span class="sd">        deflection is restricted at both the supports.</span>

<span class="sd">        Using the sign convention of upward forces and clockwise moment</span>
<span class="sd">        being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(30, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-8, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 10, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 30, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(120, 30, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(10, 0), (30, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.shear_force()</span>
<span class="sd">        -8*SingularityFunction(x, 0, 0) + 6*SingularityFunction(x, 10, 0) + 120*SingularityFunction(x, 30, -1) + 2*SingularityFunction(x, 30, 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.max_shear_force"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.max_shear_force">[docs]</a>    <span class="k">def</span> <span class="nf">max_shear_force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum Shear force and its coordinate</span>
<span class="sd">        in the Beam object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Interval</span>
        <span class="n">shear_curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear_force</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="n">shear_curve</span><span class="o">.</span><span class="n">args</span>
        <span class="n">singularity</span> <span class="o">=</span> <span class="p">[]</span>        <span class="c1"># Points at which shear function changes</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c1"># SingularityFunction in the term</span>
            <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">singularity</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">singularity</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">singularity</span><span class="p">))</span>

        <span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># List of Intervals with discrete value of shear force</span>
        <span class="n">shear_values</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># List of values of shear force in each interval</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">singularity</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">shear_slope</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]),(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">),</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">s</span><span class="p">),</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">shear_slope</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shear_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">))</span>
                <span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">])</span>
                <span class="n">val</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">limit</span><span class="p">(</span><span class="n">shear_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;+&#39;</span><span class="p">),</span> <span class="n">limit</span><span class="p">(</span><span class="n">shear_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)])</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
                <span class="n">max_shear</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">shear_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_shear</span><span class="p">)</span>
                <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">val</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_shear</span><span class="p">)])</span>
            <span class="c1"># If shear force in a particular Interval has zero or constant</span>
            <span class="c1"># slope, then above block gives NotImplementedError as</span>
            <span class="c1"># solve can&#39;t represent Interval solutions.</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">initial_shear</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">shear_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
                <span class="n">final_shear</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">shear_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="c1"># If shear_curve has a constant slope(it is a line).</span>
                <span class="k">if</span> <span class="n">shear_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">initial_shear</span> <span class="o">+</span> <span class="n">final_shear</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">initial_shear</span> <span class="o">!=</span> <span class="n">final_shear</span><span class="p">:</span>
                    <span class="n">shear_values</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">initial_shear</span><span class="p">,</span> <span class="n">final_shear</span><span class="p">])</span>
                    <span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>    <span class="c1"># shear_curve has same value in whole Interval</span>
                    <span class="n">shear_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_shear</span><span class="p">)</span>
                    <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">))</span>

        <span class="n">shear_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">shear_values</span><span class="p">))</span>
        <span class="n">maximum_shear</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">shear_values</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">shear_values</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">maximum_shear</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">maximum_shear</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.bending_moment"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.bending_moment">[docs]</a>    <span class="k">def</span> <span class="nf">bending_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Singularity Function expression which represents</span>
<span class="sd">        the bending moment curve of the Beam object.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 30 meters. A moment of magnitude 120 Nm is</span>
<span class="sd">        applied in the clockwise direction at the end of the beam. A pointload</span>
<span class="sd">        of magnitude 8 N is applied from the top of the beam at the starting</span>
<span class="sd">        point. There are two simple supports below the beam. One at the end</span>
<span class="sd">        and another one at a distance of 10 meters from the start. The</span>
<span class="sd">        deflection is restricted at both the supports.</span>

<span class="sd">        Using the sign convention of upward forces and clockwise moment</span>
<span class="sd">        being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(30, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-8, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 10, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 30, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(120, 30, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(10, 0), (30, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.bending_moment()</span>
<span class="sd">        -8*SingularityFunction(x, 0, 1) + 6*SingularityFunction(x, 10, 1) + 120*SingularityFunction(x, 30, 0) + 2*SingularityFunction(x, 30, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear_force</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.max_bmoment"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.max_bmoment">[docs]</a>    <span class="k">def</span> <span class="nf">max_bmoment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns maximum Shear force and its coordinate</span>
<span class="sd">        in the Beam object.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Interval</span>
        <span class="n">bending_curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="n">bending_curve</span><span class="o">.</span><span class="n">args</span>
        <span class="n">singularity</span> <span class="o">=</span> <span class="p">[]</span>        <span class="c1"># Points at which bending moment changes</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>    <span class="c1"># SingularityFunction in the term</span>
            <span class="n">singularity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">singularity</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">singularity</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">singularity</span><span class="p">))</span>

        <span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># List of Intervals with discrete value of bending moment</span>
        <span class="n">moment_values</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># List of values of bending moment in each interval</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">singularity</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">moment_slope</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]),(</span><span class="bp">self</span><span class="o">.</span><span class="n">shear_force</span><span class="p">()</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">),</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">s</span><span class="p">),</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>
                <span class="n">points</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">moment_slope</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bending_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">))</span>
                <span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">])</span>
                <span class="n">val</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">limit</span><span class="p">(</span><span class="n">bending_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;+&#39;</span><span class="p">),</span> <span class="n">limit</span><span class="p">(</span><span class="n">bending_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)])</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
                <span class="n">max_moment</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">moment_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_moment</span><span class="p">)</span>
                <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">val</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_moment</span><span class="p">)])</span>
            <span class="c1"># If bending moment in a particular Interval has zero or constant</span>
            <span class="c1"># slope, then above block gives NotImplementedError as solve</span>
            <span class="c1"># can&#39;t represent Interval solutions.</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="n">initial_moment</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">bending_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
                <span class="n">final_moment</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">bending_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="c1"># If bending_curve has a constant slope(it is a line).</span>
                <span class="k">if</span> <span class="n">bending_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">initial_moment</span> <span class="o">+</span> <span class="n">final_moment</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">initial_moment</span> <span class="o">!=</span> <span class="n">final_moment</span><span class="p">:</span>
                    <span class="n">moment_values</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">initial_moment</span><span class="p">,</span> <span class="n">final_moment</span><span class="p">])</span>
                    <span class="n">intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>    <span class="c1"># bending_curve has same value in whole Interval</span>
                    <span class="n">moment_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_moment</span><span class="p">)</span>
                    <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">singularity</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">))</span>

        <span class="n">moment_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">moment_values</span><span class="p">))</span>
        <span class="n">maximum_moment</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">moment_values</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="n">moment_values</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">maximum_moment</span><span class="p">)]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">maximum_moment</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.point_cflexure"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.point_cflexure">[docs]</a>    <span class="k">def</span> <span class="nf">point_cflexure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Set of point(s) with zero bending moment and</span>
<span class="sd">        where bending moment curve of the beam object changes</span>
<span class="sd">        its sign from negative to positive or vice versa.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is is 10 meter long overhanging beam. There are</span>
<span class="sd">        two simple supports below the beam. One at the start</span>
<span class="sd">        and another one at a distance of 6 meters from the start.</span>
<span class="sd">        Point loads of magnitude 10KN and 20KN are applied at</span>
<span class="sd">        2 meters and 4 meters from start respectively. A Uniformly</span>
<span class="sd">        distribute load of magnitude of magnitude 3KN/m is also</span>
<span class="sd">        applied on top starting from 6 meters away from starting</span>
<span class="sd">        point till end.</span>
<span class="sd">        Using the sign convention of upward forces and clockwise moment</span>
<span class="sd">        being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(10, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-4, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-46, 6, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(10, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(20, 4, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(3, 6, 0)</span>
<span class="sd">        &gt;&gt;&gt; b.point_cflexure()</span>
<span class="sd">        [10/3]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Piecewise</span>

        <span class="c1"># To restrict the range within length of the Beam</span>
        <span class="n">moment_curve</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
                <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">moment_curve</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                        <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points</span></div>

<div class="viewcode-block" id="Beam.slope"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.slope">[docs]</a>    <span class="k">def</span> <span class="nf">slope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Singularity Function expression which represents</span>
<span class="sd">        the slope the elastic curve of the Beam object.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 30 meters. A moment of magnitude 120 Nm is</span>
<span class="sd">        applied in the clockwise direction at the end of the beam. A pointload</span>
<span class="sd">        of magnitude 8 N is applied from the top of the beam at the starting</span>
<span class="sd">        point. There are two simple supports below the beam. One at the end</span>
<span class="sd">        and another one at a distance of 10 meters from the start. The</span>
<span class="sd">        deflection is restricted at both the supports.</span>

<span class="sd">        Using the sign convention of upward forces and clockwise moment</span>
<span class="sd">        being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(30, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-8, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 10, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 30, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(120, 30, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(10, 0), (30, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.slope()</span>
<span class="sd">        (-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)</span>
<span class="sd">            + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_modulus</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_moment</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">==</span> <span class="s2">&quot;hinge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hinge_beam_slope</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;slope&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deflection</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">args</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">conditions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">prev_slope</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">prev_end</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">prev_end</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">slope_value</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">E</span><span class="o">*</span><span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">()</span><span class="o">/</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">slope</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prev_slope</span> <span class="o">+</span> <span class="n">slope_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> \
                        <span class="p">(</span><span class="n">prev_slope</span> <span class="o">+</span> <span class="n">slope_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slope</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prev_slope</span> <span class="o">+</span> <span class="n">slope_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">prev_slope</span> <span class="o">=</span> <span class="n">slope_value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">slope</span>

        <span class="n">C3</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C3&#39;</span><span class="p">)</span>
        <span class="n">slope_curve</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C3</span>

        <span class="n">bc_eqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;slope&#39;</span><span class="p">]:</span>
            <span class="n">eqs</span> <span class="o">=</span> <span class="n">slope_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span>
            <span class="n">bc_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linsolve</span><span class="p">(</span><span class="n">bc_eqs</span><span class="p">,</span> <span class="n">C3</span><span class="p">))</span>
        <span class="n">slope_curve</span> <span class="o">=</span> <span class="n">slope_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C3</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]})</span>
        <span class="k">return</span> <span class="n">slope_curve</span></div>

<div class="viewcode-block" id="Beam.deflection"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.deflection">[docs]</a>    <span class="k">def</span> <span class="nf">deflection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Singularity Function expression which represents</span>
<span class="sd">        the elastic curve or deflection of the Beam object.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 30 meters. A moment of magnitude 120 Nm is</span>
<span class="sd">        applied in the clockwise direction at the end of the beam. A pointload</span>
<span class="sd">        of magnitude 8 N is applied from the top of the beam at the starting</span>
<span class="sd">        point. There are two simple supports below the beam. One at the end</span>
<span class="sd">        and another one at a distance of 10 meters from the start. The</span>
<span class="sd">        deflection is restricted at both the supports.</span>

<span class="sd">        Using the sign convention of upward forces and clockwise moment</span>
<span class="sd">        being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; E, I = symbols(&#39;E, I&#39;)</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(30, E, I)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(-8, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 10, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 30, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(120, 30, -2)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(10, 0), (30, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.deflection()</span>
<span class="sd">        (4000*x/3 - 4*SingularityFunction(x, 0, 3)/3 + SingularityFunction(x, 10, 3)</span>
<span class="sd">            + 60*SingularityFunction(x, 30, 2) + SingularityFunction(x, 30, 3)/3 - 12000)/(E*I)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_modulus</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_moment</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">==</span> <span class="s2">&quot;hinge&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hinge_beam_deflection</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;deflection&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;slope&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">args</span>
                <span class="n">conditions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">prev_slope</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">prev_def</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">prev_end</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">deflection</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">prev_end</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">slope_value</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">E</span><span class="o">*</span><span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">()</span><span class="o">/</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                    <span class="n">recent_segment_slope</span> <span class="o">=</span> <span class="n">prev_slope</span> <span class="o">+</span> <span class="n">slope_value</span>
                    <span class="n">deflection_value</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">recent_segment_slope</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">deflection</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> \
                            <span class="o">-</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">deflection</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">prev_slope</span> <span class="o">=</span> <span class="n">slope_value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">prev_def</span> <span class="o">=</span> <span class="n">deflection_value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">deflection</span>
            <span class="n">base_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_char</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="n">base_char</span> <span class="o">+</span> <span class="s1">&#39;3:5&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">integrate</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">(),</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;deflection&#39;</span><span class="p">]:</span>
            <span class="n">base_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_char</span>
            <span class="n">constant</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="n">base_char</span> <span class="o">+</span> <span class="s1">&#39;4&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">constant</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;slope&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;deflection&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">args</span>
                <span class="n">conditions</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">prev_slope</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">prev_def</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">prev_end</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">deflection</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">prev_end</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">slope_value</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">E</span><span class="o">*</span><span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">()</span><span class="o">/</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                    <span class="n">recent_segment_slope</span> <span class="o">=</span> <span class="n">prev_slope</span> <span class="o">+</span> <span class="n">slope_value</span>
                    <span class="n">deflection_value</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">recent_segment_slope</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">deflection</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> \
                            <span class="o">-</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">deflection</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">prev_slope</span> <span class="o">=</span> <span class="n">slope_value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">prev_def</span> <span class="o">=</span> <span class="n">deflection_value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">deflection</span>
            <span class="n">base_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_char</span>
            <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="n">base_char</span> <span class="o">+</span> <span class="s1">&#39;3:5&#39;</span><span class="p">)</span>    <span class="c1"># Integration constants</span>
            <span class="n">slope_curve</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C3</span>
            <span class="n">deflection_curve</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">slope_curve</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C4</span>
            <span class="n">bc_eqs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;deflection&#39;</span><span class="p">]:</span>
                <span class="n">eqs</span> <span class="o">=</span> <span class="n">deflection_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span>
                <span class="n">bc_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linsolve</span><span class="p">(</span><span class="n">bc_eqs</span><span class="p">,</span> <span class="p">(</span><span class="n">C3</span><span class="p">,</span> <span class="n">C4</span><span class="p">)))</span>
            <span class="n">deflection_curve</span> <span class="o">=</span> <span class="n">deflection_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C3</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">C4</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]})</span>
            <span class="k">return</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">deflection_curve</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_composite_type</span> <span class="o">==</span> <span class="s2">&quot;fixed&quot;</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">args</span>
            <span class="n">conditions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">prev_slope</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">prev_def</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">prev_end</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">deflection</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">prev_end</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">slope_value</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">E</span><span class="o">*</span><span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">()</span><span class="o">/</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="n">recent_segment_slope</span> <span class="o">=</span> <span class="n">prev_slope</span> <span class="o">+</span> <span class="n">slope_value</span>
                <span class="n">deflection_value</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">recent_segment_slope</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">deflection</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> \
                        <span class="o">-</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">deflection</span> <span class="o">+=</span> <span class="p">(</span><span class="n">prev_def</span> <span class="o">+</span> <span class="n">deflection_value</span><span class="p">)</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prev_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">prev_slope</span> <span class="o">=</span> <span class="n">slope_value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">prev_def</span> <span class="o">=</span> <span class="n">deflection_value</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">deflection</span>

        <span class="n">C4</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C4&#39;</span><span class="p">)</span>
        <span class="n">deflection_curve</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C4</span>

        <span class="n">bc_eqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="s1">&#39;deflection&#39;</span><span class="p">]:</span>
            <span class="n">eqs</span> <span class="o">=</span> <span class="n">deflection_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span>
            <span class="n">bc_eqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>

        <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linsolve</span><span class="p">(</span><span class="n">bc_eqs</span><span class="p">,</span> <span class="n">C4</span><span class="p">))</span>
        <span class="n">deflection_curve</span> <span class="o">=</span> <span class="n">deflection_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C4</span><span class="p">:</span> <span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]})</span>
        <span class="k">return</span> <span class="n">deflection_curve</span></div>

<div class="viewcode-block" id="Beam.max_deflection"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.max_deflection">[docs]</a>    <span class="k">def</span> <span class="nf">max_deflection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns point of max deflection and its coresponding deflection value</span>
<span class="sd">        in a Beam object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Piecewise</span>

        <span class="c1"># To restrict the range within length of the Beam</span>
        <span class="n">slope_curve</span> <span class="o">=</span> <span class="n">Piecewise</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
                <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="kc">True</span><span class="p">))</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">slope_curve</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span>
                        <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
        <span class="n">deflection_curve</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deflection</span><span class="p">()</span>
        <span class="n">deflections</span> <span class="o">=</span> <span class="p">[</span><span class="n">deflection_curve</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
        <span class="n">deflections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">abs</span><span class="p">,</span> <span class="n">deflections</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deflections</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_def</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">deflections</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">deflections</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_def</span><span class="p">)],</span> <span class="n">max_def</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Beam.plot_shear_force"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.plot_shear_force">[docs]</a>    <span class="k">def</span> <span class="nf">plot_shear_force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a plot for Shear force present in the Beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        subs : dictionary</span>
<span class="sd">            Python dictionary containing Symbols as key and their</span>
<span class="sd">            corresponding values.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 8 meters. A constant distributed load of 10 KN/m</span>
<span class="sd">        is applied from half of the beam till the end. There are two simple supports</span>
<span class="sd">        below the beam, one at the starting point and another at the ending point</span>
<span class="sd">        of the beam. A pointload of magnitude 5 KN is also applied from top of the</span>
<span class="sd">        beam, at a distance of 4 meters from the starting point.</span>
<span class="sd">        Take E = 200 GPa and I = 400*(10**-6) meter**4.</span>

<span class="sd">        Using the sign convention of downwards forces being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(8, 200*(10**9), 400*(10**-6))</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(5000, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 8, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(10000, 4, 0, end=8)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(0, 0), (8, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.plot_shear_force()</span>
<span class="sd">        Plot object containing:</span>
<span class="sd">        [0]: cartesian line: -13750*SingularityFunction(x, 0, 0) + 5000*SingularityFunction(x, 2, 0)</span>
<span class="sd">        + 10000*SingularityFunction(x, 4, 1) - 31250*SingularityFunction(x, 8, 0)</span>
<span class="sd">        - 10000*SingularityFunction(x, 8, 1) for x over (0.0, 8.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shear_force</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear_force</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">subs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">shear_force</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value of </span><span class="si">%s</span><span class="s1"> was not passed.&#39;</span> <span class="o">%</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">subs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">plot</span><span class="p">(</span><span class="n">shear_force</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Shear Force&#39;</span><span class="p">,</span>
                <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Value&#39;</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.plot_bending_moment"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.plot_bending_moment">[docs]</a>    <span class="k">def</span> <span class="nf">plot_bending_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a plot for Bending moment present in the Beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        subs : dictionary</span>
<span class="sd">            Python dictionary containing Symbols as key and their</span>
<span class="sd">            corresponding values.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 8 meters. A constant distributed load of 10 KN/m</span>
<span class="sd">        is applied from half of the beam till the end. There are two simple supports</span>
<span class="sd">        below the beam, one at the starting point and another at the ending point</span>
<span class="sd">        of the beam. A pointload of magnitude 5 KN is also applied from top of the</span>
<span class="sd">        beam, at a distance of 4 meters from the starting point.</span>
<span class="sd">        Take E = 200 GPa and I = 400*(10**-6) meter**4.</span>

<span class="sd">        Using the sign convention of downwards forces being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(8, 200*(10**9), 400*(10**-6))</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(5000, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 8, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(10000, 4, 0, end=8)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(0, 0), (8, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.plot_bending_moment()</span>
<span class="sd">        Plot object containing:</span>
<span class="sd">        [0]: cartesian line: -13750*SingularityFunction(x, 0, 1) + 5000*SingularityFunction(x, 2, 1)</span>
<span class="sd">        + 5000*SingularityFunction(x, 4, 2) - 31250*SingularityFunction(x, 8, 1)</span>
<span class="sd">        - 5000*SingularityFunction(x, 8, 2) for x over (0.0, 8.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bending_moment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">subs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">bending_moment</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value of </span><span class="si">%s</span><span class="s1"> was not passed.&#39;</span> <span class="o">%</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">subs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">plot</span><span class="p">(</span><span class="n">bending_moment</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Bending Moment&#39;</span><span class="p">,</span>
                <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Value&#39;</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.plot_slope"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.plot_slope">[docs]</a>    <span class="k">def</span> <span class="nf">plot_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a plot for slope of deflection curve of the Beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        subs : dictionary</span>
<span class="sd">            Python dictionary containing Symbols as key and their</span>
<span class="sd">            corresponding values.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 8 meters. A constant distributed load of 10 KN/m</span>
<span class="sd">        is applied from half of the beam till the end. There are two simple supports</span>
<span class="sd">        below the beam, one at the starting point and another at the ending point</span>
<span class="sd">        of the beam. A pointload of magnitude 5 KN is also applied from top of the</span>
<span class="sd">        beam, at a distance of 4 meters from the starting point.</span>
<span class="sd">        Take E = 200 GPa and I = 400*(10**-6) meter**4.</span>

<span class="sd">        Using the sign convention of downwards forces being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(8, 200*(10**9), 400*(10**-6))</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(5000, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 8, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(10000, 4, 0, end=8)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(0, 0), (8, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.plot_slope()</span>
<span class="sd">        Plot object containing:</span>
<span class="sd">        [0]: cartesian line: -8.59375e-5*SingularityFunction(x, 0, 2) + 3.125e-5*SingularityFunction(x, 2, 2)</span>
<span class="sd">        + 2.08333333333333e-5*SingularityFunction(x, 4, 3) - 0.0001953125*SingularityFunction(x, 8, 2)</span>
<span class="sd">        - 2.08333333333333e-5*SingularityFunction(x, 8, 3) + 0.00138541666666667 for x over (0.0, 8.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">subs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">slope</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value of </span><span class="si">%s</span><span class="s1"> was not passed.&#39;</span> <span class="o">%</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">subs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">plot</span><span class="p">(</span><span class="n">slope</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Slope&#39;</span><span class="p">,</span>
                <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Value&#39;</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.plot_deflection"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.plot_deflection">[docs]</a>    <span class="k">def</span> <span class="nf">plot_deflection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a plot for deflection curve of the Beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        subs : dictionary</span>
<span class="sd">            Python dictionary containing Symbols as key and their</span>
<span class="sd">            corresponding values.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 8 meters. A constant distributed load of 10 KN/m</span>
<span class="sd">        is applied from half of the beam till the end. There are two simple supports</span>
<span class="sd">        below the beam, one at the starting point and another at the ending point</span>
<span class="sd">        of the beam. A pointload of magnitude 5 KN is also applied from top of the</span>
<span class="sd">        beam, at a distance of 4 meters from the starting point.</span>
<span class="sd">        Take E = 200 GPa and I = 400*(10**-6) meter**4.</span>

<span class="sd">        Using the sign convention of downwards forces being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(8, 200*(10**9), 400*(10**-6))</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(5000, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 8, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(10000, 4, 0, end=8)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(0, 0), (8, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; b.plot_deflection()</span>
<span class="sd">        Plot object containing:</span>
<span class="sd">        [0]: cartesian line: 0.00138541666666667*x - 2.86458333333333e-5*SingularityFunction(x, 0, 3)</span>
<span class="sd">        + 1.04166666666667e-5*SingularityFunction(x, 2, 3) + 5.20833333333333e-6*SingularityFunction(x, 4, 4)</span>
<span class="sd">        - 6.51041666666667e-5*SingularityFunction(x, 8, 3) - 5.20833333333333e-6*SingularityFunction(x, 8, 4)</span>
<span class="sd">        for x over (0.0, 8.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deflection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deflection</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">subs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">deflection</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value of </span><span class="si">%s</span><span class="s1"> was not passed.&#39;</span> <span class="o">%</span><span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">subs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">plot</span><span class="p">(</span><span class="n">deflection</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span>
                    <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Deflection&#39;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;position&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Value&#39;</span><span class="p">,</span>
                    <span class="n">line_color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam.plot_loading_results"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam.plot_loading_results">[docs]</a>    <span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="s1">&#39;matplotlib&#39;</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">plot_loading_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns Axes object containing subplots of Shear Force, Bending Moment,</span>
<span class="sd">        Slope and Deflection of the Beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        subs : dictionary</span>
<span class="sd">            Python dictionary containing Symbols as key and their</span>
<span class="sd">            corresponding values.</span>

<span class="sd">        .. note::</span>
<span class="sd">           This method only works if numpy and matplotlib libraries</span>
<span class="sd">           are installed on the system.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 8 meters. A constant distributed load of 10</span>
<span class="sd">        KN/m is applied from half of the beam till the end. There are two</span>
<span class="sd">        simple supports below the beam, one at the starting point and another</span>
<span class="sd">        at the ending point of the beam. A pointload of magnitude 5 KN is also</span>
<span class="sd">        applied from top of the beam, at a distance of 4 meters from the</span>
<span class="sd">        starting point.  Take E = 200 GPa and I = 400*(10**-6) meter**4.</span>

<span class="sd">        Using the sign convention of downwards forces being positive.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; R1, R2 = symbols(&#39;R1, R2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam(8, 200*(10**9), 400*(10**-6))</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(5000, 2, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, 0, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, 8, -1)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(10000, 4, 0, end=8)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(0, 0), (8, 0)]</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2)</span>
<span class="sd">        &gt;&gt;&gt; axes = b.plot_loading_results()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">matplotlib</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;Install matplotlib to use this method.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">pyplot</span>
        <span class="k">if</span> <span class="n">numpy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s1">&#39;Install numpy to use this method.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">linspace</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span>

        <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="k">if</span> <span class="n">subs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deflection</span><span class="p">()</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Value of </span><span class="si">%s</span><span class="s1"> was not passed.&#39;</span> <span class="o">%</span> <span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="ow">in</span> <span class="n">subs</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">subs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

        <span class="c1"># As we are using matplotlib directly in this method, we need to change</span>
        <span class="c1"># SymPy methods to numpy functions.</span>
        <span class="n">shear</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">shear_force</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">),</span>
                         <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="n">moment</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">),</span>
                          <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">),</span>
                         <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="n">deflection</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">deflection</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">),</span>
                              <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="o">*</span><span class="n">length</span><span class="p">)</span>

        <span class="c1"># Creating a grid for subplots with 2 rows and 2 columns</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># axs is a 2D-numpy array containing axes</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">shear</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Shear Force&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">moment</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Bending Moment&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">slope</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Slope&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">deflection</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Deflection&quot;</span><span class="p">)</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>    <span class="c1"># For better spacing between subplots</span>
        <span class="k">return</span> <span class="n">axs</span></div></div>


<div class="viewcode-block" id="Beam3D"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D">[docs]</a><span class="k">class</span> <span class="nc">Beam3D</span><span class="p">(</span><span class="n">Beam</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class handles loads applied in any direction of a 3D space along</span>
<span class="sd">    with unequal values of Second moment along different axes.</span>

<span class="sd">    .. note::</span>
<span class="sd">       While solving a beam bending problem, a user should choose its</span>
<span class="sd">       own sign convention and should stick to it. The results will</span>
<span class="sd">       automatically follow the chosen sign convention.</span>
<span class="sd">       This class assumes that any kind of distributed load/moment is</span>
<span class="sd">       applied through out the span of a beam.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    There is a beam of l meters long. A constant distributed load of magnitude q</span>
<span class="sd">    is applied along y-axis from start till the end of beam. A constant distributed</span>
<span class="sd">    moment of magnitude m is also applied along z-axis from start till the end of beam.</span>
<span class="sd">    Beam is fixed at both of its end. So, deflection of the beam at the both ends</span>
<span class="sd">    is restricted.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam3D</span>
<span class="sd">    &gt;&gt;&gt; from sympy import symbols, simplify</span>
<span class="sd">    &gt;&gt;&gt; l, E, G, I, A = symbols(&#39;l, E, G, I, A&#39;)</span>
<span class="sd">    &gt;&gt;&gt; b = Beam3D(l, E, G, I, A)</span>
<span class="sd">    &gt;&gt;&gt; x, q, m = symbols(&#39;x, q, m&#39;)</span>
<span class="sd">    &gt;&gt;&gt; b.apply_load(q, 0, 0, dir=&quot;y&quot;)</span>
<span class="sd">    &gt;&gt;&gt; b.apply_moment_load(m, 0, -1, dir=&quot;z&quot;)</span>
<span class="sd">    &gt;&gt;&gt; b.shear_force()</span>
<span class="sd">    [0, -q*x, 0]</span>
<span class="sd">    &gt;&gt;&gt; b.bending_moment()</span>
<span class="sd">    [0, 0, -m*x + q*x**2/2]</span>
<span class="sd">    &gt;&gt;&gt; b.bc_slope = [(0, [0, 0, 0]), (l, [0, 0, 0])]</span>
<span class="sd">    &gt;&gt;&gt; b.bc_deflection = [(0, [0, 0, 0]), (l, [0, 0, 0])]</span>
<span class="sd">    &gt;&gt;&gt; b.solve_slope_deflection()</span>
<span class="sd">    &gt;&gt;&gt; b.slope()</span>
<span class="sd">    [0, 0, l*x*(-l*q + 3*l*(A*G*l*(l*q - 2*m) + 12*E*I*q)/(2*(A*G*l**2 + 12*E*I)) + 3*m)/(6*E*I)</span>
<span class="sd">    + q*x**3/(6*E*I) + x**2*(-l*(A*G*l*(l*q - 2*m) + 12*E*I*q)/(2*(A*G*l**2 + 12*E*I))</span>
<span class="sd">    - m)/(2*E*I)]</span>
<span class="sd">    &gt;&gt;&gt; dx, dy, dz = b.deflection()</span>
<span class="sd">    &gt;&gt;&gt; dx</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; dz</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; expectedy = (</span>
<span class="sd">    ... -l**2*q*x**2/(12*E*I) + l**2*x**2*(A*G*l*(l*q - 2*m) + 12*E*I*q)/(8*E*I*(A*G*l**2 + 12*E*I))</span>
<span class="sd">    ... + l*m*x**2/(4*E*I) - l*x**3*(A*G*l*(l*q - 2*m) + 12*E*I*q)/(12*E*I*(A*G*l**2 + 12*E*I)) - m*x**3/(6*E*I)</span>
<span class="sd">    ... + q*x**4/(24*E*I) + l*x*(A*G*l*(l*q - 2*m) + 12*E*I*q)/(2*A*G*(A*G*l**2 + 12*E*I)) - q*x**2/(2*A*G)</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; simplify(dy - expectedy)</span>
<span class="sd">    0</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [1] http://homes.civil.aau.dk/jc/FemteSemester/Beams3D.pdf</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">elastic_modulus</span><span class="p">,</span> <span class="n">shear_modulus</span> <span class="p">,</span> <span class="n">second_moment</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;Initializes the class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        length : Sympifyable</span>
<span class="sd">            A Symbol or value representing the Beam&#39;s length.</span>
<span class="sd">        elastic_modulus : Sympifyable</span>
<span class="sd">            A SymPy expression representing the Beam&#39;s Modulus of Elasticity.</span>
<span class="sd">            It is a measure of the stiffness of the Beam material.</span>
<span class="sd">        shear_modulus : Sympifyable</span>
<span class="sd">            A SymPy expression representing the Beam&#39;s Modulus of rigidity.</span>
<span class="sd">            It is a measure of rigidity of the Beam material.</span>
<span class="sd">        second_moment : Sympifyable or list</span>
<span class="sd">            A list of two elements having SymPy expression representing the</span>
<span class="sd">            Beam&#39;s Second moment of area. First value represent Second moment</span>
<span class="sd">            across y-axis and second across z-axis.</span>
<span class="sd">            Single SymPy expression can be passed if both values are same</span>
<span class="sd">        area : Sympifyable</span>
<span class="sd">            A SymPy expression representing the Beam&#39;s cross-sectional area</span>
<span class="sd">            in a plane prependicular to length of the Beam.</span>
<span class="sd">        variable : Symbol, optional</span>
<span class="sd">            A Symbol object that will be used as the variable along the beam</span>
<span class="sd">            while representing the load, shear, moment, slope and deflection</span>
<span class="sd">            curve. By default, it is set to ``Symbol(&#39;x&#39;)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elastic_modulus</span> <span class="o">=</span> <span class="n">elastic_modulus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shear_modulus</span> <span class="o">=</span> <span class="n">shear_modulus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second_moment</span> <span class="o">=</span> <span class="n">second_moment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="n">area</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;deflection&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;slope&#39;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_Singularity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slope</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deflection</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shear_modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Young&#39;s Modulus of the Beam. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shear_modulus</span>

    <span class="nd">@shear_modulus</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">shear_modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shear_modulus</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">second_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Second moment of area of the Beam. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_second_moment</span>

    <span class="nd">@second_moment</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">second_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_second_moment</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_second_moment</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cross-sectional area of the Beam. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_area</span>

    <span class="nd">@area</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_area</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">load_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a three element list representing the load vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_vector</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">moment_load_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a three element list representing moment loads on Beam.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">boundary_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary of boundary conditions applied on the beam.</span>
<span class="sd">        The dictionary has two keywords namely slope and deflection.</span>
<span class="sd">        The value of each keyword is a list of tuple, where each tuple</span>
<span class="sd">        contains loaction and value of a boundary condition in the format</span>
<span class="sd">        (location, value). Further each value is a list corresponding to</span>
<span class="sd">        slope or deflection(s) values along three axes at that location.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 4 meters. The slope at 0 should be 4 along</span>
<span class="sd">        the x-axis and 0 along others. At the other end of beam, deflection</span>
<span class="sd">        along all the three axes should be zero.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam3D</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; l, E, G, I, A, x = symbols(&#39;l, E, G, I, A, x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam3D(30, E, G, I, A, x)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_slope = [(0, (4, 0, 0))]</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(4, [0, 0, 0])]</span>
<span class="sd">        &gt;&gt;&gt; b.boundary_conditions</span>
<span class="sd">        {&#39;deflection&#39;: [(4, [0, 0, 0])], &#39;slope&#39;: [(0, (4, 0, 0))]}</span>

<span class="sd">        Here the deflection of the beam should be ``0`` along all the three axes at ``4``.</span>
<span class="sd">        Similarly, the slope of the beam should be ``4`` along x-axis and ``0``</span>
<span class="sd">        along y and z axis at ``0``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span>

<div class="viewcode-block" id="Beam3D.apply_load"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.apply_load">[docs]</a>    <span class="k">def</span> <span class="nf">apply_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method adds up the force load to a particular beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        value : Sympifyable</span>
<span class="sd">            The magnitude of an applied load.</span>
<span class="sd">        dir : String</span>
<span class="sd">            Axis along which load is applied.</span>
<span class="sd">        order : Integer</span>
<span class="sd">            The order of the applied load.</span>
<span class="sd">            - For point loads, order=-1</span>
<span class="sd">            - For constant distributed load, order=0</span>
<span class="sd">            - For ramp loads, order=1</span>
<span class="sd">            - For parabolic ramp loads, order=2</span>
<span class="sd">            - ... so on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_Singularity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_Singularity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_Singularity</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam3D.apply_moment_load"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.apply_moment_load">[docs]</a>    <span class="k">def</span> <span class="nf">apply_moment_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method adds up the moment loads to a particular beam object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>
<span class="sd">        value : Sympifyable</span>
<span class="sd">            The magnitude of an applied moment.</span>
<span class="sd">        dir : String</span>
<span class="sd">            Axis along which moment is applied.</span>
<span class="sd">        order : Integer</span>
<span class="sd">            The order of the applied load.</span>
<span class="sd">            - For point moments, order=-2</span>
<span class="sd">            - For constant distributed moment, order=-1</span>
<span class="sd">            - For ramp moments, order=0</span>
<span class="sd">            - For parabolic ramp moments, order=1</span>
<span class="sd">            - ... so on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_Singularity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_Singularity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_Singularity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span><span class="o">*</span><span class="n">SingularityFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">apply_support</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;fixed&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;pin&quot;</span> <span class="ow">or</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;roller&quot;</span><span class="p">:</span>
            <span class="n">reaction_load</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;R_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="p">[</span><span class="n">reaction_load</span><span class="p">]</span> <span class="o">=</span> <span class="n">reaction_load</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_deflection</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reaction_load</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;R_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
            <span class="n">reaction_moment</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;M_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">loc</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="p">[</span><span class="n">reaction_load</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">reaction_load</span><span class="p">,</span> <span class="n">reaction_moment</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_deflection</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_slope</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>

<div class="viewcode-block" id="Beam3D.solve_for_reaction_loads"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.solve_for_reaction_loads">[docs]</a>    <span class="k">def</span> <span class="nf">solve_for_reaction_loads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">reaction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves for the reaction forces.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        There is a beam of length 30 meters. It it supported by rollers at</span>
<span class="sd">        of its end. A constant distributed load of magnitude 8 N is applied</span>
<span class="sd">        from start till its end along y-axis. Another linear load having</span>
<span class="sd">        slope equal to 9 is applied along z-axis.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.continuum_mechanics.beam import Beam3D</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; l, E, G, I, A, x = symbols(&#39;l, E, G, I, A, x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Beam3D(30, E, G, I, A, x)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(8, start=0, order=0, dir=&quot;y&quot;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(9*x, start=0, order=0, dir=&quot;z&quot;)</span>
<span class="sd">        &gt;&gt;&gt; b.bc_deflection = [(0, [0, 0, 0]), (30, [0, 0, 0])]</span>
<span class="sd">        &gt;&gt;&gt; R1, R2, R3, R4 = symbols(&#39;R1, R2, R3, R4&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R1, start=0, order=-1, dir=&quot;y&quot;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R2, start=30, order=-1, dir=&quot;y&quot;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R3, start=0, order=-1, dir=&quot;z&quot;)</span>
<span class="sd">        &gt;&gt;&gt; b.apply_load(R4, start=30, order=-1, dir=&quot;z&quot;)</span>
<span class="sd">        &gt;&gt;&gt; b.solve_for_reaction_loads(R1, R2, R3, R4)</span>
<span class="sd">        &gt;&gt;&gt; b.reaction_loads</span>
<span class="sd">        {R1: -120, R2: -120, R3: -1350, R4: -2700}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">l</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_Singularity</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span>
        <span class="n">shear_curves</span> <span class="o">=</span> <span class="p">[</span><span class="n">integrate</span><span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">load</span> <span class="ow">in</span> <span class="n">q</span><span class="p">]</span>
        <span class="n">moment_curves</span> <span class="o">=</span> <span class="p">[</span><span class="n">integrate</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">shear</span> <span class="ow">in</span> <span class="n">shear_curves</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">react</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reaction</span> <span class="k">if</span> <span class="p">(</span><span class="n">shear_curves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">or</span> <span class="n">moment_curves</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">r</span><span class="p">))]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">react</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">shear_curve</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">shear_curves</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="n">moment_curve</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="n">moment_curves</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">linsolve</span><span class="p">([</span><span class="n">shear_curve</span><span class="p">,</span> <span class="n">moment_curve</span><span class="p">],</span> <span class="n">react</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">sol_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">react</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span>
            <span class="n">reaction_loads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span>
            <span class="c1"># Check if any of the evaluated rection exists in another direction</span>
            <span class="c1"># and if it exists then it should have same value.</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sol_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">reaction_loads</span> <span class="ow">and</span> <span class="n">sol_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">!=</span> <span class="n">reaction_loads</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ambiguous solution for </span><span class="si">%s</span><span class="s2"> in different directions.&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reaction_loads</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sol_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Beam3D.shear_force"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.shear_force">[docs]</a>    <span class="k">def</span> <span class="nf">shear_force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of three expressions which represents the shear force</span>
<span class="sd">        curve of the Beam object along all three axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_vector</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">),</span> <span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">),</span> <span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Beam3D.axial_force"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.axial_force">[docs]</a>    <span class="k">def</span> <span class="nf">axial_force</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns expression of Axial shear force present inside the Beam object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear_force</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Beam3D.bending_moment"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.bending_moment">[docs]</a>    <span class="k">def</span> <span class="nf">bending_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of three expressions which represents the bending moment</span>
<span class="sd">        curve of the Beam object along all three axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_vector</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span>
        <span class="n">shear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear_force</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">),</span> <span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shear</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">),</span>
                <span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="p">]</span></div>

<div class="viewcode-block" id="Beam3D.torsional_moment"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.torsional_moment">[docs]</a>    <span class="k">def</span> <span class="nf">torsional_moment</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns expression of Torsional moment present inside the Beam object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bending_moment</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">solve_slope_deflection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">Eq</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elastic_modulus</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear_modulus</span>
        <span class="n">I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_moment</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">I_y</span><span class="p">,</span> <span class="n">I_z</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">I_y</span> <span class="o">=</span> <span class="n">I_z</span> <span class="o">=</span> <span class="n">I</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">area</span>
        <span class="n">load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_vector</span>
        <span class="n">moment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_load_vector</span>
        <span class="n">defl</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;defl&#39;</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>

        <span class="c1"># Finding deflection along x-axis(and corresponding slope value by differentiating it)</span>
        <span class="c1"># Equation used: Derivative(E*A*Derivative(def_x(x), x), x) + load_x = 0</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">defl</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">load</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">def_x</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">defl</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Solving constants originated from dsolve</span>
        <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C1&#39;</span><span class="p">)</span>
        <span class="n">C2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C2&#39;</span><span class="p">)</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">linsolve</span><span class="p">([</span><span class="n">def_x</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">def_x</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)],</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">def_x</span> <span class="o">=</span> <span class="n">def_x</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C1</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C2</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
        <span class="n">slope_x</span> <span class="o">=</span> <span class="n">def_x</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deflection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">def_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slope</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">slope_x</span>

        <span class="c1"># Finding deflection along y-axis and slope across z-axis. System of equation involved:</span>
        <span class="c1"># 1: Derivative(E*I_z*Derivative(theta_z(x), x), x) + G*A*(Derivative(defl_y(x), x) - theta_z(x)) + moment_z = 0</span>
        <span class="c1"># 2: Derivative(G*A*(Derivative(defl_y(x), x) - theta_z(x)), x) + load_y = 0</span>
        <span class="n">C_i</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;C_i&#39;</span><span class="p">)</span>
        <span class="c1"># Substitute value of `G*A*(Derivative(defl_y(x), x) - theta_z(x))` from (2) in (1)</span>
        <span class="n">eq1</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I_z</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">theta</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="o">-</span><span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C_i</span><span class="p">)</span> <span class="o">+</span> <span class="n">moment</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">slope_z</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Solve for constants originated from using dsolve on eq1</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">linsolve</span><span class="p">([</span><span class="n">slope_z</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">slope_z</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)],</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">slope_z</span> <span class="o">=</span> <span class="n">slope_z</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C1</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C2</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>

        <span class="c1"># Put value of slope obtained back in (2) to solve for `C_i` and find deflection across y-axis</span>
        <span class="n">eq2</span> <span class="o">=</span> <span class="n">G</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">defl</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">load</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">C_i</span> <span class="o">-</span> <span class="n">G</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">slope_z</span>
        <span class="n">def_y</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">eq2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">defl</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Solve for constants originated from using dsolve on eq2</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">linsolve</span><span class="p">([</span><span class="n">def_y</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">def_y</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)],</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C_i</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deflection</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">def_y</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C1</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C_i</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slope</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">slope_z</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C_i</span><span class="p">,</span> <span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Finding deflection along z-axis and slope across y-axis. System of equation involved:</span>
        <span class="c1"># 1: Derivative(E*I_y*Derivative(theta_y(x), x), x) - G*A*(Derivative(defl_z(x), x) + theta_y(x)) + moment_y = 0</span>
        <span class="c1"># 2: Derivative(G*A*(Derivative(defl_z(x), x) + theta_y(x)), x) + load_z = 0</span>

        <span class="c1"># Substitute value of `G*A*(Derivative(defl_y(x), x) + theta_z(x))` from (2) in (1)</span>
        <span class="n">eq1</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">I_y</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">theta</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">C_i</span><span class="p">)</span> <span class="o">+</span> <span class="n">moment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">slope_y</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Solve for constants originated from using dsolve on eq1</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">linsolve</span><span class="p">([</span><span class="n">slope_y</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">slope_y</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)],</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">slope_y</span> <span class="o">=</span> <span class="n">slope_y</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C1</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C2</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>

        <span class="c1"># Put value of slope obtained back in (2) to solve for `C_i` and find deflection across z-axis</span>
        <span class="n">eq2</span> <span class="o">=</span> <span class="n">G</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">defl</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">load</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">C_i</span> <span class="o">+</span> <span class="n">G</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">slope_y</span>
        <span class="n">def_z</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">eq2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Solve for constants originated from using dsolve on eq2</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">linsolve</span><span class="p">([</span><span class="n">def_z</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">def_z</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">)],</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C_i</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deflection</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">def_z</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">C1</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C_i</span><span class="p">:</span><span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slope</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">slope_y</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C_i</span><span class="p">,</span> <span class="n">constants</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<div class="viewcode-block" id="Beam3D.slope"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.slope">[docs]</a>    <span class="k">def</span> <span class="nf">slope</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a three element list representing slope of deflection curve</span>
<span class="sd">        along all the three axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slope</span></div>

<div class="viewcode-block" id="Beam3D.deflection"><a class="viewcode-back" href="../../../../modules/physics/continuum_mechanics/beam.html#sympy.physics.continuum_mechanics.beam.Beam3D.deflection">[docs]</a>    <span class="k">def</span> <span class="nf">deflection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a three element list representing deflection curve along all</span>
<span class="sd">        the three axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deflection</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../index.html">SymPy 1.4.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018 SymPy Development Team.
      Last updated on Feb 18, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>