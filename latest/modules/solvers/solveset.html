

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Solveset &mdash; SymPy 1.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 1.0 documentation" href="../../index.html" />
    <link rel="up" title="SymPy Modules Reference" href="../index.html" />
    <link rel="next" title="Tensor Module" href="../tensor/index.html" />
    <link rel="prev" title="Inequality Solvers" href="inequalities.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../tensor/index.html" title="Tensor Module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="inequalities.html" title="Inequality Solvers"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">SymPy 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-sympy.solvers.solveset">
<span id="solveset"></span><h1>Solveset<a class="headerlink" href="#module-sympy.solvers.solveset" title="Permalink to this headline">¶</a></h1>
<p>This is the official documentation of the <tt class="docutils literal"><span class="pre">solveset</span></tt> module in solvers.
It contains the frequently asked questions about our new module to solve
equations.</p>
<div class="section" id="what-s-wrong-with-solve">
<h2>What&#8217;s wrong with solve():<a class="headerlink" href="#what-s-wrong-with-solve" title="Permalink to this headline">¶</a></h2>
<p>SymPy already has a pretty powerful <tt class="docutils literal"><span class="pre">solve</span></tt> function. But it has a lot of major
issues</p>
<ol class="arabic simple">
<li>It doesn&#8217;t have a consistent output for various types of solutions
It needs to return a lot of types of solutions consistently:<ul>
<li>Single solution : <span class="math">\(x = 1\)</span></li>
<li>Multiple solutions: <span class="math">\(x^2 = 1\)</span></li>
<li>No Solution: <span class="math">\(x^2 + 1 = 0 ; x \in \mathbb{R}\)</span></li>
<li>Interval of solution: <span class="math">\(\lfloor x \rfloor = 0\)</span></li>
<li>Infinitely many solutions: <span class="math">\(sin(x) = 0\)</span></li>
<li>Multivariate functions with point solutions: <span class="math">\(x^2 + y^2 = 0\)</span></li>
<li>Multivariate functions with non-point solution: <span class="math">\(x^2 + y^2 = 1\)</span></li>
<li>System of equations: <span class="math">\(x + y = 1\)</span> and <span class="math">\(x - y = 0\)</span></li>
<li>Relational: <span class="math">\(x &gt; 0\)</span></li>
<li>And the most important case: &#8220;We don&#8217;t Know&#8221;</li>
</ul>
</li>
<li>The input API is also a mess, there are a lot of parameters. Many of them
are not needed and they make it hard for the user and the developers to
work on solvers.</li>
<li>There are cases like finding the maxima and minima of function using
critical points where it is important to know if it has returned all the
solutions. <tt class="docutils literal"><span class="pre">solve</span></tt> does not guarantee this.</li>
</ol>
</div>
<div class="section" id="why-solveset">
<h2>Why Solveset?<a class="headerlink" href="#why-solveset" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">solveset</span></tt> has a cleaner input and output interface: <tt class="docutils literal"><span class="pre">solveset</span></tt> returns
a set object and a set object takes care of all types of output. For
cases where it doesn&#8217;t &#8220;know&#8221; all the solutions a <tt class="docutils literal"><span class="pre">ConditionSet</span></tt> with a partial
solution is returned. For input it only takes the equation, the variables
to solve for and the optional argument <tt class="docutils literal"><span class="pre">domain</span></tt> over which the equation is to
be solved.</li>
<li><tt class="docutils literal"><span class="pre">solveset</span></tt> can return infinitely many solutions. For example solving for
<span class="math">\(\sin{(x)} = 0\)</span> returns <span class="math">\(\{2 n \pi | n \in \mathbb{Z}\} \cup \{2 n \pi + \pi | n \in \mathbb{Z}\}\)</span>,
whereas <tt class="docutils literal"><span class="pre">solve</span></tt> only returns <span class="math">\([0, \pi]\)</span>.</li>
<li>There is a clear code level and interface level separation between solvers
for equations in the complex domain and the real domain. For example
solving <span class="math">\(e^x = 1\)</span> when <span class="math">\(x\)</span> is to be solved in the complex domain, returns
the set of all solutions, that is <span class="math">\(\{2 n i \pi | n \in \mathbb{Z}\}\)</span>, whereas
if <span class="math">\(x\)</span> is to be solved in the real domain then only <span class="math">\(\{0\}\)</span> is returned.</li>
</ul>
</div>
<div class="section" id="why-do-we-use-sets-as-an-output-type">
<h2>Why do we use Sets as an output type?<a class="headerlink" href="#why-do-we-use-sets-as-an-output-type" title="Permalink to this headline">¶</a></h2>
<p>SymPy has a well developed sets module, which can represent most of the set
containers in Mathematics such as:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">FiniteSet</span></tt></p>
<p>Represents a finite set of discrete numbers.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Interval</span></tt></p>
<p>Represents a real interval as a set.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ProductSet</span></tt></p>
<p>Represents a Cartesian product of sets.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ImageSet</span></tt></p>
<p>Represents the image of a set under a mathematical function</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ImageSet</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="n">ImageSet</span><span class="p">(</span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Naturals</span><span class="p">)</span>  <span class="c1"># {x**2 for x in N}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="ow">in</span> <span class="n">squares</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ComplexRegion</span></tt></p>
<p>Represents the set of all complex numbers in a region in the Argand plane.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">ConditionSet</span></tt></p>
<p>Represents the set of elements, which satisfies a given condition.</p>
</li>
</ul>
</div></blockquote>
<p>Also, the predefined set classes such as:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">Naturals</span></tt> <span class="math">\(\mathbb{N}\)</span></p>
<p>Represents the natural numbers (or counting numbers), which are all
positive integers starting from 1.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Naturals0</span></tt> <span class="math">\(\mathbb{N_0}\)</span></p>
<p>Represents the whole numbers, which are all the non-negative integers,
inclusive of 0.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Integers</span></tt> <span class="math">\(\mathbb{Z}\)</span></p>
<p>Represents all integers: positive, negative and zero.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Reals</span></tt> <span class="math">\(\mathbb{R}\)</span></p>
<p>Represents the set of all real numbers.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">Complexes</span></tt> <span class="math">\(\mathbb{C}\)</span></p>
<p>Represents the set of all complex numbers.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">EmptySet</span></tt> <span class="math">\(\phi\)</span></p>
<p>Represents the empty set.</p>
</li>
</ul>
<p>The above six sets are available as Singletons, like <tt class="docutils literal"><span class="pre">S.Integers</span></tt>.</p>
</div></blockquote>
<p>It is capable of most of the set operations in mathematics:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">Union</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Intersection</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Complement</span></tt></li>
<li><tt class="docutils literal"><span class="pre">SymmetricDifference</span></tt></li>
</ul>
</div></blockquote>
<p>The main reason for using sets as output to solvers is that it can consistently
represent many types of solutions. For the single variable case it can represent:</p>
<blockquote>
<div><ul class="simple">
<li>No solution (by the empty set).</li>
<li>Finitely many solutions (by <tt class="docutils literal"><span class="pre">FiniteSet</span></tt>).</li>
<li>Infinitely many solutions, both countably and uncountably infinite solutions
(using the <tt class="docutils literal"><span class="pre">ImageSet</span></tt> module).</li>
<li><tt class="docutils literal"><span class="pre">Interval</span></tt></li>
<li>There can also be bizarre solutions to equations like the set of rational
numbers.</li>
</ul>
</div></blockquote>
<p>No other Python object (list, dictionary, generator, Python sets) provides the
flexibility of mathematical sets which our sets module tries to emulate. The
second reason to use sets is that they are close to the entities which
mathematicians deal with and it makes it easier to reason about them.  Set
objects conform to Pythonic conventions when possible, i.e., <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span></tt> and
<tt class="docutils literal"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">A</span></tt> both work when they can be computed. Another advantage of using
objects closer to mathematical entities is that the user won&#8217;t have to &#8220;learn&#8221;
our representation and she can have her expectations transferred from her
mathematical experience.</p>
<p>For the multivariate case we represent solutions as a set of points in a
n-dimensional space and a point is represented by a <tt class="docutils literal"><span class="pre">FiniteSet</span></tt> of ordered
tuples, which is a point in <span class="math">\(\mathbb{R}^n\)</span> or <span class="math">\(\mathbb{C}^n\)</span>.</p>
<p>Please note that, the general <tt class="docutils literal"><span class="pre">FiniteSet</span></tt> is unordered, but a <tt class="docutils literal"><span class="pre">FiniteSet</span></tt>
with a tuple as its only argument becomes ordered, since a tuple is ordered.
So the order in the tuple is mapped to a pre-defined order of variables
while returning solutions.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">FiniteSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FiniteSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1"># Unordered</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FiniteSet</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># Ordered</span>
<span class="go">{(1, 2, 3)}</span>
</pre></div>
</div>
<p>Why not use dicts as output?</p>
<blockquote>
<div><p>Dictionary are easy to deal with programatically but mathematically they are
not very precise and use of them can quickly lead to inconsistency and a lot
of confusion. For example:</p>
<ul>
<li><p class="first">There are a lot of cases where we don&#8217;t know the complete solution and we
may like to output a partial solution, consider the equation <span class="math">\(fg = 0\)</span>. The
solution of this equation is the union of the solution of the following
two equations: <span class="math">\(f = 0\)</span>, <span class="math">\(g = 0\)</span>. Let&#8217;s say that we are able to solve
<span class="math">\(f = 0\)</span> but solving <span class="math">\(g = 0\)</span> isn&#8217;t supported yet. In this case we cannot
represent partial solution of the given equation <span class="math">\(fg = 0\)</span> using dicts.
This problem is solved with sets using a <tt class="docutils literal"><span class="pre">ConditionSet</span></tt> object:</p>
<p><span class="math">\(sol_f \cup \{x | x ∊ \mathbb{R} ∧ g = 0\}\)</span>, where <span class="math">\(sol_f\)</span> is the solution
of the equation <span class="math">\(f = 0\)</span>.</p>
</li>
<li><p class="first">Using a dict may lead to surprising results like:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">solve(Eq(x**2,</span> <span class="pre">1),</span> <span class="pre">x)</span> <span class="pre">!=</span> <span class="pre">solve(Eq(y**2,</span> <span class="pre">1),</span> <span class="pre">y)</span></tt></p>
<p>Mathematically, this doesn&#8217;t make sense. Using <tt class="docutils literal"><span class="pre">FiniteSet</span></tt> here
solves the problem.</p>
</li>
</ul>
</li>
<li><p class="first">It also cannot represent solutions for equations like <span class="math">\(|x| &lt; 1\)</span>, which is
a disk of radius 1 in the Argand Plane. This problem is solved using
complex sets implemented as <tt class="docutils literal"><span class="pre">ComplexRegion</span></tt>.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="input-api-of-solveset">
<h2>Input API of <tt class="docutils literal"><span class="pre">solveset</span></tt><a class="headerlink" href="#input-api-of-solveset" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">solveset</span></tt> has a cleaner input API, unlike <tt class="docutils literal"><span class="pre">solve</span></tt>. It takes a maximum
of three arguments:</p>
<p><tt class="docutils literal"><span class="pre">solveset(equation,</span> <span class="pre">variable=None,</span> <span class="pre">domain=S.Complexes)</span></tt></p>
<ul>
<li><p class="first">Equation(s)</p>
<p>The equation(s) to solve.</p>
</li>
<li><p class="first">Variable(s)</p>
<p>The variable(s) for which the equation is to be solved.</p>
</li>
<li><p class="first">Domain</p>
<p>The domain in which the equation is to be solved.</p>
</li>
</ul>
<blockquote>
<div><tt class="docutils literal"><span class="pre">solveset</span></tt> removes the <tt class="docutils literal"><span class="pre">flags</span></tt> argument of <tt class="docutils literal"><span class="pre">solve</span></tt>, which had made
the input API messy and output API inconsistent.</div></blockquote>
</div>
<div class="section" id="what-is-this-domain-argument-about">
<h2>What is this domain argument about?<a class="headerlink" href="#what-is-this-domain-argument-about" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset is designed to be independent of the assumptions on the
variable being solved for and instead, uses the <tt class="docutils literal"><span class="pre">domain</span></tt> argument to
decide the solver to dispatch the equation to, namely <tt class="docutils literal"><span class="pre">solveset_real</span></tt>
or <tt class="docutils literal"><span class="pre">solveset_complex</span></tt>. It&#8217;s unlike the old <tt class="docutils literal"><span class="pre">solve</span></tt> which considers the
assumption on the variable.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solveset</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># domain=S.Complexes is default</span>
<span class="go">{-I, I}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">EmptySet()</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="what-are-the-general-methods-employed-by-solveset-to-solve-an-equation">
<h2>What are the general methods employed by solveset to solve an equation?<a class="headerlink" href="#what-are-the-general-methods-employed-by-solveset-to-solve-an-equation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset uses various methods to solve an equation, here is a brief overview
of the methodology:</p>
<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">domain</span></tt> argument is first considered to know the domain in which
the user is interested to get the solution.</li>
<li>If the given function is a relational (<tt class="docutils literal"><span class="pre">&gt;=</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;</span></tt>), and
the domain is real, then <tt class="docutils literal"><span class="pre">solve_univariate_inequality</span></tt> and solutions are
returned. Solving for complex solutions of inequalities, like <span class="math">\(x^2 &lt; 0\)</span>
is not yet supported.</li>
<li>Based on the <tt class="docutils literal"><span class="pre">domain</span></tt>, the equation is dispatched to one of the two
functions <tt class="docutils literal"><span class="pre">solveset_real</span></tt> or <tt class="docutils literal"><span class="pre">solveset_complex</span></tt>, which solves the
given equation in the complex or real domain, respectively.</li>
<li>If the given expression is a product of two or more functions,
like say <span class="math">\(gh = 0\)</span>, then the solution to the given equation is the Union
of the solution of the equations <span class="math">\(g = 0\)</span> and <span class="math">\(h = 0\)</span>, if and only if both
<span class="math">\(g\)</span> and <span class="math">\(h\)</span> are finite for a finite input. So, the solution is built up
recursively.</li>
<li>If the function is trigonometric or hyperbolic, the function
<tt class="docutils literal"><span class="pre">_solve_real_trig</span></tt> is called, which solves it by converting it to complex
exponential form.</li>
<li>The function is now checked if there is any instance of a <tt class="docutils literal"><span class="pre">Piecewise</span></tt>
expression, if it is, then it&#8217;s converted to explict expression and
set pairs and then solved recursively.</li>
<li>The respective solver now tries to invert the equation using the routines
<tt class="docutils literal"><span class="pre">invert_real</span></tt> and <tt class="docutils literal"><span class="pre">invert_complex</span></tt>. These routines are based on the
concept of mathematical inverse (though not exactly). It reduces the
real/complex valued equation <span class="math">\(f(x) = y\)</span> to a set of equations:
<span class="math">\(\{g(x)  = h_1(y), g(x) = h_2(y), ..., g(x) = h_n(y) \}\)</span> where <span class="math">\(g(x)\)</span> is a
simpler function than <span class="math">\(f(x)\)</span>. There is some work needed to be done in
this to find invert of more complex expressions.</li>
<li>After the invert, the equations are checked for radical or Abs (Modulus),
then the method <tt class="docutils literal"><span class="pre">_solve_radical</span></tt> tries to simplify the radical, by
removing it using techniques like squarring, cubing etc, and <tt class="docutils literal"><span class="pre">_solve_abs</span></tt>
solves nested Modulus by considering the positive and negative variants,
iteratively.</li>
<li>If none of the above method is successful, then methods of polynomial is
used as follows:<ul>
<li>The method to solve the rational function, <tt class="docutils literal"><span class="pre">_solve_as_rational</span></tt>, is
called.  Based on the domain, the respective poly solver
<tt class="docutils literal"><span class="pre">_solve_as_poly_real</span></tt> or <tt class="docutils literal"><span class="pre">_solve_as_poly_complex</span></tt> is called to solve
<tt class="docutils literal"><span class="pre">f</span></tt> as a polynomial.</li>
<li>The underlying method <tt class="docutils literal"><span class="pre">_solve_as_poly</span></tt> solves the equation using
polynomial techniques if it&#8217;s already a polynomial equation or, with
a change of variables, can be made so.</li>
</ul>
</li>
<li>The final solution set returned by <tt class="docutils literal"><span class="pre">solveset</span></tt> is the intersection of the
set of solutions found above and the input domain.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-do-we-manipulate-and-return-an-infinite-solution">
<h2>How do we manipulate and return an infinite solution?<a class="headerlink" href="#how-do-we-manipulate-and-return-an-infinite-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><p class="first">In the real domain, we use our <tt class="docutils literal"><span class="pre">ImageSet</span></tt> class in the sets module to
return infinite solutions. <tt class="docutils literal"><span class="pre">ImageSet</span></tt> is an image of a set under
a mathematical function. For example, to represent the solution
of the equation <span class="math">\(\sin{(x)} = 0\)</span>, we can use the <tt class="docutils literal"><span class="pre">ImageSet</span></tt> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ImageSet</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ImageSet</span><span class="p">(</span><span class="n">Lambda</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Integers</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{2⋅n⋅π | n ∊ ℤ}</span>
</pre></div>
</div>
<p>Where <tt class="docutils literal"><span class="pre">n</span></tt> is a dummy variable. It is basically the image of the
set of integers under the function <span class="math">\(2\pi n\)</span>.</p>
</li>
<li><p class="first">In the complex domain, we use complex sets, which are implemented as the
<tt class="docutils literal"><span class="pre">ComplexRegion</span></tt> class in the sets module, to represent infinite
solution in the Argand plane. For example to represent the solution
of the equation <span class="math">\(|z| = 1\)</span>, which is a unit circle, we can use
the <tt class="docutils literal"><span class="pre">ComplexRegion</span></tt> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ComplexRegion</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ComplexRegion</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">),</span> <span class="n">polar</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{r⋅(ⅈ⋅sin(θ) + cos(θ)) | r, θ ∊ {1} × [0, 2⋅π)}</span>
</pre></div>
</div>
<p>Where the <tt class="docutils literal"><span class="pre">FiniteSet</span></tt> in the <tt class="docutils literal"><span class="pre">ProductSet</span></tt> is the range of the value
of <span class="math">\(r\)</span>, which is the radius of the circle and the <tt class="docutils literal"><span class="pre">Interval</span></tt> is the range
of <span class="math">\(\theta\)</span>, the angle from the <span class="math">\(x\)</span> axis representing a unit circle in the
Argand plane.</p>
<p>Note: We also have non-polar form notation for representing solution
in rectangular form. For example, to represent first two quadrants in the
Argand plane, we can write the <tt class="docutils literal"><span class="pre">ComplexRegion</span></tt> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ComplexRegion</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ComplexRegion</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span><span class="o">*</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">)),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{x + y⋅ⅈ | x, y ∊ (-∞, ∞) × [0, ∞)}</span>
</pre></div>
</div>
<p>where the Intervals are the range of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> for the set of complex
numbers <span class="math">\(x + iy\)</span>.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution">
<h2>How does <tt class="docutils literal"><span class="pre">solveset</span></tt> ensure that it is not returning any wrong solution?<a class="headerlink" href="#how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solvers in a Computer Algebra System are based on heuristic algorithms,
so it&#8217;s usually very hard to ensure 100% percent correctness, in every
possible case. However there are still a lot of cases where we can ensure
correctness. Solveset tries to verify correctness wherever it can. For
example:</p>
<p>Consider the equation <span class="math">\(|x| = n\)</span>. A naive method to solve this equation
would return <tt class="docutils literal"><span class="pre">{-n,</span> <span class="pre">n}</span></tt> as its solution, which is not correct since
<tt class="docutils literal"><span class="pre">{-n,</span> <span class="pre">n}</span></tt> can be its solution if and only if <tt class="docutils literal"><span class="pre">n</span></tt> is positive.
Solveset returns this information as well to ensure correctness.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">([0, ∞) ∩ {n}) ∪ ((-∞, 0] ∩ {-n})</span>
</pre></div>
</div>
<p>Though, there still a lot of work needs to be done in this regard.</p>
</div></blockquote>
</div>
<div class="section" id="search-based-solver-and-step-by-step-solution">
<h2>Search based solver and step-by-step solution<a class="headerlink" href="#search-based-solver-and-step-by-step-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Note: This is under Development.</p>
<p>After the introduction of <tt class="xref py py-class docutils literal"><span class="pre">ConditionSet</span></tt>, the
solving of equations can be seen as set transformations. Here is an abstract
view of the things we can do to solve equations.</p>
<ul class="simple">
<li>Apply various set transformations on the given set.</li>
<li>Define a metric of the usability of solutions, or a notion of some
solutions being better than others.</li>
<li>Different transformations would be the nodes of a tree.</li>
<li>Suitable searching techniques could be applied to get the best solution.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">ConditionSet</span></tt> gives us the ability to represent unevaluated equations and
inequalities in forms like <span class="math">\(\{x|f(x)=0; x \in S\}\)</span> and <span class="math">\(\{x|f(x)&gt;0; x \in S\}\)</span>
but a more powerful thing about <tt class="docutils literal"><span class="pre">ConditionSet</span></tt> is that it allows us to write
the intermediate steps as set to set transformation. Some of the transformations
are:</p>
<ul>
<li><p class="first">Composition: <span class="math">\(\{x|f(g(x))=0;x \in S\} \Rightarrow \{x|g(x)=y; x \in S, y \in \{z|f(z)=0; z \in S\}\}\)</span></p>
</li>
<li><dl class="first docutils">
<dt>Polynomial Solver: <span class="math">\(\{x | P(x) = 0;x \in S\} \Rightarrow  \{x_1,x_2, ... ,x_n\} \cap S\)</span>,</dt>
<dd><p class="first last">where <span class="math">\(x_i\)</span> are roots of <span class="math">\(P(x)\)</span>.</p>
</dd>
</dl>
</li>
<li><p class="first">Invert solver: <span class="math">\(\{x|f(x)=0;x \in S\} \Rightarrow  \{g(0)| \text{ all g such that } f(g(x)) = x\}\)</span></p>
</li>
<li><dl class="first docutils">
<dt>logcombine: <span class="math">\(\{x| \log(f(x)) + \log(g(x));x \in S\}\)</span></dt>
<dd><p class="first last"><span class="math">\(\Rightarrow  \{x| \log(f(x).g(x)); x \in S\} \text{ if } f(x) &gt; 0 \text{ and } g(x) &gt; 0\)</span>
<span class="math">\(\Rightarrow  \{x| \log(f(x)) + \log(g(x));x \in S\} \text{ otherwise}\)</span></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>product solve: <span class="math">\(\{x|f(x)g(x)=0; x \in S\}\)</span></dt>
<dd><p class="first last"><span class="math">\(\Rightarrow  \{x|f(x)=0; x \in S\} U \{x|g(x)=0; x \in S\}\)</span>
<span class="math">\(\text{ given } f(x) \text{ and } g(x) \text{ are bounded.}\)</span>
<span class="math">\(\Rightarrow  \{x|f(x)g(x)=0; x \in S\}, \text{ otherwise}\)</span></p>
</dd>
</dl>
</li>
</ul>
<p>Since the output type is same as the input type any composition of these
transformations is also a valid transformation. And our aim is to find
the right sequence of compositions (given the atoms) which transforms
the given condition set to a set which is not a condition set i.e.,
FiniteSet, Interval, Set of Integers and their Union, Intersection,
Complement or ImageSet. We can assign a cost function to each set,
such that, the more desirable that form of set is to us, the less the value
of the cost function. This way our problem is now reduced to finding the path
from the initial ConditionSet to the lowest valued set on a graph where
the atomic transformations forms the edges.</p>
</div></blockquote>
</div>
<div class="section" id="how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known">
<h2>How do we deal with cases where only some of the solutions are known?<a class="headerlink" href="#how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Creating a universal equation solver, which can solve each and every equation
we encounter in mathematics is an ideal case for solvers in a Computer
Algebra System. When cases which are not solved or can only be solved
incompletely, a <tt class="docutils literal"><span class="pre">ConditionSet</span></tt> is used and acts as an unevaluated solveset
object.</p>
<p>Note that, mathematically, finding a complete set of solutions for an
equation is undecidable. See <a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">Richardson&#8217;s theorem</a>.</p>
<p><tt class="docutils literal"><span class="pre">ConditionSet</span></tt> is basically a Set of elements which satisfy a given
condition. For example, to represent the solutions of the equation in
the real domain:</p>
<div class="math">
\[(x^2 - 4)(\sin(x) + x)\]</div>
<p>We can represent it as:</p>
<p><span class="math">\(\{-2, 2\} ∪ \{x | x \in \mathbb{R} ∧ x + \sin(x) = 0\}\)</span></p>
</div></blockquote>
</div>
<div class="section" id="what-will-you-do-with-the-old-solve">
<h2>What will you do with the old solve?<a class="headerlink" href="#what-will-you-do-with-the-old-solve" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There are still a few things <tt class="docutils literal"><span class="pre">solveset</span></tt> can&#8217;t do, which the old <tt class="docutils literal"><span class="pre">solve</span></tt>
can, such as solving non linear multivariate &amp; LambertW type equations.
Hence, it&#8217;s not yet a perfect replacement for old <tt class="docutils literal"><span class="pre">solve</span></tt>. The ultimate
goal is to:</p>
<ul class="simple">
<li>Replace <tt class="docutils literal"><span class="pre">solve</span></tt> with <tt class="docutils literal"><span class="pre">solveset</span></tt> once solveset is at least as powerful as
<tt class="docutils literal"><span class="pre">solve</span></tt>, i.e., <tt class="docutils literal"><span class="pre">solveset</span></tt> does everything that <tt class="docutils literal"><span class="pre">solve</span></tt> can do
currently, and</li>
<li>eventually rename <tt class="docutils literal"><span class="pre">solveset</span></tt> to <tt class="docutils literal"><span class="pre">solve</span></tt>.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-are-symbolic-parameters-handled-in-solveset">
<h2>How are symbolic parameters handled in solveset?<a class="headerlink" href="#how-are-symbolic-parameters-handled-in-solveset" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset is in its initial phase of development, so the symbolic parameters
aren&#8217;t handled well for all the cases, but some work has been done in this
regard to depict our ideology towards symbolic parameters. As an example,
consider the solving of <span class="math">\(|x| = n\)</span> for real <span class="math">\(x\)</span>, where <span class="math">\(n\)</span> is a symbolic
parameter. Solveset returns the value of <span class="math">\(x\)</span> considering the domain of the
symbolic parameter <span class="math">\(n\)</span> as well:</p>
<div class="math">
\[([0, \infty) \cap \{n\}) \cup ((-\infty, 0] \cap \{-n\}).\]</div>
<p>This simply means <span class="math">\(n\)</span> is the solution only when it belongs to the
<tt class="docutils literal"><span class="pre">Interval</span></tt> <span class="math">\([0, \infty)\)</span> and <span class="math">\(-n\)</span> is the solution only when <span class="math">\(-n\)</span> belongs to
the <tt class="docutils literal"><span class="pre">Interval</span></tt> <span class="math">\((- \infty, 0]\)</span>.</p>
<p>There are other cases to address too, like solving <span class="math">\(2^x + (a - 2)\)</span> for <span class="math">\(x\)</span>
where <span class="math">\(a\)</span> is a symbolic parameter.  As of now, It returns the solution as an
intersection with <span class="math">\(\mathbb{R}\)</span>, which is trivial, as it doesn&#8217;t reveal the
domain of <span class="math">\(a\)</span> in the solution.</p>
<p>Recently, we have also implemented a function to find the domain of the
expression in a FiniteSet (Intersection with the interval) in which it is
not-empty. It is a useful addition for dealing with symbolic parameters.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">not_empty_in</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_empty_in</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_empty_in</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[-sqrt(2), -1] U [1, 2]</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2015-Ideas#solvers">https://github.com/sympy/sympy/wiki/GSoC-2015-Ideas#solvers</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers">https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2015-Application-AMiT-Kumar--Solvers-:-Extending-Solveset">https://github.com/sympy/sympy/wiki/GSoC-2015-Application-AMiT-Kumar&#8211;Solvers-:-Extending-Solveset</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><a class="reference external" href="http://iamit.in/blog/">http://iamit.in/blog/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/2948">https://github.com/sympy/sympy/pull/2948</a> : Action Plan for improving solvers.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><a class="reference external" href="https://github.com/sympy/sympy/issues/6659">https://github.com/sympy/sympy/issues/6659</a> : <tt class="docutils literal"><span class="pre">solve()</span></tt> is a giant mess</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/7523">https://github.com/sympy/sympy/pull/7523</a> : <tt class="docutils literal"><span class="pre">solveset</span></tt> PR</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><a class="reference external" href="https://groups.google.com/forum/#!topic/sympy/-SIbX0AFL3Q">https://groups.google.com/forum/#!topic/sympy/-SIbX0AFL3Q</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/9696">https://github.com/sympy/sympy/pull/9696</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">https://en.wikipedia.org/wiki/Richardson%27s_theorem</a></td></tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="solveset-module-reference">
<h2>Solveset Module Reference<a class="headerlink" href="#solveset-module-reference" title="Permalink to this headline">¶</a></h2>
<p>Use <a class="reference internal" href="#sympy.solvers.solveset.solveset" title="sympy.solvers.solveset.solveset"><tt class="xref py py-func docutils literal"><span class="pre">solveset()</span></tt></a> to solve equations or expressions (assumed to be equal to 0) for a single variable.
Solving an equation like <span class="math">\(x^2 == 1\)</span> can be done as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-1, 1}</span>
</pre></div>
</div>
<p>Or one may manually rewrite the equation as an expression equal to 0:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-1, 1}</span>
</pre></div>
</div>
<p>The first argument for <a class="reference internal" href="#sympy.solvers.solveset.solveset" title="sympy.solvers.solveset.solveset"><tt class="xref py py-func docutils literal"><span class="pre">solveset()</span></tt></a> is an expression (equal to zero) or an equation and the second argument
is the symbol that we want to solve the equation for.</p>
<dl class="function">
<dt id="sympy.solvers.solveset.solveset">
<tt class="descclassname">sympy.solvers.solveset.</tt><tt class="descname">solveset</tt><big>(</big><em>f</em>, <em>symbol=None</em>, <em>domain=S.Complexes</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#solveset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a given inequality or equation with set as output</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>f</strong> : Expr or a relational.</p>
<blockquote>
<div><p>The target equation or inequality</p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable for which the equation is solved</p>
</div></blockquote>
<p><strong>domain</strong> : Set</p>
<blockquote>
<div><p>The domain over which the equation is solved</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">Set</p>
<blockquote>
<div><p>A set of values for <span class="math">\(symbol\)</span> for which <span class="math">\(f\)</span> is True or is equal to
zero. An <span class="math">\(EmptySet\)</span> is returned if <span class="math">\(f\)</span> is False or nonzero.
A <span class="math">\(ConditionSet\)</span> is returned as unsolved object if algorithms
to evaluatee complete solution are not yet implemented.</p>
</div></blockquote>
<p><span class="math">\(solveset\)</span> claims to be complete in the solution set that it returns.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>The algorithms to solve inequalities in complex domain  are
not yet implemented.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote>
<div><p>The input is not valid.</p>
</div></blockquote>
<p><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>It is a bug, please report to the github issue tracker.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sympy.solvers.solveset.solveset_real" title="sympy.solvers.solveset.solveset_real"><tt class="xref py py-obj docutils literal"><span class="pre">solveset_real</span></tt></a></dt>
<dd>solver for real domain</dd>
<dt><a class="reference internal" href="#sympy.solvers.solveset.solveset_complex" title="sympy.solvers.solveset.solveset_complex"><tt class="xref py py-obj docutils literal"><span class="pre">solveset_complex</span></tt></a></dt>
<dd>solver for complex domain</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Python interprets 0 and 1 as False and True, respectively, but
in this function they refer to solutions of an expression. So 0 and 1
return the Domain and EmptySet, respectively, while True and False
return the opposite (as they are assumed to be solutions of relational
expressions).</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">solveset</span><span class="p">,</span> <span class="n">solveset_real</span>
</pre></div>
</div>
<ul class="simple">
<li>The default domain is complex. Not specifying a domain will lead
to the solving of the equation in the complex domain (and this
is not affected by the assumptions on the symbol):</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{2*n*I*pi | n in Integers()}</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{2*n*I*pi | n in Integers()}</span>
</pre></div>
</div>
<ul class="simple">
<li>If you want to use <span class="math">\(solveset\)</span> to solve the equation in the
real domain, provide a real domain. (Using <span class="math">\(solveset\_real\)</span>
does this automatically.)</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">R</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">{0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{0}</span>
</pre></div>
</div>
<p>The solution is mostly unaffected by assumptions on the symbol,
but there may be some slight difference:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">({2*n*pi | n in Integers()} \ {0}) U ({2*n*pi + pi | n in Integers()} \ {0})</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">/</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{2*n*pi | n in Integers()} U {2*n*pi + pi | n in Integers()}</span>
</pre></div>
</div>
<ul class="simple">
<li>Inequalities can be solved over the real domain only. Use of a complex
domain leads to a NotImplementedError.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
<span class="go">(0, oo)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.solveset_real">
<tt class="descclassname">sympy.solvers.solveset.</tt><tt class="descname">solveset_real</tt><big>(</big><em>f</em>, <em>symbol</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#solveset_real"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.solveset_complex">
<tt class="descclassname">sympy.solvers.solveset.</tt><tt class="descname">solveset_complex</tt><big>(</big><em>f</em>, <em>symbol</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#solveset_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset_complex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.invert_real">
<tt class="descclassname">sympy.solvers.solveset.</tt><tt class="descname">invert_real</tt><big>(</big><em>f_x</em>, <em>y</em>, <em>x</em>, <em>domain=(-oo</em>, <em>oo)</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#invert_real"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.invert_real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.invert_complex">
<tt class="descclassname">sympy.solvers.solveset.</tt><tt class="descname">invert_complex</tt><big>(</big><em>f_x</em>, <em>y</em>, <em>x</em>, <em>domain=S.Complexes</em><big>)</big><a class="headerlink" href="#sympy.solvers.solveset.invert_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the complex valued equation <tt class="docutils literal"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">y</span></tt> to a set of equations
<tt class="docutils literal"><span class="pre">{g(x)</span> <span class="pre">=</span> <span class="pre">h_1(y),</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_n(y)</span> <span class="pre">}</span></tt> where <tt class="docutils literal"><span class="pre">g(x)</span></tt> is
a simpler function than <tt class="docutils literal"><span class="pre">f(x)</span></tt>.  The return value is a tuple <tt class="docutils literal"><span class="pre">(g(x),</span>
<span class="pre">set_h)</span></tt>, where <tt class="docutils literal"><span class="pre">g(x)</span></tt> is a function of <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">set_h</span></tt> is
the set of function <tt class="docutils literal"><span class="pre">{h_1(y),</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">h_n(y)}</span></tt>.
Here, <tt class="docutils literal"><span class="pre">y</span></tt> is not necessarily a symbol.</p>
<p>The <tt class="docutils literal"><span class="pre">set_h</span></tt> contains the functions along with the information
about their domain in which they are valid, through set
operations. For instance, if <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">Abs(x)</span> <span class="pre">-</span> <span class="pre">n</span></tt>, is inverted
in the real domain, then, the <tt class="docutils literal"><span class="pre">set_h</span></tt> doesn&#8217;t simply return
<span class="math">\({-n, n}\)</span>, as the nature of <span class="math">\(n\)</span> is unknown; rather it will return:
<span class="math">\(Intersection([0, oo) {n}) U Intersection((-oo, 0], {-n})\)</span></p>
<p>By default, the complex domain is used but note that inverting even
seemingly simple functions like <tt class="docutils literal"><span class="pre">exp(x)</span></tt> can give very different
result in the complex domain than are obtained in the real domain.
(In the case of <tt class="docutils literal"><span class="pre">exp(x)</span></tt>, the inversion via <tt class="docutils literal"><span class="pre">log</span></tt> is multi-valued
in the complex domain, having infinitely many branches.)</p>
<p>If you are working with real values only (or you are not sure which
function to use) you should probably use set the domain to
<tt class="docutils literal"><span class="pre">S.Reals</span></tt> (or use <span class="math">\(invert\_real\)</span> which does that automatically).</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.solveset.invert_real" title="sympy.solvers.solveset.invert_real"><tt class="xref py py-obj docutils literal"><span class="pre">invert_real</span></tt></a>, <a class="reference internal" href="#sympy.solvers.solveset.invert_complex" title="sympy.solvers.solveset.invert_complex"><tt class="xref py py-obj docutils literal"><span class="pre">invert_complex</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">invert_complex</span><span class="p">,</span> <span class="n">invert_real</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
</pre></div>
</div>
<p>When does exp(x) == y?</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, ImageSet(Lambda(_n, I*(2*_n*pi + arg(y)) + log(Abs(y))), Integers()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, Intersection((-oo, oo), {log(y)}))</span>
</pre></div>
</div>
<p>When does exp(x) == 1?</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, ImageSet(Lambda(_n, 2*_n*I*pi), Integers()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, {0})</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.domain_check">
<tt class="descclassname">sympy.solvers.solveset.</tt><tt class="descname">domain_check</tt><big>(</big><em>f</em>, <em>symbol</em>, <em>p</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#domain_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.domain_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns False if point p is infinite or any subexpression of f
is infinite or becomes so after replacing symbol with p. If none of
these conditions is met then True will be returned.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">domain_check</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<ul class="simple">
<li>The function relies on the assumption that the original form
of the equation has not been changed by automatic simplification.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># x/x is automatically simplified to 1</span>
<span class="go">True</span>
</pre></div>
</div>
<ul class="simple">
<li>To deal with automatic evaluations use evaluate=False:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="linear-eq-to-matrix">
<h2>linear_eq_to_matrix<a class="headerlink" href="#linear-eq-to-matrix" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sympy.solvers.solveset.linear_eq_to_matrix">
<tt class="descclassname">sympy.solvers.solveset.</tt><tt class="descname">linear_eq_to_matrix</tt><big>(</big><em>equations</em>, <em>*symbols</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#linear_eq_to_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.linear_eq_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a given System of Equations into Matrix form.
Here <span class="math">\(equations\)</span> must be a linear system of equations in
<span class="math">\(symbols\)</span>. The order of symbols in input <span class="math">\(symbols\)</span> will
determine the order of coefficients in the returned
Matrix.</p>
<p>The Matrix form corresponds to the augmented matrix form.
For example:</p>
<div class="math">
\[4x + 2y + 3z  = 1\]</div>
<div class="math">
\[3x +  y +  z  = -6\]</div>
<div class="math">
\[2x + 4y + 9z  = 2\]</div>
<p>This system would return <span class="math">\(A\)</span> &amp; <span class="math">\(b\)</span> as given below:</p>
<div class="highlight-python"><pre>    [ 4  2  3 ]          [ 1 ]
A = [ 3  1  1 ]   b  =   [-6 ]
    [ 2  4  9 ]          [ 2 ]</pre>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">linear_eq_to_matrix</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y, z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">z</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1, 2, 3],</span>
<span class="go">[3, 1, 1],</span>
<span class="go">[2, 4, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[ 1],</span>
<span class="go">[-6],</span>
<span class="go">[ 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1,  0, 1],</span>
<span class="go">[0,  1, 1],</span>
<span class="go">[1, -1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[1],</span>
<span class="go">[0],</span>
<span class="go">[0]])</span>
</pre></div>
</div>
<ul class="simple">
<li>Symbolic coefficients are also supported</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a, b, c, d, e, f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">f</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[a, b],</span>
<span class="go">[d, e]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>
<span class="go">Matrix([</span>
<span class="go">[c],</span>
<span class="go">[f]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="linsolve">
<h2>linsolve<a class="headerlink" href="#linsolve" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sympy.solvers.solveset.linsolve">
<tt class="descclassname">sympy.solvers.solveset.</tt><tt class="descname">linsolve</tt><big>(</big><em>system</em>, <em>*symbols</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#linsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.linsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve system of N linear equations with M variables, which
means both under - and overdetermined systems are supported.
The possible number of solutions is zero, one or infinite.
Zero solutions throws a ValueError, where as infinite
solutions are represented parametrically in terms of given
symbols. For unique solution a FiniteSet of ordered tuple
is returned.</p>
<p>All Standard input formats are supported:
For the given set of Equations, the respective input types
are given below:</p>
<div class="math">
\[3x + 2y -   z = 1\]</div>
<div class="math">
\[2x - 2y + 4z = -2\]</div>
<div class="math">
\[2x -   y + 2z = 0\]</div>
<ul class="simple">
<li>Augmented Matrix Form, <span class="math">\(system\)</span> given below:</li>
</ul>
<div class="highlight-python"><pre>         [3   2  -1  1]
system = [2  -2   4 -2]
         [2  -1   2  0]</pre>
</div>
<ul class="simple">
<li>List Of Equations Form</li>
</ul>
<p><span class="math">\(system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]\)</span></p>
<ul class="simple">
<li>Input A &amp; b Matrix Form (from Ax = b) are given as below:</li>
</ul>
<div class="highlight-python"><pre>    [3   2  -1 ]         [  1 ]
A = [2  -2   4 ]    b =  [ -2 ]
    [2  -1   2 ]         [  0 ]</pre>
</div>
<p><span class="math">\(system = (A, b)\)</span></p>
<p>Symbols to solve for should be given as input in all the
cases either in an iterable or as comma separated arguments.
This is done to maintain consistency in returning solutions
in the form of variable input by the user.</p>
<p>The algorithm used here is Gauss-Jordan elimination, which
results, after elimination, in an row echelon form matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns :</th><td class="field-body"><p class="first">A FiniteSet of ordered tuple of values of <span class="math">\(symbols\)</span> for which</p>
<p>the <span class="math">\(system\)</span> has solution.</p>
<p>Please note that general FiniteSet is unordered, the solution</p>
<p>returned here is not simply a FiniteSet of solutions, rather</p>
<p>it is a FiniteSet of ordered tuple, i.e. the first &amp; only</p>
<p>argument to FiniteSet is a tuple of solutions, which is ordered,</p>
<p>&amp; hence the returned solution is ordered.</p>
<p>Also note that solution could also have been returned as an</p>
<p>ordered tuple, FiniteSet is just a wrapper <span class="math">\({}\)</span> around</p>
<p>the tuple. It has no other significance except for</p>
<p>the fact it is just used to maintain a consistent output</p>
<p>format throughout the solveset.</p>
<p>Returns EmptySet(), if the linear system is inconsistent.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>The input is not valid.
The symbols are not given.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">linsolve</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x, y, z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1, 2,  3],</span>
<span class="go">[4, 5,  6],</span>
<span class="go">[7, 8, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[3],</span>
<span class="go">[6],</span>
<span class="go">[9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{(-1, 2, 0)}</span>
</pre></div>
</div>
<ul class="simple">
<li>Parametric Solution: In case the system is under determined, the function
will return parametric solution in terms of the given symbols.
Free symbols in the system are returned as it is. For e.g. in the system
below, <span class="math">\(z\)</span> is returned as the solution for variable z, which means z is a
free symbol, i.e. it can take arbitrary values.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{(z - 1, -2*z + 2, z)}</span>
</pre></div>
</div>
<ul class="simple">
<li>List of Equations as input</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Eqns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">Eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{(1, -2, -2)}</span>
</pre></div>
</div>
<ul class="simple">
<li>Augmented Matrix as input</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span>
<span class="go">Matrix([</span>
<span class="go">[2, 1,  3, 1],</span>
<span class="go">[2, 6,  8, 3],</span>
<span class="go">[6, 8, 18, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{(3/10, 2/5, 0)}</span>
</pre></div>
</div>
<ul class="simple">
<li>Solve for symbolic coefficients</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;a, b, c, d, e, f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">f</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{((-b*f + c*e)/(a*e - b*d), (a*f - c*d)/(a*e - b*d))}</span>
</pre></div>
</div>
<ul class="simple">
<li>A degenerate system returns solution as set of given
symbols.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{(x, y)}</span>
</pre></div>
</div>
<ul class="simple">
<li>For an empty system linsolve returns empty set</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">([</span> <span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">EmptySet()</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="diophantine-equations-des">
<h2>Diophantine Equations (DEs)<a class="headerlink" href="#diophantine-equations-des" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="diophantine.html#diophantine-docs"><em>Diophantine</em></a></p>
</div>
<div class="section" id="inequalities">
<h2>Inequalities<a class="headerlink" href="#inequalities" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="inequalities.html#inequality-docs"><em>Inequality Solvers</em></a></p>
</div>
<div class="section" id="ordinary-differential-equations-odes">
<h2>Ordinary Differential equations (ODEs)<a class="headerlink" href="#ordinary-differential-equations-odes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="ode.html#ode-docs"><em>ODE</em></a>.</p>
</div>
<div class="section" id="partial-differential-equations-pdes">
<h2>Partial Differential Equations (PDEs)<a class="headerlink" href="#partial-differential-equations-pdes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="pde.html#pde-docs"><em>PDE</em></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solveset</a><ul>
<li><a class="reference internal" href="#what-s-wrong-with-solve">What&#8217;s wrong with solve():</a></li>
<li><a class="reference internal" href="#why-solveset">Why Solveset?</a></li>
<li><a class="reference internal" href="#why-do-we-use-sets-as-an-output-type">Why do we use Sets as an output type?</a></li>
<li><a class="reference internal" href="#input-api-of-solveset">Input API of <tt class="docutils literal"><span class="pre">solveset</span></tt></a></li>
<li><a class="reference internal" href="#what-is-this-domain-argument-about">What is this domain argument about?</a></li>
<li><a class="reference internal" href="#what-are-the-general-methods-employed-by-solveset-to-solve-an-equation">What are the general methods employed by solveset to solve an equation?</a></li>
<li><a class="reference internal" href="#how-do-we-manipulate-and-return-an-infinite-solution">How do we manipulate and return an infinite solution?</a></li>
<li><a class="reference internal" href="#how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution">How does <tt class="docutils literal"><span class="pre">solveset</span></tt> ensure that it is not returning any wrong solution?</a></li>
<li><a class="reference internal" href="#search-based-solver-and-step-by-step-solution">Search based solver and step-by-step solution</a></li>
<li><a class="reference internal" href="#how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known">How do we deal with cases where only some of the solutions are known?</a></li>
<li><a class="reference internal" href="#what-will-you-do-with-the-old-solve">What will you do with the old solve?</a></li>
<li><a class="reference internal" href="#how-are-symbolic-parameters-handled-in-solveset">How are symbolic parameters handled in solveset?</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#solveset-module-reference">Solveset Module Reference</a></li>
<li><a class="reference internal" href="#linear-eq-to-matrix">linear_eq_to_matrix</a></li>
<li><a class="reference internal" href="#linsolve">linsolve</a></li>
<li><a class="reference internal" href="#diophantine-equations-des">Diophantine Equations (DEs)</a></li>
<li><a class="reference internal" href="#inequalities">Inequalities</a></li>
<li><a class="reference internal" href="#ordinary-differential-equations-odes">Ordinary Differential equations (ODEs)</a></li>
<li><a class="reference internal" href="#partial-differential-equations-pdes">Partial Differential Equations (PDEs)</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="inequalities.html"
                        title="previous chapter">Inequality Solvers</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../tensor/index.html"
                        title="next chapter">Tensor Module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/modules/solvers/solveset.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../tensor/index.html" title="Tensor Module"
             >next</a> |</li>
        <li class="right" >
          <a href="inequalities.html" title="Inequality Solvers"
             >previous</a> |</li>
        <li><a href="../../index.html">SymPy 1.0 documentation</a> &raquo;</li>
          <li><a href="../index.html" >SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015 SymPy Development Team.
      Last updated on Mar 08, 2016.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>