

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.categories.diagram_drawing &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy.categories" href="../../sympy/categories.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../../sympy/categories.html" accesskey="U">sympy.categories</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.categories.diagram_drawing</h1><div class="highlight"><pre>
<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">This module contains the functionality to arrange the nodes of a</span>
<span class="sd">diagram on an abstract grid, and then to produce a graphical</span>
<span class="sd">representation of the grid.</span>

<span class="sd">The currently supported back-ends are Xy-pic [Xypic].</span>

<span class="sd">Layout Algorithm</span>
<span class="sd">================</span>

<span class="sd">This section provides an overview of the algorithms implemented in</span>
<span class="sd">:class:`DiagramGrid` to lay out diagrams.</span>

<span class="sd">The first step of the algorithm is the removal composite and identity</span>
<span class="sd">morphisms which do not have properties in the supplied diagram.  The</span>
<span class="sd">premises and conclusions of the diagram are then merged.</span>

<span class="sd">The generic layout algorithm begins with the construction of the</span>
<span class="sd">&quot;skeleton&quot; of the diagram.  The skeleton is an undirected graph which</span>
<span class="sd">has the objects of the diagram as vertices and has an (undirected)</span>
<span class="sd">edge between each pair of objects between which there exist morphisms.</span>
<span class="sd">The direction of the morphisms does not matter at this stage.  The</span>
<span class="sd">skeleton also includes an edge between each pair of vertices `A` and</span>
<span class="sd">`C` such that there exists an object `B` which is connected via</span>
<span class="sd">a morphism to `A`, and via a morphism to `C`.</span>

<span class="sd">The skeleton constructed in this way has the property that every</span>
<span class="sd">object is a vertex of a triangle formed by three edges of the</span>
<span class="sd">skeleton.  This property lies at the base of the generic layout</span>
<span class="sd">algorithm.</span>

<span class="sd">After the skeleton has been constructed, the algorithm lists all</span>
<span class="sd">triangles which can be formed.  Note that some triangles will not have</span>
<span class="sd">all edges corresponding to morphisms which will actually be drawn.</span>
<span class="sd">Triangles which have only one edge or less which will actually be</span>
<span class="sd">drawn are immediately discarded.</span>

<span class="sd">The list of triangles is sorted according to the number of edges which</span>
<span class="sd">correspond to morphisms, then the triangle with the least number of such</span>
<span class="sd">edges is selected.  One of such edges is picked and the corresponding</span>
<span class="sd">objects are placed horizontally, on a grid.  This edge is recorded to</span>
<span class="sd">be in the fringe.  The algorithm then finds a &quot;welding&quot; of a triangle</span>
<span class="sd">to the fringe.  A welding is an edge in the fringe where a triangle</span>
<span class="sd">could be attached.  If the algorithm succeeds in finding such a</span>
<span class="sd">welding, it adds to the grid that vertex of the triangle which was not</span>
<span class="sd">yet included in any edge in the fringe and records the two new edges in</span>
<span class="sd">the fringe.  This process continues iteratively until all objects of</span>
<span class="sd">the diagram has been placed or until no more weldings can be found.</span>

<span class="sd">An edge is only removed from the fringe when a welding to this edge</span>
<span class="sd">has been found, and there is no room around this edge to place</span>
<span class="sd">another vertex.</span>

<span class="sd">When no more weldings can be found, but there are still triangles</span>
<span class="sd">left, the algorithm searches for a possibility of attaching one of the</span>
<span class="sd">remaining triangles to the existing structure by a vertex.  If such a</span>
<span class="sd">possibility is found, the corresponding edge of the found triangle is</span>
<span class="sd">placed in the found space and the iterative process of welding</span>
<span class="sd">triangles restarts.</span>

<span class="sd">When logical groups are supplied, each of these groups is laid out</span>
<span class="sd">independently.  Then a diagram is constructed in which groups are</span>
<span class="sd">objects and any two logical groups between which there exist morphisms</span>
<span class="sd">are connected via a morphism.  This diagram is laid out.  Finally,</span>
<span class="sd">the grid which includes all objects of the initial diagram is</span>
<span class="sd">constructed by replacing the cells which contain logical groups with</span>
<span class="sd">the corresponding laid out grids, and by correspondingly expanding the</span>
<span class="sd">rows and columns.</span>

<span class="sd">The sequential layout algorithm begins by constructing the</span>
<span class="sd">underlying undirected graph defined by the morphisms obtained after</span>
<span class="sd">simplifying premises and conclusions and merging them (see above).</span>
<span class="sd">The vertex with the minimal degree is then picked up and depth-first</span>
<span class="sd">search is started from it.  All objects which are located at distance</span>
<span class="sd">`n` from the root in the depth-first search tree, are positioned in</span>
<span class="sd">the `n`-th column of the resulting grid.  The sequential layout will</span>
<span class="sd">therefore attempt to lay the objects out along a line.</span>

<span class="sd">References</span>
<span class="sd">==========</span>

<span class="sd">[Xypic] http://www.tug.org/applications/Xy-pic/</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="kn">from</span> <span class="nn">sympy.categories</span> <span class="kn">import</span> <span class="p">(</span><span class="n">CompositeMorphism</span><span class="p">,</span> <span class="n">IdentityMorphism</span><span class="p">,</span>
                              <span class="n">NamedMorphism</span><span class="p">,</span> <span class="n">Diagram</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">default_sort_key</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">iterable</span>
<span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">latex</span>


<span class="k">class</span> <span class="nc">_GrowableGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds a growable grid of objects.</span>

<span class="sd">    It is possible to append or prepend a row or a column to the grid</span>
<span class="sd">    using the corresponding methods.  Prepending rows or columns has</span>
<span class="sd">    the effect of changing the coordinates of the already existing</span>
<span class="sd">    elements.</span>

<span class="sd">    This class currently represents a naive implementation of the</span>
<span class="sd">    functionality with little attempt at optimisation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_height</span> <span class="o">=</span> <span class="n">height</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_width</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_height</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xxx_todo_changeme</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the element located at in the i-th line and j-th</span>
<span class="sd">        column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xxx_todo_changeme1</span><span class="p">,</span> <span class="n">newvalue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the element located at in the i-th line and j-th</span>
<span class="sd">        column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">newvalue</span>

    <span class="k">def</span> <span class="nf">append_row</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends an empty row to the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_width</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">append_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends an empty column to the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_height</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepend_row</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepends the grid with an empty row.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_width</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">prepend_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepends the grid with an empty column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_height</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>


<div class="viewcode-block" id="DiagramGrid"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.DiagramGrid">[docs]</a><span class="k">class</span> <span class="nc">DiagramGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Constructs and holds the fitting of the diagram into a grid.</span>

<span class="sd">    The mission of this class is to analyse the structure of the</span>
<span class="sd">    supplied diagram and to place its objects on a grid such that,</span>
<span class="sd">    when the objects and the morphisms are actually drawn, the diagram</span>
<span class="sd">    would be &quot;readable&quot;, in the sense that there will not be many</span>
<span class="sd">    intersections of moprhisms.  This class does not perform any</span>
<span class="sd">    actual drawing.  It does strive nevertheless to offer sufficient</span>
<span class="sd">    metadata to draw a diagram.</span>

<span class="sd">    Consider the following simple diagram.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">    &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">    &gt;&gt;&gt; from sympy import pprint</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g])</span>

<span class="sd">    The simplest way to have a diagram laid out is the following:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">    &gt;&gt;&gt; (grid.width, grid.height)</span>
<span class="sd">    (2, 2)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A  B</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">       C</span>

<span class="sd">    Sometimes one sees the diagram as consisting of logical groups.</span>
<span class="sd">    One can advise ``DiagramGrid`` as to such groups by employing the</span>
<span class="sd">    ``groups`` keyword argument.</span>

<span class="sd">    Consider the following diagram:</span>

<span class="sd">    &gt;&gt;&gt; D = Object(&quot;D&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; h = NamedMorphism(D, A, &quot;h&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = NamedMorphism(D, B, &quot;k&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g, h, k])</span>

<span class="sd">    Lay it out with generic layout:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A  B  D</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">       C</span>

<span class="sd">    Now, we can group the objects `A` and `D` to have them near one</span>
<span class="sd">    another:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram, groups=[[A, D], B, C])</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    B     C</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    A  D</span>

<span class="sd">    Note how the positioning of the other objects changes.</span>

<span class="sd">    Further indications can be supplied to the constructor of</span>
<span class="sd">    :class:`DiagramGrid` using keyword arguments.  The currently</span>
<span class="sd">    supported hints are explained in the following paragraphs.</span>

<span class="sd">    :class:`DiagramGrid` does not automatically guess which layout</span>
<span class="sd">    would suit the supplied diagram better.  Consider, for example,</span>
<span class="sd">    the following linear diagram:</span>

<span class="sd">    &gt;&gt;&gt; E = Object(&quot;E&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; h = NamedMorphism(C, D, &quot;h&quot;)</span>
<span class="sd">    &gt;&gt;&gt; i = NamedMorphism(D, E, &quot;i&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g, h, i])</span>

<span class="sd">    When laid out with the generic layout, it does not get to look</span>
<span class="sd">    linear:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A  B</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">       C  D</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">          E</span>

<span class="sd">    To get it laid out in a line, use ``layout=&quot;sequential&quot;``:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram, layout=&quot;sequential&quot;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A  B  C  D  E</span>

<span class="sd">    One may sometimes need to transpose the resulting layout.  While</span>
<span class="sd">    this can always be done by hand, :class:`DiagramGrid` provides a</span>
<span class="sd">    hint for that purpose:</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram, layout=&quot;sequential&quot;, transpose=True)</span>
<span class="sd">    &gt;&gt;&gt; pprint(grid)</span>
<span class="sd">    A</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    B</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    C</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    D</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    E</span>

<span class="sd">    Separate hints can also be provided for each group.  For an</span>
<span class="sd">    example, refer to ``tests/test_drawing.py``, and see the different</span>
<span class="sd">    ways in which the five lemma [FiveLemma] can be laid out.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Diagram</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    [FiveLemma] http://en.wikipedia.org/wiki/Five_lemma</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_simplify_morphisms</span><span class="p">(</span><span class="n">morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a dictionary mapping morphisms to their properties,</span>
<span class="sd">        returns a new dictionary in which there are no morphisms which</span>
<span class="sd">        do not have properties, and which are compositions of other</span>
<span class="sd">        morphisms included in the dictionary.  Identities are dropped</span>
<span class="sd">        as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newmorphisms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">morphisms</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">CompositeMorphism</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">props</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">IdentityMorphism</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newmorphisms</span><span class="p">[</span><span class="n">morphism</span><span class="p">]</span> <span class="o">=</span> <span class="n">props</span>
        <span class="k">return</span> <span class="n">newmorphisms</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_merge_premises_conclusions</span><span class="p">(</span><span class="n">premises</span><span class="p">,</span> <span class="n">conclusions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given two dictionaries of morphisms and their properties,</span>
<span class="sd">        produces a single dictionary which includes elements from both</span>
<span class="sd">        dictionaries.  If a morphism has some properties in premises</span>
<span class="sd">        and also in conclusions, the properties in conclusions take</span>
<span class="sd">        priority.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">premises</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span> <span class="nb">list</span><span class="p">(</span><span class="n">conclusions</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_juxtapose_edges</span><span class="p">(</span><span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``edge1`` and ``edge2`` have precisely one common endpoint,</span>
<span class="sd">        returns an edge which would form a triangle with ``edge1`` and</span>
<span class="sd">        ``edge2``.</span>

<span class="sd">        If ``edge1`` and ``edge2`` don&#39;t have a common endpoint,</span>
<span class="sd">        returns ``None``.</span>

<span class="sd">        If ``edge1`` and ``edge`` are the same edge, returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">edge1</span> <span class="o">&amp;</span> <span class="n">edge2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># The edges either have no common points or are equal.</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="c"># The edges have a common endpoint.  Extract the different</span>
        <span class="c"># endpoints and set up the new edge.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">edge1</span> <span class="o">-</span> <span class="n">intersection</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">edge2</span> <span class="o">-</span> <span class="n">intersection</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_edge_append</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``edge`` is not in ``dictionary``, adds ``edge`` to the</span>
<span class="sd">        dictionary and sets its value to ``[elem]``.  Otherwise</span>
<span class="sd">        appends ``elem`` to the value of existing entry.</span>

<span class="sd">        Note that edges are undirected, thus `(A, B) = (B, A)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_build_skeleton</span><span class="p">(</span><span class="n">morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dictionary which maps edges to corresponding</span>
<span class="sd">        morphisms.  Thus for a morphism `f:A\rightarrow B`, the edge</span>
<span class="sd">        `(A, B)` will be associated with `f`.  This function also adds</span>
<span class="sd">        to the list those edges which are formed by juxtaposition of</span>
<span class="sd">        two edges already in the list.  These new edges are not</span>
<span class="sd">        associated with any morphism and are only added to assure that</span>
<span class="sd">        the diagram can be decomposed into triangles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c"># Create edges for morphisms.</span>
        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">morphisms</span><span class="p">:</span>
            <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_add_edge_append</span><span class="p">(</span>
                <span class="n">edges</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">]),</span> <span class="n">morphism</span><span class="p">)</span>

        <span class="c"># Create new edges by juxtaposing existing edges.</span>
        <span class="n">edges1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges1</span><span class="p">:</span>
                <span class="n">wv</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_juxtapose_edges</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">wv</span> <span class="ow">and</span> <span class="n">wv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">edges</span><span class="p">[</span><span class="n">wv</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">edges</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_list_triangles</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the set of triangles formed by the supplied edges.  The</span>
<span class="sd">        triangles are arbitrary and need not be commutative.  A</span>
<span class="sd">        triangle is a set that contains all three of its sides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">wv</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_juxtapose_edges</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">wv</span> <span class="ow">and</span> <span class="n">wv</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">triangles</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">wv</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">triangles</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_drop_redundant_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list which contains only those triangles who have</span>
<span class="sd">        morphisms associated with at least two edges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tri</span> <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">triangles</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tri</span> <span class="k">if</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">e</span><span class="p">]])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_morphism_length</span><span class="p">(</span><span class="n">morphism</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of a morphism.  The length of a morphism is</span>
<span class="sd">        the number of components it consists of.  A non-composite</span>
<span class="sd">        morphism is of length 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">CompositeMorphism</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_compute_triangle_min_sizes</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary mapping triangles to their minimal sizes.</span>
<span class="sd">        The minimal size of a triangle is the sum of maximal lengths</span>
<span class="sd">        of morphisms associated to the sides of the triangle.  The</span>
<span class="sd">        length of a morphism is the number of components it consists</span>
<span class="sd">        of.  A non-composite morphism is of length 1.</span>

<span class="sd">        Sorting triangles by this metric attempts to address two</span>
<span class="sd">        aspects of layout.  For triangles with only simple morphisms</span>
<span class="sd">        in the edge, this assures that triangles with all three edges</span>
<span class="sd">        visible will get typeset after triangles with less visible</span>
<span class="sd">        edges, which sometimes minimises the necessity in diagonal</span>
<span class="sd">        arrows.  For triangles with composite morphisms in the edges,</span>
<span class="sd">        this assures that objects connected with shorter morphisms</span>
<span class="sd">        will be laid out first, resulting the visual proximity of</span>
<span class="sd">        those objects which are connected by shorter morphisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">triangle_sizes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">triangle</span><span class="p">:</span>
                <span class="n">morphisms</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">morphisms</span><span class="p">:</span>
                    <span class="n">size</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_morphism_length</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">morphisms</span><span class="p">)</span>
            <span class="n">triangle_sizes</span><span class="p">[</span><span class="n">triangle</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">return</span> <span class="n">triangle_sizes</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_triangle_objects</span><span class="p">(</span><span class="n">triangle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a triangle, returns the objects included in it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># A triangle is a frozenset of three two-element frozensets</span>
        <span class="c"># (the edges).  This chains the three edges together and</span>
        <span class="c"># creates a frozenset from the iterator, thus producing a</span>
        <span class="c"># frozenset of objects of the triangle.</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">triangle</span><span class="p">)))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_other_vertex</span><span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a triangle and an edge of it, returns the vertex which</span>
<span class="sd">        opposes the edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This gets the set of objects of the triangle and then</span>
        <span class="c"># subtracts the set of objects employed in ``edge`` to get the</span>
        <span class="c"># vertex opposite to ``edge``.</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">triangle</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">edge</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_empty_point</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the cell at coordinates ``pt`` is either empty or</span>
<span class="sd">        out of the bounds of the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_put_object</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">fringe</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Places an object at the coordinate ``cords`` in ``grid``,</span>
<span class="sd">        growing the grid and updating ``fringe``, if necessary.</span>
<span class="sd">        Returns (0, 0) if no row or column has been prepended, (1, 0)</span>
<span class="sd">        if a row was prepended, (0, 1) if a column was prepended and</span>
<span class="sd">        (1, 1) if both a column and a row were prepended.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">coords</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">prepend_row</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fringe</span><span class="p">)):</span>
                <span class="p">((</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span> <span class="o">=</span> <span class="n">fringe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">fringe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append_row</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">prepend_column</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fringe</span><span class="p">)):</span>
                <span class="p">((</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span> <span class="o">=</span> <span class="n">fringe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">fringe</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append_column</span><span class="p">()</span>

        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">return</span> <span class="n">offset</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_choose_target_cell</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given two points, ``pt1`` and ``pt2``, and the welding edge</span>
<span class="sd">        ``edge``, chooses one of the two points to place the opposing</span>
<span class="sd">        vertex ``obj`` of the triangle.  If neither of this points</span>
<span class="sd">        fits, returns ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pt1_empty</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_empty_point</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
        <span class="n">pt2_empty</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_empty_point</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pt1_empty</span> <span class="ow">and</span> <span class="n">pt2_empty</span><span class="p">:</span>
            <span class="c"># Both cells are empty.  Of these two, choose that cell</span>
            <span class="c"># which will assure that a visible edge of the triangle</span>
            <span class="c"># will be drawn perpendicularly to the current welding</span>
            <span class="c"># edge.</span>

            <span class="n">A</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">skeleton</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">obj</span><span class="p">])):</span>
                <span class="k">return</span> <span class="n">pt1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pt2</span>
        <span class="k">if</span> <span class="n">pt1_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pt1</span>
        <span class="k">elif</span> <span class="n">pt2_empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pt2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_find_triangle_to_weld</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds, if possible, a triangle and an edge in the fringe to</span>
<span class="sd">        which the triangle could be attached.  Returns the tuple</span>
<span class="sd">        containing the triangle and the index of the corresponding</span>
<span class="sd">        edge in the fringe.</span>

<span class="sd">        This function relies on the fact that objects are unique in</span>
<span class="sd">        the diagram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">fringe</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">grid</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="n">b</span><span class="p">]])</span> <span class="ow">in</span> <span class="n">triangle</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_weld_triangle</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">welding_edge</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If possible, welds the triangle ``tri`` to ``fringe`` and</span>
<span class="sd">        returns ``False``.  If this method encounters a degenerate</span>
<span class="sd">        situation in the fringe and corrects it such that a restart of</span>
<span class="sd">        the search is required, it returns ``True`` (which means that</span>
<span class="sd">        a restart in finding triangle weldings is required).</span>

<span class="sd">        A degenerate situation is a situation when an edge listed in</span>
<span class="sd">        the fringe does not belong to the visual boundary of the</span>
<span class="sd">        diagram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">welding_edge</span>
        <span class="n">target_cell</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_other_vertex</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="n">b</span><span class="p">]))</span>

        <span class="c"># We now have a triangle and an edge where it can be welded to</span>
        <span class="c"># the fringe.  Decide where to place the other vertex of the</span>
        <span class="c"># triangle and check for degenerate situations en route.</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># A diagonal edge.</span>
            <span class="n">target_cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">target_cell</span><span class="p">]:</span>
                <span class="c"># That cell is already occupied.</span>
                <span class="n">target_cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">target_cell</span><span class="p">]:</span>
                    <span class="c"># Degenerate situation, this edge is not</span>
                    <span class="c"># on the actual fringe.  Correct the</span>
                    <span class="c"># fringe and go on.</span>
                    <span class="n">fringe</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c"># A horizontal edge.  We first attempt to build the</span>
            <span class="c"># triangle in the downward direction.</span>

            <span class="n">down_left</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">down_right</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">target_cell</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_choose_target_cell</span><span class="p">(</span>
                <span class="n">down_left</span><span class="p">,</span> <span class="n">down_right</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">target_cell</span><span class="p">:</span>
                <span class="c"># No room below this edge.  Check above.</span>
                <span class="n">up_left</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">up_right</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">target_cell</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_choose_target_cell</span><span class="p">(</span>
                    <span class="n">up_left</span><span class="p">,</span> <span class="n">up_right</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">target_cell</span><span class="p">:</span>
                    <span class="c"># This edge is not in the fringe, remove it</span>
                    <span class="c"># and restart.</span>
                    <span class="n">fringe</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c"># A vertical edge.  We will attempt to place the other</span>
            <span class="c"># vertex of the triangle to the right of this edge.</span>
            <span class="n">right_up</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">right_down</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">target_cell</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_choose_target_cell</span><span class="p">(</span>
                <span class="n">right_up</span><span class="p">,</span> <span class="n">right_down</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">target_cell</span><span class="p">:</span>
                <span class="c"># No room to the left.  See what&#39;s to the right.</span>
                <span class="n">left_up</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">left_down</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="n">target_cell</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_choose_target_cell</span><span class="p">(</span>
                    <span class="n">left_up</span><span class="p">,</span> <span class="n">left_down</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">obj</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">target_cell</span><span class="p">:</span>
                    <span class="c"># This edge is not in the fringe, remove it</span>
                    <span class="c"># and restart.</span>
                    <span class="n">fringe</span><span class="o">.</span><span class="n">remove</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                    <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># We now know where to place the other vertex of the</span>
        <span class="c"># triangle.</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_put_object</span><span class="p">(</span><span class="n">target_cell</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">fringe</span><span class="p">)</span>

        <span class="c"># Take care of the displacement of coordinates if a row or</span>
        <span class="c"># a column was prepended.</span>
        <span class="n">target_cell</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">target_cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">fringe</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="n">target_cell</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">target_cell</span><span class="p">)])</span>

        <span class="c"># No restart is required.</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_triangle_key</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">triangle_sizes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a key for the supplied triangle.  It should be the</span>
<span class="sd">        same independently of the hash randomisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">tri</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">triangle_sizes</span><span class="p">[</span><span class="n">tri</span><span class="p">],</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">objects</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pick_root_edge</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a given triangle always picks the same root edge.  The</span>
<span class="sd">        root edge is the edge that will be placed first on the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tri</span> <span class="k">if</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">e</span><span class="p">]]</span>
        <span class="n">sorted_candidates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
        <span class="c"># Don&#39;t forget to assure the proper ordering of the vertices</span>
        <span class="c"># in this edge.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">sorted_candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_drop_irrelevant_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns only those triangles whose set of objects is not</span>
<span class="sd">        completely included in ``placed_objects``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tri</span> <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">triangles</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">placed_objects</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span>
            <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">tri</span><span class="p">))]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_grow_pseudopod</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starting from an object in the existing structure on the grid,</span>
<span class="sd">        adds an edge to which a triangle from ``triangles`` could be</span>
<span class="sd">        welded.  If this method has found a way to do so, it returns</span>
<span class="sd">        the object it has just added.</span>

<span class="sd">        This method should be applied when ``_weld_triangle`` cannot</span>
<span class="sd">        find weldings any more.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c"># Here we need to choose a triangle which has only</span>
                <span class="c"># ``obj`` in common with the existing structure.  The</span>
                <span class="c"># situations when this is not possible should be</span>
                <span class="c"># handled elsewhere.</span>

                <span class="k">def</span> <span class="nf">good_triangle</span><span class="p">(</span><span class="n">tri</span><span class="p">):</span>
                    <span class="n">objs</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span> <span class="ow">and</span> \
                        <span class="n">placed_objects</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">objs</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">obj</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">()</span>

                <span class="n">tris</span> <span class="o">=</span> <span class="p">[</span><span class="n">tri</span> <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">triangles</span> <span class="k">if</span> <span class="n">good_triangle</span><span class="p">(</span><span class="n">tri</span><span class="p">)]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tris</span><span class="p">:</span>
                    <span class="c"># This object is not interesting.</span>
                    <span class="k">continue</span>

                <span class="c"># Pick the &quot;simplest&quot; of the triangles which could be</span>
                <span class="c"># attached.  Remember that the list of triangles is</span>
                <span class="c"># sorted according to their &quot;simplicity&quot; (see</span>
                <span class="c"># _compute_triangle_min_sizes for the metric).</span>
                <span class="c">#</span>
                <span class="c"># Note that ``tris`` are sequentially built from</span>
                <span class="c"># ``triangles``, so we don&#39;t have to worry about hash</span>
                <span class="c"># randomisation.</span>
                <span class="n">tri</span> <span class="o">=</span> <span class="n">tris</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c"># We have found a triangle which could be attached to</span>
                <span class="c"># the existing structure by a vertex.</span>

                <span class="n">candidates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tri</span> <span class="k">if</span> <span class="n">skeleton</span><span class="p">[</span><span class="n">e</span><span class="p">]],</span>
                                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">candidates</span> <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>

                <span class="c"># Note that a meaningful edge (i.e., and edge that is</span>
                <span class="c"># associated with a morphism) containing ``obj``</span>
                <span class="c"># always exists.  That&#39;s because all triangles are</span>
                <span class="c"># guaranteed to have at least two meaningful edges.</span>
                <span class="c"># See _drop_redundant_triangles.</span>

                <span class="c"># Get the object at the other end of the edge.</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">other_obj</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge</span> <span class="o">-</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">obj</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c"># Now check for free directions.  When checking for</span>
                <span class="c"># free directions, prefer the horizontal and vertical</span>
                <span class="c"># directions.</span>
                <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
                              <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_empty_point</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
                        <span class="c"># We have a found a place to grow the</span>
                        <span class="c"># pseudopod into.</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_put_object</span><span class="p">(</span>
                            <span class="n">pt</span><span class="p">,</span> <span class="n">other_obj</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">fringe</span><span class="p">)</span>

                        <span class="n">i</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">fringe</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">pt</span><span class="p">))</span>

                        <span class="k">return</span> <span class="n">other_obj</span>

        <span class="c"># This diagram is actually cooler that I can handle.  Fail cowardly.</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_handle_groups</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">,</span> <span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the slightly preprocessed morphisms of the diagram,</span>
<span class="sd">        produces a grid laid out according to ``groups``.</span>

<span class="sd">        If a group has hints, it is laid out with those hints only,</span>
<span class="sd">        without any influence from ``hints``.  Otherwise, it is laid</span>
<span class="sd">        out with ``hints``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">lay_out_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">local_hints</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            If ``group`` is a set of objects, uses a ``DiagramGrid``</span>
<span class="sd">            to lay it out and returns the grid.  Otherwise returns the</span>
<span class="sd">            object (i.e., ``group``).  If ``local_hints`` is not</span>
<span class="sd">            empty, it is supplied to ``DiagramGrid`` as the dictionary</span>
<span class="sd">            of hints.  Otherwise, the ``hints`` argument of</span>
<span class="sd">            ``_handle_groups`` is used.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">):</span>
                <span class="c"># Set up the corresponding object-to-group</span>
                <span class="c"># mappings.</span>
                <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                    <span class="n">obj_groups</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>

                <span class="c"># Lay out the current group.</span>
                <span class="k">if</span> <span class="n">local_hints</span><span class="p">:</span>
                    <span class="n">groups_grids</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span>
                        <span class="n">diagram</span><span class="o">.</span><span class="n">subdiagram_from_objects</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="o">**</span><span class="n">local_hints</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">groups_grids</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span>
                        <span class="n">diagram</span><span class="o">.</span><span class="n">subdiagram_from_objects</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj_groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="n">group</span>

        <span class="k">def</span> <span class="nf">group_to_finiteset</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Converts ``group`` to a :class:``FiniteSet`` if it is an</span>
<span class="sd">            iterable.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">group</span>

        <span class="n">obj_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">groups_grids</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># We would like to support various containers to represent</span>
        <span class="c"># groups.  To achieve that, before laying each group out, it</span>
        <span class="c"># should be converted to a FiniteSet, because that is what the</span>
        <span class="c"># following code expects.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">Dict</span><span class="p">):</span>
            <span class="n">finiteset_groups</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">local_hints</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">finiteset_group</span> <span class="o">=</span> <span class="n">group_to_finiteset</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">finiteset_groups</span><span class="p">[</span><span class="n">finiteset_group</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_hints</span>
                <span class="n">lay_out_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">local_hints</span><span class="p">)</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">finiteset_groups</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">finiteset_groups</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="n">finiteset_group</span> <span class="o">=</span> <span class="n">group_to_finiteset</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">finiteset_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">finiteset_group</span><span class="p">)</span>
                <span class="n">lay_out_group</span><span class="p">(</span><span class="n">finiteset_group</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">finiteset_groups</span>

        <span class="n">new_morphisms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">merged_morphisms</span><span class="p">:</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="n">obj_groups</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
            <span class="n">cod</span> <span class="o">=</span> <span class="n">obj_groups</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>
            <span class="c"># Note that we are not really interested in morphisms</span>
            <span class="c"># which do not employ two different groups, because</span>
            <span class="c"># these do not influence the layout.</span>
            <span class="k">if</span> <span class="n">dom</span> <span class="o">!=</span> <span class="n">cod</span><span class="p">:</span>
                <span class="c"># These are essentially unnamed morphisms; they are</span>
                <span class="c"># not going to mess in the final layout.  By giving</span>
                <span class="c"># them the same names, we avoid unnecessary</span>
                <span class="c"># duplicates.</span>
                <span class="n">new_morphisms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NamedMorphism</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">cod</span><span class="p">,</span> <span class="s">&quot;dummy&quot;</span><span class="p">))</span>

        <span class="c"># Lay out the new diagram.  Since these are dummy morphisms,</span>
        <span class="c"># properties and conclusions are irrelevant.</span>
        <span class="n">top_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span><span class="n">Diagram</span><span class="p">(</span><span class="n">new_morphisms</span><span class="p">))</span>

        <span class="c"># We now have to substitute the groups with the corresponding</span>
        <span class="c"># grids, laid out at the beginning of this function.  Compute</span>
        <span class="c"># the size of each row and column in the grid, so that all</span>
        <span class="c"># nested grids fit.</span>

        <span class="k">def</span> <span class="nf">group_size</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            For the supplied group (or object, eventually), returns</span>
<span class="sd">            the size of the cell that will hold this group (object).</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups_grids</span><span class="p">:</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">groups_grids</span><span class="p">[</span><span class="n">group</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">row_heights</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">group_size</span><span class="p">(</span><span class="n">top_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">height</span><span class="p">)]</span>

        <span class="n">column_widths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">group_size</span><span class="p">(</span><span class="n">top_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">height</span><span class="p">))</span>
                         <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">width</span><span class="p">)]</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">column_widths</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">row_heights</span><span class="p">))</span>

        <span class="n">real_row</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">real_column</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">logical_row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">logical_column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">top_grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">top_grid</span><span class="p">[</span><span class="n">logical_row</span><span class="p">,</span> <span class="n">logical_column</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">groups_grids</span><span class="p">:</span>
                    <span class="c"># This is a group.  Copy the corresponding grid in</span>
                    <span class="c"># place.</span>
                    <span class="n">local_grid</span> <span class="o">=</span> <span class="n">groups_grids</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">local_grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">local_grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                            <span class="n">grid</span><span class="p">[</span><span class="n">real_row</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
                                <span class="n">real_column</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># This is an object.  Just put it there.</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">real_row</span><span class="p">,</span> <span class="n">real_column</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

                <span class="n">real_column</span> <span class="o">+=</span> <span class="n">column_widths</span><span class="p">[</span><span class="n">logical_column</span><span class="p">]</span>
            <span class="n">real_column</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">real_row</span> <span class="o">+=</span> <span class="n">row_heights</span><span class="p">[</span><span class="n">logical_row</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">grid</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generic_layout</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces the generic layout for the supplied diagram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_objects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">diagram</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_objects</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># There only one object in the diagram, just put in on 1x1</span>
            <span class="c"># grid.</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_objects</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">grid</span>

        <span class="n">skeleton</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_build_skeleton</span><span class="p">(</span><span class="n">merged_morphisms</span><span class="p">)</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># This diagram contains only one morphism.  Draw it</span>
            <span class="c"># horizontally.</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_objects</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">grid</span>

        <span class="n">triangles</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_list_triangles</span><span class="p">(</span><span class="n">skeleton</span><span class="p">)</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_drop_redundant_triangles</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">)</span>
        <span class="n">triangle_sizes</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_compute_triangle_min_sizes</span><span class="p">(</span>
            <span class="n">triangles</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">)</span>

        <span class="n">triangles</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tri</span><span class="p">:</span>
                           <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_key</span><span class="p">(</span><span class="n">tri</span><span class="p">,</span> <span class="n">triangle_sizes</span><span class="p">))</span>

        <span class="c"># Place the first edge on the grid.</span>
        <span class="n">root_edge</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_pick_root_edge</span><span class="p">(</span><span class="n">triangles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">skeleton</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_edge</span>
        <span class="n">fringe</span> <span class="o">=</span> <span class="p">[((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))]</span>

        <span class="c"># Record which objects we now have on the grid.</span>
        <span class="n">placed_objects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">root_edge</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">placed_objects</span> <span class="o">!=</span> <span class="n">all_objects</span><span class="p">:</span>
            <span class="n">welding</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_find_triangle_to_weld</span><span class="p">(</span>
                <span class="n">triangles</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">welding</span><span class="p">:</span>
                <span class="p">(</span><span class="n">triangle</span><span class="p">,</span> <span class="n">welding_edge</span><span class="p">)</span> <span class="o">=</span> <span class="n">welding</span>

                <span class="n">restart_required</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_weld_triangle</span><span class="p">(</span>
                    <span class="n">triangle</span><span class="p">,</span> <span class="n">welding_edge</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">restart_required</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">placed_objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_triangle_objects</span><span class="p">(</span><span class="n">triangle</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># No more weldings found.  Try to attach triangles by</span>
                <span class="c"># vertices.</span>
                <span class="n">new_obj</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_grow_pseudopod</span><span class="p">(</span>
                    <span class="n">triangles</span><span class="p">,</span> <span class="n">fringe</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">skeleton</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_obj</span><span class="p">:</span>
                    <span class="c"># No more triangles can be attached, not even by</span>
                    <span class="c"># the edge.  We will set up a new diagram out of</span>
                    <span class="c"># what has been left, laid it out independently,</span>
                    <span class="c"># and then attach it to this one.</span>

                    <span class="n">remaining_objects</span> <span class="o">=</span> <span class="n">all_objects</span> <span class="o">-</span> <span class="n">placed_objects</span>

                    <span class="n">remaining_diagram</span> <span class="o">=</span> <span class="n">diagram</span><span class="o">.</span><span class="n">subdiagram_from_objects</span><span class="p">(</span>
                        <span class="n">FiniteSet</span><span class="p">(</span><span class="n">remaining_objects</span><span class="p">))</span>
                    <span class="n">remaining_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span><span class="n">remaining_diagram</span><span class="p">)</span>

                    <span class="c"># Now, let&#39;s glue ``remaining_grid`` to ``grid``.</span>
                    <span class="n">final_width</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span> <span class="o">+</span> <span class="n">remaining_grid</span><span class="o">.</span><span class="n">width</span>
                    <span class="n">final_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">remaining_grid</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
                    <span class="n">final_grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="n">final_width</span><span class="p">,</span> <span class="n">final_height</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                            <span class="n">final_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                    <span class="n">start_j</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">remaining_grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">remaining_grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                            <span class="n">final_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">start_j</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">remaining_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                    <span class="k">return</span> <span class="n">final_grid</span>

                <span class="n">placed_objects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_obj</span><span class="p">)</span>

            <span class="n">triangles</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_drop_irrelevant_triangles</span><span class="p">(</span>
                <span class="n">triangles</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_undirected_graph</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the objects and the relevant morphisms of a diagram,</span>
<span class="sd">        returns the adjacency lists of the underlying undirected</span>
<span class="sd">        graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adjlists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">adjlists</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">merged_morphisms</span><span class="p">:</span>
            <span class="n">adjlists</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">)</span>
            <span class="n">adjlists</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

        <span class="c"># Assure that the objects in the adjacency list are always in</span>
        <span class="c"># the same order.</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">adjlists</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">adjlists</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">adjlists</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sequential_layout</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Lays out the diagram in &quot;sequential&quot; layout.  This method</span>
<span class="sd">        will attempt to produce a result as close to a line as</span>
<span class="sd">        possible.  For linear diagrams, the result will actually be a</span>
<span class="sd">        line.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="n">diagram</span><span class="o">.</span><span class="n">objects</span>
        <span class="n">sorted_objects</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="c"># Set up the adjacency lists of the underlying undirected</span>
        <span class="c"># graph of ``merged_morphisms``.</span>
        <span class="n">adjlists</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_get_undirected_graph</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">)</span>

        <span class="c"># Find an object with the minimal degree.  This is going to be</span>
        <span class="c"># the root.</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">sorted_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mindegree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adjlists</span><span class="p">[</span><span class="n">root</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">sorted_objects</span><span class="p">:</span>
            <span class="n">current_degree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adjlists</span><span class="p">[</span><span class="n">obj</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">current_degree</span> <span class="o">&lt;</span> <span class="n">mindegree</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">obj</span>
                <span class="n">mindegree</span> <span class="o">=</span> <span class="n">current_degree</span>

        <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>

        <span class="n">placed_objects</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">place_objects</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Does depth-first search in the underlying graph of the</span>
<span class="sd">            diagram and places the objects en route.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c"># We will start placing new objects from here.</span>
            <span class="n">new_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">adjacent_obj</span> <span class="ow">in</span> <span class="n">adjlists</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">pt</span><span class="p">]]:</span>
                <span class="k">if</span> <span class="n">adjacent_obj</span> <span class="ow">in</span> <span class="n">placed_objects</span><span class="p">:</span>
                    <span class="c"># This object has already been placed.</span>
                    <span class="k">continue</span>

                <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_put_object</span><span class="p">(</span><span class="n">new_pt</span><span class="p">,</span> <span class="n">adjacent_obj</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="p">[])</span>
                <span class="n">placed_objects</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">adjacent_obj</span><span class="p">)</span>
                <span class="n">placed_objects</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">place_objects</span><span class="p">(</span><span class="n">new_pt</span><span class="p">,</span> <span class="n">placed_objects</span><span class="p">))</span>

                <span class="n">new_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">placed_objects</span>

        <span class="n">place_objects</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">placed_objects</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_drop_inessential_morphisms</span><span class="p">(</span><span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Removes those morphisms which should appear in the diagram,</span>
<span class="sd">        but which have no relevance to object layout.</span>

<span class="sd">        Currently this removes &quot;loop&quot; morphisms: the non-identity</span>
<span class="sd">        morphisms with the same domains and codomains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">morphisms</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">merged_morphisms</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">morphisms</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_connected_components</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a container of morphisms, returns a list of connected</span>
<span class="sd">        components formed by these morphisms.  A connected component</span>
<span class="sd">        is represented by a diagram consisting of the corresponding</span>
<span class="sd">        morphisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">component_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">component_index</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># Get the underlying undirected graph of the diagram.</span>
        <span class="n">adjlist</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_get_undirected_graph</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">traverse_component</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">current_index</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Does a depth-first search traversal of the component</span>
<span class="sd">            containing ``object``.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">component_index</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_index</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">adjlist</span><span class="p">[</span><span class="nb">object</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">component_index</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">traverse_component</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">current_index</span><span class="p">)</span>

        <span class="c"># Traverse all components.</span>
        <span class="n">current_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">adjlist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">component_index</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">traverse_component</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">current_index</span><span class="p">)</span>
                <span class="n">current_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># List the objects of the components.</span>
        <span class="n">component_objects</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">current_index</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">component_index</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">component_objects</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="c"># Finally, list the morphisms belonging to each component.</span>
        <span class="c">#</span>
        <span class="c"># Note: If some objects are isolated, they will not get any</span>
        <span class="c"># morphisms at this stage, and since the layout algorithm</span>
        <span class="c"># relies, we are essentially going to lose this object.</span>
        <span class="c"># Therefore, check if there are isolated objects and, for each</span>
        <span class="c"># of them, provide the trivial identity morphism.  It will get</span>
        <span class="c"># discarded later, but the object will be there.</span>

        <span class="n">component_morphisms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">component_objects</span><span class="p">:</span>
            <span class="n">current_morphisms</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">merged_morphisms</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="n">component</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span> <span class="ow">in</span> <span class="n">component</span><span class="p">):</span>
                    <span class="n">current_morphisms</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged_morphisms</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># Let&#39;s add an identity morphism, for the sake of</span>
                <span class="c"># surely having morphisms in this component.</span>
                <span class="n">current_morphisms</span><span class="p">[</span><span class="n">IdentityMorphism</span><span class="p">(</span><span class="n">component</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">FiniteSet</span><span class="p">()</span>

            <span class="n">component_morphisms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Diagram</span><span class="p">(</span><span class="n">current_morphisms</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">component_morphisms</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagram</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="n">premises</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_simplify_morphisms</span><span class="p">(</span><span class="n">diagram</span><span class="o">.</span><span class="n">premises</span><span class="p">)</span>
        <span class="n">conclusions</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_simplify_morphisms</span><span class="p">(</span><span class="n">diagram</span><span class="o">.</span><span class="n">conclusions</span><span class="p">)</span>
        <span class="n">all_merged_morphisms</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_merge_premises_conclusions</span><span class="p">(</span>
            <span class="n">premises</span><span class="p">,</span> <span class="n">conclusions</span><span class="p">)</span>
        <span class="n">merged_morphisms</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_drop_inessential_morphisms</span><span class="p">(</span>
            <span class="n">all_merged_morphisms</span><span class="p">)</span>

        <span class="c"># Store the merged morphisms for later use.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_morphisms</span> <span class="o">=</span> <span class="n">all_merged_morphisms</span>

        <span class="n">components</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_get_connected_components</span><span class="p">(</span>
            <span class="n">diagram</span><span class="o">.</span><span class="n">objects</span><span class="p">,</span> <span class="n">all_merged_morphisms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">groups</span> <span class="ow">and</span> <span class="p">(</span><span class="n">groups</span> <span class="o">!=</span> <span class="n">diagram</span><span class="o">.</span><span class="n">objects</span><span class="p">):</span>
            <span class="c"># Lay out the diagram according to the groups.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_handle_groups</span><span class="p">(</span>
                <span class="n">diagram</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">,</span> <span class="n">hints</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Note that we check for connectedness _before_ checking</span>
            <span class="c"># the layout hints because the layout strategies don&#39;t</span>
            <span class="c"># know how to deal with disconnected diagrams.</span>

            <span class="c"># The diagram is disconnected.  Lay out the components</span>
            <span class="c"># independently.</span>
            <span class="n">grids</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c"># Sort the components to eventually get the grids arranged</span>
            <span class="c"># in a fixed, hash-independent order.</span>
            <span class="n">components</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
                <span class="n">grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

            <span class="c"># Throw the grids together, in a line.</span>
            <span class="n">total_width</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">)</span>
            <span class="n">total_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">height</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">)</span>

            <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="n">total_width</span><span class="p">,</span> <span class="n">total_height</span><span class="p">)</span>
            <span class="n">start_j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                        <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">start_j</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

                <span class="n">start_j</span> <span class="o">+=</span> <span class="n">g</span><span class="o">.</span><span class="n">width</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="k">elif</span> <span class="s">&quot;layout&quot;</span> <span class="ow">in</span> <span class="n">hints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hints</span><span class="p">[</span><span class="s">&quot;layout&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;sequential&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_sequential_layout</span><span class="p">(</span>
                    <span class="n">diagram</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="o">.</span><span class="n">_generic_layout</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">merged_morphisms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;transpose&quot;</span><span class="p">):</span>
            <span class="c"># Transpose the resulting grid.</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">_GrowableGrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">grid</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="DiagramGrid.width"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.DiagramGrid.width">[docs]</a>    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of columns in this diagram layout.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; grid.width</span>
<span class="sd">        2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">width</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="DiagramGrid.height"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.DiagramGrid.height">[docs]</a>    <span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of rows in this diagram layout.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; grid.height</span>
<span class="sd">        2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">height</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xxx_todo_changeme2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the object placed in the row ``i`` and column ``j``.</span>
<span class="sd">        The indices are 0-based.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; (grid[0, 0], grid[0, 1])</span>
<span class="sd">        (Object(&quot;A&quot;), Object(&quot;B&quot;))</span>
<span class="sd">        &gt;&gt;&gt; (grid[1, 0], grid[1, 1])</span>
<span class="sd">        (None, Object(&quot;C&quot;))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">xxx_todo_changeme2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="DiagramGrid.morphisms"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.DiagramGrid.morphisms">[docs]</a>    <span class="k">def</span> <span class="nf">morphisms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns those morphisms (and their properties) which are</span>
<span class="sd">        sufficiently meaningful to be drawn.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; grid.morphisms</span>
<span class="sd">        {NamedMorphism(Object(&quot;A&quot;), Object(&quot;B&quot;), &quot;f&quot;): EmptySet(),</span>
<span class="sd">        NamedMorphism(Object(&quot;B&quot;), Object(&quot;C&quot;), &quot;g&quot;): EmptySet()}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_morphisms</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces a string representation of this class.</span>

<span class="sd">        This method returns a string representation of the underlying</span>
<span class="sd">        list of lists of objects.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import Diagram, DiagramGrid</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">        &gt;&gt;&gt; print(grid)</span>
<span class="sd">        [[Object(&quot;A&quot;), Object(&quot;B&quot;)],</span>
<span class="sd">        [None, Object(&quot;C&quot;)]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">_array</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ArrowStringDescription"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.ArrowStringDescription">[docs]</a><span class="k">class</span> <span class="nc">ArrowStringDescription</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Stores the information necessary for producing an Xy-pic</span>
<span class="sd">    description of an arrow.</span>

<span class="sd">    The principal goal of this class is to abstract away the string</span>
<span class="sd">    representation of an arrow and to also provide the functionality</span>
<span class="sd">    to produce the actual Xy-pic string.</span>

<span class="sd">    ``unit`` sets the unit which will be used to specify the amount of</span>
<span class="sd">    curving and other distances.  ``horizontal_direction`` should be a</span>
<span class="sd">    string of ``&quot;r&quot;`` or ``&quot;l&quot;`` specifying the horizontal offset of the</span>
<span class="sd">    target cell of the arrow relatively to the current one.</span>
<span class="sd">    ``vertical_direction`` should  specify the vertical offset using a</span>
<span class="sd">    series of either ``&quot;d&quot;`` or ``&quot;u&quot;``.  ``label_position`` should be</span>
<span class="sd">    either ``&quot;^&quot;``, ``&quot;_&quot;``,  or ``&quot;|&quot;`` to specify that the label should</span>
<span class="sd">    be positioned above the arrow, below the arrow or just over the arrow,</span>
<span class="sd">    in a break.  Note that the notions &quot;above&quot; and &quot;below&quot; are relative</span>
<span class="sd">    to arrow direction.  ``label`` stores the morphism label.</span>

<span class="sd">    This works as follows (disregard the yet unexplained arguments):</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories.diagram_drawing import ArrowStringDescription</span>
<span class="sd">    &gt;&gt;&gt; astr = ArrowStringDescription(</span>
<span class="sd">    ... unit=&quot;mm&quot;, curving=None, curving_amount=None,</span>
<span class="sd">    ... looping_start=None, looping_end=None, horizontal_direction=&quot;d&quot;,</span>
<span class="sd">    ... vertical_direction=&quot;r&quot;, label_position=&quot;_&quot;, label=&quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(str(astr))</span>
<span class="sd">    \ar[dr]_{f}</span>

<span class="sd">    ``curving`` should be one of ``&quot;^&quot;``, ``&quot;_&quot;`` to specify in which</span>
<span class="sd">    direction the arrow is going to curve. ``curving_amount`` is a number</span>
<span class="sd">    describing how many ``unit``&#39;s the morphism is going to curve:</span>

<span class="sd">    &gt;&gt;&gt; astr = ArrowStringDescription(</span>
<span class="sd">    ... unit=&quot;mm&quot;, curving=&quot;^&quot;, curving_amount=12,</span>
<span class="sd">    ... looping_start=None, looping_end=None, horizontal_direction=&quot;d&quot;,</span>
<span class="sd">    ... vertical_direction=&quot;r&quot;, label_position=&quot;_&quot;, label=&quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(str(astr))</span>
<span class="sd">    \ar@/^12mm/[dr]_{f}</span>

<span class="sd">    ``looping_start`` and ``looping_end`` are currently only used for</span>
<span class="sd">    loop morphisms, those which have the same domain and codomain.</span>
<span class="sd">    These two attributes should store a valid Xy-pic direction and</span>
<span class="sd">    specify, correspondingly, the direction the arrow gets out into</span>
<span class="sd">    and the direction the arrow gets back from:</span>

<span class="sd">    &gt;&gt;&gt; astr = ArrowStringDescription(</span>
<span class="sd">    ... unit=&quot;mm&quot;, curving=None, curving_amount=None,</span>
<span class="sd">    ... looping_start=&quot;u&quot;, looping_end=&quot;l&quot;, horizontal_direction=&quot;&quot;,</span>
<span class="sd">    ... vertical_direction=&quot;&quot;, label_position=&quot;_&quot;, label=&quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(str(astr))</span>
<span class="sd">    \ar@(u,l)[]_{f}</span>

<span class="sd">    ``label_displacement`` controls how far the arrow label is from</span>
<span class="sd">    the ends of the arrow.  For example, to position the arrow label</span>
<span class="sd">    near the arrow head, use &quot;&gt;&quot;:</span>

<span class="sd">    &gt;&gt;&gt; astr = ArrowStringDescription(</span>
<span class="sd">    ... unit=&quot;mm&quot;, curving=&quot;^&quot;, curving_amount=12,</span>
<span class="sd">    ... looping_start=None, looping_end=None, horizontal_direction=&quot;d&quot;,</span>
<span class="sd">    ... vertical_direction=&quot;r&quot;, label_position=&quot;_&quot;, label=&quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; astr.label_displacement = &quot;&gt;&quot;</span>
<span class="sd">    &gt;&gt;&gt; print(str(astr))</span>
<span class="sd">    \ar@/^12mm/[dr]_&gt;{f}</span>

<span class="sd">    Finally, ``arrow_style`` is used to specify the arrow style.  To</span>
<span class="sd">    get a dashed arrow, for example, use &quot;{--&gt;}&quot; as arrow style:</span>

<span class="sd">    &gt;&gt;&gt; astr = ArrowStringDescription(</span>
<span class="sd">    ... unit=&quot;mm&quot;, curving=&quot;^&quot;, curving_amount=12,</span>
<span class="sd">    ... looping_start=None, looping_end=None, horizontal_direction=&quot;d&quot;,</span>
<span class="sd">    ... vertical_direction=&quot;r&quot;, label_position=&quot;_&quot;, label=&quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; astr.arrow_style = &quot;{--&gt;}&quot;</span>
<span class="sd">    &gt;&gt;&gt; print(str(astr))</span>
<span class="sd">    \ar@/^12mm/@{--&gt;}[dr]_{f}</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    Instances of :class:`ArrowStringDescription` will be constructed</span>
<span class="sd">    by :class:`XypicDiagramDrawer` and provided for further use in</span>
<span class="sd">    formatters.  The user is not expected to construct instances of</span>
<span class="sd">    :class:`ArrowStringDescription` themselves.</span>

<span class="sd">    To be able to properly utilise this class, the reader is encouraged</span>
<span class="sd">    to checkout the Xy-pic user guide, available at [Xypic].</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    XypicDiagramDrawer</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    [Xypic] http://www.tug.org/applications/Xy-pic/</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">curving</span><span class="p">,</span> <span class="n">curving_amount</span><span class="p">,</span> <span class="n">looping_start</span><span class="p">,</span>
                 <span class="n">looping_end</span><span class="p">,</span> <span class="n">horizontal_direction</span><span class="p">,</span> <span class="n">vertical_direction</span><span class="p">,</span>
                 <span class="n">label_position</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curving</span> <span class="o">=</span> <span class="n">curving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curving_amount</span> <span class="o">=</span> <span class="n">curving_amount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">looping_start</span> <span class="o">=</span> <span class="n">looping_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">looping_end</span> <span class="o">=</span> <span class="n">looping_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">horizontal_direction</span> <span class="o">=</span> <span class="n">horizontal_direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vertical_direction</span> <span class="o">=</span> <span class="n">vertical_direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="n">label_position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">label_displacement</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow_style</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

        <span class="c"># This flag shows that the position of the label of this</span>
        <span class="c"># morphism was set while typesetting a curved morphism and</span>
        <span class="c"># should not be modified later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forced_label_position</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">curving</span><span class="p">:</span>
            <span class="n">curving_str</span> <span class="o">=</span> <span class="s">&quot;@/</span><span class="si">%s%d%s</span><span class="s">/&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">curving</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curving_amount</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curving_str</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">looping_start</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">looping_end</span><span class="p">:</span>
            <span class="n">looping_str</span> <span class="o">=</span> <span class="s">&quot;@(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">looping_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">looping_end</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">looping_str</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow_style</span><span class="p">:</span>

            <span class="n">style_str</span> <span class="o">=</span> <span class="s">&quot;@&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow_style</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">style_str</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">ar</span><span class="si">%s%s%s</span><span class="s">[</span><span class="si">%s%s</span><span class="s">]</span><span class="si">%s%s</span><span class="s">{</span><span class="si">%s</span><span class="s">}&quot;</span> <span class="o">%</span> \
               <span class="p">(</span><span class="n">curving_str</span><span class="p">,</span> <span class="n">looping_str</span><span class="p">,</span> <span class="n">style_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">horizontal_direction</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vertical_direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_position</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_displacement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="XypicDiagramDrawer"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.XypicDiagramDrawer">[docs]</a><span class="k">class</span> <span class="nc">XypicDiagramDrawer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Given a :class:`Diagram` and the corresponding</span>
<span class="sd">    :class:`DiagramGrid`, produces the Xy-pic representation of the</span>
<span class="sd">    diagram.</span>

<span class="sd">    The most important method in this class is ``draw``.  Consider the</span>
<span class="sd">    following triangle diagram:</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">    &gt;&gt;&gt; from sympy.categories import DiagramGrid, XypicDiagramDrawer</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g], {g * f: &quot;unique&quot;})</span>

<span class="sd">    To draw this diagram, its objects need to be laid out with a</span>
<span class="sd">    :class:`DiagramGrid`::</span>

<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>

<span class="sd">    Finally, the drawing:</span>

<span class="sd">    &gt;&gt;&gt; drawer = XypicDiagramDrawer()</span>
<span class="sd">    &gt;&gt;&gt; print(drawer.draw(diagram, grid))</span>
<span class="sd">    \xymatrix{</span>
<span class="sd">    A \ar[d]_{g\circ f} \ar[r]^{f} &amp; B \ar[ld]^{g} \\</span>
<span class="sd">    C &amp;</span>
<span class="sd">    }</span>

<span class="sd">    For further details see the docstring of this method.</span>

<span class="sd">    To control the appearance of the arrows, formatters are used.  The</span>
<span class="sd">    dictionary ``arrow_formatters`` maps morphisms to formatter</span>
<span class="sd">    functions.  A formatter is accepts an</span>
<span class="sd">    :class:`ArrowStringDescription` and is allowed to modify any of</span>
<span class="sd">    the arrow properties exposed thereby.  For example, to have all</span>
<span class="sd">    morphisms with the property ``unique`` appear as dashed arrows,</span>
<span class="sd">    and to have their names prepended with `\exists !`, the following</span>
<span class="sd">    should be done:</span>

<span class="sd">    &gt;&gt;&gt; def formatter(astr):</span>
<span class="sd">    ...   astr.label = &quot;\exists !&quot; + astr.label</span>
<span class="sd">    ...   astr.arrow_style = &quot;{--&gt;}&quot;</span>
<span class="sd">    &gt;&gt;&gt; drawer.arrow_formatters[&quot;unique&quot;] = formatter</span>
<span class="sd">    &gt;&gt;&gt; print(drawer.draw(diagram, grid))</span>
<span class="sd">    \xymatrix{</span>
<span class="sd">    A \ar@{--&gt;}[d]_{\exists !g\circ f} \ar[r]^{f} &amp; B \ar[ld]^{g} \\</span>
<span class="sd">    C &amp;</span>
<span class="sd">    }</span>

<span class="sd">    To modify the appearance of all arrows in the diagram, set</span>
<span class="sd">    ``default_arrow_formatter``.  For example, to place all morphism</span>
<span class="sd">    labels a little bit farther from the arrow head so that they look</span>
<span class="sd">    more centred, do as follows:</span>

<span class="sd">    &gt;&gt;&gt; def default_formatter(astr):</span>
<span class="sd">    ...   astr.label_displacement = &quot;(0.45)&quot;</span>
<span class="sd">    &gt;&gt;&gt; drawer.default_arrow_formatter = default_formatter</span>
<span class="sd">    &gt;&gt;&gt; print(drawer.draw(diagram, grid))</span>
<span class="sd">    \xymatrix{</span>
<span class="sd">    A \ar@{--&gt;}[d]_(0.45){\exists !g\circ f} \ar[r]^(0.45){f} &amp; B \ar[ld]^(0.45){g} \\</span>
<span class="sd">    C &amp;</span>
<span class="sd">    }</span>

<span class="sd">    In some diagrams some morphisms are drawn as curved arrows.</span>
<span class="sd">    Consider the following diagram:</span>

<span class="sd">    &gt;&gt;&gt; D = Object(&quot;D&quot;)</span>
<span class="sd">    &gt;&gt;&gt; E = Object(&quot;E&quot;)</span>
<span class="sd">    &gt;&gt;&gt; h = NamedMorphism(D, A, &quot;h&quot;)</span>
<span class="sd">    &gt;&gt;&gt; k = NamedMorphism(D, B, &quot;k&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g, h, k])</span>
<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">    &gt;&gt;&gt; drawer = XypicDiagramDrawer()</span>
<span class="sd">    &gt;&gt;&gt; print(drawer.draw(diagram, grid))</span>
<span class="sd">    \xymatrix{</span>
<span class="sd">    A \ar[r]_{f} &amp; B \ar[d]^{g} &amp; D \ar[l]^{k} \ar@/_3mm/[ll]_{h} \\</span>
<span class="sd">    &amp; C &amp;</span>
<span class="sd">    }</span>

<span class="sd">    To control how far the morphisms are curved by default, one can</span>
<span class="sd">    use the ``unit`` and ``default_curving_amount`` attributes:</span>

<span class="sd">    &gt;&gt;&gt; drawer.unit = &quot;cm&quot;</span>
<span class="sd">    &gt;&gt;&gt; drawer.default_curving_amount = 1</span>
<span class="sd">    &gt;&gt;&gt; print(drawer.draw(diagram, grid))</span>
<span class="sd">    \xymatrix{</span>
<span class="sd">    A \ar[r]_{f} &amp; B \ar[d]^{g} &amp; D \ar[l]^{k} \ar@/_1cm/[ll]_{h} \\</span>
<span class="sd">    &amp; C &amp;</span>
<span class="sd">    }</span>

<span class="sd">    In some diagrams, there are multiple curved morphisms between the</span>
<span class="sd">    same two objects.  To control by how much the curving changes</span>
<span class="sd">    between two such successive morphisms, use</span>
<span class="sd">    ``default_curving_step``:</span>

<span class="sd">    &gt;&gt;&gt; drawer.default_curving_step = 1</span>
<span class="sd">    &gt;&gt;&gt; h1 = NamedMorphism(A, D, &quot;h1&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g, h, k, h1])</span>
<span class="sd">    &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>
<span class="sd">    &gt;&gt;&gt; print(drawer.draw(diagram, grid))</span>
<span class="sd">    \xymatrix{</span>
<span class="sd">    A \ar[r]_{f} \ar@/^1cm/[rr]^{h_{1}} &amp; B \ar[d]^{g} &amp; D \ar[l]^{k} \ar@/_2cm/[ll]_{h} \\</span>
<span class="sd">    &amp; C &amp;</span>
<span class="sd">    }</span>

<span class="sd">    The default value of ``default_curving_step`` is 4 units.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    draw, ArrowStringDescription</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="s">&quot;mm&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_curving_amount</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_curving_step</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="c"># This dictionary maps properties to the corresponding arrow</span>
        <span class="c"># formatters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arrow_formatters</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># This is the default arrow formatter which will be applied to</span>
        <span class="c"># each arrow independently of its properties.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_arrow_formatter</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_process_loop_morphism</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces the information required for constructing the string</span>
<span class="sd">        representation of a loop morphism.  This function is invoked</span>
<span class="sd">        from ``_process_morphism``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _process_morphism</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
        <span class="n">looping_start</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="n">looping_end</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

        <span class="c"># This is a loop morphism.  Count how many morphisms stick</span>
        <span class="c"># in each of the four quadrants.  Note that straight</span>
        <span class="c"># vertical and horizontal morphisms count in two quadrants</span>
        <span class="c"># at the same time (i.e., a morphism going up counts both</span>
        <span class="c"># in the first and the second quadrants).</span>

        <span class="c"># The usual numbering (counterclockwise) of quadrants</span>
        <span class="c"># applies.</span>
        <span class="n">quadrant</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">m_str_info</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">morphisms_str_info</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span> <span class="o">==</span> <span class="n">obj</span><span class="p">):</span>
                <span class="c"># That&#39;s another loop morphism.  Check how it</span>
                <span class="c"># loops and mark the corresponding quadrants as</span>
                <span class="c"># busy.</span>
                <span class="p">(</span><span class="n">l_s</span><span class="p">,</span> <span class="n">l_e</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_str_info</span><span class="o">.</span><span class="n">looping_start</span><span class="p">,</span> <span class="n">m_str_info</span><span class="o">.</span><span class="n">looping_end</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">l_s</span><span class="p">,</span> <span class="n">l_e</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="s">&quot;u&quot;</span><span class="p">):</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">l_s</span><span class="p">,</span> <span class="n">l_e</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="s">&quot;l&quot;</span><span class="p">):</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">l_s</span><span class="p">,</span> <span class="n">l_e</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s">&quot;l&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">):</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">l_s</span><span class="p">,</span> <span class="n">l_e</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">):</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">obj</span><span class="p">:</span>
                <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>
                <span class="n">goes_out</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">codomain</span> <span class="o">==</span> <span class="n">obj</span><span class="p">:</span>
                <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
                <span class="n">goes_out</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">d_i</span> <span class="o">=</span> <span class="n">end_i</span> <span class="o">-</span> <span class="n">i</span>
            <span class="n">d_j</span> <span class="o">=</span> <span class="n">end_j</span> <span class="o">-</span> <span class="n">j</span>
            <span class="n">m_curving</span> <span class="o">=</span> <span class="n">m_str_info</span><span class="o">.</span><span class="n">curving</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">d_i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d_j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c"># This is really a diagonal morphism.  Detect the</span>
                <span class="c"># quadrant.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">d_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d_j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">d_i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d_j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">d_i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d_j</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">d_i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">d_j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">d_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Knowing where the other end of the morphism is</span>
                <span class="c"># and which way it goes, we now have to decide</span>
                <span class="c"># which quadrant is now the upper one and which is</span>
                <span class="c"># the lower one.</span>
                <span class="k">if</span> <span class="n">d_j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">goes_out</span><span class="p">:</span>
                        <span class="n">upper_quadrant</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">lower_quadrant</span> <span class="o">=</span> <span class="mi">3</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">upper_quadrant</span> <span class="o">=</span> <span class="mi">3</span>
                        <span class="n">lower_quadrant</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">goes_out</span><span class="p">:</span>
                        <span class="n">upper_quadrant</span> <span class="o">=</span> <span class="mi">2</span>
                        <span class="n">lower_quadrant</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">upper_quadrant</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">lower_quadrant</span> <span class="o">=</span> <span class="mi">2</span>

                <span class="k">if</span> <span class="n">m_curving</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">m_curving</span> <span class="o">==</span> <span class="s">&quot;^&quot;</span><span class="p">:</span>
                        <span class="n">quadrant</span><span class="p">[</span><span class="n">upper_quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">m_curving</span> <span class="o">==</span> <span class="s">&quot;_&quot;</span><span class="p">:</span>
                        <span class="n">quadrant</span><span class="p">[</span><span class="n">lower_quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># This morphism counts in both upper and lower</span>
                    <span class="c"># quadrants.</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="n">upper_quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="n">lower_quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">d_j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Knowing where the other end of the morphism is</span>
                <span class="c"># and which way it goes, we now have to decide</span>
                <span class="c"># which quadrant is now the left one and which is</span>
                <span class="c"># the right one.</span>
                <span class="k">if</span> <span class="n">d_i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">goes_out</span><span class="p">:</span>
                        <span class="n">left_quadrant</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">right_quadrant</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">left_quadrant</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">right_quadrant</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">goes_out</span><span class="p">:</span>
                        <span class="n">left_quadrant</span> <span class="o">=</span> <span class="mi">3</span>
                        <span class="n">right_quadrant</span> <span class="o">=</span> <span class="mi">2</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">left_quadrant</span> <span class="o">=</span> <span class="mi">2</span>
                        <span class="n">right_quadrant</span> <span class="o">=</span> <span class="mi">3</span>

                <span class="k">if</span> <span class="n">m_curving</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">m_curving</span> <span class="o">==</span> <span class="s">&quot;^&quot;</span><span class="p">:</span>
                        <span class="n">quadrant</span><span class="p">[</span><span class="n">left_quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">m_curving</span> <span class="o">==</span> <span class="s">&quot;_&quot;</span><span class="p">:</span>
                        <span class="n">quadrant</span><span class="p">[</span><span class="n">right_quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># This morphism counts in both upper and lower</span>
                    <span class="c"># quadrants.</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="n">left_quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">quadrant</span><span class="p">[</span><span class="n">right_quadrant</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Pick the freest quadrant to curve our morphism into.</span>
        <span class="n">freest_quadrant</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">quadrant</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">quadrant</span><span class="p">[</span><span class="n">freest_quadrant</span><span class="p">]:</span>
                <span class="n">freest_quadrant</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c"># Now set up proper looping.</span>
        <span class="p">(</span><span class="n">looping_start</span><span class="p">,</span> <span class="n">looping_end</span><span class="p">)</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="s">&quot;u&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;u&quot;</span><span class="p">,</span> <span class="s">&quot;l&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;l&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">),</span>
                                        <span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">)][</span><span class="n">freest_quadrant</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">curving</span><span class="p">,</span> <span class="n">label_pos</span><span class="p">,</span> <span class="n">looping_start</span><span class="p">,</span> <span class="n">looping_end</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_process_horizontal_morphism</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">target_j</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">,</span>
                                     <span class="n">object_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces the information required for constructing the string</span>
<span class="sd">        representation of a horizontal morphism.  This function is</span>
<span class="sd">        invoked from ``_process_morphism``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _process_morphism</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># The arrow is horizontal.  Check if it goes from left to</span>
        <span class="c"># right (``backwards == False``) or from right to left</span>
        <span class="c"># (``backwards == True``).</span>
        <span class="n">backwards</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">target_j</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Let&#39;s see which objects are there between ``start`` and</span>
        <span class="c"># ``end``, and then count how many morphisms stick out</span>
        <span class="c"># upwards, and how many stick out downwards.</span>
        <span class="c">#</span>
        <span class="c"># For example, consider the situation:</span>
        <span class="c">#</span>
        <span class="c">#    B1 C1</span>
        <span class="c">#    |  |</span>
        <span class="c"># A--B--C--D</span>
        <span class="c">#    |</span>
        <span class="c">#    B2</span>
        <span class="c">#</span>
        <span class="c"># Between the objects `A` and `D` there are two objects:</span>
        <span class="c"># `B` and `C`.  Further, there are two morphisms which</span>
        <span class="c"># stick out upward (the ones between `B1` and `B` and</span>
        <span class="c"># between `C` and `C1`) and one morphism which sticks out</span>
        <span class="c"># downward (the one between `B and `B2`).</span>
        <span class="c">#</span>
        <span class="c"># We need this information to decide how to curve the</span>
        <span class="c"># arrow between `A` and `D`.  First of all, since there</span>
        <span class="c"># are two objects between `A` and `D``, we must curve the</span>
        <span class="c"># arrow.  Then, we will have it curve downward, because</span>
        <span class="c"># there is more space (less morphisms stick out downward</span>
        <span class="c"># than upward).</span>
        <span class="n">up</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">down</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">straight_horizontal</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">morphisms_str_info</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">codomain</span> <span class="o">==</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">end_i</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">down</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">end_i</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="n">up</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">morphisms_str_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">curving</span><span class="p">:</span>
                    <span class="c"># This is a straight horizontal morphism,</span>
                    <span class="c"># because it has no curving.</span>
                    <span class="n">straight_horizontal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">up</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
            <span class="c"># More morphisms stick out downward than upward, let&#39;s</span>
            <span class="c"># curve the morphism up.</span>
            <span class="k">if</span> <span class="n">backwards</span><span class="p">:</span>
                <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>
                <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
                <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>

            <span class="c"># Assure that the straight horizontal morphisms have</span>
            <span class="c"># their labels on the lower side of the arrow.</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">straight_horizontal</span><span class="p">:</span>
                <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
                <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>

                <span class="n">m_str_info</span> <span class="o">=</span> <span class="n">morphisms_str_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">j1</span> <span class="o">&lt;</span> <span class="n">j2</span><span class="p">:</span>
                    <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>

                <span class="c"># Don&#39;t allow any further modifications of the</span>
                <span class="c"># position of this label.</span>
                <span class="n">m_str_info</span><span class="o">.</span><span class="n">forced_label_position</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># More morphisms stick out downward than upward, let&#39;s</span>
            <span class="c"># curve the morphism up.</span>
            <span class="k">if</span> <span class="n">backwards</span><span class="p">:</span>
                <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
                <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>
                <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>

            <span class="c"># Assure that the straight horizontal morphisms have</span>
            <span class="c"># their labels on the upper side of the arrow.</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">straight_horizontal</span><span class="p">:</span>
                <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
                <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>

                <span class="n">m_str_info</span> <span class="o">=</span> <span class="n">morphisms_str_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">j1</span> <span class="o">&lt;</span> <span class="n">j2</span><span class="p">:</span>
                    <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>

                <span class="c"># Don&#39;t allow any further modifications of the</span>
                <span class="c"># position of this label.</span>
                <span class="n">m_str_info</span><span class="o">.</span><span class="n">forced_label_position</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">curving</span><span class="p">,</span> <span class="n">label_pos</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_process_vertical_morphism</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">target_i</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">,</span>
                                   <span class="n">object_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produces the information required for constructing the string</span>
<span class="sd">        representation of a vertical morphism.  This function is</span>
<span class="sd">        invoked from ``_process_morphism``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _process_morphism</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This arrow is vertical.  Check if it goes from top to</span>
        <span class="c"># bottom (``backwards == False``) or from bottom to top</span>
        <span class="c"># (``backwards == True``).</span>
        <span class="n">backwards</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">target_i</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Let&#39;s see which objects are there between ``start`` and</span>
        <span class="c"># ``end``, and then count how many morphisms stick out to</span>
        <span class="c"># the left, and how many stick out to the right.</span>
        <span class="c">#</span>
        <span class="c"># See the corresponding comment in the previous branch of</span>
        <span class="c"># this if-statement for more details.</span>
        <span class="n">left</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">straight_vertical</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">morphisms_str_info</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">codomain</span> <span class="o">==</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">end_j</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">end_j</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">morphisms_str_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">curving</span><span class="p">:</span>
                    <span class="c"># This is a straight vertical morphism,</span>
                    <span class="c"># because it has no curving.</span>
                    <span class="n">straight_vertical</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="c"># More morphisms stick out to the left than to the</span>
            <span class="c"># right, let&#39;s curve the morphism to the right.</span>
            <span class="k">if</span> <span class="n">backwards</span><span class="p">:</span>
                <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
                <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>
                <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>

            <span class="c"># Assure that the straight vertical morphisms have</span>
            <span class="c"># their labels on the left side of the arrow.</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">straight_vertical</span><span class="p">:</span>
                <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
                <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>

                <span class="n">m_str_info</span> <span class="o">=</span> <span class="n">morphisms_str_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="n">i2</span><span class="p">:</span>
                    <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>

                <span class="c"># Don&#39;t allow any further modifications of the</span>
                <span class="c"># position of this label.</span>
                <span class="n">m_str_info</span><span class="o">.</span><span class="n">forced_label_position</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># More morphisms stick out to the right than to the</span>
            <span class="c"># left, let&#39;s curve the morphism to the left.</span>
            <span class="k">if</span> <span class="n">backwards</span><span class="p">:</span>
                <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>
                <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
                <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>

            <span class="c"># Assure that the straight vertical morphisms have</span>
            <span class="c"># their labels on the right side of the arrow.</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">straight_vertical</span><span class="p">:</span>
                <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">j1</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
                <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">j2</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>

                <span class="n">m_str_info</span> <span class="o">=</span> <span class="n">morphisms_str_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="n">i2</span><span class="p">:</span>
                    <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="s">&quot;_&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>

                <span class="c"># Don&#39;t allow any further modifications of the</span>
                <span class="c"># position of this label.</span>
                <span class="n">m_str_info</span><span class="o">.</span><span class="n">forced_label_position</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">curving</span><span class="p">,</span> <span class="n">label_pos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_morphism</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagram</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">,</span>
                          <span class="n">morphisms</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the required information, produces the string</span>
<span class="sd">        representation of ``morphism``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">repeat_string_cond</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">str_gt</span><span class="p">,</span> <span class="n">str_lt</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            If ``times &gt; 0``, repeats ``str_gt`` ``times`` times.</span>
<span class="sd">            Otherwise, repeats ``str_lt`` ``-times`` times.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">times</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">str_gt</span> <span class="o">*</span> <span class="n">times</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">str_lt</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">times</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">count_morphisms_undirected</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Counts how many processed morphisms there are between the</span>
<span class="sd">            two supplied objects.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">morphisms_str_info</span>
                        <span class="k">if</span> <span class="nb">set</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">])</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">])])</span>

        <span class="k">def</span> <span class="nf">count_morphisms_filtered</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">cod</span><span class="p">,</span> <span class="n">curving</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Counts the processed morphisms which go out of ``dom``</span>
<span class="sd">            into ``cod`` with curving ``curving``.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">m_str_info</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">morphisms_str_info</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">cod</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">m_str_info</span><span class="o">.</span><span class="n">curving</span> <span class="o">==</span> <span class="n">curving</span><span class="p">)])</span>

        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
        <span class="p">(</span><span class="n">target_i</span><span class="p">,</span> <span class="n">target_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>

        <span class="c"># We now need to determine the direction of</span>
        <span class="c"># the arrow.</span>
        <span class="n">delta_i</span> <span class="o">=</span> <span class="n">target_i</span> <span class="o">-</span> <span class="n">i</span>
        <span class="n">delta_j</span> <span class="o">=</span> <span class="n">target_j</span> <span class="o">-</span> <span class="n">j</span>
        <span class="n">vertical_direction</span> <span class="o">=</span> <span class="n">repeat_string_cond</span><span class="p">(</span><span class="n">delta_i</span><span class="p">,</span>
                                                <span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="s">&quot;u&quot;</span><span class="p">)</span>
        <span class="n">horizontal_direction</span> <span class="o">=</span> <span class="n">repeat_string_cond</span><span class="p">(</span><span class="n">delta_j</span><span class="p">,</span>
                                                  <span class="s">&quot;r&quot;</span><span class="p">,</span> <span class="s">&quot;l&quot;</span><span class="p">)</span>

        <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="n">label_pos</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
        <span class="n">looping_start</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="n">looping_end</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">delta_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">delta_j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c"># This is a loop morphism.</span>
            <span class="p">(</span><span class="n">curving</span><span class="p">,</span> <span class="n">label_pos</span><span class="p">,</span> <span class="n">looping_start</span><span class="p">,</span>
             <span class="n">looping_end</span><span class="p">)</span> <span class="o">=</span> <span class="n">XypicDiagramDrawer</span><span class="o">.</span><span class="n">_process_loop_morphism</span><span class="p">(</span>
                 <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">delta_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">target_j</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># This is a horizontal morphism.</span>
            <span class="p">(</span><span class="n">curving</span><span class="p">,</span> <span class="n">label_pos</span><span class="p">)</span> <span class="o">=</span> <span class="n">XypicDiagramDrawer</span><span class="o">.</span><span class="n">_process_horizontal_morphism</span><span class="p">(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">target_j</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">delta_j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">target_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c"># This is a vertical morphism.</span>
            <span class="p">(</span><span class="n">curving</span><span class="p">,</span> <span class="n">label_pos</span><span class="p">)</span> <span class="o">=</span> <span class="n">XypicDiagramDrawer</span><span class="o">.</span><span class="n">_process_vertical_morphism</span><span class="p">(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">target_i</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="n">count_morphisms_undirected</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">)</span>
        <span class="n">curving_amount</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">curving</span><span class="p">:</span>
            <span class="c"># This morphisms should be curved anyway.</span>
            <span class="n">curving_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_curving_amount</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">default_curving_step</span>
        <span class="k">elif</span> <span class="n">count</span><span class="p">:</span>
            <span class="c"># There are no objects between the domain and codomain of</span>
            <span class="c"># the current morphism, but this is not there already are</span>
            <span class="c"># some morphisms with the same domain and codomain, so we</span>
            <span class="c"># have to curve this one.</span>
            <span class="n">curving</span> <span class="o">=</span> <span class="s">&quot;^&quot;</span>
            <span class="n">filtered_morphisms</span> <span class="o">=</span> <span class="n">count_morphisms_filtered</span><span class="p">(</span>
                <span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">,</span> <span class="n">curving</span><span class="p">)</span>
            <span class="n">curving_amount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_curving_amount</span> <span class="o">+</span> \
                <span class="n">filtered_morphisms</span> <span class="o">*</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">default_curving_step</span>

        <span class="c"># Let&#39;s now get the name of the morphism.</span>
        <span class="n">morphism_name</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">IdentityMorphism</span><span class="p">):</span>
            <span class="n">morphism_name</span> <span class="o">=</span> <span class="s">&quot;id_{</span><span class="si">%s</span><span class="s">}&quot;</span> <span class="o">+</span> <span class="n">latex</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">CompositeMorphism</span><span class="p">):</span>
            <span class="n">component_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">latex</span><span class="p">(</span><span class="n">Symbol</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">))</span> <span class="k">for</span>
                               <span class="n">component</span> <span class="ow">in</span> <span class="n">morphism</span><span class="o">.</span><span class="n">components</span><span class="p">]</span>
            <span class="n">component_names</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">morphism_name</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">circ &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">component_names</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">NamedMorphism</span><span class="p">):</span>
            <span class="n">morphism_name</span> <span class="o">=</span> <span class="n">latex</span><span class="p">(</span><span class="n">Symbol</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ArrowStringDescription</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span> <span class="n">curving</span><span class="p">,</span> <span class="n">curving_amount</span><span class="p">,</span> <span class="n">looping_start</span><span class="p">,</span>
            <span class="n">looping_end</span><span class="p">,</span> <span class="n">horizontal_direction</span><span class="p">,</span> <span class="n">vertical_direction</span><span class="p">,</span>
            <span class="n">label_pos</span><span class="p">,</span> <span class="n">morphism_name</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_free_space_horizontal</span><span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a horizontal morphism, checks whether there is free space</span>
<span class="sd">        (i.e., space not occupied by any objects) above the morphism</span>
<span class="sd">        or below it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dom_j</span> <span class="o">&lt;</span> <span class="n">cod_j</span><span class="p">:</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">dom_j</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cod_j</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Check for free space above.</span>
        <span class="k">if</span> <span class="n">dom_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">free_up</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free_up</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">grid</span><span class="p">[</span><span class="n">dom_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span>
                           <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

        <span class="c"># Check for free space below.</span>
        <span class="k">if</span> <span class="n">dom_i</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">free_down</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free_down</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="n">dom_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span>
                             <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">free_up</span><span class="p">,</span> <span class="n">free_down</span><span class="p">,</span> <span class="n">backwards</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_free_space_vertical</span><span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">cod_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a vertical morphism, checks whether there is free space</span>
<span class="sd">        (i.e., space not occupied by any objects) to the left of the</span>
<span class="sd">        morphism or to the right of it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dom_i</span> <span class="o">&lt;</span> <span class="n">cod_i</span><span class="p">:</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">cod_i</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cod_i</span><span class="p">,</span> <span class="n">dom_i</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Check if there&#39;s space to the left.</span>
        <span class="k">if</span> <span class="n">dom_j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">free_left</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free_left</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">dom_j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                             <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">dom_j</span> <span class="o">==</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">free_right</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free_right</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">dom_j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                              <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">free_left</span><span class="p">,</span> <span class="n">free_right</span><span class="p">,</span> <span class="n">backwards</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_free_space_diagonal</span><span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">cod_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a diagonal morphism, checks whether there is free space</span>
<span class="sd">        (i.e., space not occupied by any objects) above the morphism</span>
<span class="sd">        or below it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">abs_xrange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dom_i</span> <span class="o">&lt;</span> <span class="n">cod_i</span> <span class="ow">and</span> <span class="n">dom_j</span> <span class="o">&lt;</span> <span class="n">cod_j</span><span class="p">:</span>
            <span class="c"># This morphism goes from top-left to</span>
            <span class="c"># bottom-right.</span>
            <span class="p">(</span><span class="n">start_i</span><span class="p">,</span> <span class="n">start_j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">)</span>
            <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cod_i</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">dom_i</span> <span class="o">&gt;</span> <span class="n">cod_i</span> <span class="ow">and</span> <span class="n">dom_j</span> <span class="o">&gt;</span> <span class="n">cod_j</span><span class="p">:</span>
            <span class="c"># This morphism goes from bottom-right to</span>
            <span class="c"># top-left.</span>
            <span class="p">(</span><span class="n">start_i</span><span class="p">,</span> <span class="n">start_j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cod_i</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">)</span>
            <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">dom_i</span> <span class="o">&lt;</span> <span class="n">cod_i</span> <span class="ow">and</span> <span class="n">dom_j</span> <span class="o">&gt;</span> <span class="n">cod_j</span><span class="p">:</span>
            <span class="c"># This morphism goes from top-right to</span>
            <span class="c"># bottom-left.</span>
            <span class="p">(</span><span class="n">start_i</span><span class="p">,</span> <span class="n">start_j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">)</span>
            <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cod_i</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">dom_i</span> <span class="o">&gt;</span> <span class="n">cod_i</span> <span class="ow">and</span> <span class="n">dom_j</span> <span class="o">&lt;</span> <span class="n">cod_j</span><span class="p">:</span>
            <span class="c"># This morphism goes from bottom-left to</span>
            <span class="c"># top-right.</span>
            <span class="p">(</span><span class="n">start_i</span><span class="p">,</span> <span class="n">start_j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cod_i</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">)</span>
            <span class="p">(</span><span class="n">end_i</span><span class="p">,</span> <span class="n">end_j</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">)</span>
            <span class="n">backwards</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># This is an attempt at a fast and furious strategy to</span>
        <span class="c"># decide where there is free space on the two sides of</span>
        <span class="c"># a diagonal morphism.  For a diagonal morphism</span>
        <span class="c"># starting at ``(start_i, start_j)`` and ending at</span>
        <span class="c"># ``(end_i, end_j)`` the rectangle defined by these</span>
        <span class="c"># two points is considered.  The slope of the diagonal</span>
        <span class="c"># ``alpha`` is then computed.  Then, for every cell</span>
        <span class="c"># ``(i, j)`` within the rectangle, the slope</span>
        <span class="c"># ``alpha1`` of the line through ``(start_i,</span>
        <span class="c"># start_j)`` and ``(i, j)`` is considered.  If</span>
        <span class="c"># ``alpha1`` is between 0 and ``alpha``, the point</span>
        <span class="c"># ``(i, j)`` is above the diagonal, if ``alpha1`` is</span>
        <span class="c"># between ``alpha`` and infinity, the point is below</span>
        <span class="c"># the diagonal.  Also note that, with some beforehand</span>
        <span class="c"># precautions, this trick works for both the main and</span>
        <span class="c"># the secondary diagonals of the rectangle.</span>

        <span class="c"># I have considered the possibility to only follow the</span>
        <span class="c"># shorter diagonals immediately above and below the</span>
        <span class="c"># main (or secondary) diagonal.  This, however,</span>
        <span class="c"># wouldn&#39;t have resulted in much performance gain or</span>
        <span class="c"># better detection of outer edges, because of</span>
        <span class="c"># relatively small sizes of diagram grids, while the</span>
        <span class="c"># code would have become harder to understand.</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">end_i</span> <span class="o">-</span> <span class="n">start_i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">end_j</span> <span class="o">-</span> <span class="n">start_j</span><span class="p">)</span>
        <span class="n">free_up</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">free_down</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">abs_xrange</span><span class="p">(</span><span class="n">start_i</span><span class="p">,</span> <span class="n">end_i</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">free_up</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">free_down</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">abs_xrange</span><span class="p">(</span><span class="n">start_j</span><span class="p">,</span> <span class="n">end_j</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">free_up</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">free_down</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">start_i</span><span class="p">,</span> <span class="n">start_j</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">start_j</span><span class="p">:</span>
                    <span class="n">alpha1</span> <span class="o">=</span> <span class="s">&quot;inf&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">alpha1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">start_i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">start_j</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">alpha1</span> <span class="o">==</span> <span class="s">&quot;inf&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">alpha1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">alpha</span><span class="p">)):</span>
                        <span class="n">free_down</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">alpha1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
                        <span class="n">free_up</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">free_up</span><span class="p">,</span> <span class="n">free_down</span><span class="p">,</span> <span class="n">backwards</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_push_labels_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For all straight morphisms which form the visual boundary of</span>
<span class="sd">        the laid out diagram, puts their labels on their outer sides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">set_label_position</span><span class="p">(</span><span class="n">free1</span><span class="p">,</span> <span class="n">free2</span><span class="p">,</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">,</span> <span class="n">backwards</span><span class="p">,</span> <span class="n">m_str_info</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Given the information about room available to one side and</span>
<span class="sd">            to the other side of a morphism (``free1`` and ``free2``),</span>
<span class="sd">            sets the position of the morphism label in such a way that</span>
<span class="sd">            it is on the freer side.  This latter operations involves</span>
<span class="sd">            choice between ``pos1`` and ``pos2``, taking ``backwards``</span>
<span class="sd">            in consideration.</span>

<span class="sd">            Thus this function will do nothing if either both ``free1</span>
<span class="sd">            == True`` and ``free2 == True`` or both ``free1 == False``</span>
<span class="sd">            and ``free2 == False``.  In either case, choosing one side</span>
<span class="sd">            over the other presents no advantage.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">backwards</span><span class="p">:</span>
                <span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos2</span><span class="p">,</span> <span class="n">pos1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">free1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">free2</span><span class="p">:</span>
                <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="n">pos1</span>
            <span class="k">elif</span> <span class="n">free2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">free1</span><span class="p">:</span>
                <span class="n">m_str_info</span><span class="o">.</span><span class="n">label_position</span> <span class="o">=</span> <span class="n">pos2</span>

        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">m_str_info</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">morphisms_str_info</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">m_str_info</span><span class="o">.</span><span class="n">curving</span> <span class="ow">or</span> <span class="n">m_str_info</span><span class="o">.</span><span class="n">forced_label_position</span><span class="p">:</span>
                <span class="c"># This is either a curved morphism, and curved</span>
                <span class="c"># morphisms have other magic, or the position of this</span>
                <span class="c"># label has already been fixed.</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">:</span>
                <span class="c"># This is a loop morphism, their labels, again have a</span>
                <span class="c"># different magic.</span>
                <span class="k">continue</span>

            <span class="p">(</span><span class="n">dom_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
            <span class="p">(</span><span class="n">cod_i</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">dom_i</span> <span class="o">==</span> <span class="n">cod_i</span><span class="p">:</span>
                <span class="c"># Horizontal morphism.</span>
                <span class="p">(</span><span class="n">free_up</span><span class="p">,</span> <span class="n">free_down</span><span class="p">,</span>
                 <span class="n">backwards</span><span class="p">)</span> <span class="o">=</span> <span class="n">XypicDiagramDrawer</span><span class="o">.</span><span class="n">_check_free_space_horizontal</span><span class="p">(</span>
                     <span class="n">dom_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

                <span class="n">set_label_position</span><span class="p">(</span><span class="n">free_up</span><span class="p">,</span> <span class="n">free_down</span><span class="p">,</span> <span class="s">&quot;^&quot;</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">,</span>
                                   <span class="n">backwards</span><span class="p">,</span> <span class="n">m_str_info</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">dom_j</span> <span class="o">==</span> <span class="n">cod_j</span><span class="p">:</span>
                <span class="c"># Vertical morphism.</span>
                <span class="p">(</span><span class="n">free_left</span><span class="p">,</span> <span class="n">free_right</span><span class="p">,</span>
                 <span class="n">backwards</span><span class="p">)</span> <span class="o">=</span> <span class="n">XypicDiagramDrawer</span><span class="o">.</span><span class="n">_check_free_space_vertical</span><span class="p">(</span>
                     <span class="n">dom_i</span><span class="p">,</span> <span class="n">cod_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

                <span class="n">set_label_position</span><span class="p">(</span><span class="n">free_left</span><span class="p">,</span> <span class="n">free_right</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&quot;^&quot;</span><span class="p">,</span>
                                   <span class="n">backwards</span><span class="p">,</span> <span class="n">m_str_info</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># A diagonal morphism.</span>
                <span class="p">(</span><span class="n">free_up</span><span class="p">,</span> <span class="n">free_down</span><span class="p">,</span>
                 <span class="n">backwards</span><span class="p">)</span> <span class="o">=</span> <span class="n">XypicDiagramDrawer</span><span class="o">.</span><span class="n">_check_free_space_diagonal</span><span class="p">(</span>
                     <span class="n">dom_i</span><span class="p">,</span> <span class="n">cod_i</span><span class="p">,</span> <span class="n">dom_j</span><span class="p">,</span> <span class="n">cod_j</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

                <span class="n">set_label_position</span><span class="p">(</span><span class="n">free_up</span><span class="p">,</span> <span class="n">free_down</span><span class="p">,</span> <span class="s">&quot;^&quot;</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">,</span>
                                   <span class="n">backwards</span><span class="p">,</span> <span class="n">m_str_info</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_morphism_sort_key</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a morphism sorting key such that horizontal or</span>
<span class="sd">        vertical morphisms between neighbouring objects come</span>
<span class="sd">        first, then horizontal or vertical morphisms between more</span>
<span class="sd">        far away objects, and finally, all other morphisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span>
        <span class="p">(</span><span class="n">target_i</span><span class="p">,</span> <span class="n">target_j</span><span class="p">)</span> <span class="o">=</span> <span class="n">object_coords</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">morphism</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">:</span>
            <span class="c"># Loop morphisms should get after diagonal morphisms</span>
            <span class="c"># so that the proper direction in which to curve the</span>
            <span class="c"># loop can be determined.</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">morphism</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">target_i</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_j</span> <span class="o">-</span> <span class="n">j</span><span class="p">),</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">morphism</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">target_j</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">target_i</span> <span class="o">-</span> <span class="n">i</span><span class="p">),</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">morphism</span><span class="p">))</span>

        <span class="c"># Diagonal morphism.</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">morphism</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_build_xypic_string</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphisms</span><span class="p">,</span>
                            <span class="n">morphisms_str_info</span><span class="p">,</span> <span class="n">diagram_format</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a collection of :class:`ArrowStringDescription`</span>
<span class="sd">        describing the morphisms of a diagram and the object layout</span>
<span class="sd">        information of a diagram, produces the final Xy-pic picture.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Build the mapping between objects and morphisms which have</span>
        <span class="c"># them as domains.</span>
        <span class="n">object_morphisms</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">diagram</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="n">object_morphisms</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">morphisms</span><span class="p">:</span>
            <span class="n">object_morphisms</span><span class="p">[</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">morphism</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">xymatrix</span><span class="si">%s</span><span class="s">{</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">diagram_format</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">obj</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">latex</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; &quot;</span>

                    <span class="n">morphisms_to_draw</span> <span class="o">=</span> <span class="n">object_morphisms</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">morphisms_to_draw</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">morphisms_str_info</span><span class="p">[</span><span class="n">morphism</span><span class="p">])</span> <span class="o">+</span> <span class="s">&quot; &quot;</span>

                <span class="c"># Don&#39;t put the &amp; after the last column.</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;&amp; &quot;</span>

            <span class="c"># Don&#39;t put the line break after the last row.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\\\\</span><span class="s">&quot;</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span>

        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="XypicDiagramDrawer.draw"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.XypicDiagramDrawer.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagram</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">diagram_format</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Returns the Xy-pic representation of ``diagram`` laid out in</span>
<span class="sd">        ``grid``.</span>

<span class="sd">        Consider the following simple triangle diagram.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import DiagramGrid, XypicDiagramDrawer</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; diagram = Diagram([f, g], {g * f: &quot;unique&quot;})</span>

<span class="sd">        To draw this diagram, its objects need to be laid out with a</span>
<span class="sd">        :class:`DiagramGrid`::</span>

<span class="sd">        &gt;&gt;&gt; grid = DiagramGrid(diagram)</span>

<span class="sd">        Finally, the drawing:</span>

<span class="sd">        &gt;&gt;&gt; drawer = XypicDiagramDrawer()</span>
<span class="sd">        &gt;&gt;&gt; print(drawer.draw(diagram, grid))</span>
<span class="sd">        \xymatrix{</span>
<span class="sd">        A \ar[d]_{g\circ f} \ar[r]^{f} &amp; B \ar[ld]^{g} \\</span>
<span class="sd">        C &amp;</span>
<span class="sd">        }</span>

<span class="sd">        The argument ``masked`` can be used to skip morphisms in the</span>
<span class="sd">        presentation of the diagram:</span>

<span class="sd">        &gt;&gt;&gt; print(drawer.draw(diagram, grid, masked=[g * f]))</span>
<span class="sd">        \xymatrix{</span>
<span class="sd">        A \ar[r]^{f} &amp; B \ar[ld]^{g} \\</span>
<span class="sd">        C &amp;</span>
<span class="sd">        }</span>

<span class="sd">        Finally, the ``diagram_format`` argument can be used to</span>
<span class="sd">        specify the format string of the diagram.  For example, to</span>
<span class="sd">        increase the spacing by 1 cm, proceeding as follows:</span>

<span class="sd">        &gt;&gt;&gt; print(drawer.draw(diagram, grid, diagram_format=&quot;@+1cm&quot;))</span>
<span class="sd">        \xymatrix@+1cm{</span>
<span class="sd">        A \ar[d]_{g\circ f} \ar[r]^{f} &amp; B \ar[ld]^{g} \\</span>
<span class="sd">        C &amp;</span>
<span class="sd">        }</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># This method works in several steps.  It starts by removing</span>
        <span class="c"># the masked morphisms, if necessary, and then maps objects to</span>
        <span class="c"># their positions in the grid (coordinate tuples).  Remember</span>
        <span class="c"># that objects are unique in ``Diagram`` and in the layout</span>
        <span class="c"># produced by ``DiagramGrid``, so every object is mapped to a</span>
        <span class="c"># single coordinate pair.</span>
        <span class="c">#</span>
        <span class="c"># The next step is the central step and is concerned with</span>
        <span class="c"># analysing the morphisms of the diagram and deciding how to</span>
        <span class="c"># draw them.  For example, how to curve the arrows is decided</span>
        <span class="c"># at this step.  The bulk of the analysis is implemented in</span>
        <span class="c"># ``_process_morphism``, to the result of which the</span>
        <span class="c"># appropriate formatters are applied.</span>
        <span class="c">#</span>
        <span class="c"># The result of the previous step is a list of</span>
        <span class="c"># ``ArrowStringDescription``.  After the analysis and</span>
        <span class="c"># application of formatters, some extra logic tries to assure</span>
        <span class="c"># better positioning of morphism labels (for example, an</span>
        <span class="c"># attempt is made to avoid the situations when arrows cross</span>
        <span class="c"># labels).  This functionality constitutes the next step and</span>
        <span class="c"># is implemented in ``_push_labels_out``.  Note that label</span>
        <span class="c"># positions which have been set via a formatter are not</span>
        <span class="c"># affected in this step.</span>
        <span class="c">#</span>
        <span class="c"># Finally, at the closing step, the array of</span>
        <span class="c"># ``ArrowStringDescription`` and the layout information</span>
        <span class="c"># incorporated in ``DiagramGrid`` are combined to produce the</span>
        <span class="c"># resulting Xy-pic picture.  This part of code lies in</span>
        <span class="c"># ``_build_xypic_string``.</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">masked</span><span class="p">:</span>
            <span class="n">morphisms_props</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">morphisms</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">morphisms_props</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">morphisms</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">masked</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">morphisms_props</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">props</span>

        <span class="c"># Build the mapping between objects and their position in the</span>
        <span class="c"># grid.</span>
        <span class="n">object_coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                    <span class="n">object_coords</span><span class="p">[</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>

        <span class="n">morphisms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">morphisms_props</span><span class="p">,</span>
                           <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">XypicDiagramDrawer</span><span class="o">.</span><span class="n">_morphism_sort_key</span><span class="p">(</span>
                               <span class="n">m</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">))</span>

        <span class="c"># Build the tuples defining the string representations of</span>
        <span class="c"># morphisms.</span>
        <span class="n">morphisms_str_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">morphisms</span><span class="p">:</span>
            <span class="n">string_description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_morphism</span><span class="p">(</span>
                <span class="n">diagram</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">,</span> <span class="n">morphisms</span><span class="p">,</span>
                <span class="n">morphisms_str_info</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_arrow_formatter</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">default_arrow_formatter</span><span class="p">(</span><span class="n">string_description</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">morphisms_props</span><span class="p">[</span><span class="n">morphism</span><span class="p">]:</span>
                <span class="c"># prop is a Symbol.  TODO: Find out why.</span>
                <span class="k">if</span> <span class="n">prop</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow_formatters</span><span class="p">:</span>
                    <span class="n">formatter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrow_formatters</span><span class="p">[</span><span class="n">prop</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">formatter</span><span class="p">(</span><span class="n">string_description</span><span class="p">)</span>

            <span class="n">morphisms_str_info</span><span class="p">[</span><span class="n">morphism</span><span class="p">]</span> <span class="o">=</span> <span class="n">string_description</span>

        <span class="c"># Reposition the labels a bit.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_push_labels_out</span><span class="p">(</span><span class="n">morphisms_str_info</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">object_coords</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">XypicDiagramDrawer</span><span class="o">.</span><span class="n">_build_xypic_string</span><span class="p">(</span>
            <span class="n">diagram</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">morphisms</span><span class="p">,</span> <span class="n">morphisms_str_info</span><span class="p">,</span> <span class="n">diagram_format</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="xypic_draw_diagram"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.xypic_draw_diagram">[docs]</a><span class="k">def</span> <span class="nf">xypic_draw_diagram</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">diagram_format</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span>
                       <span class="n">groups</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Provides a shortcut combining :class:`DiagramGrid` and</span>
<span class="sd">    :class:`XypicDiagramDrawer`.  Returns an Xy-pic presentation of</span>
<span class="sd">    ``diagram``.  The argument ``masked`` is a list of morphisms which</span>
<span class="sd">    will be not be drawn.  The argument ``diagram_format`` is the</span>
<span class="sd">    format string inserted after &quot;\xymatrix&quot;.  ``groups`` should be a</span>
<span class="sd">    set of logical groups.  The ``hints`` will be passed directly to</span>
<span class="sd">    the constructor of :class:`DiagramGrid`.</span>

<span class="sd">    For more information about the arguments, see the docstrings of</span>
<span class="sd">    :class:`DiagramGrid` and ``XypicDiagramDrawer.draw``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">    &gt;&gt;&gt; from sympy.categories import xypic_draw_diagram</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; diagram = Diagram([f, g], {g * f: &quot;unique&quot;})</span>
<span class="sd">    &gt;&gt;&gt; print(xypic_draw_diagram(diagram))</span>
<span class="sd">    \xymatrix{</span>
<span class="sd">    A \ar[d]_{g\circ f} \ar[r]^{f} &amp; B \ar[ld]^{g} \\</span>
<span class="sd">    C &amp;</span>
<span class="sd">    }</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    XypicDiagramDrawer, DiagramGrid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">DiagramGrid</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
    <span class="n">drawer</span> <span class="o">=</span> <span class="n">XypicDiagramDrawer</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">drawer</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">masked</span><span class="p">,</span> <span class="n">diagram_format</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="preview_diagram"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.diagram_drawing.preview_diagram">[docs]</a><span class="k">def</span> <span class="nf">preview_diagram</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">masked</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">diagram_format</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                    <span class="n">output</span><span class="o">=</span><span class="s">&#39;png&#39;</span><span class="p">,</span> <span class="n">viewer</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">euler</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combines the functionality of ``xypic_draw_diagram`` and</span>
<span class="sd">    ``sympy.printing.preview``.  The arguments ``masked``,</span>
<span class="sd">    ``diagram_format``, ``groups``, and ``hints`` are passed to</span>
<span class="sd">    ``xypic_draw_diagram``, while ``output``, ``viewer, and ``euler``</span>
<span class="sd">    are passed to ``preview``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">    &gt;&gt;&gt; from sympy.categories import preview_diagram</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; d = Diagram([f, g], {g * f: &quot;unique&quot;})</span>
<span class="sd">    &gt;&gt;&gt; preview_diagram(d)  #doctest: +SKIP</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    xypic_diagram_drawer</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">preview</span>
    <span class="n">latex_output</span> <span class="o">=</span> <span class="n">xypic_draw_diagram</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">masked</span><span class="p">,</span> <span class="n">diagram_format</span><span class="p">,</span>
                                      <span class="n">groups</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>
    <span class="n">preview</span><span class="p">(</span><span class="n">latex_output</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">viewer</span><span class="p">,</span> <span class="n">euler</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;xypic&quot;</span><span class="p">,))</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../../sympy/categories.html" >sympy.categories</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Jan 20, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>
