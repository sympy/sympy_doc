

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Sums, products, limits and extrapolation &mdash; SymPy 0.7.6.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.6.1 documentation" href="../../../index.html" />
    <link rel="up" title="Numerical calculus" href="index.html" />
    <link rel="next" title="Differentiation" href="differentiation.html" />
    <link rel="prev" title="Root-finding and optimization" href="optimization.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="differentiation.html" title="Differentiation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="optimization.html" title="Root-finding and optimization"
             accesskey="P">previous</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.6.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >SymPy Modules Reference</a> &raquo;</li>
          <li><a href="../index.html" >Welcome to mpmath&#8217;s documentation!</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Numerical calculus</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="sums-products-limits-and-extrapolation">
<h1>Sums, products, limits and extrapolation<a class="headerlink" href="#sums-products-limits-and-extrapolation" title="Permalink to this headline">¶</a></h1>
<p>The functions listed here permit approximation of infinite
sums, products, and other sequence limits.
Use <a class="reference internal" href="../general.html#mpmath.fsum" title="mpmath.fsum"><tt class="xref py py-func docutils literal"><span class="pre">mpmath.fsum()</span></tt></a> and <a class="reference internal" href="../general.html#mpmath.fprod" title="mpmath.fprod"><tt class="xref py py-func docutils literal"><span class="pre">mpmath.fprod()</span></tt></a>
for summation and multiplication of finite sequences.</p>
<div class="section" id="summation">
<h2>Summation<a class="headerlink" href="#summation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="nsum">
<h3><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt><a class="headerlink" href="#nsum" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.nsum">
<tt class="descclassname">mpmath.</tt><tt class="descname">nsum</tt><big>(</big><em>ctx</em>, <em>f</em>, <em>*intervals</em>, <em>**options</em><big>)</big><a class="headerlink" href="#mpmath.nsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sum</p>
<div class="math">
\[S = \sum_{k=a}^b f(k)\]</div>
<p>where <span class="math">\((a, b)\)</span> = <em>interval</em>, and where <span class="math">\(a = -\infty\)</span> and/or
<span class="math">\(b = \infty\)</span> are allowed, or more generally</p>
<div class="math">
\[S = \sum_{k_1=a_1}^{b_1} \cdots
\sum_{k_n=a_n}^{b_n} f(k_1,\ldots,k_n)\]</div>
<p>if multiple intervals are given.</p>
<p>Two examples of infinite series that can be summed by <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a>,
where the first converges rapidly and the second converges slowly,
are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">mp</span><span class="o">.</span><span class="n">pretty</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">2.71828182845905</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.64493406684823</span>
</pre></div>
</div>
<p>When appropriate, <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> applies convergence acceleration to
accurately estimate the sums of slowly convergent series. If the series is
finite, <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> currently does not attempt to perform any
extrapolation, and simply calls <a class="reference internal" href="../general.html#mpmath.fsum" title="mpmath.fsum"><tt class="xref py py-func docutils literal"><span class="pre">fsum()</span></tt></a>.</p>
<p>Multidimensional infinite series are reduced to a single-dimensional
series over expanding hypercubes; if both infinite and finite dimensions
are present, the finite ranges are moved innermost. For more advanced
control over the summation order, use nested calls to <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a>,
or manually rewrite the sum as a single-dimensional series.</p>
<p><strong>Options</strong></p>
<dl class="docutils">
<dt><em>tol</em></dt>
<dd>Desired maximum final error. Defaults roughly to the
epsilon of the working precision.</dd>
<dt><em>method</em></dt>
<dd>Which summation algorithm to use (described below).
Default: <tt class="docutils literal"><span class="pre">'richardson+shanks'</span></tt>.</dd>
<dt><em>maxterms</em></dt>
<dd>Cancel after at most this many terms. Default: 10*dps.</dd>
<dt><em>steps</em></dt>
<dd>An iterable giving the number of terms to add between
each extrapolation attempt. The default sequence is
[10, 20, 30, 40, ...]. For example, if you know that
approximately 100 terms will be required, efficiency might be
improved by setting this to [100, 10]. Then the first
extrapolation will be performed after 100 terms, the second
after 110, etc.</dd>
<dt><em>verbose</em></dt>
<dd>Print details about progress.</dd>
<dt><em>ignore</em></dt>
<dd>If enabled, any term that raises <tt class="docutils literal"><span class="pre">ArithmeticError</span></tt>
or <tt class="docutils literal"><span class="pre">ValueError</span></tt> (e.g. through division by zero) is replaced
by a zero. This is convenient for lattice sums with
a singular term near the origin.</dd>
</dl>
<p><strong>Methods</strong></p>
<p>Unfortunately, an algorithm that can efficiently sum any infinite
series does not exist. <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> implements several different
algorithms that each work well in different cases. The <em>method</em>
keyword argument selects a method.</p>
<p>The default method is <tt class="docutils literal"><span class="pre">'r+s'</span></tt>, i.e. both Richardson extrapolation
and Shanks transformation is attempted. A slower method that
handles more cases is <tt class="docutils literal"><span class="pre">'r+s+e'</span></tt>. For very high precision
summation, or if the summation needs to be fast (for example if
multiple sums need to be evaluated), it is a good idea to
investigate which one method works best and only use that.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">'richardson'</span></tt> / <tt class="docutils literal"><span class="pre">'r'</span></tt>:</dt>
<dd>Uses Richardson extrapolation. Provides useful extrapolation
when <span class="math">\(f(k) \sim P(k)/Q(k)\)</span> or when <span class="math">\(f(k) \sim (-1)^k P(k)/Q(k)\)</span>
for polynomials <span class="math">\(P\)</span> and <span class="math">\(Q\)</span>. See <a class="reference internal" href="#mpmath.richardson" title="mpmath.richardson"><tt class="xref py py-func docutils literal"><span class="pre">richardson()</span></tt></a> for
additional information.</dd>
<dt><tt class="docutils literal"><span class="pre">'shanks'</span></tt> / <tt class="docutils literal"><span class="pre">'s'</span></tt>:</dt>
<dd>Uses Shanks transformation. Typically provides useful
extrapolation when <span class="math">\(f(k) \sim c^k\)</span> or when successive terms
alternate signs. Is able to sum some divergent series.
See <a class="reference internal" href="#mpmath.shanks" title="mpmath.shanks"><tt class="xref py py-func docutils literal"><span class="pre">shanks()</span></tt></a> for additional information.</dd>
<dt><tt class="docutils literal"><span class="pre">'levin'</span></tt> / <tt class="docutils literal"><span class="pre">'l'</span></tt>:</dt>
<dd>Uses the Levin transformation. It performs better than the Shanks
transformation for logarithmic convergent or alternating divergent
series. The <tt class="docutils literal"><span class="pre">'levin_variant'</span></tt>-keyword selects the variant. Valid
choices are &#8220;u&#8221;, &#8220;t&#8221;, &#8220;v&#8221; and &#8220;all&#8221; whereby &#8220;all&#8221; uses all three
u,t and v simultanously (This is good for performance comparison in
conjunction with &#8220;verbose=True&#8221;). Instead of the Levin transform one can
also use the Sidi-S transform by selecting the method <tt class="docutils literal"><span class="pre">'sidi'</span></tt>.
See <a class="reference internal" href="#mpmath.levin" title="mpmath.levin"><tt class="xref py py-func docutils literal"><span class="pre">levin()</span></tt></a> for additional details.</dd>
<dt><tt class="docutils literal"><span class="pre">'alternating'</span></tt> / <tt class="docutils literal"><span class="pre">'a'</span></tt>:</dt>
<dd>This is the convergence acceleration of alternating series developped
by Cohen, Villegras and Zagier.
See <a class="reference internal" href="#mpmath.cohen_alt" title="mpmath.cohen_alt"><tt class="xref py py-func docutils literal"><span class="pre">cohen_alt()</span></tt></a> for additional details.</dd>
<dt><tt class="docutils literal"><span class="pre">'euler-maclaurin'</span></tt> / <tt class="docutils literal"><span class="pre">'e'</span></tt>:</dt>
<dd>Uses the Euler-Maclaurin summation formula to approximate
the remainder sum by an integral. This requires high-order
numerical derivatives and numerical integration. The advantage
of this algorithm is that it works regardless of the
decay rate of <span class="math">\(f\)</span>, as long as <span class="math">\(f\)</span> is sufficiently smooth.
See <a class="reference internal" href="#mpmath.sumem" title="mpmath.sumem"><tt class="xref py py-func docutils literal"><span class="pre">sumem()</span></tt></a> for additional information.</dd>
<dt><tt class="docutils literal"><span class="pre">'direct'</span></tt> / <tt class="docutils literal"><span class="pre">'d'</span></tt>:</dt>
<dd>Does not perform any extrapolation. This can be used
(and should only be used for) rapidly convergent series.
The summation automatically stops when the terms
decrease below the target tolerance.</dd>
</dl>
<p><strong>Basic examples</strong></p>
<p>A finite sum:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="go">2.45</span>
</pre></div>
</div>
<p>Summation of a series going to negative infinity and a doubly
infinite series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">1.64493406684823</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">3.15334809493716</span>
</pre></div>
</div>
<p><a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> handles sums of complex numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">+</span><span class="mf">0.25j</span><span class="p">)</span><span class="o">**</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">(1.6 + 0.8j)</span>
</pre></div>
</div>
<p>The following sum converges very rapidly, so it is most
efficient to sum it by disabling convergence acceleration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">fac</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;direct&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mpf</span><span class="p">(</span><span class="s">&#39;1e-998&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p><strong>Examples with Richardson extrapolation</strong></p>
<p>Richardson extrapolation works well for sums over rational
functions, as well as their alternating counterparts:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">k</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;richardson&#39;</span><span class="p">)</span>
<span class="go">1.2020569031595942853997381615114499907649862923405</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zeta</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">1.2020569031595942853997381615114499907649862923405</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;richardson&#39;</span><span class="p">)</span>
<span class="go">2.9348022005446793094172454999380755676568497036204</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">2</span>
<span class="go">2.9348022005446793094172454999380755676568497036204</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">/</span> <span class="n">k</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;richardson&#39;</span><span class="p">)</span>
<span class="go">-0.90154267736969571404980362113358749307373971925537</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">zeta</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span>
<span class="go">-0.90154267736969571404980362113358749307373971925538</span>
</pre></div>
</div>
<p><strong>Examples with Shanks transformation</strong></p>
<p>The Shanks transformation works well for geometric series
and typically provides excellent acceleration for Taylor
series near the border of their disk of convergence.
Here we apply it to a series for <span class="math">\(\log(2)\)</span>, which can be
seen as the Taylor series for <span class="math">\(\log(1+x)\)</span> with <span class="math">\(x = 1\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">k</span><span class="o">/</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;shanks&#39;</span><span class="p">)</span>
<span class="go">0.69314718055994530941723212145817656807550013436025</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.69314718055994530941723212145817656807550013436025</span>
</pre></div>
</div>
<p>Here we apply it to a slowly convergent geometric series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">mpf</span><span class="p">(</span><span class="s">&#39;0.995&#39;</span><span class="p">)</span><span class="o">**</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;shanks&#39;</span><span class="p">)</span>
<span class="go">200.0</span>
</pre></div>
</div>
<p>Finally, Shanks&#8217; method works very well for alternating series
where <span class="math">\(f(k) = (-1)^k g(k)\)</span>, and often does so regardless of
the exact decay rate of <span class="math">\(g(k)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span><span class="o">**</span><span class="mf">1.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;shanks&#39;</span><span class="p">)</span>
<span class="go">0.765147024625408</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">zeta</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="go">0.765147024625408</span>
</pre></div>
</div>
<p>The following slowly convergent alternating series has no known
closed-form value. Evaluating the sum a second time at higher
precision indicates that the value is probably correct:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;shanks&#39;</span><span class="p">)</span>
<span class="go">0.924299897222939</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">k</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;shanks&#39;</span><span class="p">)</span>
<span class="go">0.92429989722293885595957018136</span>
</pre></div>
</div>
<p><strong>Examples with Levin transformation</strong></p>
<p>The following example calculates Euler&#8217;s constant as the constant term in
the Laurent expansion of zeta(s) at s=1. This sum converges extremly slow
because of the logarithmic convergence behaviour of the Dirichlet series
for zeta.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">z</span><span class="p">)),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">euler</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Now we sum the zeta function outside its range of convergence
(attention: This does not work at the negative integers!):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3j</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">levin_variant</span> <span class="o">=</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">zeta</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">3j</span><span class="p">)))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>The next example resummates an asymptotic series expansion of an integral
related to the exponential integral.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># exact = mp.quad(lambda x: mp.exp(-x)/(1+x/z),[0,mp.inf])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">expint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="c"># this is the symbolic expression for the integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">n</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;sidi&quot;</span><span class="p">,</span> <span class="n">levin_variant</span> <span class="o">=</span> <span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">exact</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Following highly divergent asymptotic expansion needs some care. Firstly we
need copious amount of working precision. Secondly the stepsize must not be
chosen to large, otherwise nsum may miss the point where the Levin transform
converges and reach the point where only numerical garbage is produced due to
numerical cancellation.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># exact = mp.quad(lambda x: mp.exp( -x * x / 2 - z * x ** 4), [0,mp.inf]) * 2 / mp.sqrt(2 * mp.pi)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">one</span> <span class="o">/</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">z</span><span class="p">))</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">besselk</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">one</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">one</span> <span class="o">/</span> <span class="p">(</span><span class="mi">32</span> <span class="o">*</span> <span class="n">z</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="c"># this is the symbolic expression for the integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">**</span> <span class="n">n</span><span class="p">)),</span>
<span class="gp">... </span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">levin_variant</span> <span class="o">=</span> <span class="s">&quot;t&quot;</span><span class="p">,</span> <span class="n">workprec</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="n">mp</span><span class="o">.</span><span class="n">prec</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">exact</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>The hypergeoemtric function can also be summed outside its range of convergence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">hyp2f1</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">4</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">rf</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">rf</span><span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">rf</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">exact</span><span class="o">-</span><span class="n">v</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p><strong>Examples with Cohen&#8217;s alternating series resummation</strong></p>
<blockquote>
<div><p>The next example sums the alternating zeta function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>The derivate of the alternating zeta function outside its range of
convergence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">altzeta</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
<span class="go">0.0</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>Examples with Euler-Maclaurin summation</strong></p>
<p>The sum in the following example has the wrong rate of convergence
for either Richardson or Shanks to be effective.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">log</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mf">2.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;euler-maclaurin&#39;</span><span class="p">)</span>
<span class="go">0.38734195032621</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="go">0.38734195032621</span>
</pre></div>
</div>
<p>Increasing <tt class="docutils literal"><span class="pre">steps</span></tt> improves speed at higher precision:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;euler-maclaurin&#39;</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">250</span><span class="p">])</span>
<span class="go">0.38734195032620997271199237593105101319948228874688</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">diff</span><span class="p">(</span><span class="n">zeta</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="go">0.38734195032620997271199237593105101319948228874688</span>
</pre></div>
</div>
<p><strong>Divergent series</strong></p>
<p>The Shanks transformation is able to sum some <em>divergent</em>
series. In particular, it is often able to sum Taylor series
beyond their radius of convergence (this is due to a relation
between the Shanks transformation and Pade approximations;
see <a class="reference internal" href="approximation.html#mpmath.pade" title="mpmath.pade"><tt class="xref py py-func docutils literal"><span class="pre">pade()</span></tt></a> for an alternative way to evaluate divergent
Taylor series). Furthermore the Levin-transform examples above
contain some divergent series resummation.</p>
<p>Here we apply it to <span class="math">\(\log(1+x)\)</span> far outside the region of
convergence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">)</span><span class="o">**</span><span class="n">k</span><span class="o">/</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">method</span><span class="o">=</span><span class="s">&#39;shanks&#39;</span><span class="p">)</span>
<span class="go">2.3025850929940456840179914546843642076011014886288</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">2.3025850929940456840179914546843642076011014886288</span>
</pre></div>
</div>
<p>A particular type of divergent series that can be summed
using the Shanks transformation is geometric series.
The result is the same as using the closed-form formula
for an infinite geometric series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">continue</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">mpf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">n</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;shanks&#39;</span><span class="p">)))</span>
<span class="gp">...</span>
<span class="go">-8.0 0.111111111111111 0.111111111111111</span>
<span class="go">-7.0 0.125 0.125</span>
<span class="go">-6.0 0.142857142857143 0.142857142857143</span>
<span class="go">-5.0 0.166666666666667 0.166666666666667</span>
<span class="go">-4.0 0.2 0.2</span>
<span class="go">-3.0 0.25 0.25</span>
<span class="go">-2.0 0.333333333333333 0.333333333333333</span>
<span class="go">-1.0 0.5 0.5</span>
<span class="go">0.0 1.0 1.0</span>
<span class="go">2.0 -1.0 -1.0</span>
<span class="go">3.0 -0.5 -0.5</span>
<span class="go">4.0 -0.333333333333333 -0.333333333333333</span>
<span class="go">5.0 -0.25 -0.25</span>
<span class="go">6.0 -0.2 -0.2</span>
<span class="go">7.0 -0.166666666666667 -0.166666666666667</span>
</pre></div>
</div>
<p><strong>Multidimensional sums</strong></p>
<p>Any combination of finite and infinite ranges is allowed for the
summation indices:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="go">28.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="go">6.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="n">z</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">y</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="n">y</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">z</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">7.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="n">x</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">z</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="n">y</span><span class="p">),</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">7.0</span>
</pre></div>
</div>
<p>Some nice examples of double series with analytic solutions or
reductions to single-dimensional series (see [1]):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">1.60669515241529</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">1.60669515241529</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">j</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">0.278070510848213</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">pi</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">ln2</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span>
<span class="go">0.278070510848213</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">0.129319852864168</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">altzeta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">altzeta</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.129319852864168</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">0.0790756439455825</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">altzeta</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">altzeta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.0790756439455825</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">:</span> <span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">**</span><span class="n">m</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="mi">3</span><span class="o">**</span><span class="n">m</span><span class="o">+</span><span class="n">m</span><span class="o">*</span><span class="mi">3</span><span class="o">**</span><span class="n">n</span><span class="p">)),</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">0.28125</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mpf</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span><span class="o">/</span><span class="mi">32</span>
<span class="go">0.28125</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:</span> <span class="n">fac</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">fac</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">fac</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="n">workprec</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="go">1.64493406684823</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zeta</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.64493406684823</span>
</pre></div>
</div>
<p>A hard example of a multidimensional sum is the Madelung constant
in three dimensions (see [2]). The defining sum converges very
slowly and only conditionally, so <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> is lucky to
obtain an accurate value through convergence acceleration. The
second evaluation below uses a much more efficient, rapidly
convergent 2D sum:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">-1.74756459463318</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="o">-</span><span class="mi">12</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">sech</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">pi</span> <span class="o">*</span> \
<span class="gp">... </span>    <span class="n">sqrt</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">-1.74756459463318</span>
</pre></div>
</div>
<p>Another example of a lattice sum in 2D:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="n">ignore</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">-2.1775860903036</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">pi</span><span class="o">*</span><span class="n">ln2</span>
<span class="go">-2.1775860903036</span>
</pre></div>
</div>
<p>An example of an Eisenstein series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">*</span><span class="mi">1j</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">ignore</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">(3.1512120021539 + 0.0j)</span>
</pre></div>
</div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference internal" href="../references.html#weisstein">[Weisstein]</a> <a class="reference external" href="http://mathworld.wolfram.com/DoubleSeries.html">http://mathworld.wolfram.com/DoubleSeries.html</a>,</li>
<li><a class="reference internal" href="../references.html#weisstein">[Weisstein]</a> <a class="reference external" href="http://mathworld.wolfram.com/MadelungConstants.html">http://mathworld.wolfram.com/MadelungConstants.html</a></li>
</ol>
</dd></dl>

</div>
<div class="section" id="sumem">
<h3><tt class="xref py py-func docutils literal"><span class="pre">sumem()</span></tt><a class="headerlink" href="#sumem" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.sumem">
<tt class="descclassname">mpmath.</tt><tt class="descname">sumem</tt><big>(</big><em>ctx</em>, <em>f</em>, <em>interval</em>, <em>tol=None</em>, <em>reject=10</em>, <em>integral=None</em>, <em>adiffs=None</em>, <em>bdiffs=None</em>, <em>verbose=False</em>, <em>error=False</em>, <em>_fast_abort=False</em><big>)</big><a class="headerlink" href="#mpmath.sumem" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the Euler-Maclaurin formula to compute an approximation accurate
to within <tt class="docutils literal"><span class="pre">tol</span></tt> (which defaults to the present epsilon) of the sum</p>
<div class="math">
\[S = \sum_{k=a}^b f(k)\]</div>
<p>where <span class="math">\((a,b)\)</span> are given by <tt class="docutils literal"><span class="pre">interval</span></tt> and <span class="math">\(a\)</span> or <span class="math">\(b\)</span> may be
infinite. The approximation is</p>
<div class="math">
\[S \sim \int_a^b f(x) \,dx + \frac{f(a)+f(b)}{2} +
\sum_{k=1}^{\infty} \frac{B_{2k}}{(2k)!}
\left(f^{(2k-1)}(b)-f^{(2k-1)}(a)\right).\]</div>
<p>The last sum in the Euler-Maclaurin formula is not generally
convergent (a notable exception is if <span class="math">\(f\)</span> is a polynomial, in
which case Euler-Maclaurin actually gives an exact result).</p>
<p>The summation is stopped as soon as the quotient between two
consecutive terms falls below <em>reject</em>. That is, by default
(<em>reject</em> = 10), the summation is continued as long as each
term adds at least one decimal.</p>
<p>Although not convergent, convergence to a given tolerance can
often be &#8220;forced&#8221; if <span class="math">\(b = \infty\)</span> by summing up to <span class="math">\(a+N\)</span> and then
applying the Euler-Maclaurin formula to the sum over the range
<span class="math">\((a+N+1, \ldots, \infty)\)</span>. This procedure is implemented by
<a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a>.</p>
<p>By default numerical quadrature and differentiation is used.
If the symbolic values of the integral and endpoint derivatives
are known, it is more efficient to pass the value of the
integral explicitly as <tt class="docutils literal"><span class="pre">integral</span></tt> and the derivatives
explicitly as <tt class="docutils literal"><span class="pre">adiffs</span></tt> and <tt class="docutils literal"><span class="pre">bdiffs</span></tt>. The derivatives
should be given as iterables that yield
<span class="math">\(f(a), f'(a), f''(a), \ldots\)</span> (and the equivalent for <span class="math">\(b\)</span>).</p>
<p><strong>Examples</strong></p>
<p>Summation of an infinite series, with automatic and symbolic
integral and derivative values (the second should be much faster):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">mp</span><span class="o">.</span><span class="n">pretty</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sumem</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.03174336652030209012658168043874142714132886413417</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">mpf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">adiffs</span><span class="o">=</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="o">*</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">32</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">999</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sumem</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">integral</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">adiffs</span><span class="o">=</span><span class="n">D</span><span class="p">)</span>
<span class="go">0.03174336652030209012658168043874142714132886413417</span>
</pre></div>
</div>
<p>An exact evaluation of a finite polynomial sum:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sumem</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="mi">5</span><span class="o">-</span><span class="mi">12</span><span class="o">*</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">100000</span><span class="p">,</span> <span class="mi">200000</span><span class="p">])</span>
<span class="go">10500155000624963999742499550000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">5</span><span class="o">-</span><span class="mi">12</span><span class="o">*</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">100000</span><span class="p">,</span> <span class="mi">200001</span><span class="p">)))</span>
<span class="go">10500155000624963999742499550000</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sumap">
<h3><tt class="xref py py-func docutils literal"><span class="pre">sumap()</span></tt><a class="headerlink" href="#sumap" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.sumap">
<tt class="descclassname">mpmath.</tt><tt class="descname">sumap</tt><big>(</big><em>ctx</em>, <em>f</em>, <em>interval</em>, <em>integral=None</em>, <em>error=False</em><big>)</big><a class="headerlink" href="#mpmath.sumap" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates an infinite series of an analytic summand <em>f</em> using the
Abel-Plana formula</p>
<div class="math">
\[\sum_{k=0}^{\infty} f(k) = \int_0^{\infty} f(t) dt + \frac{1}{2} f(0) +
    i \int_0^{\infty} \frac{f(it)-f(-it)}{e^{2\pi t}-1} dt.\]</div>
<p>Unlike the Euler-Maclaurin formula (see <a class="reference internal" href="#mpmath.sumem" title="mpmath.sumem"><tt class="xref py py-func docutils literal"><span class="pre">sumem()</span></tt></a>),
the Abel-Plana formula does not require derivatives. However,
it only works when <span class="math">\(|f(it)-f(-it)|\)</span> does not
increase too rapidly with <span class="math">\(t\)</span>.</p>
<p><strong>Examples</strong></p>
<p>The Abel-Plana formula is particularly useful when the summand
decreases like a power of <span class="math">\(k\)</span>; for example when the sum is a pure
zeta function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span> <span class="n">mp</span><span class="o">.</span><span class="n">pretty</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sumap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mf">2.5</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">1.34148725725091717975677</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zeta</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
<span class="go">1.34148725725091717975677</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sumap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1j</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">2.5</span><span class="o">+</span><span class="mf">2.5j</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">])</span>
<span class="go">(-3.385361068546473342286084 - 0.7432082105196321803869551j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zeta</span><span class="p">(</span><span class="mf">2.5</span><span class="o">+</span><span class="mf">2.5j</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="mi">1j</span><span class="p">)</span>
<span class="go">(-3.385361068546473342286084 - 0.7432082105196321803869551j)</span>
</pre></div>
</div>
<p>If the series is alternating, numerical quadrature along the real
line is likely to give poor results, so it is better to evaluate
the first term symbolically whenever possible:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span> <span class="n">z</span><span class="o">=-</span><span class="mf">0.75</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">expint</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chop</span><span class="p">(</span><span class="n">sumap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">z</span><span class="o">**</span><span class="n">k</span> <span class="o">/</span> <span class="n">k</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span> <span class="n">integral</span><span class="o">=</span><span class="n">I</span><span class="p">))</span>
<span class="go">-0.6917036036904594510141448</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polylog</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>
<span class="go">-0.6917036036904594510141448</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="products">
<h2>Products<a class="headerlink" href="#products" title="Permalink to this headline">¶</a></h2>
<div class="section" id="nprod">
<h3><tt class="xref py py-func docutils literal"><span class="pre">nprod()</span></tt><a class="headerlink" href="#nprod" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.nprod">
<tt class="descclassname">mpmath.</tt><tt class="descname">nprod</tt><big>(</big><em>ctx</em>, <em>f</em>, <em>interval</em>, <em>nsum=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.nprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the product</p>
<div class="math">
\[P = \prod_{k=a}^b f(k)\]</div>
<p>where <span class="math">\((a, b)\)</span> = <em>interval</em>, and where <span class="math">\(a = -\infty\)</span> and/or
<span class="math">\(b = \infty\)</span> are allowed.</p>
<p>By default, <a class="reference internal" href="#mpmath.nprod" title="mpmath.nprod"><tt class="xref py py-func docutils literal"><span class="pre">nprod()</span></tt></a> uses the same extrapolation methods as
<a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a>, except applied to the partial products rather than
partial sums, and the same keyword options as for <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> are
supported. If <tt class="docutils literal"><span class="pre">nsum=True</span></tt>, the product is instead computed via
<a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> as</p>
<div class="math">
\[P = \exp\left( \sum_{k=a}^b \log(f(k)) \right).\]</div>
<p>This is slower, but can sometimes yield better results. It is
also required (and used automatically) when Euler-Maclaurin
summation is requested.</p>
<p><strong>Examples</strong></p>
<p>A simple finite product:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span> <span class="n">mp</span><span class="o">.</span><span class="n">pretty</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">24.0</span>
</pre></div>
</div>
<p>A large number of infinite products have known exact values,
and can therefore be used as a reference. Most of the following
examples are taken from MathWorld [1].</p>
<p>A few infinite products with simple values are:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">*</span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">3.141592653589793238462643</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.6666666666666666666666667</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.5</span>
</pre></div>
</div>
<p>Next, several more infinite products with more complicated
values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">]);</span> <span class="n">exp</span><span class="p">(</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span>
<span class="go">5.180668317897115748416626</span>
<span class="go">5.180668317897115748416626</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">]);</span> <span class="n">pi</span><span class="o">*</span><span class="n">csch</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="go">0.2720290549821331629502366</span>
<span class="go">0.2720290549821331629502366</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.8480540493529003921296502</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pi</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">cosh</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span><span class="p">))</span>
<span class="go">0.8480540493529003921296502</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">/</span><span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.848936182858244485224927</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">3</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">csch</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">pi</span>
<span class="go">1.848936182858244485224927</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">]);</span> <span class="n">sinh</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="go">0.9190194775937444301739244</span>
<span class="go">0.9190194775937444301739244</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mi">6</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.9826842777421925183244759</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">cosh</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0.9826842777421925183244759</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">]);</span> <span class="n">sinh</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="go">1.838038955187488860347849</span>
<span class="go">1.838038955187488860347849</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="o">/</span><span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">1.447255926890365298959138</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">euler</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="go">1.447255926890365298959138</span>
</pre></div>
</div>
<p>The following two products are equivalent and can be evaluated in
terms of a Jacobi theta function. Pi can be replaced by any value
(as long as convergence is preserved):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">pi</span><span class="o">**-</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">pi</span><span class="o">**-</span><span class="n">k</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.3838451207481672404778686</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">tanh</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.3838451207481672404778686</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jtheta</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="n">pi</span><span class="p">)</span>
<span class="go">0.3838451207481672404778686</span>
</pre></div>
</div>
<p>This product does not have a known closed form value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">0.2887880950866024212788997</span>
</pre></div>
</div>
<p>A product taken from <span class="math">\(-\infty\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="go">0.8093965973662901095786805</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cosh</span><span class="p">(</span><span class="n">pi</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="go">0.8093965973662901095786805</span>
</pre></div>
</div>
<p>A doubly infinite product:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)),</span> <span class="p">[</span><span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">inf</span><span class="p">])</span>
<span class="go">23.41432688231864337420035</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="n">tanh</span><span class="p">(</span><span class="n">pi</span><span class="p">))</span>
<span class="go">23.41432688231864337420035</span>
</pre></div>
</div>
<p>A product requiring the use of Euler-Maclaurin summation to compute
an accurate value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">nprod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="o">**</span><span class="mf">2.5</span><span class="p">),</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">inf</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;e&#39;</span><span class="p">)</span>
<span class="go">0.696155111336231052898125</span>
</pre></div>
</div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference internal" href="../references.html#weisstein">[Weisstein]</a> <a class="reference external" href="http://mathworld.wolfram.com/InfiniteProduct.html">http://mathworld.wolfram.com/InfiniteProduct.html</a></li>
</ol>
</dd></dl>

</div>
</div>
<div class="section" id="limits-limit">
<h2>Limits (<tt class="docutils literal"><span class="pre">limit</span></tt>)<a class="headerlink" href="#limits-limit" title="Permalink to this headline">¶</a></h2>
<div class="section" id="limit">
<h3><tt class="xref py py-func docutils literal"><span class="pre">limit()</span></tt><a class="headerlink" href="#limit" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.limit">
<tt class="descclassname">mpmath.</tt><tt class="descname">limit</tt><big>(</big><em>ctx</em>, <em>f</em>, <em>x</em>, <em>direction=1</em>, <em>exp=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#mpmath.limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes an estimate of the limit</p>
<div class="math">
\[\lim_{t \to x} f(t)\]</div>
<p>where <span class="math">\(x\)</span> may be finite or infinite.</p>
<p>For finite <span class="math">\(x\)</span>, <a class="reference internal" href="#mpmath.limit" title="mpmath.limit"><tt class="xref py py-func docutils literal"><span class="pre">limit()</span></tt></a> evaluates <span class="math">\(f(x + d/n)\)</span> for
consecutive integer values of <span class="math">\(n\)</span>, where the approach direction
<span class="math">\(d\)</span> may be specified using the <em>direction</em> keyword argument.
For infinite <span class="math">\(x\)</span>, <a class="reference internal" href="#mpmath.limit" title="mpmath.limit"><tt class="xref py py-func docutils literal"><span class="pre">limit()</span></tt></a> evaluates values of
<span class="math">\(f(\mathrm{sign}(x) \cdot n)\)</span>.</p>
<p>If the approach to the limit is not sufficiently fast to give
an accurate estimate directly, <a class="reference internal" href="#mpmath.limit" title="mpmath.limit"><tt class="xref py py-func docutils literal"><span class="pre">limit()</span></tt></a> attempts to find
the limit using Richardson extrapolation or the Shanks
transformation. You can select between these methods using
the <em>method</em> keyword (see documentation of <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> for
more information).</p>
<p><strong>Options</strong></p>
<p>The following options are available with essentially the
same meaning as for <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a>: <em>tol</em>, <em>method</em>, <em>maxterms</em>,
<em>steps</em>, <em>verbose</em>.</p>
<p>If the option <em>exp=True</em> is set, <span class="math">\(f\)</span> will be
sampled at exponentially spaced points <span class="math">\(n = 2^1, 2^2, 2^3, \ldots\)</span>
instead of the linearly spaced points <span class="math">\(n = 1, 2, 3, \ldots\)</span>.
This can sometimes improve the rate of convergence so that
<a class="reference internal" href="#mpmath.limit" title="mpmath.limit"><tt class="xref py py-func docutils literal"><span class="pre">limit()</span></tt></a> may return a more accurate answer (and faster).
However, do note that this can only be used if <span class="math">\(f\)</span>
supports fast and accurate evaluation for arguments that
are extremely close to the limit point (or if infinite,
very large arguments).</p>
<p><strong>Examples</strong></p>
<p>A basic evaluation of a removable singularity:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="n">mp</span><span class="o">.</span><span class="n">pretty</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">0.166666666666666666666666666667</span>
</pre></div>
</div>
<p>Computing the exponential function using its limit definition:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">3</span><span class="o">/</span><span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span>
<span class="go">20.0855369231876677409285296546</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exp</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">20.0855369231876677409285296546</span>
</pre></div>
</div>
<p>A limit for <span class="math">\(\pi\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="mi">4</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">fac</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span>
<span class="go">3.14159265358979323846264338328</span>
</pre></div>
</div>
<p>Calculating the coefficient in Stirling&#8217;s formula:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="n">e</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">),</span> <span class="n">inf</span><span class="p">)</span>
<span class="go">2.50662827463100050241576528481</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="go">2.50662827463100050241576528481</span>
</pre></div>
</div>
<p>Evaluating Euler&#8217;s constant <span class="math">\(\gamma\)</span> using the limit representation</p>
<div class="math">
\[\gamma = \lim_{n \rightarrow \infty } \left[ \left(
\sum_{k=1}^n \frac{1}{k} \right) - \log(n) \right]\]</div>
<p>(which converges notoriously slowly):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">sum</span><span class="p">([</span><span class="n">mpf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span>
<span class="go">0.577215664901532860606512090082</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">+</span><span class="n">euler</span>
<span class="go">0.577215664901532860606512090082</span>
</pre></div>
</div>
<p>With default settings, the following limit converges too slowly
to be evaluated accurately. Changing to exponential sampling
however gives a perfect result:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">+</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">inf</span><span class="p">)</span>
<span class="go">0.992831158558330281129249686491</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">exp</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="extrapolation">
<h2>Extrapolation<a class="headerlink" href="#extrapolation" title="Permalink to this headline">¶</a></h2>
<p>The following functions provide a direct interface to
extrapolation algorithms. <tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt> and <tt class="xref py py-func docutils literal"><span class="pre">limit()</span></tt> essentially
work by calling the following functions with an increasing
number of terms until the extrapolated limit is accurate enough.</p>
<p>The following functions may be useful to call directly if the
precise number of terms needed to achieve a desired accuracy is
known in advance, or if one wishes to study the convergence
properties of the algorithms.</p>
<div class="section" id="richardson">
<h3><tt class="xref py py-func docutils literal"><span class="pre">richardson()</span></tt><a class="headerlink" href="#richardson" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.richardson">
<tt class="descclassname">mpmath.</tt><tt class="descname">richardson</tt><big>(</big><em>ctx</em>, <em>seq</em><big>)</big><a class="headerlink" href="#mpmath.richardson" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list <tt class="docutils literal"><span class="pre">seq</span></tt> of the first <span class="math">\(N\)</span> elements of a slowly convergent
infinite sequence, <a class="reference internal" href="#mpmath.richardson" title="mpmath.richardson"><tt class="xref py py-func docutils literal"><span class="pre">richardson()</span></tt></a> computes the <span class="math">\(N\)</span>-term
Richardson extrapolate for the limit.</p>
<p><a class="reference internal" href="#mpmath.richardson" title="mpmath.richardson"><tt class="xref py py-func docutils literal"><span class="pre">richardson()</span></tt></a> returns <span class="math">\((v, c)\)</span> where <span class="math">\(v\)</span> is the estimated
limit and <span class="math">\(c\)</span> is the magnitude of the largest weight used during the
computation. The weight provides an estimate of the precision
lost to cancellation. Due to cancellation effects, the sequence must
be typically be computed at a much higher precision than the target
accuracy of the extrapolation.</p>
<p><strong>Applicability and issues</strong></p>
<p>The <span class="math">\(N\)</span>-step Richardson extrapolation algorithm used by
<a class="reference internal" href="#mpmath.richardson" title="mpmath.richardson"><tt class="xref py py-func docutils literal"><span class="pre">richardson()</span></tt></a> is described in [1].</p>
<p>Richardson extrapolation only works for a specific type of sequence,
namely one converging like partial sums of
<span class="math">\(P(1)/Q(1) + P(2)/Q(2) + \ldots\)</span> where <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are polynomials.
When the sequence does not convergence at such a rate
<a class="reference internal" href="#mpmath.richardson" title="mpmath.richardson"><tt class="xref py py-func docutils literal"><span class="pre">richardson()</span></tt></a> generally produces garbage.</p>
<p>Richardson extrapolation has the advantage of being fast: the <span class="math">\(N\)</span>-term
extrapolate requires only <span class="math">\(O(N)\)</span> arithmetic operations, and usually
produces an estimate that is accurate to <span class="math">\(O(N)\)</span> digits. Contrast with
the Shanks transformation (see <a class="reference internal" href="#mpmath.shanks" title="mpmath.shanks"><tt class="xref py py-func docutils literal"><span class="pre">shanks()</span></tt></a>), which requires
<span class="math">\(O(N^2)\)</span> operations.</p>
<p><a class="reference internal" href="#mpmath.richardson" title="mpmath.richardson"><tt class="xref py py-func docutils literal"><span class="pre">richardson()</span></tt></a> is unable to produce an estimate for the
approximation error. One way to estimate the error is to perform
two extrapolations with slightly different <span class="math">\(N\)</span> and comparing the
results.</p>
<p>Richardson extrapolation does not work for oscillating sequences.
As a simple workaround, <a class="reference internal" href="#mpmath.richardson" title="mpmath.richardson"><tt class="xref py py-func docutils literal"><span class="pre">richardson()</span></tt></a> detects if the last
three elements do not differ monotonically, and in that case
applies extrapolation only to the even-index elements.</p>
<p><strong>Example</strong></p>
<p>Applying Richardson extrapolation to the Leibniz series for <span class="math">\(\pi\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> <span class="n">mp</span><span class="o">.</span><span class="n">pretty</span> <span class="o">=</span> <span class="bp">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">richardson</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span>
<span class="go">3.2126984126984126984126984127</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">([</span><span class="n">v</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="go">[0.0711058, 2.0]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">richardson</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="mi">30</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span>
<span class="go">3.14159265468624052829954206226</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">([</span><span class="n">v</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="go">[1.09645e-9, 20833.3]</span>
</pre></div>
</div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference internal" href="../references.html#benderorszag">[BenderOrszag]</a> pp. 375-376</li>
</ol>
</dd></dl>

</div>
<div class="section" id="shanks">
<h3><tt class="xref py py-func docutils literal"><span class="pre">shanks()</span></tt><a class="headerlink" href="#shanks" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.shanks">
<tt class="descclassname">mpmath.</tt><tt class="descname">shanks</tt><big>(</big><em>ctx</em>, <em>seq</em>, <em>table=None</em>, <em>randomized=False</em><big>)</big><a class="headerlink" href="#mpmath.shanks" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a list <tt class="docutils literal"><span class="pre">seq</span></tt> of the first <span class="math">\(N\)</span> elements of a slowly
convergent infinite sequence <span class="math">\((A_k)\)</span>, <a class="reference internal" href="#mpmath.shanks" title="mpmath.shanks"><tt class="xref py py-func docutils literal"><span class="pre">shanks()</span></tt></a> computes the iterated
Shanks transformation <span class="math">\(S(A), S(S(A)), \ldots, S^{N/2}(A)\)</span>. The Shanks
transformation often provides strong convergence acceleration,
especially if the sequence is oscillating.</p>
<p>The iterated Shanks transformation is computed using the Wynn
epsilon algorithm (see [1]). <a class="reference internal" href="#mpmath.shanks" title="mpmath.shanks"><tt class="xref py py-func docutils literal"><span class="pre">shanks()</span></tt></a> returns the full
epsilon table generated by Wynn&#8217;s algorithm, which can be read
off as follows:</p>
<ul class="simple">
<li>The table is a list of lists forming a lower triangular matrix,
where higher row and column indices correspond to more accurate
values.</li>
<li>The columns with even index hold dummy entries (required for the
computation) and the columns with odd index hold the actual
extrapolates.</li>
<li>The last element in the last row is typically the most
accurate estimate of the limit.</li>
<li>The difference to the third last element in the last row
provides an estimate of the approximation error.</li>
<li>The magnitude of the second last element provides an estimate
of the numerical accuracy lost to cancellation.</li>
</ul>
<p>For convenience, so the extrapolation is stopped at an odd index
so that <tt class="docutils literal"><span class="pre">shanks(seq)[-1][-1]</span></tt> always gives an estimate of the
limit.</p>
<p>Optionally, an existing table can be passed to <a class="reference internal" href="#mpmath.shanks" title="mpmath.shanks"><tt class="xref py py-func docutils literal"><span class="pre">shanks()</span></tt></a>.
This can be used to efficiently extend a previous computation after
new elements have been appended to the sequence. The table will
then be updated in-place.</p>
<p><strong>The Shanks transformation</strong></p>
<p>The Shanks transformation is defined as follows (see [2]): given
the input sequence <span class="math">\((A_0, A_1, \ldots)\)</span>, the transformed sequence is
given by</p>
<div class="math">
\[S(A_k) = \frac{A_{k+1}A_{k-1}-A_k^2}{A_{k+1}+A_{k-1}-2 A_k}\]</div>
<p>The Shanks transformation gives the exact limit <span class="math">\(A_{\infty}\)</span> in a
single step if <span class="math">\(A_k = A + a q^k\)</span>. Note in particular that it
extrapolates the exact sum of a geometric series in a single step.</p>
<p>Applying the Shanks transformation once often improves convergence
substantially for an arbitrary sequence, but the optimal effect is
obtained by applying it iteratively:
<span class="math">\(S(S(A_k)), S(S(S(A_k))), \ldots\)</span>.</p>
<p>Wynn&#8217;s epsilon algorithm provides an efficient way to generate
the table of iterated Shanks transformations. It reduces the
computation of each element to essentially a single division, at
the cost of requiring dummy elements in the table. See [1] for
details.</p>
<p><strong>Precision issues</strong></p>
<p>Due to cancellation effects, the sequence must be typically be
computed at a much higher precision than the target accuracy
of the extrapolation.</p>
<p>If the Shanks transformation converges to the exact limit (such
as if the sequence is a geometric series), then a division by
zero occurs. By default, <a class="reference internal" href="#mpmath.shanks" title="mpmath.shanks"><tt class="xref py py-func docutils literal"><span class="pre">shanks()</span></tt></a> handles this case by
terminating the iteration and returning the table it has
generated so far. With <em>randomized=True</em>, it will instead
replace the zero by a pseudorandom number close to zero.
(TODO: find a better solution to this problem.)</p>
<p><strong>Examples</strong></p>
<p>We illustrate by applying Shanks transformation to the Leibniz
series for <span class="math">\(\pi\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="nb">sum</span><span class="p">(</span><span class="n">mpf</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">shanks</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="mi">7</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">T</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">nprint</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">[-0.75]</span>
<span class="go">[1.25, 3.16667]</span>
<span class="go">[-1.75, 3.13333, -28.75]</span>
<span class="go">[2.25, 3.14524, 82.25, 3.14234]</span>
<span class="go">[-2.75, 3.13968, -177.75, 3.14139, -969.937]</span>
<span class="go">[3.25, 3.14271, 327.25, 3.14166, 3515.06, 3.14161]</span>
</pre></div>
</div>
<p>The extrapolated accuracy is about 4 digits, and about 4 digits
may have been lost due to cancellation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pi</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])])</span>
<span class="go">[2.22532e-5, 4.78309e-5, 3515.06]</span>
</pre></div>
</div>
<p>Now we extend the computation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">shanks</span><span class="p">(</span><span class="n">S</span><span class="p">[:</span><span class="mi">25</span><span class="p">],</span> <span class="n">T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nprint</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pi</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])])</span>
<span class="go">[3.75527e-19, 1.48478e-19, 2.96014e+17]</span>
</pre></div>
</div>
<p>The value for pi is now accurate to 18 digits. About 18 digits may
also have been lost to cancellation.</p>
<p>Here is an example with a geometric series, where the convergence
is immediate (the sum is exactly 1):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">shanks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.875</span><span class="p">,</span> <span class="mf">0.9375</span><span class="p">,</span> <span class="mf">0.96875</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">nprint</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
<span class="go">[4.0]</span>
<span class="go">[8.0, 1.0]</span>
</pre></div>
</div>
<p><strong>References</strong></p>
<ol class="arabic simple">
<li><a class="reference internal" href="../references.html#gravesmorris">[GravesMorris]</a></li>
<li><a class="reference internal" href="../references.html#benderorszag">[BenderOrszag]</a> pp. 368-375</li>
</ol>
</dd></dl>

</div>
<div class="section" id="levin">
<h3><tt class="xref py py-func docutils literal"><span class="pre">levin()</span></tt><a class="headerlink" href="#levin" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.levin">
<tt class="descclassname">mpmath.</tt><tt class="descname">levin</tt><big>(</big><em>ctx</em>, <em>method='levin'</em>, <em>variant='u'</em><big>)</big><a class="headerlink" href="#mpmath.levin" title="Permalink to this definition">¶</a></dt>
<dd><p>This interface implements Levin&#8217;s (nonlinear) sequence transformation for
convergence acceleration and summation of divergent series. It performs
better than the Shanks/Wynn-epsilon algorithm for logarithmic convergent
or alternating divergent series.</p>
<p>Let <em>A</em> be the series we want to sum:</p>
<div class="math">
\[A = \sum_{k=0}^{\infty} a_k\]</div>
<p>Attention: all <span class="math">\(a_k\)</span> must be non-zero!</p>
<p>Let <span class="math">\(s_n\)</span> be the partial sums of this series:</p>
<div class="math">
\[s_n = \sum_{k=0}^n a_k.\]</div>
<p><strong>Methods</strong></p>
<p>Calling <tt class="docutils literal"><span class="pre">levin</span></tt> returns an object with the following methods.</p>
<p><tt class="docutils literal"><span class="pre">update(...)</span></tt> works with the list of individual terms <span class="math">\(a_k\)</span> of <em>A</em>, and
<tt class="docutils literal"><span class="pre">update_step(...)</span></tt> works with the list of partial sums <span class="math">\(s_k\)</span> of <em>A</em>:</p>
<div class="code highlight-python"><div class="highlight"><pre><span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="o">...</span><span class="n">update</span><span class="p">([</span><span class="n">a_0</span><span class="p">,</span> <span class="n">a_1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span> <span class="n">a_k</span><span class="p">])</span>
<span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="o">...</span><span class="n">update_psum</span><span class="p">([</span><span class="n">s_0</span><span class="p">,</span> <span class="n">s_1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span> <span class="n">s_k</span><span class="p">])</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">step(...)</span></tt> works with the individual terms <span class="math">\(a_k\)</span> and <tt class="docutils literal"><span class="pre">step_psum(...)</span></tt>
works with the partial sums <span class="math">\(s_k\)</span>:</p>
<div class="code highlight-python"><div class="highlight"><pre><span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="o">...</span><span class="n">step</span><span class="p">(</span><span class="n">a_k</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="o">...</span><span class="n">step_psum</span><span class="p">(</span><span class="n">s_k</span><span class="p">)</span>
</pre></div>
</div>
<p><em>v</em> is the current estimate for <em>A</em>, and <em>e</em> is an error estimate which is
simply the difference between the current estimate and the last estimate.
One should not mix <tt class="docutils literal"><span class="pre">update</span></tt>, <tt class="docutils literal"><span class="pre">update_psum</span></tt>, <tt class="docutils literal"><span class="pre">step</span></tt> and <tt class="docutils literal"><span class="pre">step_psum</span></tt>.</p>
<p><strong>A word of caution</strong></p>
<p>One can only hope for good results (i.e. convergence acceleration or
resummation) if the <span class="math">\(s_n\)</span> have some well defind asymptotic behavior for
large <span class="math">\(n\)</span> and are not erratic or random. Furthermore one usually needs very
high working precision because of the numerical cancellation. If the working
precision is insufficient, levin may produce silently numerical garbage.
Furthermore even if the Levin-transformation converges, in the general case
there is no proof that the result is mathematically sound. Only for very
special classes of problems one can prove that the Levin-transformation
converges to the expected result (for example Stieltjes-type integrals).
Furthermore the Levin-transform is quite expensive (i.e. slow) in comparison
to Shanks/Wynn-epsilon, Richardson &amp; co.
In summary one can say that the Levin-transformation is powerful but
unreliable and that it may need a copious amount of working precision.</p>
<p>The Levin transform has several variants differing in the choice of weights.
Some variants are better suited for the possible flavours of convergence
behaviour of <em>A</em> than other variants:</p>
<div class="code highlight-python"><pre>convergence behaviour   levin-u   levin-t   levin-v   shanks/wynn-epsilon

logarithmic               +         -         +           -
linear                    +         +         +           +
alternating divergent     +         +         +           +

  "+" means the variant is suitable,"-" means the variant is not suitable;
  for comparison the Shanks/Wynn-epsilon transform is listed, too.</pre>
</div>
<p>The variant is controlled though the variant keyword (i.e. <tt class="docutils literal"><span class="pre">variant=&quot;u&quot;</span></tt>,
<tt class="docutils literal"><span class="pre">variant=&quot;t&quot;</span></tt> or <tt class="docutils literal"><span class="pre">variant=&quot;v&quot;</span></tt>). Overall &#8220;u&#8221; is probably the best choice.</p>
<p>Finally it is possible to use the Sidi-S transform instead of the Levin transform
by using the keyword <tt class="docutils literal"><span class="pre">method='sidi'</span></tt>. The Sidi-S transform works better than the
Levin transformation for some divergent series (see the examples).</p>
<p>Parameters:</p>
<div class="code highlight-python"><pre>method      "levin" or "sidi" chooses either the Levin or the Sidi-S transformation
variant     "u","t" or "v" chooses the weight variant.</pre>
</div>
<p>The Levin transform is also accessible through the nsum interface.
<tt class="docutils literal"><span class="pre">method=&quot;l&quot;</span></tt> or <tt class="docutils literal"><span class="pre">method=&quot;levin&quot;</span></tt> select the normal Levin transform while
<tt class="docutils literal"><span class="pre">method=&quot;sidi&quot;</span></tt>
selects the Sidi-S transform. The variant is in both cases selected through the
levin_variant keyword. The stepsize in <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> must not be chosen too large, otherwise
it will miss the point where the Levin transform converges resulting in numerical
overflow/garbage. For highly divergent series a copious amount of working precision
must be chosen.</p>
<p><strong>Examples</strong></p>
<p>First we sum the zeta function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="n">mp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="mi">53</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eps</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">extraprec</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">prec</span><span class="p">):</span> <span class="c"># levin needs a high working precision</span>
<span class="gp">... </span>    <span class="n">L</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">levin</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">variant</span> <span class="o">=</span> <span class="s">&quot;u&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">s</span> <span class="o">+=</span> <span class="n">mp</span><span class="o">.</span><span class="n">one</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">update_psum</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">break</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;iteration limit exceeded&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">levin_variant</span> <span class="o">=</span> <span class="s">&quot;u&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">w</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Now we sum the zeta function outside its range of convergence
(attention: This does not work at the negative integers!):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eps</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">extraprec</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">prec</span><span class="p">):</span> <span class="c"># levin needs a high working precision</span>
<span class="gp">... </span>    <span class="n">L</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">levin</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">variant</span> <span class="o">=</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">A</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">s</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3j</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">break</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;iteration limit exceeded&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">zeta</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">3j</span><span class="p">)))</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3j</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">levin_variant</span> <span class="o">=</span> <span class="s">&quot;v&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">w</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Now we sum the divergent asymptotic expansion of an integral related to the
exponential integral (see also [2] p.373). The Sidi-S transform works best here:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="o">/</span><span class="n">z</span><span class="p">),[</span><span class="mi">0</span><span class="p">,</span><span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># exact = z * mp.exp(z) * mp.expint(1,z) # this is the symbolic expression for the integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eps</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">extraprec</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">prec</span><span class="p">):</span> <span class="c"># high working precisions are mandatory for divergent resummation</span>
<span class="gp">... </span>    <span class="n">L</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">levin</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s">&quot;sidi&quot;</span><span class="p">,</span> <span class="n">variant</span> <span class="o">=</span> <span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">break</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;iteration limit exceeded&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">exact</span><span class="p">))</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">n</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;sidi&quot;</span><span class="p">,</span> <span class="n">levin_variant</span> <span class="o">=</span> <span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">w</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Another highly divergent integral is also summable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eps</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">z</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">4</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># exact = mp.exp(mp.one / (32 * z)) * mp.besselk(mp.one / 4, mp.one / (32 * z)) / (4 * mp.sqrt(z * mp.pi)) # this is the symbolic expression for the integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">extraprec</span><span class="p">(</span><span class="mi">7</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">prec</span><span class="p">):</span>  <span class="c"># we need copious amount of precision to sum this highly divergent series</span>
<span class="gp">... </span>    <span class="n">L</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">levin</span><span class="p">(</span><span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">variant</span> <span class="o">=</span> <span class="s">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">**</span> <span class="n">n</span><span class="p">))</span>
<span class="gp">... </span>        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">step_psum</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">break</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;iteration limit exceeded&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">exact</span><span class="p">))</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4</span> <span class="o">**</span> <span class="n">n</span><span class="p">)),</span>
<span class="gp">... </span>  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">levin_variant</span> <span class="o">=</span> <span class="s">&quot;t&quot;</span><span class="p">,</span> <span class="n">workprec</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="n">mp</span><span class="o">.</span><span class="n">prec</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">w</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>These examples run with 15-20 decimal digits precision. For higher precision the
working precision must be raised.</p>
<p><strong>Examples for nsum</strong></p>
<p>Here we calculate Euler&#8217;s constant as the constant term in the Laurent
expansion of <span class="math">\(\zeta(s)\)</span> at <span class="math">\(s=1\)</span>. This sum converges extremly slowly because of
the logarithmic convergence behaviour of the Dirichlet series for zeta:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">z</span><span class="p">)),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;l&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">euler</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>The Sidi-S transform performs excellently for the alternating series of <span class="math">\(\log(2)\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;sidi&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Hypergeometric series can also be summed outside their range of convergence.
The stepsize in <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> must not be chosen too large, otherwise it will miss the
point where the Levin transform converges resulting in numerical overflow/garbage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exact</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">hyp2f1</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">4</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">rf</span><span class="p">(</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">rf</span><span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">rf</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">mp</span><span class="o">.</span><span class="n">mpf</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;levin&quot;</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">exact</span><span class="o">-</span><span class="n">v</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>References:</p>
<blockquote>
<div><dl class="docutils">
<dt>[1] E.J. Weniger - &#8220;Nonlinear Sequence Transformations for the Acceleration of</dt>
<dd>Convergence and the Summation of Divergent Series&#8221; arXiv:math/0306302</dd>
</dl>
<p>[2] A. Sidi - &#8220;Pratical Extrapolation Methods&#8221;</p>
<p>[3] H.H.H. Homeier - &#8220;Scalar Levin-Type Sequence Transformations&#8221; arXiv:math/0005209</p>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="cohen-alt">
<h3><tt class="xref py py-func docutils literal"><span class="pre">cohen_alt()</span></tt><a class="headerlink" href="#cohen-alt" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="mpmath.cohen_alt">
<tt class="descclassname">mpmath.</tt><tt class="descname">cohen_alt</tt><big>(</big><em>ctx</em><big>)</big><a class="headerlink" href="#mpmath.cohen_alt" title="Permalink to this definition">¶</a></dt>
<dd><p>This interface implements the convergence acceleration of alternating series
as described in H. Cohen, F.R. Villegas, D. Zagier - &#8220;Convergence Acceleration
of Alternating Series&#8221;. This series transformation works only well if the
individual terms of the series have an alternating sign. It belongs to the
class of linear series transformations (in contrast to the Shanks/Wynn-epsilon
or Levin transform). This series transformation is also able to sum some types
of divergent series. See the paper under which conditions this resummation is
mathematical sound.</p>
<p>Let <em>A</em> be the series we want to sum:</p>
<div class="math">
\[A = \sum_{k=0}^{\infty} a_k\]</div>
<p>Let <span class="math">\(s_n\)</span> be the partial sums of this series:</p>
<div class="math">
\[s_n = \sum_{k=0}^n a_k.\]</div>
<p><strong>Interface</strong></p>
<p>Calling <tt class="docutils literal"><span class="pre">cohen_alt</span></tt> returns an object with the following methods.</p>
<p>Then <tt class="docutils literal"><span class="pre">update(...)</span></tt> works with the list of individual terms <span class="math">\(a_k\)</span> and
<tt class="docutils literal"><span class="pre">update_psum(...)</span></tt> works with the list of partial sums <span class="math">\(s_k\)</span>:</p>
<div class="code highlight-python"><div class="highlight"><pre><span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="o">...</span><span class="n">update</span><span class="p">([</span><span class="n">a_0</span><span class="p">,</span> <span class="n">a_1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span> <span class="n">a_k</span><span class="p">])</span>
<span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="o">...</span><span class="n">update_psum</span><span class="p">([</span><span class="n">s_0</span><span class="p">,</span> <span class="n">s_1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span> <span class="n">s_k</span><span class="p">])</span>
</pre></div>
</div>
<p><em>v</em> is the current estimate for <em>A</em>, and <em>e</em> is an error estimate which is
simply the difference between the current estimate and the last estimate.</p>
<p><strong>Examples</strong></p>
<p>Here we compute the alternating zeta function using <tt class="docutils literal"><span class="pre">update_psum</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="n">mp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AC</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">cohen_alt</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">s</span> <span class="o">+=</span> <span class="o">-</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">one</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">AC</span><span class="o">.</span><span class="n">update_psum</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;iteration limit exceeded&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">pi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">12</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Here we compute the product <span class="math">\(\prod_{n=1}^{\infty} \Gamma(1+1/(2n-1)) / \Gamma(1+1/(2n))\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AC</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">cohen_alt</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">mp</span><span class="o">.</span><span class="n">loggamma</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">mp</span><span class="o">.</span><span class="n">one</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
<span class="gp">... </span>    <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">mp</span><span class="o">.</span><span class="n">loggamma</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">mp</span><span class="o">.</span><span class="n">one</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)))</span>
<span class="gp">... </span>    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>    <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">AC</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">mp</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">break</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&quot;iteration limit exceeded&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="mf">1.06215090557106</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">cohen_alt</span></tt> is also accessible through the <a class="reference internal" href="#mpmath.nsum" title="mpmath.nsum"><tt class="xref py py-func docutils literal"><span class="pre">nsum()</span></tt></a> interface:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">nsum</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="n">n</span> <span class="o">*</span> <span class="n">mp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">method</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">chop</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">mp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">mp</span><span class="o">.</span><span class="n">altzeta</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Sums, products, limits and extrapolation</a><ul>
<li><a class="reference internal" href="#summation">Summation</a><ul>
<li><a class="reference internal" href="#nsum"><tt class="docutils literal"><span class="pre">nsum()</span></tt></a></li>
<li><a class="reference internal" href="#sumem"><tt class="docutils literal"><span class="pre">sumem()</span></tt></a></li>
<li><a class="reference internal" href="#sumap"><tt class="docutils literal"><span class="pre">sumap()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#products">Products</a><ul>
<li><a class="reference internal" href="#nprod"><tt class="docutils literal"><span class="pre">nprod()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#limits-limit">Limits (<tt class="docutils literal"><span class="pre">limit</span></tt>)</a><ul>
<li><a class="reference internal" href="#limit"><tt class="docutils literal"><span class="pre">limit()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#extrapolation">Extrapolation</a><ul>
<li><a class="reference internal" href="#richardson"><tt class="docutils literal"><span class="pre">richardson()</span></tt></a></li>
<li><a class="reference internal" href="#shanks"><tt class="docutils literal"><span class="pre">shanks()</span></tt></a></li>
<li><a class="reference internal" href="#levin"><tt class="docutils literal"><span class="pre">levin()</span></tt></a></li>
<li><a class="reference internal" href="#cohen-alt"><tt class="docutils literal"><span class="pre">cohen_alt()</span></tt></a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="optimization.html"
                        title="previous chapter">Root-finding and optimization</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="differentiation.html"
                        title="next chapter">Differentiation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../_sources/modules/mpmath/calculus/sums_limits.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="differentiation.html" title="Differentiation"
             >next</a> |</li>
        <li class="right" >
          <a href="optimization.html" title="Root-finding and optimization"
             >previous</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.6.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >SymPy Modules Reference</a> &raquo;</li>
          <li><a href="../index.html" >Welcome to mpmath&#8217;s documentation!</a> &raquo;</li>
          <li><a href="index.html" >Numerical calculus</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014 SymPy Development Team.
      Last updated on Sep 03, 2015.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>