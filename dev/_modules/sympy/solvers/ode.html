

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.solvers.ode &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.solvers.ode</h1><div class="highlight"><pre>
<span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">This module contains :py:meth:`~sympy.solvers.ode.dsolve` and different helper</span>
<span class="sd">functions that it uses.</span>

<span class="sd">:py:meth:`~sympy.solvers.ode.dsolve` solves ordinary differential equations.</span>
<span class="sd">See the docstring on the various functions for their uses.  Note that partial</span>
<span class="sd">differential equations support is in ``pde.py``.  Note that hint functions</span>
<span class="sd">have docstrings describing their various methods, but they are intended for</span>
<span class="sd">internal use.  Use ``dsolve(ode, func, hint=hint)`` to solve an ODE using a</span>
<span class="sd">specific hint.  See also the docstring on</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.dsolve`.</span>

<span class="sd">**Functions in this module**</span>

<span class="sd">    These are the user functions in this module:</span>

<span class="sd">    - :py:meth:`~sympy.solvers.ode.dsolve` - Solves ODEs.</span>
<span class="sd">    - :py:meth:`~sympy.solvers.ode.classify_ode` - Classifies ODEs into</span>
<span class="sd">      possible hints for :py:meth:`~sympy.solvers.ode.dsolve`.</span>
<span class="sd">    - :py:meth:`~sympy.solvers.ode.checkodesol` - Checks if an equation is the</span>
<span class="sd">      solution to an ODE.</span>
<span class="sd">    - :py:meth:`~sympy.solvers.ode.homogeneous_order` - Returns the</span>
<span class="sd">      homogeneous order of an expression.</span>

<span class="sd">    These are the non-solver helper functions that are for internal use.  The</span>
<span class="sd">    user should use the various options to</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve` to obtain the functionality provided</span>
<span class="sd">    by these functions:</span>

<span class="sd">    - :py:meth:`~sympy.solvers.ode.odesimp` - Does all forms of ODE</span>
<span class="sd">      simplification.</span>
<span class="sd">    - :py:meth:`~sympy.solvers.ode.ode_sol_simplicity` - A key function for</span>
<span class="sd">      comparing solutions by simplicity.</span>
<span class="sd">    - :py:meth:`~sympy.solvers.ode.constantsimp` - Simplifies arbitrary</span>
<span class="sd">      constants.</span>
<span class="sd">    - :py:meth:`~sympy.solvers.ode.constant_renumber` - Renumber arbitrary</span>
<span class="sd">      constants.</span>
<span class="sd">    - :py:meth:`~sympy.solvers.ode._handle_Integral` - Evaluate unevaluated</span>
<span class="sd">      Integrals.</span>

<span class="sd">    See also the docstrings of these functions.</span>

<span class="sd">**Currently implemented solver methods**</span>

<span class="sd">The following methods are implemented for solving ordinary differential</span>
<span class="sd">equations.  See the docstrings of the various hint functions for more</span>
<span class="sd">information on each (run ``help(ode)``):</span>

<span class="sd">  - 1st order separable differential equations.</span>
<span class="sd">  - 1st order differential equations whose coefficients or `dx` and `dy` are</span>
<span class="sd">    functions homogeneous of the same order.</span>
<span class="sd">  - 1st order exact differential equations.</span>
<span class="sd">  - 1st order linear differential equations.</span>
<span class="sd">  - 1st order Bernoulli differential equations.</span>
<span class="sd">  - 2nd order Liouville differential equations.</span>
<span class="sd">  - `n`\th order linear homogeneous differential equation with constant</span>
<span class="sd">    coefficients.</span>
<span class="sd">  - `n`\th order linear inhomogeneous differential equation with constant</span>
<span class="sd">    coefficients using the method of undetermined coefficients.</span>
<span class="sd">  - `n`\th order linear inhomogeneous differential equation with constant</span>
<span class="sd">    coefficients using the method of variation of parameters.</span>

<span class="sd">**Philosophy behind this module**</span>

<span class="sd">This module is designed to make it easy to add new ODE solving methods without</span>
<span class="sd">having to mess with the solving code for other methods.  The idea is that</span>
<span class="sd">there is a :py:meth:`~sympy.solvers.ode.classify_ode` function, which takes in</span>
<span class="sd">an ODE and tells you what hints, if any, will solve the ODE.  It does this</span>
<span class="sd">without attempting to solve the ODE, so it is fast.  Each solving method is a</span>
<span class="sd">hint, and it has its own function, named ``ode_&lt;hint&gt;``.  That function takes</span>
<span class="sd">in the ODE and any match expression gathered by</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.classify_ode` and returns a solved result.  If</span>
<span class="sd">this result has any integrals in it, the hint function will return an</span>
<span class="sd">unevaluated :py:class:`~sympy.integrals.Integral` class.</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.dsolve`, which is the user wrapper function</span>
<span class="sd">around all of this, will then call :py:meth:`~sympy.solvers.ode.odesimp` on</span>
<span class="sd">the result, which, among other things, will attempt to solve the equation for</span>
<span class="sd">the dependent variable (the function we are solving for), simplify the</span>
<span class="sd">arbitrary constants in the expression, and evaluate any integrals, if the hint</span>
<span class="sd">allows it.</span>

<span class="sd">**How to add new solution methods**</span>

<span class="sd">If you have an ODE that you want :py:meth:`~sympy.solvers.ode.dsolve` to be</span>
<span class="sd">able to solve, try to avoid adding special case code here.  Instead, try</span>
<span class="sd">finding a general method that will solve your ODE, as well as others.  This</span>
<span class="sd">way, the :py:mod:`~sympy.solvers.ode` module will become more robust, and</span>
<span class="sd">unhindered by special case hacks.  WolphramAlpha and Maple&#39;s</span>
<span class="sd">DETools[odeadvisor] function are two resources you can use to classify a</span>
<span class="sd">specific ODE.  It is also better for a method to work with an `n`\th order ODE</span>
<span class="sd">instead of only with specific orders, if possible.</span>

<span class="sd">To add a new method, there are a few things that you need to do.  First, you</span>
<span class="sd">need a hint name for your method.  Try to name your hint so that it is</span>
<span class="sd">unambiguous with all other methods, including ones that may not be implemented</span>
<span class="sd">yet.  If your method uses integrals, also include a ``hint_Integral`` hint.</span>
<span class="sd">If there is more than one way to solve ODEs with your method, include a hint</span>
<span class="sd">for each one, as well as a ``&lt;hint&gt;_best`` hint.  Your ``ode_&lt;hint&gt;_best()``</span>
<span class="sd">function should choose the best using min with ``ode_sol_simplicity`` as the</span>
<span class="sd">key argument.  See</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.ode_1st_homogeneous_coeff_best`, for example.</span>
<span class="sd">The function that uses your method will be called ``ode_&lt;hint&gt;()``, so the</span>
<span class="sd">hint must only use characters that are allowed in a Python function name</span>
<span class="sd">(alphanumeric characters and the underscore &#39;``_``&#39; character).  Include a</span>
<span class="sd">function for every hint, except for ``_Integral`` hints</span>
<span class="sd">(:py:meth:`~sympy.solvers.ode.dsolve` takes care of those automatically).</span>
<span class="sd">Hint names should be all lowercase, unless a word is commonly capitalized</span>
<span class="sd">(such as Integral or Bernoulli).  If you have a hint that you do not want to</span>
<span class="sd">run with ``all_Integral`` that doesn&#39;t have an ``_Integral`` counterpart (such</span>
<span class="sd">as a best hint that would defeat the purpose of ``all_Integral``), you will</span>
<span class="sd">need to remove it manually in the :py:meth:`~sympy.solvers.ode.dsolve` code.</span>
<span class="sd">See also the :py:meth:`~sympy.solvers.ode.classify_ode` docstring for</span>
<span class="sd">guidelines on writing a hint name.</span>

<span class="sd">Determine *in general* how the solutions returned by your method compare with</span>
<span class="sd">other methods that can potentially solve the same ODEs.  Then, put your hints</span>
<span class="sd">in the :py:data:`~sympy.solvers.ode.allhints` tuple in the order that they</span>
<span class="sd">should be called.  The ordering of this tuple determines which hints are</span>
<span class="sd">default.  Note that exceptions are ok, because it is easy for the user to</span>
<span class="sd">choose individual hints with :py:meth:`~sympy.solvers.ode.dsolve`.  In</span>
<span class="sd">general, ``_Integral`` variants should go at the end of the list, and</span>
<span class="sd">``_best`` variants should go before the various hints they apply to.  For</span>
<span class="sd">example, the ``undetermined_coefficients`` hint comes before the</span>
<span class="sd">``variation_of_parameters`` hint because, even though variation of parameters</span>
<span class="sd">is more general than undetermined coefficients, undetermined coefficients</span>
<span class="sd">generally returns cleaner results for the ODEs that it can solve than</span>
<span class="sd">variation of parameters does, and it does not require integration, so it is</span>
<span class="sd">much faster.</span>

<span class="sd">Next, you need to have a match expression or a function that matches the type</span>
<span class="sd">of the ODE, which you should put in :py:meth:`~sympy.solvers.ode.classify_ode`</span>
<span class="sd">(if the match function is more than just a few lines, like</span>
<span class="sd">:py:meth:`~sympy.solvers.ode._undetermined_coefficients_match`, it should go</span>
<span class="sd">outside of :py:meth:`~sympy.solvers.ode.classify_ode`).  It should match the</span>
<span class="sd">ODE without solving for it as much as possible, so that</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.classify_ode` remains fast and is not hindered by</span>
<span class="sd">bugs in solving code.  Be sure to consider corner cases.  For example, if your</span>
<span class="sd">solution method involves dividing by something, make sure you exclude the case</span>
<span class="sd">where that division will be 0.</span>

<span class="sd">In most cases, the matching of the ODE will also give you the various parts</span>
<span class="sd">that you need to solve it.  You should put that in a dictionary (``.match()``</span>
<span class="sd">will do this for you), and add that as ``matching_hints[&#39;hint&#39;] = matchdict``</span>
<span class="sd">in the relevant part of :py:meth:`~sympy.solvers.ode.classify_ode`.</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.classify_ode` will then send this to</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.dsolve`, which will send it to your function as</span>
<span class="sd">the ``match`` argument.  Your function should be named ``ode_&lt;hint&gt;(eq, func,</span>
<span class="sd">order, match)`.  If you need to send more information, put it in the ``match``</span>
<span class="sd">dictionary.  For example, if you had to substitute in a dummy variable in</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.classify_ode` to match the ODE, you will need to</span>
<span class="sd">pass it to your function using the `match` dict to access it.  You can access</span>
<span class="sd">the independent variable using ``func.args[0]``, and the dependent variable</span>
<span class="sd">(the function you are trying to solve for) as ``func.func``.  If, while trying</span>
<span class="sd">to solve the ODE, you find that you cannot, raise ``NotImplementedError``.</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.dsolve` will catch this error with the ``all``</span>
<span class="sd">meta-hint, rather than causing the whole routine to fail.</span>

<span class="sd">Add a docstring to your function that describes the method employed.  Like</span>
<span class="sd">with anything else in SymPy, you will need to add a doctest to the docstring,</span>
<span class="sd">in addition to real tests in ``test_ode.py``.  Try to maintain consistency</span>
<span class="sd">with the other hint functions&#39; docstrings.  Add your method to the list at the</span>
<span class="sd">top of this docstring.  Also, add your method to ``ode.rst`` in the</span>
<span class="sd">``docs/src`` directory, so that the Sphinx docs will pull its docstring into</span>
<span class="sd">the main SymPy documentation.  Be sure to make the Sphinx documentation by</span>
<span class="sd">running ``make html`` from within the doc directory to verify that the</span>
<span class="sd">docstring formats correctly.</span>

<span class="sd">If your solution method involves integrating, use :py:meth:`C.Integral()</span>
<span class="sd">&lt;sympy.core.C.Integral&gt;` instead of</span>
<span class="sd">:py:meth:`~sympy.core.expr.Expr.integrate`.  This allows the user to bypass</span>
<span class="sd">hard/slow integration by using the ``_Integral`` variant of your hint.  In</span>
<span class="sd">most cases, calling :py:meth:`sympy.core.basic.Basic.doit` will integrate your</span>
<span class="sd">solution.  If this is not the case, you will need to write special code in</span>
<span class="sd">:py:meth:`~sympy.solvers.ode._handle_Integral`.  Arbitrary constants should be</span>
<span class="sd">symbols named ``C1``, ``C2``, and so on.  All solution methods should return</span>
<span class="sd">an equality instance.  If you need an arbitrary number of arbitrary constants,</span>
<span class="sd">you can use ``constants = numbered_symbols(prefix=&#39;C&#39;, cls=Symbol, start=1)``.</span>
<span class="sd">If it is possible to solve for the dependent function in a general way, do so.</span>
<span class="sd">Otherwise, do as best as you can, but do not call solve in your</span>
<span class="sd">``ode_&lt;hint&gt;()`` function.  :py:meth:`~sympy.solvers.ode.odesimp` will attempt</span>
<span class="sd">to solve the solution for you, so you do not need to do that.  Lastly, if your</span>
<span class="sd">ODE has a common simplification that can be applied to your solutions, you can</span>
<span class="sd">add a special case in :py:meth:`~sympy.solvers.ode.odesimp` for it.  For</span>
<span class="sd">example, solutions returned from the ``1st_homogeneous_coeff`` hints often</span>
<span class="sd">have many :py:meth:`~sympy.functions.log` terms, so</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.odesimp` calls</span>
<span class="sd">:py:meth:`~sympy.simplify.logcombine` on them (it also helps to write the</span>
<span class="sd">arbitrary constant as ``log(C1)`` instead of ``C1`` in this case).  Also</span>
<span class="sd">consider common ways that you can rearrange your solution to have</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.constantsimp` take better advantage of it.  It is</span>
<span class="sd">better to put simplification in :py:meth:`~sympy.solvers.ode.odesimp` than in</span>
<span class="sd">your method, because it can then be turned off with the simplify flag in</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.dsolve`.  If you have any extraneous</span>
<span class="sd">simplification in your function, be sure to only run it using ``if</span>
<span class="sd">match.get(&#39;simplify&#39;, True):``, especially if it can be slow or if it can</span>
<span class="sd">reduce the domain of the solution.</span>

<span class="sd">Finally, as with every contribution to SymPy, your method will need to be</span>
<span class="sd">tested.  Add a test for each method in ``test_ode.py``.  Follow the</span>
<span class="sd">conventions there, i.e., test the solver using ``dsolve(eq, f(x),</span>
<span class="sd">hint=your_hint)``, and also test the solution using</span>
<span class="sd">:py:meth:`~sympy.solvers.ode.checkodesol` (you can put these in a separate</span>
<span class="sd">tests and skip/XFAIL if it runs too slow/doesn&#39;t work).  Be sure to call your</span>
<span class="sd">hint specifically in :py:meth:`~sympy.solvers.ode.dsolve`, that way the test</span>
<span class="sd">won&#39;t be broken simply by the introduction of another matching hint.  If your</span>
<span class="sd">method works for higher order (&gt;1) ODEs, you will need to run ``sol =</span>
<span class="sd">constant_renumber(sol, &#39;C&#39;, 1, order)`` for each solution, where ``order`` is</span>
<span class="sd">the order of the ODE.  This is because ``constant_renumber`` renumbers the</span>
<span class="sd">arbitrary constants by printing order, which is platform dependent.  Try to</span>
<span class="sd">test every corner case of your solver, including a range of orders if it is a</span>
<span class="sd">`n`\th order solver, but if your solver is slow, such as if it involves hard</span>
<span class="sd">integration, try to keep the test run time down.</span>

<span class="sd">Feel free to refactor existing hints to avoid duplicating code or creating</span>
<span class="sd">inconsistencies.  If you can show that your method exactly duplicates an</span>
<span class="sd">existing method, including in the simplicity and speed of obtaining the</span>
<span class="sd">solutions, then you can remove the old, less general method.  The existing</span>
<span class="sd">code is tested extensively in ``test_ode.py``, so if anything is broken, one</span>
<span class="sd">of those tests will surely fail.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Add</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">oo</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">set_union</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.exceptions</span> <span class="kn">import</span> <span class="n">SymPyDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">factor_terms</span><span class="p">,</span> <span class="n">gcd_terms</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span>
    <span class="n">expand</span><span class="p">,</span> <span class="n">expand_mul</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.multidimensional</span> <span class="kn">import</span> <span class="n">vectorize</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">NaN</span>
<span class="kn">from</span> <span class="nn">sympy.core.relational</span> <span class="kn">import</span> <span class="n">Equality</span><span class="p">,</span> <span class="n">Eq</span>
<span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="kn">import</span> <span class="n">sympify</span>

<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">Piecewise</span>
<span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">wronskian</span>
<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">,</span> <span class="n">terms_gcd</span><span class="p">,</span> <span class="n">PolynomialError</span>
<span class="kn">from</span> <span class="nn">sympy.series</span> <span class="kn">import</span> <span class="n">Order</span>
<span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">collect</span><span class="p">,</span> <span class="n">logcombine</span><span class="p">,</span> <span class="n">powsimp</span><span class="p">,</span> <span class="n">separatevars</span><span class="p">,</span> \
    <span class="n">simplify</span><span class="p">,</span> <span class="n">trigsimp</span><span class="p">,</span> <span class="n">denom</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">posify</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="kn">import</span> <span class="n">_mexpand</span>
<span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="kn">import</span> <span class="n">solve</span>

<span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">numbered_symbols</span><span class="p">,</span> <span class="n">default_sort_key</span><span class="p">,</span> <span class="n">sift</span>
<span class="kn">from</span> <span class="nn">sympy.solvers.deutils</span> <span class="kn">import</span> <span class="n">_preprocess</span><span class="p">,</span> <span class="n">ode_order</span><span class="p">,</span> <span class="n">_desolve</span>

<span class="c">#: This is a list of hints in the order that they should be preferred by</span>
<span class="c">#: :py:meth:`~sympy.solvers.ode.classify_ode`. In general, hints earlier in the</span>
<span class="c">#: list should produce simpler solutions than those later in the list (for</span>
<span class="c">#: ODEs that fit both).  For now, the order of this list is based on empirical</span>
<span class="c">#: observations by the developers of SymPy.</span>
<span class="c">#:</span>
<span class="c">#: The hint used by :py:meth:`~sympy.solvers.ode.dsolve` for a specific ODE</span>
<span class="c">#: can be overridden (see the docstring).</span>
<span class="c">#:</span>
<span class="c">#: In general, ``_Integral`` hints are grouped at the end of the list, unless</span>
<span class="c">#: there is a method that returns an unevaluable integral most of the time</span>
<span class="c">#: (which go near the end of the list anyway).  ``default``, ``all``,</span>
<span class="c">#: ``best``, and ``all_Integral`` meta-hints should not be included in this</span>
<span class="c">#: list, but ``_best`` and ``_Integral`` hints should be included.</span>
<span class="n">allhints</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s">&quot;separable&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_exact&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_linear&quot;</span><span class="p">,</span>
    <span class="s">&quot;Bernoulli&quot;</span><span class="p">,</span>
    <span class="s">&quot;Riccati_special_minus2&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_best&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_subs_indep_div_dep&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_subs_dep_div_indep&quot;</span><span class="p">,</span>
    <span class="s">&quot;almost_linear&quot;</span><span class="p">,</span>
    <span class="s">&quot;linear_coefficients&quot;</span><span class="p">,</span>
    <span class="s">&quot;separable_reduced&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_constant_coeff_homogeneous&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_euler_eq_homogeneous&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_constant_coeff_undetermined_coefficients&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_constant_coeff_variation_of_parameters&quot;</span><span class="p">,</span>
    <span class="s">&quot;Liouville&quot;</span><span class="p">,</span>
    <span class="s">&quot;separable_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_linear_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;Bernoulli_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_subs_indep_div_dep_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;1st_homogeneous_coeff_subs_dep_div_indep_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;almost_linear_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;linear_coefficients_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;separable_reduced_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;nth_linear_constant_coeff_variation_of_parameters_Integral&quot;</span><span class="p">,</span>
    <span class="s">&quot;Liouville_Integral&quot;</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">sub_func_doit</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    When replacing the func with something else, we usually want the</span>
<span class="sd">    derivative evaluated, so this function helps in making that happen.</span>

<span class="sd">    To keep subs from having to look through all derivatives, we mask them off</span>
<span class="sd">    with dummy variables, do the func sub, and then replace masked-off</span>
<span class="sd">    derivatives with their doit values.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Derivative, symbols, Function</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import sub_func_doit</span>
<span class="sd">    &gt;&gt;&gt; x, z = symbols(&#39;x, z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Function(&#39;y&#39;)</span>

<span class="sd">    &gt;&gt;&gt; sub_func_doit(3*Derivative(y(x), x) - 1, y(x), x)</span>
<span class="sd">    2</span>

<span class="sd">    &gt;&gt;&gt; sub_func_doit(x*Derivative(y(x), x) - y(x)**2 + y(x), y(x),</span>
<span class="sd">    ... 1/(x*(z + 1/x)))</span>
<span class="sd">    x*(-1/(x**2*(z + 1/x)) + 1/(x**3*(z + 1/x)**2)) + 1/(x*(z + 1/x))</span>
<span class="sd">    ...- 1/(x**2*(z + 1/x)**2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">repu</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Derivative</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
        <span class="n">repu</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
        <span class="n">reps</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>

    <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">repu</span><span class="p">)</span>


<div class="viewcode-block" id="dsolve"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.dsolve">[docs]</a><span class="k">def</span> <span class="nf">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves any (supported) kind of ordinary differential equation.</span>

<span class="sd">    **Usage**</span>

<span class="sd">        ``dsolve(eq, f(x), hint)`` -&gt; Solve ordinary differential equation</span>
<span class="sd">        ``eq`` for function ``f(x)``, using method ``hint``.</span>


<span class="sd">    **Details**</span>

<span class="sd">        ``eq`` can be any supported ordinary differential equation (see the</span>
<span class="sd">            :py:mod:`~sympy.solvers.ode` docstring for supported methods).</span>
<span class="sd">            This can either be an :py:class:`~sympy.core.relational.Equality`,</span>
<span class="sd">            or an expression, which is assumed to be equal to ``0``.</span>

<span class="sd">        ``f(x)`` is a function of one variable whose derivatives in that</span>
<span class="sd">            variable make up the ordinary differential equation ``eq``.  In</span>
<span class="sd">            many cases it is not necessary to provide this; it will be</span>
<span class="sd">            autodetected (and an error raised if it couldn&#39;t be detected).</span>

<span class="sd">        ``hint`` is the solving method that you want dsolve to use.  Use</span>
<span class="sd">            ``classify_ode(eq, f(x))`` to get all of the possible hints for an</span>
<span class="sd">            ODE.  The default hint, ``default``, will use whatever hint is</span>
<span class="sd">            returned first by :py:meth:`~sympy.solvers.ode.classify_ode`.  See</span>
<span class="sd">            Hints below for more options that you can use for hint.</span>

<span class="sd">        ``simplify`` enables simplification by</span>
<span class="sd">            :py:meth:`~sympy.solvers.ode.odesimp`.  See its docstring for more</span>
<span class="sd">            information.  Turn this off, for example, to disable solving of</span>
<span class="sd">            solutions for ``func`` or simplification of arbitrary constants.</span>
<span class="sd">            It will still integrate with this hint. Note that the solution may</span>
<span class="sd">            contain more arbitrary constants than the order of the ODE with</span>
<span class="sd">            this option enabled.</span>

<span class="sd">    **Hints**</span>

<span class="sd">        Aside from the various solving methods, there are also some meta-hints</span>
<span class="sd">        that you can pass to :py:meth:`~sympy.solvers.ode.dsolve`:</span>

<span class="sd">        ``default``:</span>
<span class="sd">                This uses whatever hint is returned first by</span>
<span class="sd">                :py:meth:`~sympy.solvers.ode.classify_ode`. This is the</span>
<span class="sd">                default argument to :py:meth:`~sympy.solvers.ode.dsolve`.</span>

<span class="sd">        ``all``:</span>
<span class="sd">                To make :py:meth:`~sympy.solvers.ode.dsolve` apply all</span>
<span class="sd">                relevant classification hints, use ``dsolve(ODE, func,</span>
<span class="sd">                hint=&quot;all&quot;)``.  This will return a dictionary of</span>
<span class="sd">                ``hint:solution`` terms.  If a hint causes dsolve to raise the</span>
<span class="sd">                ``NotImplementedError``, value of that hint&#39;s key will be the</span>
<span class="sd">                exception object raised.  The dictionary will also include</span>
<span class="sd">                some special keys:</span>

<span class="sd">                - ``order``: The order of the ODE.  See also</span>
<span class="sd">                  :py:meth:`~sympy.solvers.deutils.ode_order` in</span>
<span class="sd">                  ``deutils.py``.</span>
<span class="sd">                - ``best``: The simplest hint; what would be returned by</span>
<span class="sd">                  ``best`` below.</span>
<span class="sd">                - ``best_hint``: The hint that would produce the solution</span>
<span class="sd">                  given by ``best``.  If more than one hint produces the best</span>
<span class="sd">                  solution, the first one in the tuple returned by</span>
<span class="sd">                  :py:meth:`~sympy.solvers.ode.classify_ode` is chosen.</span>
<span class="sd">                - ``default``: The solution that would be returned by default.</span>
<span class="sd">                  This is the one produced by the hint that appears first in</span>
<span class="sd">                  the tuple returned by</span>
<span class="sd">                  :py:meth:`~sympy.solvers.ode.classify_ode`.</span>

<span class="sd">        ``all_Integral``:</span>
<span class="sd">                This is the same as ``all``, except if a hint also has a</span>
<span class="sd">                corresponding ``_Integral`` hint, it only returns the</span>
<span class="sd">                ``_Integral`` hint.  This is useful if ``all`` causes</span>
<span class="sd">                :py:meth:`~sympy.solvers.ode.dsolve` to hang because of a</span>
<span class="sd">                difficult or impossible integral.  This meta-hint will also be</span>
<span class="sd">                much faster than ``all``, because</span>
<span class="sd">                :py:meth:`~sympy.core.expr.Expr.integrate` is an expensive</span>
<span class="sd">                routine.</span>

<span class="sd">        ``best``:</span>
<span class="sd">                To have :py:meth:`~sympy.solvers.ode.dsolve` try all methods</span>
<span class="sd">                and return the simplest one.  This takes into account whether</span>
<span class="sd">                the solution is solvable in the function, whether it contains</span>
<span class="sd">                any Integral classes (i.e.  unevaluatable integrals), and</span>
<span class="sd">                which one is the shortest in size.</span>

<span class="sd">        See also the :py:meth:`~sympy.solvers.ode.classify_ode` docstring for</span>
<span class="sd">        more info on hints, and the :py:mod:`~sympy.solvers.ode` docstring for</span>
<span class="sd">        a list of all supported hints.</span>

<span class="sd">    **Tips**</span>

<span class="sd">        - You can declare the derivative of an unknown function this way:</span>

<span class="sd">            &gt;&gt;&gt; from sympy import Function, Derivative</span>
<span class="sd">            &gt;&gt;&gt; from sympy.abc import x # x is the independent variable</span>
<span class="sd">            &gt;&gt;&gt; f = Function(&quot;f&quot;)(x) # f is a function of x</span>
<span class="sd">            &gt;&gt;&gt; # f_ will be the derivative of f with respect to x</span>
<span class="sd">            &gt;&gt;&gt; f_ = Derivative(f, x)</span>

<span class="sd">        - See ``test_ode.py`` for many tests, which serves also as a set of</span>
<span class="sd">          examples for how to use :py:meth:`~sympy.solvers.ode.dsolve`.</span>
<span class="sd">        - :py:meth:`~sympy.solvers.ode.dsolve` always returns an</span>
<span class="sd">          :py:class:`~sympy.core.relational.Equality` class (except for the</span>
<span class="sd">          case when the hint is ``all`` or ``all_Integral``).  If possible, it</span>
<span class="sd">          solves the solution explicitly for the function being solved for.</span>
<span class="sd">          Otherwise, it returns an implicit solution.</span>
<span class="sd">        - Arbitrary constants are symbols named ``C1``, ``C2``, and so on.</span>
<span class="sd">        - Because all solutions should be mathematically equivalent, some</span>
<span class="sd">          hints may return the exact same result for an ODE. Often, though,</span>
<span class="sd">          two different hints will return the same solution formatted</span>
<span class="sd">          differently.  The two should be equivalent. Also note that sometimes</span>
<span class="sd">          the values of the arbitrary constants in two different solutions may</span>
<span class="sd">          not be the same, because one constant may have &quot;absorbed&quot; other</span>
<span class="sd">          constants into it.</span>
<span class="sd">        - Do ``help(ode.ode_&lt;hintname&gt;)`` to get help more information on a</span>
<span class="sd">          specific hint, where ``&lt;hintname&gt;`` is the name of a hint without</span>
<span class="sd">          ``_Integral``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq, Derivative, sin, cos</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(Derivative(f(x), x, x) + 9*f(x), f(x))</span>
<span class="sd">    f(x) == C1*sin(3*x) + C2*cos(3*x)</span>

<span class="sd">    &gt;&gt;&gt; eq = sin(x)*cos(f(x)) + cos(x)*sin(f(x))*f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, hint=&#39;separable_reduced&#39;)</span>
<span class="sd">    f(x) == C1/(C2*x - 1)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, hint=&#39;1st_exact&#39;)</span>
<span class="sd">    [f(x) == -acos(C1/cos(x)) + 2*pi, f(x) == acos(C1/cos(x))]</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, hint=&#39;almost_linear&#39;)</span>
<span class="sd">    [f(x) == -acos(-sqrt(C1/cos(x)**2)) + 2*pi, f(x) == -acos(sqrt(C1/cos(x)**2)) + 2*pi,</span>
<span class="sd">    f(x) == acos(-sqrt(C1/cos(x)**2)), f(x) == acos(sqrt(C1/cos(x)**2))]</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, hint=&#39;best&#39;)</span>
<span class="sd">    f(x) == C1/(C2*x - 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">given_hint</span> <span class="o">=</span> <span class="n">hint</span>  <span class="c"># hint given by the user</span>

    <span class="c"># See the docstring of _desolve for more details.</span>
    <span class="n">hints</span> <span class="o">=</span> <span class="n">_desolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
        <span class="n">hint</span><span class="o">=</span><span class="n">hint</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s">&#39;ode&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;eq&#39;</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span>
    <span class="n">all_</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">all_</span><span class="p">:</span>
        <span class="n">retdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">failed_hints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">gethints</span> <span class="o">=</span> <span class="n">classify_ode</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">orderedhints</span> <span class="o">=</span> <span class="n">gethints</span><span class="p">[</span><span class="s">&#39;ordered_hints&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">hint</span> <span class="ow">in</span> <span class="n">hints</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">_helper_simplify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">hints</span><span class="p">[</span><span class="n">hint</span><span class="p">],</span> <span class="n">simplify</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">,</span> <span class="n">detail</span><span class="p">:</span>
                <span class="n">failed_hints</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span> <span class="o">=</span> <span class="n">detail</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retdict</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span> <span class="o">=</span> <span class="n">rv</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">hints</span><span class="p">[</span><span class="n">hint</span><span class="p">][</span><span class="s">&#39;func&#39;</span><span class="p">]</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;best&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">retdict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">trysolving</span><span class="o">=</span><span class="ow">not</span> <span class="n">simplify</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">given_hint</span> <span class="o">==</span> <span class="s">&#39;best&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;best&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">orderedhints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;best&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">retdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;best_hint&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gethints</span><span class="p">[</span><span class="s">&#39;default&#39;</span><span class="p">]</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gethints</span><span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">]</span>
        <span class="n">retdict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">failed_hints</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">retdict</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c"># The key &#39;hint&#39; stores the hint needed to be solved for.</span>
        <span class="n">hint</span> <span class="o">=</span> <span class="n">hints</span><span class="p">[</span><span class="s">&#39;hint&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_helper_simplify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">hints</span><span class="p">,</span> <span class="n">simplify</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">_helper_simplify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Helper function of dsolve that calls the respective</span>
<span class="sd">    :py:mod:`~sympy.solvers.ode` functions to solve for the ordinary</span>
<span class="sd">    differential equations. This minimises the computation in calling</span>
<span class="sd">    :py:meth:`~sympy.solvers.deutils._desolve` multiple times.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>
    <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;_Integral&#39;</span><span class="p">):</span>
        <span class="n">solvefunc</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="s">&#39;ode_&#39;</span> <span class="o">+</span> <span class="n">hint</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s">&#39;_Integral&#39;</span><span class="p">)]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solvefunc</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="s">&#39;ode_&#39;</span> <span class="o">+</span> <span class="n">hint</span><span class="p">]</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;func&#39;</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">]</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">hint</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
        <span class="c"># odesimp() will attempt to integrate, if necessary, apply constantsimp(),</span>
        <span class="c"># attempt to solve for func, and apply any other hint specific</span>
        <span class="c"># simplifications</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">odesimp</span><span class="p">(</span><span class="n">solvefunc</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">),</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># We still want to integrate (you can disable it separately with the hint)</span>
        <span class="n">match</span><span class="p">[</span><span class="s">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># Some hints can take advantage of this option</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="n">_handle_Integral</span><span class="p">(</span><span class="n">solvefunc</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">),</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rv</span>

<div class="viewcode-block" id="classify_ode"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.classify_ode">[docs]</a><span class="k">def</span> <span class="nf">classify_ode</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Returns a tuple of possible :py:meth:`~sympy.solvers.ode.dsolve`</span>
<span class="sd">    classifications for an ODE.</span>

<span class="sd">    The tuple is ordered so that first item is the classification that</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve` uses to solve the ODE by default.  In</span>
<span class="sd">    general, classifications at the near the beginning of the list will</span>
<span class="sd">    produce better solutions faster than those near the end, thought there are</span>
<span class="sd">    always exceptions.  To make :py:meth:`~sympy.solvers.ode.dsolve` use a</span>
<span class="sd">    different classification, use ``dsolve(ODE, func,</span>
<span class="sd">    hint=&lt;classification&gt;)``.  See also the</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve` docstring for different meta-hints</span>
<span class="sd">    you can use.</span>

<span class="sd">    If ``dict`` is true, :py:meth:`~sympy.solvers.ode.classify_ode` will</span>
<span class="sd">    return a dictionary of ``hint:match`` expression terms. This is intended</span>
<span class="sd">    for internal use by :py:meth:`~sympy.solvers.ode.dsolve`.  Note that</span>
<span class="sd">    because dictionaries are ordered arbitrarily, this will most likely not be</span>
<span class="sd">    in the same order as the tuple.</span>

<span class="sd">    You can get help on different hints by executing</span>
<span class="sd">    ``help(ode.ode_hintname)``, where ``hintname`` is the name of the hint</span>
<span class="sd">    without ``_Integral``.</span>

<span class="sd">    See :py:data:`~sympy.solvers.ode.allhints` or the</span>
<span class="sd">    :py:mod:`~sympy.solvers.ode` docstring for a list of all supported hints</span>
<span class="sd">    that can be returned from :py:meth:`~sympy.solvers.ode.classify_ode`.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    These are remarks on hint names.</span>

<span class="sd">    ``_Integral``</span>

<span class="sd">        If a classification has ``_Integral`` at the end, it will return the</span>
<span class="sd">        expression with an unevaluated :py:class:`~sympy.integrals.Integral`</span>
<span class="sd">        class in it.  Note that a hint may do this anyway if</span>
<span class="sd">        :py:meth:`~sympy.core.expr.Expr.integrate` cannot do the integral,</span>
<span class="sd">        though just using an ``_Integral`` will do so much faster.  Indeed, an</span>
<span class="sd">        ``_Integral`` hint will always be faster than its corresponding hint</span>
<span class="sd">        without ``_Integral`` because</span>
<span class="sd">        :py:meth:`~sympy.core.expr.Expr.integrate` is an expensive routine.</span>
<span class="sd">        If :py:meth:`~sympy.solvers.ode.dsolve` hangs, it is probably because</span>
<span class="sd">        :py:meth:`~sympy.core.expr.Expr.integrate` is hanging on a tough or</span>
<span class="sd">        impossible integral.  Try using an ``_Integral`` hint or</span>
<span class="sd">        ``all_Integral`` to get it return something.</span>

<span class="sd">        Note that some hints do not have ``_Integral`` counterparts.  This is</span>
<span class="sd">        because :py:meth:`~sympy.solvers.ode.integrate` is not used in solving</span>
<span class="sd">        the ODE for those method. For example, `n`\th order linear homogeneous</span>
<span class="sd">        ODEs with constant coefficients do not require integration to solve,</span>
<span class="sd">        so there is no ``nth_linear_homogeneous_constant_coeff_Integrate``</span>
<span class="sd">        hint. You can easily evaluate any unevaluated</span>
<span class="sd">        :py:class:`~sympy.integrals.Integral`\s in an expression by doing</span>
<span class="sd">        ``expr.doit()``.</span>

<span class="sd">    Ordinals</span>

<span class="sd">        Some hints contain an ordinal such as ``1st_linear``.  This is to help</span>
<span class="sd">        differentiate them from other hints, as well as from other methods</span>
<span class="sd">        that may not be implemented yet. If a hint has ``nth`` in it, such as</span>
<span class="sd">        the ``nth_linear`` hints, this means that the method used to applies</span>
<span class="sd">        to ODEs of any order.</span>

<span class="sd">    ``indep`` and ``dep``</span>

<span class="sd">        Some hints contain the words ``indep`` or ``dep``.  These reference</span>
<span class="sd">        the independent variable and the dependent function, respectively. For</span>
<span class="sd">        example, if an ODE is in terms of `f(x)`, then ``indep`` will refer to</span>
<span class="sd">        `x` and ``dep`` will refer to `f`.</span>

<span class="sd">    ``subs``</span>

<span class="sd">        If a hints has the word ``subs`` in it, it means the the ODE is solved</span>
<span class="sd">        by substituting the expression given after the word ``subs`` for a</span>
<span class="sd">        single dummy variable.  This is usually in terms of ``indep`` and</span>
<span class="sd">        ``dep`` as above.  The substituted expression will be written only in</span>
<span class="sd">        characters allowed for names of Python objects, meaning operators will</span>
<span class="sd">        be spelled out.  For example, ``indep``/``dep`` will be written as</span>
<span class="sd">        ``indep_div_dep``.</span>

<span class="sd">    ``coeff``</span>

<span class="sd">        The word ``coeff`` in a hint refers to the coefficients of something</span>
<span class="sd">        in the ODE, usually of the derivative terms.  See the docstring for</span>
<span class="sd">        the individual methods for more info (``help(ode)``).  This is</span>
<span class="sd">        contrast to ``coefficients``, as in ``undetermined_coefficients``,</span>
<span class="sd">        which refers to the common name of a method.</span>

<span class="sd">    ``_best``</span>

<span class="sd">        Methods that have more than one fundamental way to solve will have a</span>
<span class="sd">        hint for each sub-method and a ``_best`` meta-classification. This</span>
<span class="sd">        will evaluate all hints and return the best, using the same</span>
<span class="sd">        considerations as the normal ``best`` meta-hint.</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, classify_ode, Eq</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; classify_ode(Eq(f(x).diff(x), 0), f(x))</span>
<span class="sd">    (&#39;separable&#39;, &#39;1st_linear&#39;, &#39;1st_homogeneous_coeff_best&#39;,</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;,</span>
<span class="sd">    &#39;nth_linear_constant_coeff_homogeneous&#39;, &#39;separable_Integral&#39;,</span>
<span class="sd">    &#39;1st_linear_Integral&#39;,</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="sd">    &#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;)</span>
<span class="sd">    &gt;&gt;&gt; classify_ode(f(x).diff(x, 2) + 3*f(x).diff(x) + 2*f(x) - 4)</span>
<span class="sd">    (&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;,</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters&#39;,</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prep</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;prep&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">expand</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;dsolve() and classify_ode() only &quot;</span>
        <span class="s">&quot;work with functions of one variable, not </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prep</span> <span class="ow">or</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">func_</span> <span class="o">=</span> <span class="n">_preprocess</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">func_</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">classify_ode</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">prep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">ode_order</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="c"># hint:matchdict or hint:(tuple of matchdicts)</span>
    <span class="c"># Also will contain &quot;default&quot;:&lt;default hint&gt; and &quot;order&quot;:order items.</span>
    <span class="n">matching_hints</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;order&quot;</span><span class="p">:</span> <span class="n">order</span><span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;default&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">matching_hints</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">df</span><span class="p">])</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;k&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">df</span><span class="p">])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;c1&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a2&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">])</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;b2&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">])</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;c2&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">])</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;d2&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">])</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="c"># Precondition to try remove f(x) from highest order derivative</span>
    <span class="n">reduced_eq</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">deriv_coef</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">deriv_coef</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">deriv_coef</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">c1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">c1</span><span class="p">]:</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">r</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span>
                <span class="n">reduced_eq</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">arg</span><span class="o">/</span><span class="n">den</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reduced_eq</span><span class="p">:</span>
        <span class="n">reduced_eq</span> <span class="o">=</span> <span class="n">eq</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c">## Linear case: a(x)*y&#39;+b(x)*y+c(x) == 0</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">reduced_eq</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="p">(</span><span class="n">reduced_eq</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="p">[</span><span class="n">tmp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="n">dep</span><span class="p">]]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">dep</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
             <span class="n">b</span><span class="p">:</span> <span class="n">dep</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
             <span class="n">c</span><span class="p">:</span> <span class="n">ind</span><span class="p">}</span>
        <span class="c"># double check f[a] since the preconditioning may have failed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span> <span class="o">-</span> <span class="n">reduced_eq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_linear&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_linear_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c">## Bernoulli case: a(x)*y&#39;+b(x)*y+c(x)*y**n == 0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span>
            <span class="n">reduced_eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># See issue 1577</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Bernoulli&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Bernoulli_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c">## Riccati special n == -2 case: a2*y&#39;+b2*y**2+c2*y/x+d2/x**2 == 0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">reduced_eq</span><span class="p">,</span>
            <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a2</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">b2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">d2</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">b2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">r</span><span class="p">[</span><span class="n">d2</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;a2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;b2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b2</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;c2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;d2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span>
            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Riccati_special_minus2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c"># NON-REDUCED FORM OF EQUATION matches</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">e</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>

            <span class="c">## Exact Differential Equation: P(x, y) + Q(x, y)*y&#39; = 0 where</span>
            <span class="c"># dP/dy == dQ/dx</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">numerator</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="c"># The following few conditions try to convert a non-exact</span>
                    <span class="c"># differential equation into an exact one.</span>
                    <span class="c"># References : Differential equations with applications</span>
                    <span class="c"># and historical notes - George E. Simmons</span>

                    <span class="k">if</span> <span class="n">numerator</span><span class="p">:</span>
                        <span class="c"># If (dP/dy - dQ/dx) / Q = f(x)</span>
                        <span class="c"># then exp(integral(f(x))*equation becomes exact</span>
                        <span class="n">factor</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">numerator</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
                        <span class="n">variables</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">free_symbols</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">==</span> <span class="n">variables</span><span class="o">.</span><span class="n">pop</span><span class="p">():</span>
                            <span class="n">factor</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
                            <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
                            <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
                            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c"># If (dP/dy - dQ/dx) / -P = f(y)</span>
                            <span class="c"># then exp(integral(f(y))*equation becomes exact</span>
                            <span class="n">factor</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="o">-</span><span class="n">numerator</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                            <span class="n">variables</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">free_symbols</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="n">variables</span><span class="o">.</span><span class="n">pop</span><span class="p">():</span>
                                <span class="n">factor</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
                                <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
                                <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">*=</span> <span class="n">factor</span>
                                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="c"># Differentiating the coefficients might fail because of things</span>
                <span class="c"># like f(2*x).diff(x).  See issue 1525 and issue 1620.</span>
                <span class="k">pass</span>

        <span class="c"># This match is used for several cases below; we now collect on</span>
        <span class="c"># f(x) so the matching works.</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">reduced_eq</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="c"># Using r[d] and r[e] without any modification for hints</span>
            <span class="c"># linear-coefficients and separable-reduced.</span>
            <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>  <span class="c"># ODE = d/e + df</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">den</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>

            <span class="c">## Separable Case: y&#39; == P(y)*Q(x)</span>
            <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="c"># m1[coeff]*m1[x]*m1[y] + m2[coeff]*m2[x]*m2[y]*y&#39;</span>
            <span class="n">m1</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="n">m2</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">m1</span> <span class="ow">and</span> <span class="n">m2</span><span class="p">:</span>
                <span class="n">r1</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;m1&#39;</span><span class="p">:</span> <span class="n">m1</span><span class="p">,</span> <span class="s">&#39;m2&#39;</span><span class="p">:</span> <span class="n">m2</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;separable&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;separable_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span>

            <span class="c">## First order equation with homogeneous coefficients:</span>
            <span class="c"># dy/dx == F(y/x) or dy/dx == F(x/y)</span>
            <span class="n">ordera</span> <span class="o">=</span> <span class="n">homogeneous_order</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ordera</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">orderb</span> <span class="o">=</span> <span class="n">homogeneous_order</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ordera</span> <span class="o">==</span> <span class="n">orderb</span><span class="p">:</span>
                    <span class="c"># u1=y/x and u2=x/y</span>
                    <span class="n">u1</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u1&#39;</span><span class="p">)</span>
                    <span class="n">u2</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u2&#39;</span><span class="p">)</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;1st_homogeneous_coeff_subs&quot;</span>
                    <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;_dep_div_indep&quot;</span>
                    <span class="n">s2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;_indep_div_dep&quot;</span>
                    <span class="k">if</span> <span class="n">simplify</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="n">u1</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">u1</span><span class="p">}))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="n">s1</span> <span class="o">+</span> <span class="s">&quot;_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">simplify</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+</span> <span class="n">u2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">u2</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">}))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="n">s2</span> <span class="o">+</span> <span class="s">&quot;_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">matching_hints</span> <span class="ow">and</span> <span class="n">s2</span> <span class="ow">in</span> <span class="n">matching_hints</span><span class="p">:</span>
                        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;1st_homogeneous_coeff_best&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

            <span class="c">## Linear coefficients of the form</span>
            <span class="c"># y&#39;+ F((a*x + b*y + c)/(a&#39;*x + b&#39;y + c&#39;)) = 0</span>
            <span class="c"># that can be reduced to homogeneous form.</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">num</span><span class="o">/</span><span class="n">den</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">_linear_coeff_match</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
                <span class="n">xarg</span><span class="p">,</span> <span class="n">yarg</span> <span class="o">=</span> <span class="n">params</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
                <span class="c"># Dummy substitution for df and f(x).</span>
                <span class="n">dummy_eq</span> <span class="o">=</span> <span class="n">reduced_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(((</span><span class="n">df</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">u</span><span class="p">)))</span>
                <span class="n">reps</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xarg</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span> <span class="o">+</span> <span class="n">yarg</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">df</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
                <span class="n">dummy_eq</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">dummy_eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
                <span class="c"># get the re-cast values for e and d</span>
                <span class="n">r2</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">dummy_eq</span><span class="p">),</span> <span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">r2</span><span class="p">:</span>
                    <span class="n">orderd</span> <span class="o">=</span> <span class="n">homogeneous_order</span><span class="p">(</span><span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">orderd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">ordere</span> <span class="o">=</span> <span class="n">homogeneous_order</span><span class="p">(</span><span class="n">r2</span><span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">orderd</span> <span class="o">==</span> <span class="n">ordere</span><span class="p">:</span>
                            <span class="c"># Match arguments are passed in such a way that it</span>
                            <span class="c"># is coherent with the already existing homogeneous</span>
                            <span class="c"># functions.</span>
                            <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">r2</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">r2</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;xarg&#39;</span><span class="p">:</span> <span class="n">xarg</span><span class="p">,</span> <span class="s">&#39;yarg&#39;</span><span class="p">:</span> <span class="n">yarg</span><span class="p">,</span>
                                <span class="s">&#39;d&#39;</span><span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">})</span>
                            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;linear_coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>
                            <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;linear_coefficients_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>

            <span class="c">## Equation of the form y&#39; + (y/x)*H(x^n*y) = 0</span>
            <span class="c"># that can be reduced to separable form</span>

            <span class="n">factor</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">)</span>

            <span class="c"># Try representing factor in terms of x^n*y</span>
            <span class="c"># where n is lowest power of x in factor;</span>
            <span class="c"># first remove terms like sqrt(2)*3 from factor.atoms(Mul)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">mul</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">mul</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">mul</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">u</span> <span class="ow">and</span> <span class="n">u</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
                <span class="n">r2</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;t&#39;</span><span class="p">:</span> <span class="n">t</span><span class="p">}</span>
                <span class="n">xpart</span><span class="p">,</span> <span class="n">ypart</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">test</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">subs</span><span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">u</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">t</span><span class="p">)))</span>
                <span class="n">free</span> <span class="o">=</span> <span class="n">test</span><span class="o">.</span><span class="n">free_symbols</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">free</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">r2</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;power&#39;</span><span class="p">:</span> <span class="n">xpart</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;u&#39;</span><span class="p">:</span> <span class="n">test</span><span class="p">})</span>
                    <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;separable_reduced&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>
                    <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;separable_reduced_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>

        <span class="c">## Almost-linear equation of the form f(x)*g(y)*y&#39; + k(x)*l(y) + m(x) = 0</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">r2</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">r2</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c"># Separate the terms having f(x) to r[d] and</span>
                <span class="c"># remaining to r[c]</span>
                <span class="n">no_f</span><span class="p">,</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="n">no_f</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">factor</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">factor</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">as_Add</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">r2</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="n">e</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">:</span> <span class="n">d</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">:</span> <span class="n">c</span><span class="p">,</span> <span class="s">&#39;u&#39;</span><span class="p">:</span> <span class="n">u</span><span class="p">})</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">/=</span> <span class="n">u</span>
                <span class="n">r2</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">/=</span> <span class="n">u</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;almost_linear&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;almost_linear_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c"># Liouville ODE in the form</span>
        <span class="c"># f(x).diff(x, 2) + g(f(x))*(f(x).diff(x))**2 + h(x)*f(x).diff(x)</span>
        <span class="c"># See Goldstein and Braun, &quot;Advanced Methods for the Solution of</span>
        <span class="c"># Differential Equations&quot;, pg. 98</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">d</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">df</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">df</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">reduced_eq</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">or</span> <span class="n">g</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;g&#39;</span><span class="p">:</span> <span class="n">g</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">:</span> <span class="n">h</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Liouville&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;Liouville_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c"># nth order linear ODE</span>
        <span class="c"># a_n(x)y^(n) + ... + a_1(x)y&#39; + a_0(x)y = F(x) = b</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">_nth_linear_match</span><span class="p">(</span><span class="n">reduced_eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

        <span class="c"># Constant coefficient case (a_i is constant for all i)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c"># Inhomogeneous case: F(x) is not identically 0</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">undetcoeff</span> <span class="o">=</span> <span class="n">_undetermined_coefficients_match</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;nth_linear_constant_coeff_variation_of_parameters&quot;</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="n">s</span> <span class="o">+</span> <span class="s">&quot;_Integral&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">if</span> <span class="n">undetcoeff</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]:</span>
                    <span class="n">r</span><span class="p">[</span><span class="s">&#39;trialset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">undetcoeff</span><span class="p">[</span><span class="s">&#39;trialset&#39;</span><span class="p">]</span>
                    <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;nth_linear_constant_coeff_undetermined_&quot;</span>
                        <span class="s">&quot;coefficients&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
            <span class="c"># Homogeneous case: F(x) is identically 0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;nth_linear_constant_coeff_homogeneous&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c"># Euler equation case (a_i * x**i for all i)</span>
        <span class="k">def</span> <span class="nf">_test_term</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
            <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">            Linear Euler ODEs have the form  K*x**order*diff(y(x),x,order),</span>
<span class="sd">            where K is independent of x and y(x), order&gt;= 0.</span>
<span class="sd">            So we need to check that for each term, coeff == K*x**order from</span>
<span class="sd">            some K.  We have a few cases, since coeff may have several</span>
<span class="sd">            different types.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="n">order</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="n">order</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">args</span>
            <span class="k">elif</span> <span class="n">coeff</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coeff</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">coeff</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">_test_term</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;nth_linear_euler_eq_homogeneous&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="c"># Order keys based on allhints.</span>
    <span class="n">retlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">allhints</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matching_hints</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c"># Dictionaries are ordered arbitrarily, so make note of which</span>
        <span class="c"># hint would come first for dsolve().  Use an ordered dict in Py 3.</span>
        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;default&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">retlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">retlist</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="n">matching_hints</span><span class="p">[</span><span class="s">&quot;ordered_hints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">retlist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">matching_hints</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">retlist</span><span class="p">)</span>
</div>
<span class="nd">@vectorize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<div class="viewcode-block" id="odesimp"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.odesimp">[docs]</a><span class="k">def</span> <span class="nf">odesimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Simplifies ODEs, including trying to solve for ``func`` and running</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.constantsimp`.</span>

<span class="sd">    It may use knowledge of the type of solution that the hint returns to</span>
<span class="sd">    apply additional simplifications.</span>

<span class="sd">    It also attempts to integrate any :py:class:`~sympy.integrals.Integral`\s</span>
<span class="sd">    in the expression, if the hint is not an ``_Integral`` hint.</span>

<span class="sd">    This function should have no effect on expressions returned by</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve`, as</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve` already calls</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.odesimp`, but the individual hint functions</span>
<span class="sd">    do not call :py:meth:`~sympy.solvers.ode.odesimp` (because the</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve` wrapper does).  Therefore, this</span>
<span class="sd">    function is designed for mainly internal use.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sin, symbols, dsolve, pprint, Function</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import odesimp</span>
<span class="sd">    &gt;&gt;&gt; x , u2, C1= symbols(&#39;x,u2,C1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    &gt;&gt;&gt; eq = dsolve(x*f(x).diff(x) - f(x) - x*sin(f(x)/x), f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="sd">    ... simplify=False)</span>
<span class="sd">    &gt;&gt;&gt; pprint(eq, wrap_line=False)</span>
<span class="sd">                            x</span>
<span class="sd">                           ----</span>
<span class="sd">                           f(x)</span>
<span class="sd">                             /</span>
<span class="sd">                            |</span>
<span class="sd">                            |   /        1   \</span>
<span class="sd">                            |  -|u2 + -------|</span>
<span class="sd">                            |   |        /1 \|</span>
<span class="sd">                            |   |     sin|--||</span>
<span class="sd">                            |   \        \u2//</span>
<span class="sd">    log(f(x)) = log(C1) +   |  ---------------- d(u2)</span>
<span class="sd">                            |          2</span>
<span class="sd">                            |        u2</span>
<span class="sd">                            |</span>
<span class="sd">                           /</span>

<span class="sd">    &gt;&gt;&gt; pprint(odesimp(eq, f(x), 1,</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span>
<span class="sd">    ... )) #doctest: +SKIP</span>
<span class="sd">        x</span>
<span class="sd">    --------- = C1</span>
<span class="sd">       /f(x)\</span>
<span class="sd">    tan|----|</span>
<span class="sd">       \2*x /</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>

    <span class="c"># First, integrate if the hint allows it.</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">_handle_Integral</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Equality</span><span class="p">)</span>

    <span class="c"># Second, clean up the arbitrary constants.</span>
    <span class="c"># Right now, nth linear hints can put as many as 2*order constants in an</span>
    <span class="c"># expression.  If that number grows with another hint, the third argument</span>
    <span class="c"># here should be raised accordingly, or constantsimp() rewritten to handle</span>
    <span class="c"># an arbitrary number of constants.</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">)</span>

    <span class="c"># Lastly, now that we have cleaned up the expression, try solving for func.</span>
    <span class="c"># When RootOf is implemented in solve(), we will want to return a RootOf</span>
    <span class="c"># everytime instead of an Equality.</span>

    <span class="c"># Get the f(x) on the left if possible.</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span><span class="p">)]</span>

    <span class="c"># make sure we are working with lists of solutions in simplified form.</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="c"># The solution is already solved</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq</span><span class="p">]</span>

        <span class="c"># special simplification of the rhs</span>
        <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;nth_linear_constant_coeff&quot;</span><span class="p">):</span>
            <span class="c"># Collect terms to make the solution look nice.</span>
            <span class="c"># This is also necessary for constantsimp to remove unnecessary</span>
            <span class="c"># terms from the particular solution from variation of parameters</span>
            <span class="k">global</span> <span class="n">collectterms</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rhs</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">collectterms</span>
            <span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sol</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c"># The solution is not solved, so try to solve it</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">eqsol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">eqsol</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">,</span> <span class="n">PolynomialError</span><span class="p">):</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">eq</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">denom</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">expr</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># XXX: the rest of odesimp() expects each ``t`` to be in a</span>
            <span class="c"># specific normal form: rational expression with numerator</span>
            <span class="c"># expanded, but with combined exponential functions (at</span>
            <span class="c"># least in this setup all tests pass).</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">_expand</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">eqsol</span><span class="p">]</span>

        <span class="c"># special simplification of the lhs.</span>
        <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;1st_homogeneous_coeff&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">eqi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
                <span class="n">newi</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">eqi</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newi</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span> <span class="ow">and</span> <span class="n">newi</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">newi</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">newi</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span>
                <span class="n">eq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">newi</span>

    <span class="c"># We cleaned up the costants before solving to help the solve engine with</span>
    <span class="c"># a simpler expression, but the solved expression could have introduced</span>
    <span class="c"># things like -C1, so rerun constantsimp() one last time before returning.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eqi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="n">eqi</span> <span class="o">=</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">eqi</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">)</span>
        <span class="n">eq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">constant_renumber</span><span class="p">(</span><span class="n">eqi</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">order</span><span class="p">)</span>

    <span class="c"># If there is only 1 solution, return it;</span>
    <span class="c"># otherwise return the list of solutions.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">eq</span>
</div>
<div class="viewcode-block" id="checkodesol"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.checkodesol">[docs]</a><span class="k">def</span> <span class="nf">checkodesol</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span> <span class="n">solve_for_func</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Substitutes ``sol`` into ``ode`` and checks that the result is ``0``.</span>

<span class="sd">    This only works when ``func`` is one function, like `f(x)`.  ``sol`` can</span>
<span class="sd">    be a single solution or a list of solutions.  Each solution may be an</span>
<span class="sd">    :py:class:`~sympy.core.relational.Equality` that the solution satisfies,</span>
<span class="sd">    e.g. ``Eq(f(x), C1), Eq(f(x) + C1, 0)``; or simply an</span>
<span class="sd">    :py:class:`~sympy.core.expr.Expr`, e.g. ``f(x) - C1``. In most cases it</span>
<span class="sd">    will not be necessary to explicitly identify the function, but if the</span>
<span class="sd">    function cannot be inferred from the original equation it can be supplied</span>
<span class="sd">    through the ``func`` argument.</span>

<span class="sd">    If a sequence of solutions is passed, the same sort of container will be</span>
<span class="sd">    used to return the result for each solution.</span>

<span class="sd">    It tries the following methods, in order, until it finds zero equivalence:</span>

<span class="sd">    1. Substitute the solution for `f` in the original equation.  This only</span>
<span class="sd">       works if ``ode`` is solved for `f`.  It will attempt to solve it first</span>
<span class="sd">       unless ``solve_for_func == False``.</span>
<span class="sd">    2. Take `n` derivatives of the solution, where `n` is the order of</span>
<span class="sd">       ``ode``, and check to see if that is equal to the solution.  This only</span>
<span class="sd">       works on exact ODEs.</span>
<span class="sd">    3. Take the 1st, 2nd, ..., `n`\th derivatives of the solution, each time</span>
<span class="sd">       solving for the derivative of `f` of that order (this will always be</span>
<span class="sd">       possible because `f` is a linear operator). Then back substitute each</span>
<span class="sd">       derivative into ``ode`` in reverse order.</span>

<span class="sd">    This function returns a tuple.  The first item in the tuple is ``True`` if</span>
<span class="sd">    the substitution results in ``0``, and ``False`` otherwise. The second</span>
<span class="sd">    item in the tuple is what the substitution results in.  It should always</span>
<span class="sd">    be ``0`` if the first item is ``True``. Note that sometimes this function</span>
<span class="sd">    will ``False``, but with an expression that is identically equal to ``0``,</span>
<span class="sd">    instead of returning ``True``.  This is because</span>
<span class="sd">    :py:meth:`~sympy.simplify.simplify.simplify` cannot reduce the expression</span>
<span class="sd">    to ``0``.  If an expression returned by this function vanishes</span>
<span class="sd">    identically, then ``sol`` really is a solution to ``ode``.</span>

<span class="sd">    If this function seems to hang, it is probably because of a hard</span>
<span class="sd">    simplification.</span>

<span class="sd">    To use this function to test, test the first item of the tuple.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Eq, Function, checkodesol, symbols</span>
<span class="sd">    &gt;&gt;&gt; x, C1 = symbols(&#39;x,C1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; checkodesol(f(x).diff(x), Eq(f(x), C1))</span>
<span class="sd">    (True, 0)</span>
<span class="sd">    &gt;&gt;&gt; assert checkodesol(f(x).diff(x), C1)[0]</span>
<span class="sd">    &gt;&gt;&gt; assert not checkodesol(f(x).diff(x), x)[0]</span>
<span class="sd">    &gt;&gt;&gt; checkodesol(f(x).diff(x, 2), x**2)</span>
<span class="sd">    (False, 2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">ode</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">_preprocess</span><span class="p">(</span><span class="n">ode</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">AppliedUndef</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">sol</span> <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">sol</span><span class="p">])]</span>
            <span class="n">funcs</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;must pass func arg to checkodesol for this case.&#39;</span><span class="p">)</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">funcs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="c"># ========== deprecation handling</span>
    <span class="c"># After the deprecation period this handling section becomes:</span>
    <span class="c"># ----------</span>
    <span class="c"># if not is_unfunc(func) or len(func.args) != 1:</span>
    <span class="c">#     raise ValueError(</span>
    <span class="c">#         &quot;func must be a function of one variable, not %s&quot; % func)</span>
    <span class="c"># ----------</span>
    <span class="c"># assume, during deprecation, that sol and func are reversed</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;If you really do want sol to be just </span><span class="si">%s</span><span class="s">, use Eq(</span><span class="si">%s</span><span class="s">, 0) &quot;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;instead.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="n">SymPyDeprecationWarning</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">feature</span><span class="o">=</span><span class="s">&quot;The order of the &quot;</span>
            <span class="s">&quot;arguments sol and func to checkodesol()&quot;</span><span class="p">,</span>
            <span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;checkodesol(ode, sol, func)&quot;</span><span class="p">,</span> <span class="n">issue</span><span class="o">=</span><span class="mi">3384</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
        <span class="n">sol</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="p">,</span> <span class="n">sol</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">filldedent</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">        func (or sol, during deprecation) must be a function</span>
<span class="s">        of one variable. Got sol = </span><span class="si">%s</span><span class="s">, func = </span><span class="si">%s</span><span class="s">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="p">)))</span>
    <span class="c"># ========== end of deprecation handling</span>
    <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">sol</span><span class="p">)(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">solve_for_func</span><span class="o">=</span><span class="n">solve_for_func</span><span class="p">),</span> <span class="n">sol</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">testnum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">ode_order</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">solve_for_func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">)):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">solved</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">solved</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">solved</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="n">Eq</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">solved</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">solve_for_func</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">ode</span><span class="p">,</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">solved</span><span class="p">],</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">solve_for_func</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">result</span>

    <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">testnum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># First pass, try substituting a solved solution directly into the</span>
            <span class="c"># ODE. This has the highest chance of succeeding.</span>
            <span class="n">ode_diff</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">ode</span><span class="o">.</span><span class="n">rhs</span>

            <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">ode_diff</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">ode_diff</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ss</span><span class="p">:</span>
                <span class="c"># with the new numer_denom in power.py, if we do a simple</span>
                <span class="c"># expansion then testnum == 0 verifies all solutions.</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">testnum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Second pass. If we cannot substitute f, try seeing if the nth</span>
            <span class="c"># derivative is equal, this will only work for odes that are exact,</span>
            <span class="c"># by definition.</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span>
                <span class="n">trigsimp</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span> <span class="o">-</span> <span class="n">diff</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span> <span class="o">-</span>
                <span class="n">trigsimp</span><span class="p">(</span><span class="n">ode</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span> <span class="o">+</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">ode</span><span class="o">.</span><span class="n">rhs</span><span class="p">))</span>
            <span class="c"># s2 = simplify(</span>
            <span class="c">#     diff(sol.lhs, x, order) - diff(sol.rhs, x, order) - \</span>
            <span class="c">#     ode.lhs + ode.rhs)</span>
            <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">testnum</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># Third pass. Try solving for df/dx and substituting that into the</span>
            <span class="c"># ODE. Thanks to Chris Smith for suggesting this method.  Many of</span>
            <span class="c"># the comments below are his too.</span>
            <span class="c"># The method:</span>
            <span class="c"># - Take each of 1..n derivatives of the solution.</span>
            <span class="c"># - Solve each nth derivative for d^(n)f/dx^(n)</span>
            <span class="c">#   (the differential of that order)</span>
            <span class="c"># - Back substitute into the ODE in decreasing order</span>
            <span class="c">#   (i.e., n, n-1, ...)</span>
            <span class="c"># - Check the result for zero equivalence</span>
            <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">diffsols</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="p">}</span>
            <span class="k">elif</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">diffsols</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diffsols</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c"># Differentiation is a linear operator, so there should always</span>
                <span class="c"># be 1 solution. Nonetheless, we test just to make sure.</span>
                <span class="c"># We only need to solve once.  After that, we automatically</span>
                <span class="c"># have the solution to the differential in the order we want.</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ds</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">sdf</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">sdf</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># This is what the solution says df/dx should be.</span>
                    <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="c"># Make sure the above didn&#39;t fail.</span>
            <span class="k">if</span> <span class="n">testnum</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Substitute it into ODE to check for self consistency.</span>
                <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">ode</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">ode</span><span class="o">.</span><span class="n">rhs</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">diffsols</span><span class="p">:</span>
                        <span class="c"># We can only substitute f(x) if the solution was</span>
                        <span class="c"># solved for f(x).</span>
                        <span class="k">break</span>
                    <span class="n">lhs</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">diffsols</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">ode_or_bool</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
                    <span class="n">ode_or_bool</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">ode_or_bool</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ode_or_bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ode_or_bool</span><span class="p">:</span>
                            <span class="n">lhs</span> <span class="o">=</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lhs</span> <span class="o">=</span> <span class="n">ode_or_bool</span><span class="o">.</span><span class="n">lhs</span>
                        <span class="n">rhs</span> <span class="o">=</span> <span class="n">ode_or_bool</span><span class="o">.</span><span class="n">rhs</span>
                <span class="c"># No sense in overworking simplify -- just prove that the</span>
                <span class="c"># numerator goes to zero</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">((</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="c"># since solutions are obtained using force=True we test</span>
                <span class="c"># using the same level of assumptions</span>
                <span class="c">## replace function with dummy so assumptions will work</span>
                <span class="n">_func</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;func&#39;</span><span class="p">)</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">_func</span><span class="p">)</span>
                <span class="c">## posify the expression</span>
                <span class="n">num</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">num</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">_func</span><span class="p">:</span> <span class="n">func</span><span class="p">})</span>
                <span class="n">testnum</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">s</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>  <span class="c"># The code above never was able to change s</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Unable to test if &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span> <span class="o">+</span>
            <span class="s">&quot; is a solution to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ode</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_sol_simplicity"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_sol_simplicity">[docs]</a><span class="k">def</span> <span class="nf">ode_sol_simplicity</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">trysolving</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Returns an extended integer representing how simple a solution to an ODE</span>
<span class="sd">    is.</span>

<span class="sd">    The following things are considered, in order from most simple to least:</span>

<span class="sd">    - ``sol`` is solved for ``func``.</span>
<span class="sd">    - ``sol`` is not solved for ``func``, but can be if passed to solve (e.g.,</span>
<span class="sd">      a solution returned by ``dsolve(ode, func, simplify=False``).</span>
<span class="sd">    - If ``sol`` is not solved for ``func``, then base the result on the</span>
<span class="sd">      length of ``sol``, as computed by ``len(str(sol))``.</span>
<span class="sd">    - If ``sol`` has any unevaluated :py:class:`~sympy.integrals.Integral`\s,</span>
<span class="sd">      this will automatically be considered less simple than any of the above.</span>

<span class="sd">    This function returns an integer such that if solution A is simpler than</span>
<span class="sd">    solution B by above metric, then ``ode_sol_simplicity(sola, func) &lt;</span>
<span class="sd">    ode_sol_simplicity(solb, func)``.</span>

<span class="sd">    Currently, the following are the numbers returned, but if the heuristic is</span>
<span class="sd">    ever improved, this may change.  Only the ordering is guaranteed.</span>

<span class="sd">    +----------------------------------------------+-------------------+</span>
<span class="sd">    | Simplicity                                   | Return            |</span>
<span class="sd">    +==============================================+===================+</span>
<span class="sd">    | ``sol`` solved for ``func``                  | ``-2``            |</span>
<span class="sd">    +----------------------------------------------+-------------------+</span>
<span class="sd">    | ``sol`` not solved for ``func`` but can be   | ``-1``            |</span>
<span class="sd">    +----------------------------------------------+-------------------+</span>
<span class="sd">    | ``sol`` is not solved nor solvable for       | ``len(str(sol))`` |</span>
<span class="sd">    | ``func``                                     |                   |</span>
<span class="sd">    +----------------------------------------------+-------------------+</span>
<span class="sd">    | ``sol`` contains an                          | ``oo``            |</span>
<span class="sd">    | :py:class:`~sympy.integrals.Integral`        |                   |</span>
<span class="sd">    +----------------------------------------------+-------------------+</span>

<span class="sd">    ``oo`` here means the SymPy infinity, which should compare greater than</span>
<span class="sd">    any integer.</span>

<span class="sd">    If you already know :py:meth:`~sympy.solvers.solvers.solve` cannot solve</span>
<span class="sd">    ``sol``, you can use ``trysolving=False`` to skip that step, which is the</span>
<span class="sd">    only potentially slow step.  For example,</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve` with the ``simplify=False`` flag</span>
<span class="sd">    should do this.</span>

<span class="sd">    If ``sol`` is a list of solutions, if the worst solution in the list</span>
<span class="sd">    returns ``oo`` it returns that, otherwise it returns ``len(str(sol))``,</span>
<span class="sd">    that is, the length of the string representation of the whole list.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    This function is designed to be passed to ``min`` as the key argument,</span>
<span class="sd">    such as ``min(listofsolutions, key=lambda i: ode_sol_simplicity(i,</span>
<span class="sd">    f(x)))``.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Function, Eq, tan, cos, sqrt, Integral</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import ode_sol_simplicity</span>
<span class="sd">    &gt;&gt;&gt; x, C1, C2 = symbols(&#39;x, C1, C2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ode_sol_simplicity(Eq(f(x), C1*x**2), f(x))</span>
<span class="sd">    -2</span>
<span class="sd">    &gt;&gt;&gt; ode_sol_simplicity(Eq(x**2 + f(x), C1), f(x))</span>
<span class="sd">    -1</span>
<span class="sd">    &gt;&gt;&gt; ode_sol_simplicity(Eq(f(x), C1*Integral(2*x, x)), f(x))</span>
<span class="sd">    oo</span>
<span class="sd">    &gt;&gt;&gt; eq1 = Eq(f(x)/tan(f(x)/(2*x)), C1)</span>
<span class="sd">    &gt;&gt;&gt; eq2 = Eq(f(x)/tan(f(x)/(2*x) + f(x)), C2)</span>
<span class="sd">    &gt;&gt;&gt; [ode_sol_simplicity(eq, f(x)) for eq in [eq1, eq2]]</span>
<span class="sd">    [26, 33]</span>
<span class="sd">    &gt;&gt;&gt; min([eq1, eq2], key=lambda i: ode_sol_simplicity(i, f(x)))</span>
<span class="sd">    f(x)/tan(f(x)/(2*x)) == C1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># TODO: if two solutions are solved for f(x), we still want to be</span>
    <span class="c"># able to get the simpler of the two</span>

    <span class="c"># See the docstring for the coercion rules.  We check easier (faster)</span>
    <span class="c"># things here first, to save time.</span>

    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">sol</span><span class="p">):</span>
        <span class="c"># See if there are Integrals</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">trysolving</span><span class="o">=</span><span class="n">trysolving</span><span class="p">)</span> <span class="o">==</span> <span class="n">oo</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">oo</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sol</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">oo</span>

    <span class="c"># Next, try to solve for func.  This code will change slightly when RootOf</span>
    <span class="c"># is implemented in solve().  Probably a RootOf solution should fall</span>
    <span class="c"># somewhere between a normal solution and an unsolvable expression.</span>

    <span class="c"># First, see if they are already solved</span>
    <span class="k">if</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="n">sol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sol</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">2</span>
    <span class="c"># We are not so lucky, try solving manually</span>
    <span class="k">if</span> <span class="n">trysolving</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sols</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c"># Finally, a naive computation based on the length of the string version</span>
    <span class="c"># of the expression.  This may favor combined fractions because they</span>
    <span class="c"># will not have duplicate denominators, and may slightly favor expressions</span>
    <span class="c"># with fewer additions and subtractions, as those are separated by spaces</span>
    <span class="c"># by the printer.</span>

    <span class="c"># Additional ideas for simplicity heuristics are welcome, like maybe</span>
    <span class="c"># checking if a equation has a larger domain, or if constantsimp has</span>
    <span class="c"># introduced arbitrary constants numbered higher than the order of a</span>
    <span class="c"># given ODE that sol is a solution of.</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sol</span><span class="p">))</span>

</div>
<span class="nd">@vectorize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<div class="viewcode-block" id="constantsimp"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.constantsimp">[docs]</a><span class="k">def</span> <span class="nf">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">independentsymbol</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span> <span class="n">startnumber</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">symbolname</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Simplifies an expression with arbitrary constants in it.</span>

<span class="sd">    This function is written specifically to work with</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve`, and is not intended for general use.</span>

<span class="sd">    Simplification is done by &quot;absorbing&quot; the arbitrary constants in to other</span>
<span class="sd">    arbitrary constants, numbers, and symbols that they are not independent</span>
<span class="sd">    of.</span>

<span class="sd">    The symbols must all have the same name with numbers after it, for</span>
<span class="sd">    example, ``C1``, ``C2``, ``C3``.  The ``symbolname`` here would be</span>
<span class="sd">    &#39;``C``&#39;, the ``startnumber`` would be 1, and the ``endnumber`` would be 3.</span>
<span class="sd">    If the arbitrary constants are independent of the variable ``x``, then the</span>
<span class="sd">    independent symbol would be ``x``.  There is no need to specify the</span>
<span class="sd">    dependent function, such as ``f(x)``, because it already has the</span>
<span class="sd">    independent symbol, ``x``, in it.</span>

<span class="sd">    Because terms are &quot;absorbed&quot; into arbitrary constants and because</span>
<span class="sd">    constants are renumbered after simplifying, the arbitrary constants in</span>
<span class="sd">    expr are not necessarily equal to the ones of the same name in the</span>
<span class="sd">    returned result.</span>

<span class="sd">    If two or more arbitrary constants are added, multiplied, or raised to the</span>
<span class="sd">    power of each other, they are first absorbed together into a single</span>
<span class="sd">    arbitrary constant.  Then the new constant is combined into other terms if</span>
<span class="sd">    necessary.</span>

<span class="sd">    Absorption is done with limited assistance: terms of</span>
<span class="sd">    :py:class:`~sympy.core.add.Add`\s are collected to try join constants and</span>
<span class="sd">    powers with exponents that are :py:class:`~sympy.core.add.Add`\s are</span>
<span class="sd">    expanded so `e^x (C_1 \cos(x) + C_2 \cos(x))` will simplify to `e^x C_1</span>
<span class="sd">    \cos(x)` and `e^{C_1 + x}` will be simplified to `C_1 e^x`.</span>

<span class="sd">    Use :py:meth:`~sympy.solvers.ode.constant_renumber` to renumber constants</span>
<span class="sd">    after simplification or else arbitrary numbers on constants may appear,</span>
<span class="sd">    e.g. `C_1 + C_3 x`.</span>

<span class="sd">    In rare cases, a single constant can be &quot;simplified&quot; into two constants.</span>
<span class="sd">    Every differential equation solution should have as many arbitrary</span>
<span class="sd">    constants as the order of the differential equation.  The result here will</span>
<span class="sd">    be technically correct, but it may, for example, have `C_1` and `C_2` in</span>
<span class="sd">    an expression, when `C_1` is actually equal to `C_2`.  Use your discretion</span>
<span class="sd">    in such situations, and also take advantage of the ability to use hints in</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import constantsimp</span>
<span class="sd">    &gt;&gt;&gt; C1, C2, C3, x, y = symbols(&#39;C1,C2,C3,x,y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; constantsimp(2*C1*x, x, 3)</span>
<span class="sd">    C1*x</span>
<span class="sd">    &gt;&gt;&gt; constantsimp(C1 + 2 + x + y, x, 3)</span>
<span class="sd">    C1 + x</span>
<span class="sd">    &gt;&gt;&gt; constantsimp(C1*C2 + 2 + x + y + C3*x, x, 3)</span>
<span class="sd">    C1 + C3*x</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># This function works recursively.  The idea is that, for Mul,</span>
    <span class="c"># Add, Pow, and Function, if the class has a constant in it, then</span>
    <span class="c"># we can simplify it, which we do by recursing down and</span>
    <span class="c"># simplifying up.  Otherwise, we can skip that part of the</span>
    <span class="c"># expression.</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">symbolname</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">constantsymbols</span> <span class="o">=</span> <span class="n">symbolname</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">constantsymbols</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span>
            <span class="n">symbolname</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%i</span><span class="s">:</span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">independentsymbol</span>
    <span class="n">con_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">constantsymbols</span><span class="p">)</span>
    <span class="n">ARGS</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">constantsymbols</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="c"># For now, only treat the special case where one side of the equation</span>
        <span class="c"># is a constant</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span> <span class="ow">in</span> <span class="n">con_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rhs</span> <span class="o">+</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="o">*</span><span class="n">ARGS</span><span class="p">)</span> <span class="o">-</span> <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
            <span class="c"># this could break if expr.lhs is absorbed into another constant,</span>
            <span class="c"># but for now, the only solutions that return Eq&#39;s with a constant</span>
            <span class="c"># on one side are first order.  At any rate, it will still be</span>
            <span class="c"># technically correct.  The expression will just have too many</span>
            <span class="c"># constants in it</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span> <span class="ow">in</span> <span class="n">con_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="n">ARGS</span><span class="p">)</span> <span class="o">-</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="o">*</span><span class="n">ARGS</span><span class="p">),</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="n">ARGS</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s">&#39;has&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">constantsymbols</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># ================ pre-processing ================</span>
        <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="c"># return the lowest numbered constant symbol that appears in ``i``</span>
            <span class="c"># else return ``i``</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">con_set</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">constantsymbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># collect terms to get constants together</span>
        <span class="n">new_expr</span> <span class="o">=</span> <span class="n">terms_gcd</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="c"># don&#39;t let C1*exp(x) + C2*exp(2*x) become exp(x)*(C1 + C2*exp(x))</span>
            <span class="n">infac</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">asfac</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">new_expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">:</span>
                    <span class="n">asfac</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="n">infac</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">fi</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">args</span>
                        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">asfac</span> <span class="ow">and</span> <span class="n">infac</span><span class="p">:</span>
                    <span class="n">new_expr</span> <span class="o">=</span> <span class="n">expr</span>
                    <span class="k">break</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">new_expr</span>
        <span class="c"># don&#39;t allow a number to be factored out of an expression</span>
        <span class="c"># that has no denominator</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">h</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">denom</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">*</span><span class="n">a</span>
                        <span class="n">expr</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="c"># let numbers absorb into constants of an Add, perhaps</span>
            <span class="c"># in the base of a power, if all its terms have a constant</span>
            <span class="c"># symbol in them, e.g. sqrt(2)*(C1 + C2*x) -&gt; C1 + C2*x</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">sift</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">)</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="bp">True</span><span class="p">]</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="bp">False</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">num</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                        <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> \
                                <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span>
                                <span class="n">con_set</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                            <span class="n">expr</span> <span class="o">=</span> <span class="n">sign</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">num</span><span class="p">))</span><span class="o">*</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                            <span class="k">break</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>  <span class="c"># check again that it&#39;s still a Mul</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">newi</span> <span class="o">=</span> <span class="n">_take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newi</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">newi</span><span class="o">*</span><span class="n">d</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">_take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ai</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="c"># handle powers like exp(C0 + g(x)) -&gt; C0*exp(g(x))</span>
        <span class="n">pows</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Function</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Pow</span><span class="p">)</span> <span class="k">if</span>
                <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">p</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span>
                <span class="n">p</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">pows</span><span class="p">:</span>
            <span class="n">reps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pows</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="n">ei</span><span class="p">,</span> <span class="n">ed</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">_take</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">ei</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">:</span>
                    <span class="n">reps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="n">ed</span><span class="p">))</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
            <span class="c"># a C1*C2 may have been introduced and the code below won&#39;t</span>
            <span class="c"># handle that so handle it now: once to handle the C1*C2</span>
            <span class="c"># and once to handle any C0*f(x) + C0*f(x)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">muls</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">constantsymbols</span><span class="p">)]</span>
                <span class="n">reps</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">muls</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">newi</span> <span class="o">=</span> <span class="n">_take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">newi</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">reps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">_take</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">))</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span>
        <span class="c"># ================ end of pre-processing ================</span>
        <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hasconst</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">isPowExp</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">reeval</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">:</span>
                <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newconst</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">hasconst</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">:</span>
                    <span class="n">isPowExp</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)):</span>
            <span class="n">isimp</span> <span class="o">=</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">newargs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">ARGS</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isimp</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">:</span>
                <span class="n">reeval</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">hasconst</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">newconst</span> <span class="o">=</span> <span class="n">isimp</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">isPowExp</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">newargs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">isimp</span>
        <span class="k">if</span> <span class="n">hasconst</span><span class="p">:</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">newargs</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">isPowExp</span><span class="p">:</span>
                <span class="n">newargs</span> <span class="o">=</span> <span class="n">newargs</span> <span class="o">+</span> <span class="p">[</span><span class="n">newconst</span><span class="p">]</span>  <span class="c"># Order matters in this case</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">newconst</span><span class="p">]</span> <span class="o">+</span> <span class="n">newargs</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">hasconst</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">newconst</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newfuncargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">constantsimp</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">ARGS</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">newfuncargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reeval</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">constantsimp</span><span class="p">(</span><span class="n">newexpr</span><span class="p">,</span> <span class="o">*</span><span class="n">ARGS</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">newexpr</span>

</div>
<div class="viewcode-block" id="constant_renumber"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.constant_renumber">[docs]</a><span class="k">def</span> <span class="nf">constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Renumber arbitrary constants in ``expr`` to have numbers 1 through `N`</span>
<span class="sd">    where `N` is ``endnumber - startnumber + 1`` at most.</span>

<span class="sd">    This is a simple function that goes through and renumbers any</span>
<span class="sd">    :py:class:`~sympy.core.symbol.Symbol` with a name in the form ``symbolname</span>
<span class="sd">    + num`` where ``num`` is in the range from ``startnumber`` to</span>
<span class="sd">    ``endnumber``.</span>

<span class="sd">    Symbols are renumbered based on ``.sort_key()``, so they should be</span>
<span class="sd">    numbered roughly in the order that they appear in the final, printed</span>
<span class="sd">    expression.  Note that this ordering is based in part on hashes, so it can</span>
<span class="sd">    produce different results on different machines.</span>

<span class="sd">    The structure of this function is very similar to that of</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.constantsimp`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Eq, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import constant_renumber</span>
<span class="sd">    &gt;&gt;&gt; x, C0, C1, C2, C3, C4 = symbols(&#39;x,C:5&#39;)</span>

<span class="sd">    Only constants in the given range (inclusive) are renumbered;</span>
<span class="sd">    the renumbering always starts from 1:</span>

<span class="sd">    &gt;&gt;&gt; constant_renumber(C1 + C3 + C4, &#39;C&#39;, 1, 3)</span>
<span class="sd">    C1 + C2 + C4</span>
<span class="sd">    &gt;&gt;&gt; constant_renumber(C0 + C1 + C3 + C4, &#39;C&#39;, 2, 4)</span>
<span class="sd">    C0 + 2*C1 + C2</span>
<span class="sd">    &gt;&gt;&gt; constant_renumber(C0 + 2*C1 + C2, &#39;C&#39;, 0, 1)</span>
<span class="sd">    C1 + 3*C2</span>
<span class="sd">    &gt;&gt;&gt; pprint(C2 + C1*x + C3*x**2)</span>
<span class="sd">                    2</span>
<span class="sd">    C1*x + C2 + C3*x</span>
<span class="sd">    &gt;&gt;&gt; pprint(constant_renumber(C2 + C1*x + C3*x**2, &#39;C&#39;, 1, 3))</span>
<span class="sd">                    2</span>
<span class="sd">    C1 + C2*x + C3*x</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">)(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">constant_renumber</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">symbolname</span><span class="o">=</span><span class="n">symbolname</span><span class="p">,</span>
            <span class="n">startnumber</span><span class="o">=</span><span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="o">=</span><span class="n">endnumber</span><span class="p">),</span> <span class="n">expr</span><span class="p">))</span>
    <span class="k">global</span> <span class="n">newstartnumber</span>
    <span class="n">newstartnumber</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        We need to have an internal recursive function so that</span>
<span class="sd">        newstartnumber maintains its values throughout recursive calls.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constantsymbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">Symbol</span><span class="p">(</span>
            <span class="n">symbolname</span> <span class="o">+</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">startnumber</span><span class="p">,</span>
        <span class="n">endnumber</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">global</span> <span class="n">newstartnumber</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span>
                <span class="n">_constant_renumber</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">),</span>
                <span class="n">_constant_renumber</span><span class="p">(</span>
                    <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Pow</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">constantsymbols</span><span class="p">):</span>
            <span class="c"># Base case, as above.  Hope there aren&#39;t constants inside</span>
            <span class="c"># of some other class, because they won&#39;t be renumbered.</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Piecewise</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">elif</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">:</span>
            <span class="c"># Renumbering happens here</span>
            <span class="n">newconst</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">symbolname</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">newstartnumber</span><span class="p">))</span>
            <span class="n">newstartnumber</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">newconst</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">sympy.core.containers</span> <span class="kn">import</span> <span class="n">Tuple</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">[</span><span class="n">_constant_renumber</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span>
                <span class="n">endnumber</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sortedargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="c"># make a mapping to send all constantsymbols to S.One and use</span>
                <span class="c"># that to make sure that term ordering is not dependent on</span>
                <span class="c"># the indexed value of C</span>
                <span class="n">C_1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ci</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">constantsymbols</span><span class="p">]</span>
                <span class="n">sortedargs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">arg</span><span class="p">:</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">C_1</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span>
                    <span class="o">*</span><span class="p">[</span><span class="n">_constant_renumber</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span>
                    <span class="n">endnumber</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sortedargs</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">_constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolname</span><span class="p">,</span> <span class="n">startnumber</span><span class="p">,</span> <span class="n">endnumber</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_handle_Integral</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">hint</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Converts a solution with Integrals in it into an actual solution.</span>

<span class="sd">    For most hints, this simply runs ``expr.doit()``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">y</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="k">if</span> <span class="n">hint</span> <span class="o">==</span> <span class="s">&quot;1st_exact&quot;</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">y</span>
    <span class="k">elif</span> <span class="n">hint</span> <span class="o">==</span> <span class="s">&quot;1st_exact_Integral&quot;</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">y</span>
    <span class="k">elif</span> <span class="n">hint</span> <span class="o">==</span> <span class="s">&quot;nth_linear_constant_coeff_homogeneous&quot;</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">hint</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&quot;_Integral&quot;</span><span class="p">):</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="k">return</span> <span class="n">sol</span>


<span class="c"># FIXME: replace the general solution in the docstring with</span>
<span class="c"># dsolve(equation, hint=&#39;1st_exact_Integral&#39;).  You will need to be able</span>
<span class="c"># to have assumptions on P and Q that dP/dy = dQ/dx.</span>
<div class="viewcode-block" id="ode_1st_exact"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_exact">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_exact</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves 1st order exact ordinary differential equations.</span>

<span class="sd">    A 1st order differential equation is called exact if it is the total</span>
<span class="sd">    differential of a function. That is, the differential equation</span>

<span class="sd">    .. math:: P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0</span>

<span class="sd">    is exact if there is some function `F(x, y)` such that `P(x, y) =</span>
<span class="sd">    \partial{}F/\partial{}x` and `Q(x, y) = \partial{}F/\partial{}y`.  It can</span>
<span class="sd">    be shown that a necessary and sufficient condition for a first order ODE</span>
<span class="sd">    to be exact is that `\partial{}P/\partial{}y = \partial{}Q/\partial{}x`.</span>
<span class="sd">    Then, the solution will be as given below::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, Eq, Integral, symbols, pprint</span>
<span class="sd">        &gt;&gt;&gt; x, y, t, x0, y0, C1= symbols(&#39;x,y,t,x0,y0,C1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; P, Q, F= map(Function, [&#39;P&#39;, &#39;Q&#39;, &#39;F&#39;])</span>
<span class="sd">        &gt;&gt;&gt; pprint(Eq(Eq(F(x, y), Integral(P(t, y), (t, x0, x)) +</span>
<span class="sd">        ... Integral(Q(x0, t), (t, y0, y))), C1))</span>
<span class="sd">                    x                y</span>
<span class="sd">                    /                /</span>
<span class="sd">                   |                |</span>
<span class="sd">        F(x, y) =  |  P(t, y) dt +  |  Q(x0, t) dt = C1</span>
<span class="sd">                   |                |</span>
<span class="sd">                  /                /</span>
<span class="sd">                  x0               y0</span>

<span class="sd">    Where the first partials of `P` and `Q` exist and are continuous in a</span>
<span class="sd">    simply connected region.</span>

<span class="sd">    A note: SymPy currently has no way to represent inert substitution on an</span>
<span class="sd">    expression, so the hint ``1st_exact_Integral`` will return an integral</span>
<span class="sd">    with `dy`.  This is supposed to represent the function that you are</span>
<span class="sd">    solving for.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, cos, sin</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(cos(f(x)) - (x*sin(f(x)) - f(x)**2)*f(x).diff(x),</span>
<span class="sd">    ... f(x), hint=&#39;1st_exact&#39;)</span>
<span class="sd">    x*cos(f(x)) + f(x)**3/3 == C1</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Exact_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 73</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># d+e*diff(f(x),x)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]]</span>
    <span class="k">global</span> <span class="n">y</span>  <span class="c"># This is the only way to pass dummy y to _handle_Integral</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="c"># Refer Joel Moses, &quot;Symbolic Integration - The Stormy Decade&quot;,</span>
    <span class="c"># Communications of the ACM, Volume 14, Number 8, August 1971, pp. 558</span>
    <span class="c"># which gives the method to solve an exact differential equation.</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">((</span><span class="n">e</span> <span class="o">-</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))),</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">C1</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_1st_homogeneous_coeff_best"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_homogeneous_coeff_best">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_homogeneous_coeff_best</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Returns the best solution to an ODE from the two hints</span>
<span class="sd">    ``1st_homogeneous_coeff_subs_dep_div_indep`` and</span>
<span class="sd">    ``1st_homogeneous_coeff_subs_indep_div_dep``.</span>

<span class="sd">    This is as determined by :py:meth:`~ode_sol_simplicity`.</span>

<span class="sd">    See the :py:meth:`~ode_1st_homogeneous_coeff_subs_indep_div_dep` and</span>
<span class="sd">    :py:meth:`~ode_1st_homogeneous_coeff_subs_dep_div_indep` docstrings for</span>
<span class="sd">    more information on these hints.  Note that there is no</span>
<span class="sd">    ``1st_homogeneous_coeff_best_Integral`` hint.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(2*x*f(x) + (x**2 + f(x)**2)*f(x).diff(x), f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_best&#39;, simplify=False))</span>
<span class="sd">                             /    2    \</span>
<span class="sd">                             | 3*x     |</span>
<span class="sd">                          log|----- + 1|</span>
<span class="sd">                             | 2       |</span>
<span class="sd">                             \f (x)    /</span>
<span class="sd">    log(f(x)) = log(C1) - --------------</span>
<span class="sd">                                3</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Homogeneous_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 59</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># There are two substitutions that solve the equation, u1=y/x and u2=x/y</span>
    <span class="c"># They produce different integrals, so try them both and see which</span>
    <span class="c"># one is easier.</span>
    <span class="n">sol1</span> <span class="o">=</span> <span class="n">ode_1st_homogeneous_coeff_subs_indep_div_dep</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
    <span class="n">sol2</span> <span class="o">=</span> <span class="n">ode_1st_homogeneous_coeff_subs_dep_div_indep</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span>
    <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
    <span class="n">simplify</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
        <span class="n">sol1</span> <span class="o">=</span> <span class="n">odesimp</span><span class="p">(</span>
            <span class="n">sol1</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="s">&quot;1st_homogeneous_coeff_subs_indep_div_dep&quot;</span><span class="p">)</span>
        <span class="n">sol2</span> <span class="o">=</span> <span class="n">odesimp</span><span class="p">(</span>
            <span class="n">sol2</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="s">&quot;1st_homogeneous_coeff_subs_dep_div_indep&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">([</span><span class="n">sol1</span><span class="p">,</span> <span class="n">sol2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span>
        <span class="n">trysolving</span><span class="o">=</span><span class="ow">not</span> <span class="n">simplify</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="ode_1st_homogeneous_coeff_subs_dep_div_indep"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_homogeneous_coeff_subs_dep_div_indep</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves a 1st order differential equation with homogeneous coefficients</span>
<span class="sd">    using the substitution `u_1 = \frac{\text{&lt;dependent</span>
<span class="sd">    variable&gt;}}{\text{&lt;independent variable&gt;}}`.</span>

<span class="sd">    This is a differential equation</span>

<span class="sd">    .. math:: P(x, y) + Q(x, y) dy/dx = 0</span>

<span class="sd">    such that `P` and `Q` are homogeneous and of the same order.  A function</span>
<span class="sd">    `F(x, y)` is homogeneous of order `n` if `F(x t, y t) = t^n F(x, y)`.</span>
<span class="sd">    Equivalently, `F(x, y)` can be rewritten as `G(y/x)` or `H(x/y)`.  See</span>
<span class="sd">    also the docstring of :py:meth:`~sympy.solvers.ode.homogeneous_order`.</span>

<span class="sd">    If the coefficients `P` and `Q` in the differential equation above are</span>
<span class="sd">    homogeneous functions of the same order, then it can be shown that the</span>
<span class="sd">    substitution `y = u_1 x` (i.e. `u_1 = y/x`) will turn the differential</span>
<span class="sd">    equation into an equation separable in the variables `x` and `u`.  If</span>
<span class="sd">    `h(u_1)` is the function that results from making the substitution `u_1 =</span>
<span class="sd">    f(x)/x` on `P(x, f(x))` and `g(u_2)` is the function that results from the</span>
<span class="sd">    substitution on `Q(x, f(x))` in the differential equation `P(x, f(x)) +</span>
<span class="sd">    Q(x, f(x)) f&#39;(x) = 0`, then the general solution is::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; f, g, h = map(Function, [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = g(f(x)/x) + h(f(x)/x)*f(x).diff(x)</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">         /f(x)\    /f(x)\ d</span>
<span class="sd">        g|----| + h|----|*--(f(x))</span>
<span class="sd">         \ x  /    \ x  / dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x),</span>
<span class="sd">        ... hint=&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;))</span>
<span class="sd">                       f(x)</span>
<span class="sd">                       ----</span>
<span class="sd">                        x</span>
<span class="sd">                         /</span>
<span class="sd">                        |</span>
<span class="sd">                        |       -h(u1)</span>
<span class="sd">        log(x) = C1 +   |  ---------------- d(u1)</span>
<span class="sd">                        |  u1*h(u1) + g(u1)</span>
<span class="sd">                        |</span>
<span class="sd">                       /</span>

<span class="sd">    Where `u_1 h(u_1) + g(u_1) \ne 0` and `x \ne 0`.</span>

<span class="sd">    See also the docstrings of</span>
<span class="sd">    :py:meth:`~ode_1st_homogeneous_coeff_best` and</span>
<span class="sd">    :py:meth:`~ode_1st_homogeneous_coeff_subs_indep_div_dep`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(2*x*f(x) + (x**2 + f(x)**2)*f(x).diff(x), f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;, simplify=False))</span>
<span class="sd">                          /          3   \</span>
<span class="sd">                          |3*f(x)   f (x)|</span>
<span class="sd">                       log|------ + -----|</span>
<span class="sd">                          |  x         3 |</span>
<span class="sd">                          \           x  /</span>
<span class="sd">    log(x) = log(C1) - -------------------</span>
<span class="sd">                                3</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Homogeneous_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 59</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">u1</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u1&#39;</span><span class="p">)</span>  <span class="c"># u1 == f(x)/x</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># d+e*diff(f(x),x)</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">xarg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;xarg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">yarg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;yarg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nb">int</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span>
        <span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">u1</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]]))</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]:</span> <span class="n">u1</span><span class="p">}),</span>
        <span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">))</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">C1</span><span class="p">)),</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span> <span class="o">-</span> <span class="n">yarg</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xarg</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">sol</span>

</div>
<div class="viewcode-block" id="ode_1st_homogeneous_coeff_subs_indep_div_dep"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_homogeneous_coeff_subs_indep_div_dep</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves a 1st order differential equation with homogeneous coefficients</span>
<span class="sd">    using the substitution `u_2 = \frac{\text{&lt;independent</span>
<span class="sd">    variable&gt;}}{\text{&lt;dependent variable&gt;}}`.</span>

<span class="sd">    This is a differential equation</span>

<span class="sd">    .. math:: P(x, y) + Q(x, y) dy/dx = 0</span>

<span class="sd">    such that `P` and `Q` are homogeneous and of the same order.  A function</span>
<span class="sd">    `F(x, y)` is homogeneous of order `n` if `F(x t, y t) = t^n F(x, y)`.</span>
<span class="sd">    Equivalently, `F(x, y)` can be rewritten as `G(y/x)` or `H(x/y)`.  See</span>
<span class="sd">    also the docstring of :py:meth:`~sympy.solvers.ode.homogeneous_order`.</span>

<span class="sd">    If the coefficients `P` and `Q` in the differential equation above are</span>
<span class="sd">    homogeneous functions of the same order, then it can be shown that the</span>
<span class="sd">    substitution `x = u_2 y` (i.e. `u_2 = x/y`) will turn the differential</span>
<span class="sd">    equation into an equation separable in the variables `y` and `u_2`.  If</span>
<span class="sd">    `h(u_2)` is the function that results from making the substitution `u_2 =</span>
<span class="sd">    x/f(x)` on `P(x, f(x))` and `g(u_2)` is the function that results from the</span>
<span class="sd">    substitution on `Q(x, f(x))` in the differential equation `P(x, f(x)) +</span>
<span class="sd">    Q(x, f(x)) f&#39;(x) = 0`, then the general solution is:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f, g, h = map(Function, [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;])</span>
<span class="sd">    &gt;&gt;&gt; genform = g(x/f(x)) + h(x/f(x))*f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">     / x  \    / x  \ d</span>
<span class="sd">    g|----| + h|----|*--(f(x))</span>
<span class="sd">     \f(x)/    \f(x)/ dx</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(genform, f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;))</span>
<span class="sd">                 x</span>
<span class="sd">                ----</span>
<span class="sd">                f(x)</span>
<span class="sd">                  /</span>
<span class="sd">                 |</span>
<span class="sd">                 |       -g(u2)</span>
<span class="sd">                 |  ---------------- d(u2)</span>
<span class="sd">                 |  u2*g(u2) + h(u2)</span>
<span class="sd">                 |</span>
<span class="sd">                /</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    f(x) = C1*e</span>

<span class="sd">    Where `u_2 g(u_2) + h(u_2) \ne 0` and `f(x) \ne 0`.</span>

<span class="sd">    See also the docstrings of</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.ode_1st_homogeneous_coeff_best` and</span>
<span class="sd">    :py:meth:`~ode_1st_homogeneous_coeff_subs_dep_div_indep`.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, pprint, dsolve</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(2*x*f(x) + (x**2 + f(x)**2)*f(x).diff(x), f(x),</span>
<span class="sd">    ... hint=&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="sd">    ... simplify=False))</span>
<span class="sd">                             /    2    \</span>
<span class="sd">                             | 3*x     |</span>
<span class="sd">                          log|----- + 1|</span>
<span class="sd">                             | 2       |</span>
<span class="sd">                             \f (x)    /</span>
<span class="sd">    log(f(x)) = log(C1) - --------------</span>
<span class="sd">                                3</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Homogeneous_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 59</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;u2&#39;</span><span class="p">)</span>  <span class="c"># u2 == x/f(x)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># d+e*diff(f(x),x)</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">xarg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;xarg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># If xarg present take xarg, else zero</span>
    <span class="n">yarg</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;yarg&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c"># If yarg present take yarg, else zero</span>
    <span class="nb">int</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span>
        <span class="n">simplify</span><span class="p">(</span>
            <span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]]</span><span class="o">/</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]]</span> <span class="o">+</span> <span class="n">u2</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;d&#39;</span><span class="p">]]))</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="n">u2</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]:</span> <span class="mi">1</span><span class="p">})),</span>
        <span class="p">(</span><span class="n">u2</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="nb">int</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">C1</span><span class="p">)),</span> <span class="n">force</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span> <span class="o">-</span> <span class="n">yarg</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">xarg</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">sol</span>

<span class="c"># XXX: Should this function maybe go somewhere else?</span>

</div>
<div class="viewcode-block" id="homogeneous_order"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.homogeneous_order">[docs]</a><span class="k">def</span> <span class="nf">homogeneous_order</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Returns the order `n` if `g` is homogeneous and ``None`` if it is not</span>
<span class="sd">    homogeneous.</span>

<span class="sd">    Determines if a function is homogeneous and if so of what order.  A</span>
<span class="sd">    function `f(x, y, \cdots)` is homogeneous of order `n` if `f(t x, t y,</span>
<span class="sd">    \cdots) = t^n f(x, y, \cdots)`.</span>

<span class="sd">    If the function is of two variables, `F(x, y)`, then `f` being homogeneous</span>
<span class="sd">    of any order is equivalent to being able to rewrite `F(x, y)` as `G(x/y)`</span>
<span class="sd">    or `H(y/x)`.  This fact is used to solve 1st order ordinary differential</span>
<span class="sd">    equations whose coefficients are homogeneous of the same order (see the</span>
<span class="sd">    docstrings of</span>
<span class="sd">    :py:meth:`~solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep` and</span>
<span class="sd">    :py:meth:`~solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep`).</span>

<span class="sd">    Symbols can be functions, but every argument of the function must be a</span>
<span class="sd">    symbol, and the arguments of the function that appear in the expression</span>
<span class="sd">    must match those given in the list of symbols.  If a declared function</span>
<span class="sd">    appears with different arguments than given in the list of symbols,</span>
<span class="sd">    ``None`` is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, homogeneous_order, sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(f(x), f(x)) is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(f(x,y), f(y, x), x, y) is None</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(f(x), f(x), x)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(x**2*f(x)/sqrt(x**2+f(x)**2), x, f(x))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; homogeneous_order(x**2+f(x), x, f(x)) is None</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.simplify.simplify</span> <span class="kn">import</span> <span class="n">separatevars</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;homogeneous_order: no symbols were given.&quot;</span><span class="p">)</span>
    <span class="n">symset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="c"># The following are not supported</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Order</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># These are all constants</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">is_NumberSymbol</span> <span class="ow">or</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">is_number</span>
            <span class="p">):</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="c"># Replace all functions with dummy variables</span>
    <span class="n">dum</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
    <span class="n">newsyms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">symset</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s">&#39;is_Function&#39;</span><span class="p">)]:</span>
        <span class="n">iargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iargs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">symset</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dummyvar</span> <span class="o">=</span> <span class="n">dum</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dummyvar</span><span class="p">)</span>
            <span class="n">symset</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">newsyms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dummyvar</span><span class="p">)</span>
    <span class="n">symset</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newsyms</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">symset</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># assuming order of a nested function can only be equal to zero</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span> <span class="k">if</span> <span class="n">homogeneous_order</span><span class="p">(</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">symset</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="c"># make the replacement of x with x*t and see if t can be factored out</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># It is sufficient that t &gt; 0</span>
    <span class="n">eqs</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symset</span><span class="p">]),</span> <span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="n">t</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">eqs</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>  <span class="c"># there was no term with only t</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">eqs</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">as_Add</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>

</div>
<div class="viewcode-block" id="ode_1st_linear"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_1st_linear">[docs]</a><span class="k">def</span> <span class="nf">ode_1st_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves 1st order linear differential equations.</span>

<span class="sd">    These are differential equations of the form</span>

<span class="sd">    .. math:: dy/dx + P(x) y = Q(x)\text{.}</span>

<span class="sd">    These kinds of differential equations can be solved in a general way.  The</span>
<span class="sd">    integrating factor `e^{\int P(x) \,dx}` will turn the equation into a</span>
<span class="sd">    separable equation.  The general solution is::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint, diff, sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; f, P, Q = map(Function, [&#39;f&#39;, &#39;P&#39;, &#39;Q&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(f(x).diff(x) + P(x)*f(x), Q(x))</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                    d</span>
<span class="sd">        P(x)*f(x) + --(f(x)) = Q(x)</span>
<span class="sd">                    dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x), hint=&#39;1st_linear_Integral&#39;))</span>
<span class="sd">               /       /                   \</span>
<span class="sd">               |      |                    |</span>
<span class="sd">               |      |         /          |     /</span>
<span class="sd">               |      |        |           |    |</span>
<span class="sd">               |      |        | P(x) dx   |  - | P(x) dx</span>
<span class="sd">               |      |        |           |    |</span>
<span class="sd">               |      |       /            |   /</span>
<span class="sd">        f(x) = |C1 +  | Q(x)*e           dx|*e</span>
<span class="sd">               |      |                    |</span>
<span class="sd">               \     /                     /</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(Eq(x*diff(f(x), x) - f(x), x**2*sin(x)),</span>
<span class="sd">    ... f(x), &#39;1st_linear&#39;))</span>
<span class="sd">    f(x) = x*(C1 - cos(x))</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 92</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># a*diff(f(x),x) + b*f(x) + c</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]],</span> <span class="n">x</span><span class="p">))</span>
    <span class="n">tt</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]]),</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c"># take almost-linear u if present, else f(x)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="n">tt</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span><span class="o">/</span><span class="n">t</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_Bernoulli"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_Bernoulli">[docs]</a><span class="k">def</span> <span class="nf">ode_Bernoulli</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves Bernoulli differential equations.</span>

<span class="sd">    These are equations of the form</span>

<span class="sd">    .. math:: dy/dx + P(x) y = Q(x) y^n\text{, }n \ne 1`\text{.}</span>

<span class="sd">    The substitution `w = 1/y^{1-n}` will transform an equation of this form</span>
<span class="sd">    into one that is linear (see the docstring of</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.ode_1st_linear`).  The general solution is::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, n</span>
<span class="sd">        &gt;&gt;&gt; f, P, Q = map(Function, [&#39;f&#39;, &#39;P&#39;, &#39;Q&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(f(x).diff(x) + P(x)*f(x), Q(x)*f(x)**n)</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                    d                n</span>
<span class="sd">        P(x)*f(x) + --(f(x)) = Q(x)*f (x)</span>
<span class="sd">                    dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x), hint=&#39;Bernoulli_Integral&#39;)) #doctest: +SKIP</span>
<span class="sd">                                                                                       1</span>
<span class="sd">                                                                                      ----</span>
<span class="sd">                                                                                     1 - n</span>
<span class="sd">               //                /                            \                     \</span>
<span class="sd">               ||               |                             |                     |</span>
<span class="sd">               ||               |                  /          |             /       |</span>
<span class="sd">               ||               |                 |           |            |        |</span>
<span class="sd">               ||               |        (1 - n)* | P(x) dx   |  (-1 + n)* | P(x) dx|</span>
<span class="sd">               ||               |                 |           |            |        |</span>
<span class="sd">               ||               |                /            |           /         |</span>
<span class="sd">        f(x) = ||C1 + (-1 + n)* | -Q(x)*e                   dx|*e                   |</span>
<span class="sd">               ||               |                             |                     |</span>
<span class="sd">               \\               /                            /                     /</span>


<span class="sd">    Note that the equation is separable when `n = 1` (see the docstring of</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.ode_separable`).</span>

<span class="sd">    &gt;&gt;&gt; pprint(dsolve(Eq(f(x).diff(x) + P(x)*f(x), Q(x)*f(x)), f(x),</span>
<span class="sd">    ... hint=&#39;separable_Integral&#39;))</span>
<span class="sd">     f(x)</span>
<span class="sd">       /</span>
<span class="sd">      |                /</span>
<span class="sd">      |  1            |</span>
<span class="sd">      |  - dy = C1 +  | (-P(x) + Q(x)) dx</span>
<span class="sd">      |  y            |</span>
<span class="sd">      |              /</span>
<span class="sd">     /</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint, log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    &gt;&gt;&gt; pprint(dsolve(Eq(x*f(x).diff(x) + f(x), log(x)*f(x)**2),</span>
<span class="sd">    ... f(x), hint=&#39;Bernoulli&#39;))</span>
<span class="sd">                    1</span>
<span class="sd">    f(x) = -------------------</span>
<span class="sd">             /     log(x)   1\</span>
<span class="sd">           x*|C1 + ------ + -|</span>
<span class="sd">             \       x      x/</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Bernoulli_differential_equation</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 95</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># a*diff(f(x),x) + b*f(x) + c*f(x)**n, n != 1</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">exp</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]])</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;b&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]],</span> <span class="n">x</span><span class="p">))</span>
    <span class="n">tt</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">t</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;c&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]],</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">((</span><span class="n">tt</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span><span class="o">/</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;n&#39;</span><span class="p">]])))</span>

</div>
<div class="viewcode-block" id="ode_Riccati_special_minus2"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_Riccati_special_minus2">[docs]</a><span class="k">def</span> <span class="nf">ode_Riccati_special_minus2</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The general Riccati equation has the form</span>

<span class="sd">    .. math:: dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}</span>

<span class="sd">    While it does not have a general solution [1], the &quot;special&quot; form, `dy/dx</span>
<span class="sd">    = a y^2 - b x^c`, does have solutions in many cases [2].  This routine</span>
<span class="sd">    returns a solution for `a(dy/dx) = b y^2 + c y/x + d/x^2` that is obtained</span>
<span class="sd">    by using a suitable change of variables to reduce it to the special form</span>
<span class="sd">    and is valid when neither `a` nor `b` are zero and either `c` or `d` is</span>
<span class="sd">    zero.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, a, b, c, d</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import dsolve, checkodesol</span>
<span class="sd">    &gt;&gt;&gt; from sympy import pprint, Function</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = f(x)</span>
<span class="sd">    &gt;&gt;&gt; genform = a*y.diff(x) - (b*y**2 + c*y/x + d/x**2)</span>
<span class="sd">    &gt;&gt;&gt; sol = dsolve(genform, y)</span>
<span class="sd">    &gt;&gt;&gt; pprint(sol, wrap_line=False)</span>
<span class="sd">            /                                 /        __________________       \\</span>
<span class="sd">            |           __________________    |       /                2        ||</span>
<span class="sd">            |          /                2     |     \/  4*b*d - (a + c)  *log(x)||</span>
<span class="sd">           -|a + c - \/  4*b*d - (a + c)  *tan|C1 + ----------------------------||</span>
<span class="sd">            \                                 \                 2*a             //</span>
<span class="sd">    f(x) = ------------------------------------------------------------------------</span>
<span class="sd">                                            2*b*x</span>

<span class="sd">    &gt;&gt;&gt; checkodesol(genform, sol, order=1)[0]</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati</span>
<span class="sd">    2. http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf -</span>
<span class="sd">       http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># a2*diff(f(x),x) + b2*f(x) + c2*f(x)/x + d2/x**2</span>
    <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="s">&#39;a2 b2 c2 d2&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">d2</span><span class="o">*</span><span class="n">b2</span> <span class="o">-</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">c2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">mu</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">mu</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a2</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">b2</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="ode_Liouville"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_Liouville">[docs]</a><span class="k">def</span> <span class="nf">ode_Liouville</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves 2nd order Liouville differential equations.</span>

<span class="sd">    The general form of a Liouville ODE is</span>

<span class="sd">    .. math:: \frac{d^2 y}{dx^2} + g(y) \left(\!</span>
<span class="sd">                \frac{dy}{dx}\!\right)^2 + h(x)</span>
<span class="sd">                \frac{dy}{dx}\text{.}</span>

<span class="sd">    The general solution is:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint, diff</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; f, g, h = map(Function, [&#39;f&#39;, &#39;g&#39;, &#39;h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(diff(f(x),x,x) + g(f(x))*diff(f(x),x)**2 +</span>
<span class="sd">        ... h(x)*diff(f(x),x), 0)</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                          2                    2</span>
<span class="sd">                /d       \         d          d</span>
<span class="sd">        g(f(x))*|--(f(x))|  + h(x)*--(f(x)) + ---(f(x)) = 0</span>
<span class="sd">                \dx      /         dx           2</span>
<span class="sd">                                              dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x), hint=&#39;Liouville_Integral&#39;))</span>
<span class="sd">                                          f(x)</span>
<span class="sd">                  /                     /</span>
<span class="sd">                 |                     |</span>
<span class="sd">                 |     /               |     /</span>
<span class="sd">                 |    |                |    |</span>
<span class="sd">                 |  - | h(x) dx        |    | g(y) dy</span>
<span class="sd">                 |    |                |    |</span>
<span class="sd">                 |   /                 |   /</span>
<span class="sd">        C1 + C2* | e            dx +   |  e           dy = 0</span>
<span class="sd">                 |                     |</span>
<span class="sd">                /                     /</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(diff(f(x), x, x) + diff(f(x), x)**2/f(x) +</span>
<span class="sd">    ... diff(f(x), x)/x, f(x), hint=&#39;Liouville&#39;))</span>
<span class="sd">               ________________           ________________</span>
<span class="sd">    [f(x) = -\/ C1 + C2*log(x) , f(x) = \/ C1 + C2*log(x) ]</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Goldstein and Braun, &quot;Advanced Methods for the Solution of Differential</span>
<span class="sd">      Equations&quot;, pp. 98</span>
<span class="sd">    - http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Liouville ODE:</span>
    <span class="c">#  f(x).diff(x, 2) + g(f(x))*(f(x).diff(x, 2))**2 + h(x)*f(x).diff(x)</span>
    <span class="c"># See Goldstein and Braun, &quot;Advanced Methods for the Solution of</span>
    <span class="c"># Differential Equations&quot;, pg. 98, as well as</span>
    <span class="c"># http://www.maplesoft.com/support/help/view.aspx?path=odeadvisor/Liouville</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># f(x).diff(x, 2) + g*f(x).diff(x)**2 + h*f(x).diff(x)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C2&#39;</span><span class="p">)</span>
    <span class="nb">int</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">],</span> <span class="n">y</span><span class="p">)),</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="nb">int</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;h&#39;</span><span class="p">],</span> <span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sol</span>

</div>
<span class="k">def</span> <span class="nf">_nth_linear_match</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Matches a differential equation to the linear form:</span>

<span class="sd">    .. math:: a_n(x) y^{(n)} + \cdots + a_1(x)y&#39; + a_0(x) y + B(x) = 0</span>

<span class="sd">    Returns a dict of order:coeff terms, where order is the order of the</span>
<span class="sd">    derivative on each term, and coeff is the coefficient of that derivative.</span>
<span class="sd">    The key ``-1`` holds the function `B(x)`. Returns ``None`` if the ODE is</span>
<span class="sd">    not linear.  This function assumes that ``func`` has already been checked</span>
<span class="sd">    to be good.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, cos, sin</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import _nth_linear_match</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _nth_linear_match(f(x).diff(x, 3) + 2*f(x).diff(x) +</span>
<span class="sd">    ... x*f(x).diff(x, 2) + cos(x)*f(x).diff(x) + x - f(x) -</span>
<span class="sd">    ... sin(x), f(x), 3)</span>
<span class="sd">    {-1: x - sin(x), 0: -1, 1: cos(x) + 2, 2: x, 3: 1}</span>
<span class="sd">    &gt;&gt;&gt; _nth_linear_match(f(x).diff(x, 3) + 2*f(x).diff(x) +</span>
<span class="sd">    ... x*f(x).diff(x, 2) + cos(x)*f(x).diff(x) + x - f(x) -</span>
<span class="sd">    ... sin(f(x)), f(x), 3) == None</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">one_x</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">])</span>
    <span class="n">terms</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="n">terms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">==</span> <span class="n">one_x</span><span class="p">)</span> \
                    <span class="ow">or</span> <span class="n">f</span> <span class="o">==</span> <span class="n">func</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">terms</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span> <span class="o">+=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">terms</span>


<span class="k">def</span> <span class="nf">ode_nth_linear_euler_eq_homogeneous</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">returns</span><span class="o">=</span><span class="s">&#39;sol&#39;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an `n`\th order linear homogeneous variable-coefficient</span>
<span class="sd">    Cauchy-Euler equidimensional ordinary differential equation.</span>

<span class="sd">    This is an equation with form `0 = a_0 f(x) + a_1 x f&#39;(x) + a_2 x^2 f&#39;&#39;(x)</span>
<span class="sd">    \cdots`.</span>

<span class="sd">    These equations can be solved in a general manner, by substituting</span>
<span class="sd">    solutions of the form `f(x) = x^r`, and deriving a characteristic equation</span>
<span class="sd">    for `r`.  When there are repeated roots, we include extra terms of the</span>
<span class="sd">    form `C_{r k} \ln^k(x) x^r`, where `C_{r k}` is an arbitrary integration</span>
<span class="sd">    constant, `r` is a root of the characteristic equation, and `k` ranges</span>
<span class="sd">    over the multiplicity of `r`.  In the cases where the roots are complex,</span>
<span class="sd">    solutions of the form `C_1 x^a \sin(b \log(x)) + C_2 x^a \cos(b \log(x))`</span>
<span class="sd">    are returned, based on expansions with Eulers formula.  The general</span>
<span class="sd">    solution is the sum of the terms found.  If SymPy cannot find exact roots</span>
<span class="sd">    to the characteristic equation, a</span>
<span class="sd">    :py:class:`~sympy.polys.rootoftools.RootOf` instance will be returned</span>
<span class="sd">    instead.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(4*x**2*f(x).diff(x, 2) + f(x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_euler_eq_homogeneous&#39;)</span>
<span class="sd">    ... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        f(x) == sqrt(x)*(C1 + C2*log(x))</span>

<span class="sd">    Note that because this method does not involve integration, there is no</span>
<span class="sd">    ``nth_linear_euler_eq_homogeneous_Integral`` hint.</span>

<span class="sd">    The following is for internal use:</span>

<span class="sd">    - ``returns = &#39;sol&#39;`` returns the solution to the ODE.</span>
<span class="sd">    - ``returns = &#39;list&#39;`` returns a list of linearly independent solutions,</span>
<span class="sd">      corresponding to the fundamental solution set, for use with non</span>
<span class="sd">      homogeneous solution methods like variation of parameters and</span>
<span class="sd">      undetermined coefficients.  Note that, though the solutions should be</span>
<span class="sd">      linearly independent, this function does not explicitly check that.  You</span>
<span class="sd">      can do ``assert simplify(wronskian(sollist)) != 0`` to check for linear</span>
<span class="sd">      independence.  Also, ``assert len(sollist) == order`` will need to pass.</span>
<span class="sd">    - ``returns = &#39;both&#39;``, return a dictionary ``{&#39;sol&#39;: &lt;solution to ODE&gt;,</span>
<span class="sd">      &#39;list&#39;: &lt;list of linearly independent solutions&gt;}``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; eq = f(x).diff(x, 2)*x**2 - 4*f(x).diff(x)*x + 6*f(x)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(eq, f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_euler_eq_homogeneous&#39;))</span>
<span class="sd">            2</span>
<span class="sd">    f(x) = x *(C1 + C2*x)</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation</span>
<span class="sd">    - C. Bender &amp; S. Orszag, &quot;Advanced Mathematical Methods for Scientists and</span>
<span class="sd">      Engineers&quot;, Springer 1999, pp. 12</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">collectterms</span>
    <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>

    <span class="c"># A generator of constants</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># First, set up characteristic equation.</span>
    <span class="n">chareq</span><span class="p">,</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">chareq</span> <span class="o">+=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">symbol</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**-</span><span class="n">symbol</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>

    <span class="n">chareq</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">chareq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
    <span class="n">chareqroots</span> <span class="o">=</span> <span class="p">[</span><span class="n">RootOf</span><span class="p">(</span><span class="n">chareq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">chareq</span><span class="o">.</span><span class="n">degree</span><span class="p">())]</span>

    <span class="c"># Create a dict root: multiplicity or charroots</span>
    <span class="n">charroots</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">chareqroots</span><span class="p">:</span>
        <span class="n">charroots</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">gsol</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c"># We need keep track of terms so we can run collect() at the end.</span>
    <span class="c"># This is necessary for constantsimp to work properly.</span>
    <span class="n">ln</span> <span class="o">=</span> <span class="n">log</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="ow">in</span> <span class="n">charroots</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">):</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">root</span><span class="p">)</span><span class="o">*</span><span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">multiplicity</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
            <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">root</span><span class="p">)</span><span class="o">*</span><span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reroot</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">imroot</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">reroot</span><span class="p">)</span><span class="o">*</span><span class="p">(</span>
                    <span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="o">+</span> <span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
                <span class="c"># Preserve ordering (multiplicity, real part, imaginary part)</span>
                <span class="c"># It will be assumed implicitly when constructing</span>
                <span class="c"># fundamental solution sets.</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
    <span class="k">if</span> <span class="n">returns</span> <span class="o">==</span> <span class="s">&#39;sol&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">returns</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;list&#39;</span> <span class="s">&#39;both&#39;</span><span class="p">):</span>
        <span class="c"># HOW TO TEST THIS CODE? (dsolve does not pass &#39;returns&#39; through)</span>
        <span class="c"># Create a list of (hopefully) linearly independent solutions</span>
        <span class="n">gensols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Keep track of when to use sin or cos for nonzero imroot</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">imroot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">reroot</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sin_form</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">reroot</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">sin_form</span> <span class="ow">in</span> <span class="n">gensols</span><span class="p">:</span>
                    <span class="n">cos_form</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">reroot</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                    <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cos_form</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sin_form</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">returns</span> <span class="o">==</span> <span class="s">&#39;list&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gensols</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s">&#39;sol&#39;</span><span class="p">:</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="p">),</span> <span class="s">&#39;list&#39;</span><span class="p">:</span> <span class="n">gensols</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown value for key &quot;returns&quot;.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="ode_almost_linear"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_almost_linear">[docs]</a><span class="k">def</span> <span class="nf">ode_almost_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an almost-linear differential equation.</span>

<span class="sd">    The general form of an almost linear differential equation is</span>

<span class="sd">    .. math:: f(x) g(y) y + k(x) l(y) + m(x) = 0</span>
<span class="sd">                \text{where} l&#39;(y) = g(y)\text{.}</span>

<span class="sd">    This can be solved by substituting `l(y) = u(y)`.  Making the given</span>
<span class="sd">    substitution reduces it to a linear differential equation of the form `u&#39;</span>
<span class="sd">    + P(x) u + Q(x) = 0`.</span>

<span class="sd">    The general solution is</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, n</span>
<span class="sd">        &gt;&gt;&gt; f, g, k, l = map(Function, [&#39;f&#39;, &#39;g&#39;, &#39;k&#39;, &#39;l&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(f(x)*(l(y).diff(y)) + k(x)*l(y) + g(x))</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">             d</span>
<span class="sd">        f(x)*--(l(y)) + g(x) + k(x)*l(y) = 0</span>
<span class="sd">             dy</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, hint = &#39;almost_linear&#39;))</span>
<span class="sd">               /     //   -y*g(x)                  \\</span>
<span class="sd">               |     ||   --------     for k(x) = 0||</span>
<span class="sd">               |     ||     f(x)                   ||  -y*k(x)</span>
<span class="sd">               |     ||                            ||  --------</span>
<span class="sd">               |     ||       y*k(x)               ||    f(x)</span>
<span class="sd">        l(y) = |C1 + |&lt;       ------               ||*e</span>
<span class="sd">               |     ||        f(x)                ||</span>
<span class="sd">               |     ||-g(x)*e                     ||</span>
<span class="sd">               |     ||--------------   otherwise  ||</span>
<span class="sd">               |     ||     k(x)                   ||</span>
<span class="sd">               \     \\                            //</span>


<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :meth:`sympy.solvers.ode.ode_1st_linear`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, Derivative, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import dsolve, classify_ode</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d = f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; eq = x*d + x*f(x) + 1</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, f(x), hint=&#39;almost_linear&#39;)</span>
<span class="sd">    f(x) == (C1 - Ei(x))*exp(-x)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(eq, f(x), hint=&#39;almost_linear&#39;))</span>
<span class="sd">                         -x</span>
<span class="sd">    f(x) = (C1 - Ei(x))*e</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Joel Moses, &quot;Symbolic Integration - The Stormy Decade&quot;, Communications</span>
<span class="sd">      of the ACM, Volume 14, Number 8, August 1971, pp. 558</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Since ode_1st_linear has already been implemented, and the</span>
    <span class="c"># coefficients have been modified to the required form in</span>
    <span class="c"># classify_ode, just passing eq, func, order and match to</span>
    <span class="c"># ode_1st_linear will give the required output.</span>
    <span class="k">return</span> <span class="n">ode_1st_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">_linear_coeff_match</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Helper function to match hint ``linear_coefficients``.</span>

<span class="sd">    Matches the expression to the form `(a_1 x + b_1 f(x) + c_1)/(a_2 x + b_2</span>
<span class="sd">    f(x) + c_2)` where the following conditions hold:</span>

<span class="sd">    1. `a_1`, `b_1`, `c_1`, `a_2`, `b_2`, `c_2` are Rationals;</span>
<span class="sd">    2. `c_1` or `c_2` are not equal to zero;</span>
<span class="sd">    3. `a_2 b_1 - a_1 b_2` is not equal to zero.</span>

<span class="sd">    Return ``xarg``, ``yarg`` where</span>

<span class="sd">    1. ``xarg`` = `(b_2 c_1 - b_1 c_2)/(a_2 b_1 - a_1 b_2)`</span>
<span class="sd">    2. ``yarg`` = `(a_1 c_2 - a_2 c_1)/(a_2 b_1 - a_1 b_2)`</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import _linear_coeff_match</span>
<span class="sd">    &gt;&gt;&gt; from sympy.functions.elementary.trigonometric import sin</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; _linear_coeff_match((</span>
<span class="sd">    ... (-25*f(x) - 8*x + 62)/(4*f(x) + 11*x - 11)), f(x))</span>
<span class="sd">    (1/9, 22/9)</span>
<span class="sd">    &gt;&gt;&gt; _linear_coeff_match(</span>
<span class="sd">    ... sin((-5*f(x) - 8*x + 6)/(4*f(x) + x - 1)), f(x))</span>
<span class="sd">    (19/27, 2/27)</span>
<span class="sd">    &gt;&gt;&gt; _linear_coeff_match(sin(f(x)/x), f(x))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">abc</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">        Internal function of _linear_coeff_match</span>
<span class="sd">        that returns Rationals a, b, c</span>
<span class="sd">        if eq is a*x + b*f(x) + c, else None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">as_Add</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">eq</span> <span class="o">==</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="sd">r&#39;&#39;&#39;</span>
<span class="sd">        Internal function of _linear_coeff_match that returns Rationals a1,</span>
<span class="sd">        b1, c1, a2, b2, c2 and a2*b1 - a1*b2 of the expression (a1*x + b1*f(x)</span>
<span class="sd">        + c1)/(a2*x + b2*f(x) + c2) if one of c1 or c2 and a2*b1 - a1*b2 is</span>
<span class="sd">        non-zero, else None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">together</span><span class="p">()</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">abc</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">abc</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">a2</span><span class="o">*</span><span class="n">b1</span> <span class="o">-</span> <span class="n">a1</span><span class="o">*</span><span class="n">b2</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">c1</span> <span class="ow">or</span> <span class="n">c2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">d</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">d</span>

    <span class="n">m</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span> <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">func</span> <span class="o">!=</span> <span class="n">f</span> <span class="ow">and</span>
         <span class="n">fi</span><span class="o">.</span><span class="n">nargs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">fi</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Function</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">([</span><span class="n">expr</span><span class="p">])</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">match</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">m1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span> <span class="o">==</span> <span class="n">m1</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">m</span><span class="p">):</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">m1</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">b2</span><span class="o">*</span><span class="n">c1</span> <span class="o">-</span> <span class="n">b1</span><span class="o">*</span><span class="n">c2</span><span class="p">)</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="o">*</span><span class="n">c2</span> <span class="o">-</span> <span class="n">a2</span><span class="o">*</span><span class="n">c1</span><span class="p">)</span><span class="o">/</span><span class="n">denom</span>

<div class="viewcode-block" id="ode_linear_coefficients"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_linear_coefficients">[docs]</a><span class="k">def</span> <span class="nf">ode_linear_coefficients</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves a differential equation with linear coefficients.</span>

<span class="sd">    The general form of a differential equation with linear coefficients is</span>

<span class="sd">    .. math:: y&#39; + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y +</span>
<span class="sd">                c_2}\!\right) = 0\text{,}</span>

<span class="sd">    where `a_1`, `b_1`, `c_1`, `a_2`, `b_2`, `c_2` are constants and `a_1 b_2</span>
<span class="sd">    - a_2 b_1 \ne 0`.</span>

<span class="sd">    This can be solved by substituting:</span>

<span class="sd">    .. math:: x = x&#39; + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1 b_2}</span>

<span class="sd">              y = y&#39; + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1</span>
<span class="sd">                  b_2}\text{.}</span>

<span class="sd">    This substitution reduces the equation to a homogeneous differential</span>
<span class="sd">    equation.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :meth:`sympy.solvers.ode.ode_1st_homogeneous_coeff_best`</span>
<span class="sd">    :meth:`sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep`</span>
<span class="sd">    :meth:`sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, Derivative, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import dsolve, classify_ode</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; df = f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; eq = (x + f(x) + 1)*df + (f(x) - 6*x + 1)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, hint=&#39;linear_coefficients&#39;)</span>
<span class="sd">    [f(x) == -x - sqrt(C1 + 7*x**2) - 1, f(x) == -x + sqrt(C1 + 7*x**2) - 1]</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(eq, hint=&#39;linear_coefficients&#39;))</span>
<span class="sd">                      ___________                     ___________</span>
<span class="sd">                   /         2                     /         2</span>
<span class="sd">    [f(x) = -x - \/  C1 + 7*x   - 1, f(x) = -x + \/  C1 + 7*x   - 1]</span>


<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Joel Moses, &quot;Symbolic Integration - The Stormy Decade&quot;, Communications</span>
<span class="sd">      of the ACM, Volume 14, Number 8, August 1971, pp. 558</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">ode_1st_homogeneous_coeff_best</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_separable_reduced"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_separable_reduced">[docs]</a><span class="k">def</span> <span class="nf">ode_separable_reduced</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves a differential equation that can be reduced to the separable form.</span>

<span class="sd">    The general form of this equation is</span>

<span class="sd">    .. math:: y&#39; + (y/x) H(x^n y) = 0\text{}.</span>

<span class="sd">    This can be solved by substituting `u(y) = x^n y`.  The equation then</span>
<span class="sd">    reduces to the separable form `\frac{u&#39;}{u (\mathrm{power} - H(u))} -</span>
<span class="sd">    \frac{1}{x} = 0`.</span>

<span class="sd">    The general solution is:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, n</span>
<span class="sd">        &gt;&gt;&gt; f, g = map(Function, [&#39;f&#39;, &#39;g&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = f(x).diff(x) + (f(x)/x)*g(x**n*f(x))</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                         / n     \</span>
<span class="sd">        d          f(x)*g\x *f(x)/</span>
<span class="sd">        --(f(x)) + ---------------</span>
<span class="sd">        dx                x</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, hint=&#39;separable_reduced&#39;))</span>
<span class="sd">         n</span>
<span class="sd">        x *f(x)</span>
<span class="sd">          /</span>
<span class="sd">         |</span>
<span class="sd">         |         1</span>
<span class="sd">         |    ------------ dy = C1 + log(x)</span>
<span class="sd">         |    y*(n - g(y))</span>
<span class="sd">         |</span>
<span class="sd">         /</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    :meth:`sympy.solvers.ode.ode_separable`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, Derivative, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import dsolve, classify_ode</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d = f(x).diff(x)</span>
<span class="sd">    &gt;&gt;&gt; eq = (x - x**2*f(x))*d - f(x)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(eq, hint=&#39;separable_reduced&#39;)</span>
<span class="sd">    [f(x) == (-sqrt(C1*x**2 + 1) + 1)/x, f(x) == (sqrt(C1*x**2 + 1) + 1)/x]</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(eq, hint=&#39;separable_reduced&#39;))</span>
<span class="sd">                 ___________                ___________</span>
<span class="sd">                /     2                    /     2</span>
<span class="sd">            - \/  C1*x  + 1  + 1         \/  C1*x  + 1  + 1</span>
<span class="sd">    [f(x) = --------------------, f(x) = ------------------]</span>
<span class="sd">                     x                           x</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Joel Moses, &quot;Symbolic Integration - The Stormy Decade&quot;, Communications</span>
<span class="sd">      of the ACM, Volume 14, Number 8, August 1971, pp. 558</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Arguments are passed in a way so that they are coherent with the</span>
    <span class="c"># ode_separable function</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">match</span><span class="p">[</span><span class="s">&#39;u&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">ycoeff</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="s">&#39;power&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">))</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;coeff&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span> <span class="n">ycoeff</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;coeff&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;m1&#39;</span><span class="p">:</span> <span class="n">m1</span><span class="p">,</span> <span class="s">&#39;m2&#39;</span><span class="p">:</span> <span class="n">m2</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">:</span> <span class="n">y</span><span class="p">,</span> <span class="s">&#39;hint&#39;</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="n">match</span><span class="p">[</span><span class="s">&#39;power&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">ode_separable</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ode_nth_linear_constant_coeff_homogeneous"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous">[docs]</a><span class="k">def</span> <span class="nf">ode_nth_linear_constant_coeff_homogeneous</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
        <span class="n">returns</span><span class="o">=</span><span class="s">&#39;sol&#39;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an `n`\th order linear homogeneous differential equation with</span>
<span class="sd">    constant coefficients.</span>

<span class="sd">    This is an equation of the form</span>

<span class="sd">    .. math:: a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f&#39;(x)</span>
<span class="sd">                + a_0 f(x) = 0\text{.}</span>

<span class="sd">    These equations can be solved in a general manner, by taking the roots of</span>
<span class="sd">    the characteristic equation `a_n m^n + a_{n-1} m^{n-1} + \cdots + a_1 m +</span>
<span class="sd">    a_0 = 0`.  The solution will then be the sum of `C_n x^i e^{r x}` terms,</span>
<span class="sd">    for each where `C_n` is an arbitrary constant, `r` is a root of the</span>
<span class="sd">    characteristic equation and `i` is one of each from 0 to the multiplicity</span>
<span class="sd">    of the root - 1 (for example, a root 3 of multiplicity 2 would create the</span>
<span class="sd">    terms `C_1 e^{3 x} + C_2 x e^{3 x}`).  The exponential is usually expanded</span>
<span class="sd">    for complex roots using Euler&#39;s equation `e{I x} = \cos(x) + I \sin(x)`.</span>
<span class="sd">    Complex roots always come in conjugate pairs in polynomials with real</span>
<span class="sd">    coefficients, so the two roots will be represented (after simplifying the</span>
<span class="sd">    constants) as `e^{a x} \left(C_1 \cos(b x) + C_2 \sin(b x)\right)`.</span>

<span class="sd">    If SymPy cannot find exact roots to the characteristic equation, a</span>
<span class="sd">    :py:class:`~sympy.polys.rootoftools.RootOf` instance will be return</span>
<span class="sd">    instead.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dsolve(f(x).diff(x, 5) + 10*f(x).diff(x) - 2*f(x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_constant_coeff_homogeneous&#39;)</span>
<span class="sd">    ... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    f(x) == C1*exp(x*RootOf(_x**5 + 10*_x - 2, 0)) +</span>
<span class="sd">    C2*exp(x*RootOf(_x**5 + 10*_x - 2, 1)) +</span>
<span class="sd">    C3*exp(x*RootOf(_x**5 + 10*_x - 2, 2)) +</span>
<span class="sd">    C4*exp(x*RootOf(_x**5 + 10*_x - 2, 3)) +</span>
<span class="sd">    C5*exp(x*RootOf(_x**5 + 10*_x - 2, 4))</span>

<span class="sd">    Note that because this method does not involve integration, there is no</span>
<span class="sd">    ``nth_linear_constant_coeff_homogeneous_Integral`` hint.</span>

<span class="sd">    The following is for internal use:</span>

<span class="sd">    - ``returns = &#39;sol&#39;`` returns the solution to the ODE.</span>
<span class="sd">    - ``returns = &#39;list&#39;`` returns a list of linearly independent solutions,</span>
<span class="sd">      for use with non homogeneous solution methods like variation of</span>
<span class="sd">      parameters and undetermined coefficients.  Note that, though the</span>
<span class="sd">      solutions should be linearly independent, this function does not</span>
<span class="sd">      explicitly check that.  You can do ``assert simplify(wronskian(sollist))</span>
<span class="sd">      != 0`` to check for linear independence.  Also, ``assert len(sollist) ==</span>
<span class="sd">      order`` will need to pass.</span>
<span class="sd">    - ``returns = &#39;both&#39;``, return a dictionary ``{&#39;sol&#39;: &lt;solution to ODE&gt;,</span>
<span class="sd">      &#39;list&#39;: &lt;list of linearly independent solutions&gt;}``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(f(x).diff(x, 4) + 2*f(x).diff(x, 3) -</span>
<span class="sd">    ... 2*f(x).diff(x, 2) - 6*f(x).diff(x) + 5*f(x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_constant_coeff_homogeneous&#39;))</span>
<span class="sd">                        x                            -2*x</span>
<span class="sd">    f(x) = (C1 + C2*x)*e  + (C3*sin(x) + C4*cos(x))*e</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Linear_differential_equation section:</span>
<span class="sd">      Nonhomogeneous_equation_with_constant_coefficients</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 211</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>

    <span class="c"># A generator of constants</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># First, set up characteristic equation.</span>
    <span class="n">chareq</span><span class="p">,</span> <span class="n">symbol</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chareq</span> <span class="o">+=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">symbol</span><span class="o">**</span><span class="n">i</span>

    <span class="n">chareq</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">chareq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
    <span class="n">chareqroots</span> <span class="o">=</span> <span class="p">[</span> <span class="n">RootOf</span><span class="p">(</span><span class="n">chareq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">chareq</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span> <span class="p">]</span>

    <span class="c"># Create a dict root: multiplicity or charroots</span>
    <span class="n">charroots</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">chareqroots</span><span class="p">:</span>
        <span class="n">charroots</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">gsol</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c"># We need keep track of terms so we can run collect() at the end.</span>
    <span class="c"># This is necessary for constantsimp to work properly.</span>
    <span class="k">global</span> <span class="n">collectterms</span>
    <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">multiplicity</span> <span class="ow">in</span> <span class="n">charroots</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multiplicity</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">):</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">(</span><span class="n">root</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">multiplicity</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reroot</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">imroot</span> <span class="o">=</span> <span class="n">im</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">gsol</span> <span class="o">+=</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">constants</span><span class="o">.</span><span class="n">next</span><span class="p">()</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
                <span class="c"># This ordering is important</span>
                <span class="n">collectterms</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span><span class="p">)]</span> <span class="o">+</span> <span class="n">collectterms</span>
    <span class="k">if</span> <span class="n">returns</span> <span class="o">==</span> <span class="s">&#39;sol&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">returns</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;list&#39;</span> <span class="s">&#39;both&#39;</span><span class="p">):</span>
        <span class="c"># Create a list of (hopefully) linearly independent solutions</span>
        <span class="n">gensols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c"># Keep track of when to use sin or cos for nonzero imroot</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">imroot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">gensols</span><span class="p">:</span>
                    <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gensols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">returns</span> <span class="o">==</span> <span class="s">&#39;list&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gensols</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s">&#39;sol&#39;</span><span class="p">:</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="p">),</span> <span class="s">&#39;list&#39;</span><span class="p">:</span> <span class="n">gensols</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Unknown value for key &quot;returns&quot;.&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ode_nth_linear_constant_coeff_undetermined_coefficients"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients">[docs]</a><span class="k">def</span> <span class="nf">ode_nth_linear_constant_coeff_undetermined_coefficients</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an `n`\th order linear differential equation with constant</span>
<span class="sd">    coefficients using the method of undetermined coefficients.</span>

<span class="sd">    This method works on differential equations of the form</span>

<span class="sd">    .. math:: a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f&#39;(x)</span>
<span class="sd">                + a_0 f(x) = P(x)\text{,}</span>

<span class="sd">    where `P(x)` is a function that has a finite number of linearly</span>
<span class="sd">    independent derivatives.</span>

<span class="sd">    Functions that fit this requirement are finite sums functions of the form</span>
<span class="sd">    `a x^i e^{b x} \sin(c x + d)` or `a x^i e^{b x} \cos(c x + d)`, where `i`</span>
<span class="sd">    is a non-negative integer and `a`, `b`, `c`, and `d` are constants.  For</span>
<span class="sd">    example any polynomial in `x`, functions like `x^2 e^{2 x}`, `x \sin(x)`,</span>
<span class="sd">    and `e^x \cos(x)` can all be used.  Products of `\sin`&#39;s and `\cos`&#39;s have</span>
<span class="sd">    a finite number of derivatives, because they can be expanded into `\sin(a</span>
<span class="sd">    x)` and `\cos(b x)` terms.  However, SymPy currently cannot do that</span>
<span class="sd">    expansion, so you will need to manually rewrite the expression in terms of</span>
<span class="sd">    the above to use this method.  So, for example, you will need to manually</span>
<span class="sd">    convert `\sin^2(x)` into `(1 + \cos(2 x))/2` to properly apply the method</span>
<span class="sd">    of undetermined coefficients on it.</span>

<span class="sd">    This method works by creating a trial function from the expression and all</span>
<span class="sd">    of its linear independent derivatives and substituting them into the</span>
<span class="sd">    original ODE.  The coefficients for each term will be a system of linear</span>
<span class="sd">    equations, which are be solved for and substituted, giving the solution.</span>
<span class="sd">    If any of the trial functions are linearly dependent on the solution to</span>
<span class="sd">    the homogeneous equation, they are multiplied by sufficient `x` to make</span>
<span class="sd">    them linearly independent.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint, exp, cos</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(f(x).diff(x, 2) + 2*f(x).diff(x) + f(x) -</span>
<span class="sd">    ... 4*exp(-x)*x**2 + cos(2*x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;))</span>
<span class="sd">           /             4\</span>
<span class="sd">           |            x |  -x   4*sin(2*x)   3*cos(2*x)</span>
<span class="sd">    f(x) = |C1 + C2*x + --|*e   - ---------- + ----------</span>
<span class="sd">           \            3 /           25           25</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 221</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gensol</span> <span class="o">=</span> <span class="n">ode_nth_linear_constant_coeff_homogeneous</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
        <span class="n">returns</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">)</span>
    <span class="n">match</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gensol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_solve_undetermined_coefficients</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_solve_undetermined_coefficients</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Helper function for the method of undetermined coefficients.</span>

<span class="sd">    See the</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients`</span>
<span class="sd">    docstring for more information on this method.</span>

<span class="sd">    The parameter ``match`` should be a dictionary that has the following</span>
<span class="sd">    keys:</span>

<span class="sd">    ``list``</span>
<span class="sd">      A list of solutions to the homogeneous equation, such as the list</span>
<span class="sd">      returned by</span>
<span class="sd">      ``ode_nth_linear_constant_coeff_homogeneous(returns=&#39;list&#39;)``.</span>

<span class="sd">    ``sol``</span>
<span class="sd">      The general solution, such as the solution returned by</span>
<span class="sd">      ``ode_nth_linear_constant_coeff_homogeneous(returns=&#39;sol&#39;)``.</span>

<span class="sd">    ``trialset``</span>
<span class="sd">      The set of trial functions as returned by</span>
<span class="sd">      ``_undetermined_coefficients_match()[&#39;trialset&#39;]``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">numbered_symbols</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Dummy</span><span class="p">)</span>
    <span class="n">coefflist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gensols</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;list&#39;</span><span class="p">]</span>
    <span class="n">gsol</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;sol&#39;</span><span class="p">]</span>
    <span class="n">trialset</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;trialset&#39;</span><span class="p">]</span>
    <span class="n">notneedset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="n">newtrialset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="k">global</span> <span class="n">collectterms</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gensols</span><span class="p">)</span> <span class="o">!=</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Cannot find &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">+</span>
        <span class="s">&quot; solutions to the homogeneous equation nessesary to apply&quot;</span> <span class="o">+</span>
        <span class="s">&quot; undetermined coefficients to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">+</span>
        <span class="s">&quot; (number of terms != order)&quot;</span><span class="p">)</span>
    <span class="n">usedsin</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="n">mult</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># The multiplicity of the root</span>
    <span class="n">getmult</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">,</span> <span class="n">imroot</span> <span class="ow">in</span> <span class="n">collectterms</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">getmult</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">getmult</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">getmult</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">imroot</span><span class="p">:</span>
            <span class="c"># Alternate between sin and cos</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">)</span> <span class="ow">in</span> <span class="n">usedsin</span><span class="p">:</span>
                <span class="n">check</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">imroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">check</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">imroot</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
                <span class="n">usedsin</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">reroot</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">reroot</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check</span> <span class="ow">in</span> <span class="n">trialset</span><span class="p">:</span>
            <span class="c"># If an element of the trial function is already part of the</span>
            <span class="c"># homogeneous solution, we need to multiply by sufficient x to</span>
            <span class="c"># make it linearly independent.  We also don&#39;t need to bother</span>
            <span class="c"># checking for the coefficients on those elements, since we</span>
            <span class="c"># already know it will be 0.</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">check</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">mult</span> <span class="ow">in</span> <span class="n">trialset</span><span class="p">:</span>
                    <span class="n">mult</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">trialset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">check</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">mult</span><span class="p">)</span>
            <span class="n">notneedset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>

    <span class="n">newtrialset</span> <span class="o">=</span> <span class="n">trialset</span> <span class="o">-</span> <span class="n">notneedset</span>

    <span class="n">trialfunc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">newtrialset</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">coefflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">trialfunc</span> <span class="o">+=</span> <span class="n">c</span><span class="o">*</span><span class="n">i</span>

    <span class="n">eqs</span> <span class="o">=</span> <span class="n">sub_func_doit</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">trialfunc</span><span class="p">)</span>

    <span class="n">coeffsdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">trialset</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trialset</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="n">eqs</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">eqs</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">coeffsdict</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span>

    <span class="n">coeffvals</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">coeffsdict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">coefflist</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffvals</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s">&quot;Could not solve `</span><span class="si">%s</span><span class="s">` using the &quot;</span>
            <span class="s">&quot;method of undetermined coefficients &quot;</span>
            <span class="s">&quot;(unable to solve for coefficients).&quot;</span> <span class="o">%</span> <span class="n">eq</span><span class="p">)</span>

    <span class="n">psol</span> <span class="o">=</span> <span class="n">trialfunc</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">coeffvals</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">+</span> <span class="n">psol</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_undetermined_coefficients_match</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Returns a trial function match if undetermined coefficients can be applied</span>
<span class="sd">    to ``expr``, and ``None`` otherwise.</span>

<span class="sd">    A trial expression can be found for an expression for use with the method</span>
<span class="sd">    of undetermined coefficients if the expression is an</span>
<span class="sd">    additive/multiplicative combination of constants, polynomials in `x` (the</span>
<span class="sd">    independent variable of expr), `\sin(a x + b)`, `\cos(a x + b)`, and</span>
<span class="sd">    `e^{a x}` terms (in other words, it has a finite number of linearly</span>
<span class="sd">    independent derivatives).</span>

<span class="sd">    Note that you may still need to multiply each term returned here by</span>
<span class="sd">    sufficient `x` to make it linearly independent with the solutions to the</span>
<span class="sd">    homogeneous equation.</span>

<span class="sd">    This is intended for internal use by ``undetermined_coefficients`` hints.</span>

<span class="sd">    SymPy currently has no way to convert `\sin^n(x) \cos^m(y)` into a sum of</span>
<span class="sd">    only `\sin(a x)` and `\cos(b x)` terms, so these are not implemented.  So,</span>
<span class="sd">    for example, you will need to manually convert `\sin^2(x)` into `[1 +</span>
<span class="sd">    \cos(2 x)]/2` to properly apply the method of undetermined coefficients on</span>
<span class="sd">    it.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import log, exp</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import _undetermined_coefficients_match</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; _undetermined_coefficients_match(9*x*exp(x) + exp(-x), x)</span>
<span class="sd">    {&#39;test&#39;: True, &#39;trialset&#39;: set([x*exp(x), exp(-x), exp(x)])}</span>
<span class="sd">    &gt;&gt;&gt; _undetermined_coefficients_match(log(x), x)</span>
<span class="sd">    {&#39;test&#39;: False}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">)</span>  <span class="c"># exp(x)*exp(2*x + 1) =&gt; exp(3*x + 1)</span>
    <span class="n">retdict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_test_term</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Test if ``expr`` fits the proper form for undetermined coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">_test_term</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">):</span>
                <span class="n">foundtrig</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="c"># Make sure that there is only one trig function in the args.</span>
                <span class="c"># See the docstring.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">foundtrig</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">foundtrig</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">_test_term</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span> <span class="ow">in</span> <span class="p">(</span><span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> \
                <span class="n">expr</span><span class="o">.</span><span class="n">exp</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_get_trial_set</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">exprs</span><span class="o">=</span><span class="nb">set</span><span class="p">([])):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Returns a set of trial terms for undetermined coefficients.</span>

<span class="sd">        The idea behind undetermined coefficients is that the terms expression</span>
<span class="sd">        repeat themselves after a finite number of derivatives, except for the</span>
<span class="sd">        coefficients (they are linearly dependent).  So if we collect these,</span>
<span class="sd">        we should have the terms of our trial function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_remove_coefficient</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">            Returns the expression without a coefficient.</span>

<span class="sd">            Similar to expr.as_independent(x)[1], except it only works</span>
<span class="sd">            multiplicatively.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c"># I was using the below match, but it doesn&#39;t always put all of the</span>
            <span class="c"># coefficient in c.  c.f. 2**x*6*exp(x)*log(2)</span>
            <span class="c"># The below code is probably cleaner anyway.</span>
<span class="c">#            c = Wild(&#39;c&#39;, exclude=[x])</span>
<span class="c">#            t = Wild(&#39;t&#39;)</span>
<span class="c">#            r = expr.match(c*t)</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                        <span class="n">term</span> <span class="o">*=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">expr</span>
            <span class="k">return</span> <span class="n">term</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_remove_coefficient</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exprs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">_remove_coefficient</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                    <span class="n">exprs</span> <span class="o">=</span> <span class="n">exprs</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">_get_trial_set</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">exprs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">_remove_coefficient</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">tmpset</span> <span class="o">=</span> <span class="n">exprs</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">term</span><span class="p">]))</span>
            <span class="n">oldset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">while</span> <span class="n">tmpset</span> <span class="o">!=</span> <span class="n">oldset</span><span class="p">:</span>
                <span class="c"># If you get stuck in this loop, then _test_term is probably</span>
                <span class="c"># broken</span>
                <span class="n">oldset</span> <span class="o">=</span> <span class="n">tmpset</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">_remove_coefficient</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="n">tmpset</span> <span class="o">=</span> <span class="n">tmpset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">_get_trial_set</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">tmpset</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmpset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="n">tmpset</span>
        <span class="k">return</span> <span class="n">exprs</span>

    <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_test_term</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;test&#39;</span><span class="p">]:</span>
        <span class="c"># Try to generate a list of trial solutions that will have the</span>
        <span class="c"># undetermined coefficients. Note that if any of these are not linearly</span>
        <span class="c"># independent with any of the solutions to the homogeneous equation,</span>
        <span class="c"># then they will need to be multiplied by sufficient x to make them so.</span>
        <span class="c"># This function DOES NOT do that (it doesn&#39;t even look at the</span>
        <span class="c"># homogeneous equation).</span>
        <span class="n">retdict</span><span class="p">[</span><span class="s">&#39;trialset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_trial_set</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">retdict</span>


<div class="viewcode-block" id="ode_nth_linear_constant_coeff_variation_of_parameters"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters">[docs]</a><span class="k">def</span> <span class="nf">ode_nth_linear_constant_coeff_variation_of_parameters</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves an `n`\th order linear differential equation with constant</span>
<span class="sd">    coefficients using the method of variation of parameters.</span>

<span class="sd">    This method works on any differential equations of the form</span>

<span class="sd">    .. math:: f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f&#39;(x) + a_0</span>
<span class="sd">                f(x) = P(x)\text{.}</span>

<span class="sd">    This method works by assuming that the particular solution takes the form</span>

<span class="sd">    .. math:: \sum_{x=1}^{n} c_i(x) y_i(x)\text{,}</span>

<span class="sd">    where `y_i` is the `i`\th solution to the homogeneous equation.  The</span>
<span class="sd">    solution is then solved using Wronskian&#39;s and Cramer&#39;s Rule.  The</span>
<span class="sd">    particular solution is given by</span>

<span class="sd">    .. math:: \sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx</span>
<span class="sd">                \right) y_i(x) \text{,}</span>

<span class="sd">    where `W(x)` is the Wronskian of the fundamental system (the system of `n`</span>
<span class="sd">    linearly independent solutions to the homogeneous equation), and `W_i(x)`</span>
<span class="sd">    is the Wronskian of the fundamental system with the `i`\th column replaced</span>
<span class="sd">    with `[0, 0, \cdots, 0, P(x)]`.</span>

<span class="sd">    This method is general enough to solve any `n`\th order inhomogeneous</span>
<span class="sd">    linear differential equation with constant coefficients, but sometimes</span>
<span class="sd">    SymPy cannot simplify the Wronskian well enough to integrate it.  If this</span>
<span class="sd">    method hangs, try using the</span>
<span class="sd">    ``nth_linear_constant_coeff_variation_of_parameters_Integral`` hint and</span>
<span class="sd">    simplifying the integrals manually.  Also, prefer using</span>
<span class="sd">    ``nth_linear_constant_coeff_undetermined_coefficients`` when it</span>
<span class="sd">    applies, because it doesn&#39;t use integration, making it faster and more</span>
<span class="sd">    reliable.</span>

<span class="sd">    Warning, using simplify=False with</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters&#39; in</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.dsolve` may cause it to hang, because it will</span>
<span class="sd">    not attempt to simplify the Wronskian before integrating.  It is</span>
<span class="sd">    recommended that you only use simplify=False with</span>
<span class="sd">    &#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39; for this</span>
<span class="sd">    method, especially if the solution to the homogeneous equation has</span>
<span class="sd">    trigonometric functions in it.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, pprint, exp, log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(f(x).diff(x, 3) - 3*f(x).diff(x, 2) +</span>
<span class="sd">    ... 3*f(x).diff(x) - f(x) - exp(x)*log(x), f(x),</span>
<span class="sd">    ... hint=&#39;nth_linear_constant_coeff_variation_of_parameters&#39;))</span>
<span class="sd">           /                     3                \</span>
<span class="sd">           |                2   x *(6*log(x) - 11)|  x</span>
<span class="sd">    f(x) = |C1 + C2*x + C3*x  + ------------------|*e</span>
<span class="sd">           \                            36        /</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - http://en.wikipedia.org/wiki/Variation_of_parameters</span>
<span class="sd">    - http://planetmath.org/encyclopedia/VariationOfParameters.html</span>
<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 233</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">gensol</span> <span class="o">=</span> <span class="n">ode_nth_linear_constant_coeff_homogeneous</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
        <span class="n">returns</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">)</span>
    <span class="n">match</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">gensol</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_solve_variation_of_parameters</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_solve_variation_of_parameters</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Helper function for the method of variation of parameters.</span>

<span class="sd">    See the</span>
<span class="sd">    :py:meth:`~sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters`</span>
<span class="sd">    docstring for more information on this method.</span>

<span class="sd">    The parameter ``match`` should be a dictionary that has the following</span>
<span class="sd">    keys:</span>

<span class="sd">    ``list``</span>
<span class="sd">      A list of solutions to the homogeneous equation, such as the list</span>
<span class="sd">      returned by</span>
<span class="sd">      ``ode_nth_linear_constant_coeff_homogeneous(returns=&#39;list&#39;)``.</span>

<span class="sd">    ``sol``</span>
<span class="sd">      The general solution, such as the solution returned by</span>
<span class="sd">      ``ode_nth_linear_constant_coeff_homogeneous(returns=&#39;sol&#39;)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>
    <span class="n">psol</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">gensols</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;list&#39;</span><span class="p">]</span>
    <span class="n">gsol</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="s">&#39;sol&#39;</span><span class="p">]</span>
    <span class="n">wr</span> <span class="o">=</span> <span class="n">wronskian</span><span class="p">(</span><span class="n">gensols</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">wr</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">wr</span><span class="p">)</span>  <span class="c"># We need much better simplification for</span>
                           <span class="c"># some ODEs. See issue 1563, for example.</span>

        <span class="c"># To reduce commonly occuring sin(x)**2 + cos(x)**2 to 1</span>
        <span class="n">wr</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">wr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">wr</span><span class="p">:</span>
        <span class="c"># The wronskian will be 0 iff the solutions are not linearly</span>
        <span class="c"># independent.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Cannot find &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">+</span>
        <span class="s">&quot; solutions to the homogeneous equation nessesary to apply &quot;</span> <span class="o">+</span>
        <span class="s">&quot;variation of parameters to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; (Wronskian == 0)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gensols</span><span class="p">)</span> <span class="o">!=</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Cannot find &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">+</span>
        <span class="s">&quot; solutions to the homogeneous equation nessesary to apply &quot;</span> <span class="o">+</span>
        <span class="s">&quot;variation of parameters to &quot;</span> <span class="o">+</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot; (number of terms != order)&quot;</span><span class="p">)</span>
    <span class="n">negoneterm</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gensols</span><span class="p">:</span>
        <span class="n">psol</span> <span class="o">+=</span> <span class="n">negoneterm</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">wronskian</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">i</span><span class="p">,</span>
        <span class="n">gensols</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">wr</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">i</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="n">negoneterm</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">psol</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">psol</span><span class="p">)</span>
        <span class="n">psol</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">psol</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">gsol</span><span class="o">.</span><span class="n">rhs</span> <span class="o">+</span> <span class="n">psol</span><span class="p">)</span>


<div class="viewcode-block" id="ode_separable"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.ode_separable">[docs]</a><span class="k">def</span> <span class="nf">ode_separable</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solves separable 1st order differential equations.</span>

<span class="sd">    This is any differential equation that can be written as `P(y)</span>
<span class="sd">    \tfrac{dy}{dx} = Q(x)`.  The solution can then just be found by</span>
<span class="sd">    rearranging terms and integrating: `\int P(y) \,dy = \int Q(x) \,dx`.</span>
<span class="sd">    This hint uses :py:meth:`sympy.simplify.separatevars` as its back end, so</span>
<span class="sd">    if a separable equation is not caught by this solver, it is most likely</span>
<span class="sd">    the fault of that function.  :py:meth:`~sympy.simplify.separatevars` is</span>
<span class="sd">    smart enough to do most expansion and factoring necessary to convert a</span>
<span class="sd">    separable equation `F(x, y)` into the proper form `P(x)\cdot{}Q(y)`.  The</span>
<span class="sd">    general solution is::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, dsolve, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; a, b, c, d, f = map(Function, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;f&#39;])</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(a(x)*b(f(x))*f(x).diff(x), c(x)*d(f(x)))</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">                     d</span>
<span class="sd">        a(x)*b(f(x))*--(f(x)) = c(x)*d(f(x))</span>
<span class="sd">                     dx</span>
<span class="sd">        &gt;&gt;&gt; pprint(dsolve(genform, f(x), hint=&#39;separable_Integral&#39;))</span>
<span class="sd">             f(x)</span>
<span class="sd">           /                  /</span>
<span class="sd">          |                  |</span>
<span class="sd">          |  b(y)            | c(x)</span>
<span class="sd">          |  ---- dy = C1 +  | ---- dx</span>
<span class="sd">          |  d(y)            | a(x)</span>
<span class="sd">          |                  |</span>
<span class="sd">         /                  /</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, dsolve, Eq</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; pprint(dsolve(Eq(f(x)*f(x).diff(x) + x, 3*x*f(x)**2), f(x),</span>
<span class="sd">    ... hint=&#39;separable&#39;, simplify=False))</span>
<span class="sd">       /   2       \         2</span>
<span class="sd">    log\3*f (x) - 1/        x</span>
<span class="sd">    ---------------- = C1 + --</span>
<span class="sd">           6                2</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - M. Tenenbaum &amp; H. Pollard, &quot;Ordinary Differential Equations&quot;,</span>
<span class="sd">      Dover 1963, pp. 52</span>

<span class="sd">    # indirect doctest</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">func</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;C1&#39;</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">match</span>  <span class="c"># {&#39;m1&#39;:m1, &#39;m2&#39;:m2, &#39;y&#39;:y}</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;hint&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c"># get u from separable_reduced else get f(x)</span>
    <span class="k">return</span> <span class="n">Eq</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m2&#39;</span><span class="p">][</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m2&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m1&#39;</span><span class="p">][</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]],</span>
        <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">],</span> <span class="bp">None</span><span class="p">,</span> <span class="n">u</span><span class="p">)),</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m1&#39;</span><span class="p">][</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="s">&#39;m1&#39;</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">/</span>
        <span class="n">r</span><span class="p">[</span><span class="s">&#39;m2&#39;</span><span class="p">][</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">C1</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">checkinfsol</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">infinitesimals</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    This function is used to check if the given infinitesimals are the</span>
<span class="sd">    actual infinitesimals for the given first order differential equation.</span>
<span class="sd">    As of now, it simply checks, by substituting the infinitesimals in the</span>
<span class="sd">    partial differential equation.</span>
<span class="sd">    (eta.diff(x) + (eta.diff(y) - xi.diff(x))*h -</span>
<span class="sd">    (xi.diff(y))*h**2 - xi*(h.diff(x)) - eta*(h.diff(y))) = 0</span>
<span class="sd">    where eta, and xi are the infinitesimals and h(x,y) = dy/dx</span>

<span class="sd">    The infinitesimals should be given in the form of a list of dicts</span>
<span class="sd">    [{xi(x, y): inf, eta(x, y): inf}], corresponding to the</span>
<span class="sd">    output of the function infinitesimals. It returns a list</span>
<span class="sd">    of values of the form [(True/False, sol)] where sol is the value</span>
<span class="sd">    obtained after substituting the infinitesimals in the PDE. If it</span>
<span class="sd">    is True, then sol would be zero.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">func</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">_preprocess</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;ODE&#39;s have only one independent variable&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">ode_order</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Lie groups solver has been implemented &quot;</span>
            <span class="s">&quot;only for first order differential equations&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="p">])</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">eq</span><span class="p">),</span> <span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="o">-</span><span class="n">match</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">/</span><span class="n">match</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;xi&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;eta&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">dxi</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;xi&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="n">deta</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;eta&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="n">pde</span> <span class="o">=</span> <span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">h</span> <span class="o">-</span>
                <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xi</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
            <span class="n">soltup</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">infinitesimals</span><span class="p">:</span>
                <span class="n">tsol</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="n">S</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">dxi</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
                    <span class="n">eta</span><span class="p">:</span> <span class="n">S</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">deta</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">y</span><span class="p">)}</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">pde</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tsol</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">sol</span><span class="p">:</span>
                    <span class="n">soltup</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">False</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">soltup</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">soltup</span>

<div class="viewcode-block" id="infinitesimals"><a class="viewcode-back" href="../../../modules/solvers/ode.html#sympy.solvers.ode.infinitesimals">[docs]</a><span class="k">def</span> <span class="nf">infinitesimals</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The functions xi and eta, are called the infinitesimals which help in</span>
<span class="sd">    the process of finding a new co-ordinate system, in which a differential</span>
<span class="sd">    equation can be simplified. They are tangents to the coordinate curves, in</span>
<span class="sd">    which the differential equation is simplified.</span>

<span class="sd">    Consider the transformation (x, y) --&gt; (X, Y) such that X and Y are</span>
<span class="sd">    f(x, y, lambda) and g(x, y, lambda) and such that the</span>
<span class="sd">    differential equation remains invariant. Xi and eta are the tangents to</span>
<span class="sd">    the transformed coordinates X and Y, when lambda is the identity.</span>

<span class="sd">    The infinitesimals can be found by solving the following Partial Differential</span>
<span class="sd">    Equation.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Function, diff, Eq, pprint</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; xi, eta, h = map(Function, [&#39;xi&#39;, &#39;eta&#39;, &#39;h&#39;])</span>
<span class="sd">        &gt;&gt;&gt; h = h(x, y)  # dy/dx = h</span>
<span class="sd">        &gt;&gt;&gt; eta = eta(x, y)</span>
<span class="sd">        &gt;&gt;&gt; xi = xi(x, y)</span>
<span class="sd">        &gt;&gt;&gt; genform = Eq(eta.diff(x) + (eta.diff(y) - xi.diff(x))*h</span>
<span class="sd">        ... - (xi.diff(y))*h**2 - xi*(h.diff(x)) - eta*(h.diff(y)), 0)</span>
<span class="sd">        &gt;&gt;&gt; pprint(genform)</span>
<span class="sd">        /d               d           \                     d              2       d</span>
<span class="sd">        |--(eta(x, y)) - --(xi(x, y))|*h(x, y) - eta(x, y)*--(h(x, y)) - h (x, y)*--(x</span>
<span class="sd">        \dy              dx          /                     dy                     dy</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">                            d             d</span>
<span class="sd">        i(x, y)) - xi(x, y)*--(h(x, y)) + --(eta(x, y)) = 0</span>
<span class="sd">                            dx            dx</span>

<span class="sd">    Once the infinitesimals are found, the following partial differential</span>
<span class="sd">    equations would help us find the transformed coordinates (X, Y)</span>

<span class="sd">    1. X.diff(x)*xi + X.diff(y)*eta = 0</span>
<span class="sd">    2. Y.diff(x)*xi + Y.diff(y)*eta = 1</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Function, diff</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.ode import infinitesimals</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; eq = f(x).diff(x) - x**2*f(x)</span>
<span class="sd">    &gt;&gt;&gt; infinitesimals(eq)</span>
<span class="sd">    [{eta(x, f(x)): exp(x**3/3), xi(x, f(x)): 0},</span>
<span class="sd">    {eta(x, f(x)): f(x), xi(x, f(x)): 0},</span>
<span class="sd">    {eta(x, f(x)): 0, xi(x, f(x)): x**(-2)}]</span>


<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    - Solving differential equations by Symmetry Groups,</span>
<span class="sd">      John Starrett, pp. 1 - pp. 14</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.integrals.integrals</span> <span class="kn">import</span> <span class="n">integrate</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">func</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">_preprocess</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">args</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;ODE&#39;s have only one independent variable&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">ode_order</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Infinitesimals for only &quot;</span>
            <span class="s">&quot;first order ODE&#39;s have been implemented&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="c"># Matching differential equation of the form a*df + b</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="p">])</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">)</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;match&#39;</span><span class="p">,</span>
                <span class="n">collect</span><span class="p">(</span><span class="n">expand</span><span class="p">(</span><span class="n">eq</span><span class="p">),</span> <span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span>
            <span class="n">h</span> <span class="o">=</span> <span class="o">-</span><span class="n">simplify</span><span class="p">(</span><span class="n">match</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">/</span><span class="n">match</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;xi&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;eta&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="n">hx</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">hy</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">xieta</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c"># This is the PDE that has to be solved using various</span>
            <span class="c"># heuristics. The purpose is to &quot;intelligently&quot; guess</span>
            <span class="c"># the functions xi and eta. All the heuristics are cited</span>
            <span class="c"># from the paper &quot;Computer Algebra Solving of first order</span>
            <span class="c"># ODE&#39;s Using Symmetry Methods&quot; unless otherwise specified.</span>
            <span class="c"># Here dy/dx = h</span>
            <span class="c"># [eta.diff(x) + (eta.diff(y) - xi.diff(x))*h</span>
            <span class="c"># - xi.diff(y)*h**2 - xi*(h.diff(x)) - eta*(h.diff(y))) = 0]</span>
            <span class="c"># The first heuristic uses the following four sets of</span>
            <span class="c"># assumptions on xi and eta</span>
            <span class="c"># 1. [xi = 0, eta = f(x)]</span>
            <span class="c"># 2. [xi = 0, eta = f(y)]</span>
            <span class="c"># 3. [xi = f(x), eta = 0]</span>
            <span class="c"># 4. [xi = f(y), eta = 0]</span>
            <span class="c"># Assuming xi = 0 and eta to be a function of x, the PDE</span>
            <span class="c"># reduces to eta.diff(x) - eta*(h.diff(y)) = 0</span>
            <span class="c"># If h.diff(y) is a function of x, then this can usually</span>
            <span class="c"># be integrated easily.</span>
            <span class="n">hysym</span> <span class="o">=</span> <span class="n">hy</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hysym</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fx</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">hy</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inf</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="n">fx</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">)}</span>
                    <span class="k">if</span> <span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xieta</span><span class="p">:</span>
                        <span class="n">xieta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

            <span class="c"># Assuming xi = 0 and eta to be a function of y, the PDE</span>
            <span class="c"># reduces to eta.diff(y)*h - eta*(h.diff(y)) = 0</span>
            <span class="c"># If h.diff(y)/h is a function of y, then this can usually</span>
            <span class="c"># be integrated easily.</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="n">hy</span><span class="o">/</span><span class="n">h</span>
            <span class="n">facsym</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">facsym</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fy</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inf</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="n">fy</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">)}</span>
                    <span class="k">if</span> <span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xieta</span><span class="p">:</span>
                        <span class="n">xieta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

            <span class="c"># Assuming eta = 0 and xi to be a function of x, the PDE</span>
            <span class="c"># reduces to - (xi.diff(x))*h - xi*(h.diff(x))</span>
            <span class="c"># If -h.diff(x)/h is a function of x, then this can usually</span>
            <span class="c"># be integrated easily.</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="o">-</span><span class="n">hx</span><span class="o">/</span><span class="n">h</span>
            <span class="n">facsym</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">facsym</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fx</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inf</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="n">fx</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">),</span> <span class="n">eta</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
                    <span class="k">if</span> <span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xieta</span><span class="p">:</span>
                        <span class="n">xieta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

            <span class="c"># Assuming eta = 0 and xi to be a function of y, the PDE</span>
            <span class="c"># reduces to - xi.diff(y)*h**2 - xi*(h.diff(x))</span>
            <span class="c"># If -h.diff(x)/h**2 is a function of y, then this can usually</span>
            <span class="c"># be integrated easily.</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="o">-</span><span class="n">hx</span><span class="o">/</span><span class="p">(</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">facsym</span> <span class="o">=</span> <span class="n">factor</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">facsym</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fy</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">integrate</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inf</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="n">fy</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">),</span> <span class="n">eta</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
                    <span class="k">if</span> <span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xieta</span><span class="p">:</span>
                        <span class="n">xieta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

            <span class="c"># The second heuristic uses the following four sets of</span>
            <span class="c"># assumptions on xi and eta</span>
            <span class="c"># 1. [xi = 0, eta = f(x)*g(y)]</span>
            <span class="c"># 2. [xi = 0, eta = f(y)*g(x)]</span>
            <span class="c"># 3. [xi = f(x)*g(y), eta = 0]</span>
            <span class="c"># 4. [xi = f(y)*g(x), eta = 0]</span>
            <span class="c"># g is a function built by extracting algebraic factors from the</span>
            <span class="c"># numerator and denominator of the ODE to be solved and f is an</span>
            <span class="c"># unknown function to be determined by solving auxiliary ODE&#39;s</span>
            <span class="c"># after substituting g in the PDE.</span>
            <span class="c"># If the auxilliary ODE obtained is separable in f, it is assumed</span>
            <span class="c"># that this heuristic works.</span>
            <span class="n">argx</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># Extracting factors containing x only</span>
            <span class="n">argy</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># Extracting factors containing y only</span>
            <span class="n">Fx</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">Fy</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">)(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">Fx</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Fy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)])</span>
            <span class="n">gcd</span> <span class="o">=</span> <span class="n">gcd_terms</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gcd</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">gcd</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">gcd</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">gcd</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">gcd</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                    <span class="n">argy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="o">**</span><span class="n">power</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">gcd</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">gcd</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">gcd</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="n">argx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="o">**</span><span class="n">power</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">gcd</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">factors</span> <span class="o">=</span> <span class="n">gcd</span><span class="o">.</span><span class="n">args</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="n">arg</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">argy</span><span class="p">:</span>
                            <span class="n">argy</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">arg</span><span class="o">*</span><span class="n">factory</span> <span class="k">for</span> <span class="n">factory</span> <span class="ow">in</span> <span class="n">argy</span><span class="p">])</span>
                        <span class="n">argy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="n">arg</span><span class="o">.</span><span class="n">is_algebraic_expr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">argx</span><span class="p">:</span>
                            <span class="n">argx</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">arg</span><span class="o">*</span><span class="n">factorx</span> <span class="k">for</span> <span class="n">factorx</span> <span class="ow">in</span> <span class="n">argx</span><span class="p">])</span>
                        <span class="n">argx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">argy</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">argy</span><span class="p">:</span>
                    <span class="c"># Assuming xi = 0, and eta to be f(x)*g(y), the PDE reduces to</span>
                    <span class="c"># (f(x).diff(x)*g(y) + f(x)*g(y).diff(y)*h - f(x)*g(y)*(hy) = 0)</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Fx</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">arg</span> <span class="o">+</span> <span class="n">Fx</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">-</span> <span class="n">Fx</span><span class="o">*</span><span class="n">arg</span><span class="o">*</span><span class="p">(</span><span class="n">hy</span><span class="p">)</span>
                    <span class="c"># This means y can be successfully eliminated from eq.</span>
                    <span class="c"># The same logic applies for the four assumptions below</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">var</span><span class="p">:</span>
                        <span class="n">coeffx</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                        <span class="n">match</span> <span class="o">=</span> <span class="n">coeffx</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">Fx</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                            <span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">match</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">/</span><span class="n">match</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">Fx</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="c"># This heuristic is assumed to work if the auxilliary ODE</span>
                            <span class="c"># obtained is separable in Fx and x. The same logic</span>
                            <span class="c"># is used for the cases below.</span>
                            <span class="n">red</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">red</span><span class="p">:</span>
                                <span class="n">inty</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">red</span><span class="p">[</span><span class="n">y</span><span class="p">]),</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">intx</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">msol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">inty</span><span class="p">,</span> <span class="n">intx</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                                    <span class="k">pass</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">msol</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="ow">not</span> <span class="n">sol</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                                            <span class="n">inf</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="p">(</span><span class="n">sol</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">)}</span>
                                            <span class="k">if</span> <span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xieta</span><span class="p">:</span>
                                                <span class="n">xieta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

                    <span class="c"># Assuming eta = 0, and xi to be f(x)*g(y), the PDE reduces to</span>
                    <span class="c"># (f(x).diff(x)*g(y)*h + f(x)*g(y).diff(y)*h**2 +</span>
                    <span class="c"># f(x)*g(y)*h.diff(x) = 0)</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="p">((</span><span class="n">Fx</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">arg</span><span class="o">*</span><span class="n">h</span> <span class="o">+</span> <span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Fx</span><span class="o">*</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span>
                        <span class="n">Fx</span><span class="o">*</span><span class="n">arg</span><span class="o">*</span><span class="p">(</span><span class="n">hx</span><span class="p">))</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">var</span><span class="p">:</span>
                        <span class="n">coeffx</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
                        <span class="n">match</span> <span class="o">=</span> <span class="n">coeffx</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">Fx</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                            <span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">match</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">/</span><span class="n">match</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">Fx</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">red</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">red</span><span class="p">:</span>
                                <span class="n">inty</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">red</span><span class="p">[</span><span class="n">y</span><span class="p">]),</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">intx</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">msol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">inty</span><span class="p">,</span> <span class="n">intx</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                                    <span class="k">pass</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">msol</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="ow">not</span> <span class="n">sol</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                                            <span class="n">inf</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">sol</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">),</span> <span class="n">eta</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
                                            <span class="k">if</span> <span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xieta</span><span class="p">:</span>
                                                <span class="n">xieta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">argx</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">argx</span><span class="p">:</span>
                    <span class="c"># Assuming xi = 0, and eta to be g(x)*f(y), the PDE reduces to</span>
                    <span class="c"># (g(x).diff(x)*f(y) + g(x)*f(y).diff(y)*h - g(x)*f(y)*hy = 0)</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">Fy</span> <span class="o">+</span> <span class="n">arg</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">-</span> <span class="n">arg</span><span class="o">*</span><span class="n">hy</span><span class="o">*</span><span class="n">Fy</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">var</span><span class="p">:</span>
                        <span class="n">coeffy</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
                        <span class="n">match</span> <span class="o">=</span> <span class="n">coeffy</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">Fy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                            <span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">match</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">/</span><span class="n">match</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                            <span class="n">red</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">red</span><span class="p">:</span>
                                <span class="n">intx</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">red</span><span class="p">[</span><span class="n">x</span><span class="p">]),</span> <span class="n">x</span><span class="p">)</span>
                                <span class="n">inty</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="n">y</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">msol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">intx</span><span class="p">,</span> <span class="n">inty</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                                    <span class="k">pass</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">msol</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="ow">not</span> <span class="n">sol</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                                            <span class="n">inf</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="p">(</span><span class="n">sol</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">)}</span>
                                            <span class="k">if</span> <span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xieta</span><span class="p">:</span>
                                                <span class="n">xieta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

                    <span class="c"># Assuming eta = 0, and xi to be g(x)*f(y), the PDE reduces to</span>
                    <span class="c"># (g(x).diff(x)*f(y)*h + g(x)*f(y).diff(y)*h**2 +</span>
                    <span class="c"># g(x)*f(y)*h.diff(x) = 0)</span>
                    <span class="n">eq</span> <span class="o">=</span> <span class="p">((</span><span class="n">arg</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">h</span><span class="o">*</span><span class="n">Fy</span> <span class="o">+</span> <span class="n">h</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">arg</span><span class="o">*</span><span class="p">(</span><span class="n">Fy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span>
                        <span class="n">arg</span><span class="o">*</span><span class="n">Fy</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">var</span><span class="p">:</span>
                        <span class="n">coeffy</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
                        <span class="n">match</span> <span class="o">=</span> <span class="n">coeffy</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">Fy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                            <span class="n">match</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">match</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">/</span><span class="n">match</span><span class="p">[</span><span class="n">c</span><span class="p">])</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">Fy</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                            <span class="n">red</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">match</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">red</span><span class="p">:</span>
                                <span class="n">intx</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">red</span><span class="p">[</span><span class="n">x</span><span class="p">]),</span> <span class="n">x</span><span class="p">)</span>
                                <span class="n">inty</span> <span class="o">=</span> <span class="n">integrate</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="n">y</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>
                                <span class="k">try</span><span class="p">:</span>
                                    <span class="n">msol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">intx</span><span class="p">,</span> <span class="n">inty</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                                    <span class="k">pass</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">msol</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="ow">not</span> <span class="n">sol</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                                            <span class="n">inf</span> <span class="o">=</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">sol</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">),</span> <span class="n">eta</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
                                            <span class="k">if</span> <span class="n">inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">xieta</span><span class="p">:</span>
                                                <span class="n">xieta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inf</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">xieta</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Jun 29, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>