
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>sympy.categories.baseclasses &#8212; SymPy 1.1.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link href="http://docs.sympy.org/latest/_modules/sympy/categories/baseclasses.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for sympy.categories.baseclasses</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="k">import</span> <span class="n">S</span><span class="p">,</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="k">import</span> <span class="nb">range</span><span class="p">,</span> <span class="n">iterable</span>
<span class="kn">from</span> <span class="nn">sympy.sets</span> <span class="k">import</span> <span class="n">Set</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">EmptySet</span>


<span class="k">class</span> <span class="nc">Class</span><span class="p">(</span><span class="n">Set</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for any kind of class in the set-theoretic sense.</span>

<span class="sd">    In axiomatic set theories, everything is a class.  A class which</span>
<span class="sd">    can be a member of another class is a set.  A class which is not a</span>
<span class="sd">    member of another class is a proper class.  The class `\{1, 2\}`</span>
<span class="sd">    is a set; the class of all sets is a proper class.</span>

<span class="sd">    This class is essentially a synonym for :class:`sympy.core.Set`.</span>
<span class="sd">    The goal of this class is to assure easier migration to the</span>
<span class="sd">    eventual proper implementation of set theory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_proper</span> <span class="o">=</span> <span class="kc">False</span>


<div class="viewcode-block" id="Object"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.Object">[docs]</a><span class="k">class</span> <span class="nc">Object</span><span class="p">(</span><span class="n">Symbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for any kind of object in an abstract category.</span>

<span class="sd">    While technically any instance of :class:`Basic` will do, this</span>
<span class="sd">    class is the recommended way to create abstract objects in</span>
<span class="sd">    abstract categories.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="Morphism"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.Morphism">[docs]</a><span class="k">class</span> <span class="nc">Morphism</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for any morphism in an abstract category.</span>

<span class="sd">    In abstract categories, a morphism is an arrow between two</span>
<span class="sd">    category objects.  The object where the arrow starts is called the</span>
<span class="sd">    domain, while the object where the arrow ends is called the</span>
<span class="sd">    codomain.</span>

<span class="sd">    Two morphisms between the same pair of objects are considered to</span>
<span class="sd">    be the same morphisms.  To distinguish between morphisms between</span>
<span class="sd">    the same objects use :class:`NamedMorphism`.</span>

<span class="sd">    It is prohibited to instantiate this class.  Use one of the</span>
<span class="sd">    derived classes instead.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    IdentityMorphism, NamedMorphism, CompositeMorphism</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">codomain</span><span class="p">):</span>
        <span class="k">raise</span><span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot instantiate Morphism.  Use derived classes instead.&quot;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the domain of the morphism.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f.domain</span>
<span class="sd">        Object(&quot;A&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">codomain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the codomain of the morphism.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f.codomain</span>
<span class="sd">        Object(&quot;B&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="Morphism.compose"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.Morphism.compose">[docs]</a>    <span class="k">def</span> <span class="nf">compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Composes self with the supplied morphism.</span>

<span class="sd">        The order of elements in the composition is the usual order,</span>
<span class="sd">        i.e., to construct `g\circ f` use ``g.compose(f)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g * f</span>
<span class="sd">        CompositeMorphism((NamedMorphism(Object(&quot;A&quot;), Object(&quot;B&quot;), &quot;f&quot;),</span>
<span class="sd">        NamedMorphism(Object(&quot;B&quot;), Object(&quot;C&quot;), &quot;g&quot;)))</span>
<span class="sd">        &gt;&gt;&gt; (g * f).domain</span>
<span class="sd">        Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; (g * f).codomain</span>
<span class="sd">        Object(&quot;C&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeMorphism</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Composes self with the supplied morphism.</span>

<span class="sd">        The semantics of this operation is given by the following</span>
<span class="sd">        equation: ``g * f == g.compose(f)`` for composable morphisms</span>
<span class="sd">        ``g`` and ``f``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        compose</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


<div class="viewcode-block" id="IdentityMorphism"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.IdentityMorphism">[docs]</a><span class="k">class</span> <span class="nc">IdentityMorphism</span><span class="p">(</span><span class="n">Morphism</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents an identity morphism.</span>

<span class="sd">    An identity morphism is a morphism with equal domain and codomain,</span>
<span class="sd">    which acts as an identity with respect to composition.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, IdentityMorphism</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; id_A = IdentityMorphism(A)</span>
<span class="sd">    &gt;&gt;&gt; id_B = IdentityMorphism(B)</span>
<span class="sd">    &gt;&gt;&gt; f * id_A == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; id_B * f == f</span>
<span class="sd">    True</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Morphism</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Basic</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="NamedMorphism"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.NamedMorphism">[docs]</a><span class="k">class</span> <span class="nc">NamedMorphism</span><span class="p">(</span><span class="n">Morphism</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a morphism which has a name.</span>

<span class="sd">    Names are used to distinguish between morphisms which have the</span>
<span class="sd">    same domain and codomain: two named morphisms are equal if they</span>
<span class="sd">    have the same domains, codomains, and names.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f</span>
<span class="sd">    NamedMorphism(Object(&quot;A&quot;), Object(&quot;B&quot;), &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f.name</span>
<span class="sd">    &#39;f&#39;</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    Morphism</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">codomain</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Empty morphism names not allowed.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Basic</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">codomain</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of the morphism.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f.name</span>
<span class="sd">        &#39;f&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">name</span></div>


<div class="viewcode-block" id="CompositeMorphism"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.CompositeMorphism">[docs]</a><span class="k">class</span> <span class="nc">CompositeMorphism</span><span class="p">(</span><span class="n">Morphism</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a morphism which is a composition of other morphisms.</span>

<span class="sd">    Two composite morphisms are equal if the morphisms they were</span>
<span class="sd">    obtained from (components) are the same and were listed in the</span>
<span class="sd">    same order.</span>

<span class="sd">    The arguments to the constructor for this class should be listed</span>
<span class="sd">    in diagram order: to obtain the composition `g\circ f` from the</span>
<span class="sd">    instances of :class:`Morphism` ``g`` and ``f`` use</span>
<span class="sd">    ``CompositeMorphism(f, g)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, CompositeMorphism</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g * f</span>
<span class="sd">    CompositeMorphism((NamedMorphism(Object(&quot;A&quot;), Object(&quot;B&quot;), &quot;f&quot;),</span>
<span class="sd">    NamedMorphism(Object(&quot;B&quot;), Object(&quot;C&quot;), &quot;g&quot;)))</span>
<span class="sd">    &gt;&gt;&gt; CompositeMorphism(f, g) == g * f</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_morphism</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">morphism</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intelligently adds ``morphism`` to tuple ``t``.</span>

<span class="sd">        If ``morphism`` is a composite morphism, its components are</span>
<span class="sd">        added to the tuple.  If ``morphism`` is an identity, nothing</span>
<span class="sd">        is added to the tuple.</span>

<span class="sd">        No composability checks are performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">CompositeMorphism</span><span class="p">):</span>
            <span class="c1"># ``morphism`` is a composite morphism; we have to</span>
            <span class="c1"># denest its components.</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">morphism</span><span class="o">.</span><span class="n">components</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">IdentityMorphism</span><span class="p">):</span>
            <span class="c1"># ``morphism`` is an identity.  Nothing happens.</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">morphism</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">components</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">components</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Morphism</span><span class="p">):</span>
            <span class="c1"># Maybe the user has explicitly supplied a list of</span>
            <span class="c1"># morphisms.</span>
            <span class="k">return</span> <span class="n">CompositeMorphism</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">normalised_components</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">()</span>

        <span class="c1"># TODO: Fix the unpythonicity.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">following</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">Morphism</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">following</span><span class="p">,</span> <span class="n">Morphism</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;All components must be morphisms.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">codomain</span> <span class="o">!=</span> <span class="n">following</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Uncomposable morphisms.&quot;</span><span class="p">)</span>

            <span class="n">normalised_components</span> <span class="o">=</span> <span class="n">CompositeMorphism</span><span class="o">.</span><span class="n">_add_morphism</span><span class="p">(</span>
                <span class="n">normalised_components</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>

        <span class="c1"># We haven&#39;t added the last morphism to the list of normalised</span>
        <span class="c1"># components.  Add it now.</span>
        <span class="n">normalised_components</span> <span class="o">=</span> <span class="n">CompositeMorphism</span><span class="o">.</span><span class="n">_add_morphism</span><span class="p">(</span>
            <span class="n">normalised_components</span><span class="p">,</span> <span class="n">components</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">normalised_components</span><span class="p">:</span>
            <span class="c1"># If ``normalised_components`` is empty, only identities</span>
            <span class="c1"># were supplied.  Since they all were composable, they are</span>
            <span class="c1"># all the same identities.</span>
            <span class="k">return</span> <span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">normalised_components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># No sense to construct a whole CompositeMorphism.</span>
            <span class="k">return</span> <span class="n">normalised_components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Basic</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">normalised_components</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the components of this composite morphism.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; (g * f).components</span>
<span class="sd">        (NamedMorphism(Object(&quot;A&quot;), Object(&quot;B&quot;), &quot;f&quot;),</span>
<span class="sd">        NamedMorphism(Object(&quot;B&quot;), Object(&quot;C&quot;), &quot;g&quot;))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the domain of this composite morphism.</span>

<span class="sd">        The domain of the composite morphism is the domain of its</span>
<span class="sd">        first component.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; (g * f).domain</span>
<span class="sd">        Object(&quot;A&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">codomain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the codomain of this composite morphism.</span>

<span class="sd">        The codomain of the composite morphism is the codomain of its</span>
<span class="sd">        last component.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; (g * f).codomain</span>
<span class="sd">        Object(&quot;C&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">codomain</span>

<div class="viewcode-block" id="CompositeMorphism.flatten"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.CompositeMorphism.flatten">[docs]</a>    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forgets the composite structure of this morphism.</span>

<span class="sd">        If ``new_name`` is not empty, returns a :class:`NamedMorphism`</span>
<span class="sd">        with the supplied name, otherwise returns a :class:`Morphism`.</span>
<span class="sd">        In both cases the domain of the new morphism is the domain of</span>
<span class="sd">        this composite morphism and the codomain of the new morphism</span>
<span class="sd">        is the codomain of this composite morphism.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; (g * f).flatten(&quot;h&quot;)</span>
<span class="sd">        NamedMorphism(Object(&quot;A&quot;), Object(&quot;C&quot;), &quot;h&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NamedMorphism</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">codomain</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Category"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.Category">[docs]</a><span class="k">class</span> <span class="nc">Category</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An (abstract) category.</span>

<span class="sd">    A category [JoyOfCats] is a quadruple `\mbox{K} = (O, \hom, id,</span>
<span class="sd">    \circ)` consisting of</span>

<span class="sd">    * a (set-theoretical) class `O`, whose members are called</span>
<span class="sd">      `K`-objects,</span>

<span class="sd">    * for each pair `(A, B)` of `K`-objects, a set `\hom(A, B)` whose</span>
<span class="sd">      members are called `K`-morphisms from `A` to `B`,</span>

<span class="sd">    * for a each `K`-object `A`, a morphism `id:A\rightarrow A`,</span>
<span class="sd">      called the `K`-identity of `A`,</span>

<span class="sd">    * a composition law `\circ` associating with every `K`-morphisms</span>
<span class="sd">      `f:A\rightarrow B` and `g:B\rightarrow C` a `K`-morphism `g\circ</span>
<span class="sd">      f:A\rightarrow C`, called the composite of `f` and `g`.</span>

<span class="sd">    Composition is associative, `K`-identities are identities with</span>
<span class="sd">    respect to composition, and the sets `\hom(A, B)` are pairwise</span>
<span class="sd">    disjoint.</span>

<span class="sd">    This class knows nothing about its objects and morphisms.</span>
<span class="sd">    Concrete cases of (abstract) categories should be implemented as</span>
<span class="sd">    classes derived from this one.</span>

<span class="sd">    Certain instances of :class:`Diagram` can be asserted to be</span>
<span class="sd">    commutative in a :class:`Category` by supplying the argument</span>
<span class="sd">    ``commutative_diagrams`` in the constructor.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram, Category</span>
<span class="sd">    &gt;&gt;&gt; from sympy import FiniteSet</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; d = Diagram([f, g])</span>
<span class="sd">    &gt;&gt;&gt; K = Category(&quot;K&quot;, commutative_diagrams=[d])</span>
<span class="sd">    &gt;&gt;&gt; K.commutative_diagrams == FiniteSet(d)</span>
<span class="sd">    True</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    Diagram</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="n">EmptySet</span><span class="p">(),</span> <span class="n">commutative_diagrams</span><span class="o">=</span><span class="n">EmptySet</span><span class="p">()):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A Category cannot have an empty name.&quot;</span><span class="p">)</span>

        <span class="n">new_category</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">Class</span><span class="p">(</span><span class="n">objects</span><span class="p">),</span>
                                     <span class="n">FiniteSet</span><span class="p">(</span><span class="o">*</span><span class="n">commutative_diagrams</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_category</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the name of this category.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Category</span>
<span class="sd">        &gt;&gt;&gt; K = Category(&quot;K&quot;)</span>
<span class="sd">        &gt;&gt;&gt; K.name</span>
<span class="sd">        &#39;K&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the class of objects of this category.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, Category</span>
<span class="sd">        &gt;&gt;&gt; from sympy import FiniteSet</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; K = Category(&quot;K&quot;, FiniteSet(A, B))</span>
<span class="sd">        &gt;&gt;&gt; K.objects</span>
<span class="sd">        Class({Object(&quot;A&quot;), Object(&quot;B&quot;)})</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">commutative_diagrams</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :class:`FiniteSet` of diagrams which are known to</span>
<span class="sd">        be commutative in this category.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram, Category</span>
<span class="sd">        &gt;&gt;&gt; from sympy import FiniteSet</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; K = Category(&quot;K&quot;, commutative_diagrams=[d])</span>
<span class="sd">        &gt;&gt;&gt; K.commutative_diagrams == FiniteSet(d)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">hom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;hom-sets are not implemented in Category.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">all_morphisms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Obtaining the class of morphisms is not implemented in Category.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Diagram"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.Diagram">[docs]</a><span class="k">class</span> <span class="nc">Diagram</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a diagram in a certain category.</span>

<span class="sd">    Informally, a diagram is a collection of objects of a category and</span>
<span class="sd">    certain morphisms between them.  A diagram is still a monoid with</span>
<span class="sd">    respect to morphism composition; i.e., identity morphisms, as well</span>
<span class="sd">    as all composites of morphisms included in the diagram belong to</span>
<span class="sd">    the diagram.  For a more formal approach to this notion see</span>
<span class="sd">    [Pare1970].</span>

<span class="sd">    The components of composite morphisms are also added to the</span>
<span class="sd">    diagram.  No properties are assigned to such morphisms by default.</span>

<span class="sd">    A commutative diagram is often accompanied by a statement of the</span>
<span class="sd">    following kind: &quot;if such morphisms with such properties exist,</span>
<span class="sd">    then such morphisms which such properties exist and the diagram is</span>
<span class="sd">    commutative&quot;.  To represent this, an instance of :class:`Diagram`</span>
<span class="sd">    includes a collection of morphisms which are the premises and</span>
<span class="sd">    another collection of conclusions.  ``premises`` and</span>
<span class="sd">    ``conclusions`` associate morphisms belonging to the corresponding</span>
<span class="sd">    categories with the :class:`FiniteSet`&#39;s of their properties.</span>

<span class="sd">    The set of properties of a composite morphism is the intersection</span>
<span class="sd">    of the sets of properties of its components.  The domain and</span>
<span class="sd">    codomain of a conclusion morphism should be among the domains and</span>
<span class="sd">    codomains of the morphisms listed as the premises of a diagram.</span>

<span class="sd">    No checks are carried out of whether the supplied object and</span>
<span class="sd">    morphisms do belong to one and the same category.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">    &gt;&gt;&gt; from sympy import FiniteSet, pprint, default_sort_key</span>
<span class="sd">    &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">    &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">    &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">    &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">    &gt;&gt;&gt; d = Diagram([f, g])</span>
<span class="sd">    &gt;&gt;&gt; premises_keys = sorted(d.premises.keys(), key=default_sort_key)</span>
<span class="sd">    &gt;&gt;&gt; pprint(premises_keys, use_unicode=False)</span>
<span class="sd">    [g*f:A--&gt;C, id:A--&gt;A, id:B--&gt;B, id:C--&gt;C, f:A--&gt;B, g:B--&gt;C]</span>
<span class="sd">    &gt;&gt;&gt; pprint(d.premises, use_unicode=False)</span>
<span class="sd">    {g*f:A--&gt;C: EmptySet(), id:A--&gt;A: EmptySet(), id:B--&gt;B: EmptySet(), id:C--&gt;C:</span>
<span class="sd">    EmptySet(), f:A--&gt;B: EmptySet(), g:B--&gt;C: EmptySet()}</span>
<span class="sd">    &gt;&gt;&gt; d = Diagram([f, g], {g * f: &quot;unique&quot;})</span>
<span class="sd">    &gt;&gt;&gt; pprint(d.conclusions)</span>
<span class="sd">    {g*f:A--&gt;C: {unique}}</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>
<span class="sd">    [Pare1970] B. Pareigis: Categories and functors.  Academic Press,</span>
<span class="sd">    1970.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_set_dict_union</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``key`` is in ``dictionary``, set the new value of ``key``</span>
<span class="sd">        to be the union between the old value and ``value``.</span>
<span class="sd">        Otherwise, set the value of ``key`` to ``value.</span>

<span class="sd">        Returns ``True`` if the key already was in the dictionary and</span>
<span class="sd">        ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">|</span> <span class="n">value</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_morphism_closure</span><span class="p">(</span><span class="n">morphisms</span><span class="p">,</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">props</span><span class="p">,</span> <span class="n">add_identities</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">recurse_composites</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a morphism and its attributes to the supplied dictionary</span>
<span class="sd">        ``morphisms``.  If ``add_identities`` is True, also adds the</span>
<span class="sd">        identity morphisms for the domain and the codomain of</span>
<span class="sd">        ``morphism``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Diagram</span><span class="o">.</span><span class="n">_set_dict_union</span><span class="p">(</span><span class="n">morphisms</span><span class="p">,</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">props</span><span class="p">):</span>
            <span class="c1"># We have just added a new morphism.</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">IdentityMorphism</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">props</span><span class="p">:</span>
                    <span class="c1"># Properties for identity morphisms don&#39;t really</span>
                    <span class="c1"># make sense, because very much is known about</span>
                    <span class="c1"># identity morphisms already, so much that they</span>
                    <span class="c1"># are trivial.  Having properties for identity</span>
                    <span class="c1"># morphisms would only be confusing.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Instances of IdentityMorphism cannot have properties.&quot;</span><span class="p">)</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">add_identities</span><span class="p">:</span>
                <span class="n">empty</span> <span class="o">=</span> <span class="n">EmptySet</span><span class="p">()</span>

                <span class="n">id_dom</span> <span class="o">=</span> <span class="n">IdentityMorphism</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
                <span class="n">id_cod</span> <span class="o">=</span> <span class="n">IdentityMorphism</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">)</span>

                <span class="n">Diagram</span><span class="o">.</span><span class="n">_set_dict_union</span><span class="p">(</span><span class="n">morphisms</span><span class="p">,</span> <span class="n">id_dom</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span>
                <span class="n">Diagram</span><span class="o">.</span><span class="n">_set_dict_union</span><span class="p">(</span><span class="n">morphisms</span><span class="p">,</span> <span class="n">id_cod</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">existing_morphism</span><span class="p">,</span> <span class="n">existing_props</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">morphisms</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">new_props</span> <span class="o">=</span> <span class="n">existing_props</span> <span class="o">&amp;</span> <span class="n">props</span>
                <span class="k">if</span> <span class="n">morphism</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">existing_morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">:</span>
                    <span class="n">left</span> <span class="o">=</span> <span class="n">morphism</span> <span class="o">*</span> <span class="n">existing_morphism</span>
                    <span class="n">Diagram</span><span class="o">.</span><span class="n">_set_dict_union</span><span class="p">(</span><span class="n">morphisms</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">new_props</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span> <span class="o">==</span> <span class="n">existing_morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
                    <span class="n">right</span> <span class="o">=</span> <span class="n">existing_morphism</span> <span class="o">*</span> <span class="n">morphism</span>
                    <span class="n">Diagram</span><span class="o">.</span><span class="n">_set_dict_union</span><span class="p">(</span><span class="n">morphisms</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">new_props</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">morphism</span><span class="p">,</span> <span class="n">CompositeMorphism</span><span class="p">)</span> <span class="ow">and</span> <span class="n">recurse_composites</span><span class="p">:</span>
                <span class="c1"># This is a composite morphism, add its components as</span>
                <span class="c1"># well.</span>
                <span class="n">empty</span> <span class="o">=</span> <span class="n">EmptySet</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">morphism</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                    <span class="n">Diagram</span><span class="o">.</span><span class="n">_add_morphism_closure</span><span class="p">(</span><span class="n">morphisms</span><span class="p">,</span> <span class="n">component</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span>
                                                  <span class="n">add_identities</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new instance of Diagram.</span>

<span class="sd">        If no arguments are supplied, an empty diagram is created.</span>

<span class="sd">        If at least an argument is supplied, ``args[0]`` is</span>
<span class="sd">        interpreted as the premises of the diagram.  If ``args[0]`` is</span>
<span class="sd">        a list, it is interpreted as a list of :class:`Morphism`&#39;s, in</span>
<span class="sd">        which each :class:`Morphism` has an empty set of properties.</span>
<span class="sd">        If ``args[0]`` is a Python dictionary or a :class:`Dict`, it</span>
<span class="sd">        is interpreted as a dictionary associating to some</span>
<span class="sd">        :class:`Morphism`&#39;s some properties.</span>

<span class="sd">        If at least two arguments are supplied ``args[1]`` is</span>
<span class="sd">        interpreted as the conclusions of the diagram.  The type of</span>
<span class="sd">        ``args[1]`` is interpreted in exactly the same way as the type</span>
<span class="sd">        of ``args[0]``.  If only one argument is supplied, the diagram</span>
<span class="sd">        has no conclusions.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import IdentityMorphism, Diagram</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; IdentityMorphism(A) in d.premises.keys()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g * f in d.premises.keys()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g], {g * f: &quot;unique&quot;})</span>
<span class="sd">        &gt;&gt;&gt; d.conclusions[g * f]</span>
<span class="sd">        {unique}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">premises</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">conclusions</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Here we will keep track of the objects which appear in the</span>
        <span class="c1"># premises.</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="n">EmptySet</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We&#39;ve got some premises in the arguments.</span>
            <span class="n">premises_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">premises_arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># The user has supplied a list of morphisms, none of</span>
                <span class="c1"># which have any attributes.</span>
                <span class="n">empty</span> <span class="o">=</span> <span class="n">EmptySet</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">premises_arg</span><span class="p">:</span>
                    <span class="n">objects</span> <span class="o">|=</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">)</span>
                    <span class="n">Diagram</span><span class="o">.</span><span class="n">_add_morphism_closure</span><span class="p">(</span><span class="n">premises</span><span class="p">,</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">empty</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">premises_arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">premises_arg</span><span class="p">,</span> <span class="n">Dict</span><span class="p">):</span>
                <span class="c1"># The user has supplied a dictionary of morphisms and</span>
                <span class="c1"># their properties.</span>
                <span class="k">for</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="n">premises_arg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">objects</span> <span class="o">|=</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">)</span>
                    <span class="n">Diagram</span><span class="o">.</span><span class="n">_add_morphism_closure</span><span class="p">(</span>
                        <span class="n">premises</span><span class="p">,</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="o">*</span><span class="n">props</span><span class="p">)</span> <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">props</span><span class="p">)</span> <span class="k">else</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">props</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># We also have some conclusions.</span>
            <span class="n">conclusions_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conclusions_arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># The user has supplied a list of morphisms, none of</span>
                <span class="c1"># which have any attributes.</span>
                <span class="n">empty</span> <span class="o">=</span> <span class="n">EmptySet</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="n">conclusions_arg</span><span class="p">:</span>
                    <span class="c1"># Check that no new objects appear in conclusions.</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">sympify</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">))</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">)):</span>
                        <span class="c1"># No need to add identities and recurse</span>
                        <span class="c1"># composites this time.</span>
                        <span class="n">Diagram</span><span class="o">.</span><span class="n">_add_morphism_closure</span><span class="p">(</span>
                            <span class="n">conclusions</span><span class="p">,</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">add_identities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">recurse_composites</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conclusions_arg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> \
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">conclusions_arg</span><span class="p">,</span> <span class="n">Dict</span><span class="p">):</span>
                <span class="c1"># The user has supplied a dictionary of morphisms and</span>
                <span class="c1"># their properties.</span>
                <span class="k">for</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="n">conclusions_arg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># Check that no new objects appear in conclusions.</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">)</span> <span class="ow">and</span> \
                       <span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">):</span>
                        <span class="c1"># No need to add identities and recurse</span>
                        <span class="c1"># composites this time.</span>
                        <span class="n">Diagram</span><span class="o">.</span><span class="n">_add_morphism_closure</span><span class="p">(</span>
                            <span class="n">conclusions</span><span class="p">,</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="o">*</span><span class="n">props</span><span class="p">)</span> <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">props</span><span class="p">)</span> <span class="k">else</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">props</span><span class="p">),</span>
                            <span class="n">add_identities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">recurse_composites</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Basic</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Dict</span><span class="p">(</span><span class="n">premises</span><span class="p">),</span> <span class="n">Dict</span><span class="p">(</span><span class="n">conclusions</span><span class="p">),</span> <span class="n">objects</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">premises</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the premises of this diagram.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import IdentityMorphism, Diagram</span>
<span class="sd">        &gt;&gt;&gt; from sympy import pretty</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; id_A = IdentityMorphism(A)</span>
<span class="sd">        &gt;&gt;&gt; id_B = IdentityMorphism(B)</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f])</span>
<span class="sd">        &gt;&gt;&gt; print(pretty(d.premises, use_unicode=False))</span>
<span class="sd">        {id:A--&gt;A: EmptySet(), id:B--&gt;B: EmptySet(), f:A--&gt;B: EmptySet()}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">conclusions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the conclusions of this diagram.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism</span>
<span class="sd">        &gt;&gt;&gt; from sympy.categories import IdentityMorphism, Diagram</span>
<span class="sd">        &gt;&gt;&gt; from sympy import FiniteSet</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; IdentityMorphism(A) in d.premises.keys()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g * f in d.premises.keys()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g], {g * f: &quot;unique&quot;})</span>
<span class="sd">        &gt;&gt;&gt; d.conclusions[g * f] == FiniteSet(&quot;unique&quot;)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :class:`FiniteSet` of objects that appear in this</span>
<span class="sd">        diagram.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g])</span>
<span class="sd">        &gt;&gt;&gt; d.objects</span>
<span class="sd">        {Object(&quot;A&quot;), Object(&quot;B&quot;), Object(&quot;C&quot;)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<div class="viewcode-block" id="Diagram.hom"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.Diagram.hom">[docs]</a>    <span class="k">def</span> <span class="nf">hom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 2-tuple of sets of morphisms between objects A and</span>
<span class="sd">        B: one set of morphisms listed as premises, and the other set</span>
<span class="sd">        of morphisms listed as conclusions.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">        &gt;&gt;&gt; from sympy import pretty</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g], {g * f: &quot;unique&quot;})</span>
<span class="sd">        &gt;&gt;&gt; print(pretty(d.hom(A, C), use_unicode=False))</span>
<span class="sd">        ({g*f:A--&gt;C}, {g*f:A--&gt;C})</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        Object, Morphism</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">premises</span> <span class="o">=</span> <span class="n">EmptySet</span><span class="p">()</span>
        <span class="n">conclusions</span> <span class="o">=</span> <span class="n">EmptySet</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">premises</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">A</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span> <span class="o">==</span> <span class="n">B</span><span class="p">):</span>
                <span class="n">premises</span> <span class="o">|=</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">morphism</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">morphism</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conclusions</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">A</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span> <span class="o">==</span> <span class="n">B</span><span class="p">):</span>
                <span class="n">conclusions</span> <span class="o">|=</span> <span class="n">FiniteSet</span><span class="p">(</span><span class="n">morphism</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">premises</span><span class="p">,</span> <span class="n">conclusions</span><span class="p">)</span></div>

<div class="viewcode-block" id="Diagram.is_subdiagram"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.Diagram.is_subdiagram">[docs]</a>    <span class="k">def</span> <span class="nf">is_subdiagram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diagram</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether ``diagram`` is a subdiagram of ``self``.</span>
<span class="sd">        Diagram `D&#39;` is a subdiagram of `D` if all premises</span>
<span class="sd">        (conclusions) of `D&#39;` are contained in the premises</span>
<span class="sd">        (conclusions) of `D`.  The morphisms contained</span>
<span class="sd">        both in `D&#39;` and `D` should have the same properties for `D&#39;`</span>
<span class="sd">        to be a subdiagram of `D`.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g], {g * f: &quot;unique&quot;})</span>
<span class="sd">        &gt;&gt;&gt; d1 = Diagram([f])</span>
<span class="sd">        &gt;&gt;&gt; d.is_subdiagram(d1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; d1.is_subdiagram(d)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">premises</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([(</span><span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">premises</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">diagram</span><span class="o">.</span><span class="n">premises</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">premises</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">diagram</span><span class="o">.</span><span class="n">premises</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">premises</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">conclusions</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([(</span><span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conclusions</span><span class="p">)</span> <span class="ow">and</span>
                           <span class="p">(</span><span class="n">diagram</span><span class="o">.</span><span class="n">conclusions</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">conclusions</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">diagram</span><span class="o">.</span><span class="n">conclusions</span><span class="p">])</span>

        <span class="c1"># Premises is surely ``True`` here.</span>
        <span class="k">return</span> <span class="n">conclusions</span></div>

<div class="viewcode-block" id="Diagram.subdiagram_from_objects"><a class="viewcode-back" href="../../../modules/categories.html#sympy.categories.Diagram.subdiagram_from_objects">[docs]</a>    <span class="k">def</span> <span class="nf">subdiagram_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If ``objects`` is a subset of the objects of ``self``, returns</span>
<span class="sd">        a diagram which has as premises all those premises of ``self``</span>
<span class="sd">        which have a domains and codomains in ``objects``, likewise</span>
<span class="sd">        for conclusions.  Properties are preserved.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.categories import Object, NamedMorphism, Diagram</span>
<span class="sd">        &gt;&gt;&gt; from sympy import FiniteSet</span>
<span class="sd">        &gt;&gt;&gt; A = Object(&quot;A&quot;)</span>
<span class="sd">        &gt;&gt;&gt; B = Object(&quot;B&quot;)</span>
<span class="sd">        &gt;&gt;&gt; C = Object(&quot;C&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = NamedMorphism(A, B, &quot;f&quot;)</span>
<span class="sd">        &gt;&gt;&gt; g = NamedMorphism(B, C, &quot;g&quot;)</span>
<span class="sd">        &gt;&gt;&gt; d = Diagram([f, g], {f: &quot;unique&quot;, g*f: &quot;veryunique&quot;})</span>
<span class="sd">        &gt;&gt;&gt; d1 = d.subdiagram_from_objects(FiniteSet(A, B))</span>
<span class="sd">        &gt;&gt;&gt; d1 == Diagram([f], {f: &quot;unique&quot;})</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">objects</span><span class="o">.</span><span class="n">is_subset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Supplied objects should all belong to the diagram.&quot;</span><span class="p">)</span>

        <span class="n">new_premises</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">premises</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">sympify</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">))</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">)):</span>
                <span class="n">new_premises</span><span class="p">[</span><span class="n">morphism</span><span class="p">]</span> <span class="o">=</span> <span class="n">props</span>

        <span class="n">new_conclusions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">morphism</span><span class="p">,</span> <span class="n">props</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conclusions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">sympify</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">objects</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">morphism</span><span class="o">.</span><span class="n">codomain</span><span class="p">))</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">true</span><span class="p">)):</span>
                <span class="n">new_conclusions</span><span class="p">[</span><span class="n">morphism</span><span class="p">]</span> <span class="o">=</span> <span class="n">props</span>

        <span class="k">return</span> <span class="n">Diagram</span><span class="p">(</span><span class="n">new_premises</span><span class="p">,</span> <span class="n">new_conclusions</span><span class="p">)</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">SymPy 1.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017 SymPy Development Team.
      Last updated on Jul 27, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>