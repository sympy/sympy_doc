

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.combinatorics.perm_groups &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy.combinatorics" href="../combinatorics.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../combinatorics.html" accesskey="U">sympy.combinatorics</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.combinatorics.perm_groups</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span><span class="p">,</span> <span class="n">choice</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Basic</span>
<span class="kn">from</span> <span class="nn">sympy.combinatorics</span> <span class="kn">import</span> <span class="n">Permutation</span>
<span class="kn">from</span> <span class="nn">sympy.combinatorics.permutations</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_af_commutes_with</span><span class="p">,</span> <span class="n">_af_invert</span><span class="p">,</span>
    <span class="n">_af_rmul</span><span class="p">,</span> <span class="n">_af_rmuln</span><span class="p">,</span> <span class="n">_af_pow</span><span class="p">,</span> <span class="n">Cycle</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.combinatorics.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_check_cycles_alt_sym</span><span class="p">,</span>
    <span class="n">_distribute_gens_by_base</span><span class="p">,</span> <span class="n">_orbits_transversals_from_bsgs</span><span class="p">,</span>
    <span class="n">_handle_precomputed_bsgs</span><span class="p">,</span> <span class="n">_base_ordering</span><span class="p">,</span> <span class="n">_strong_gens_from_distr</span><span class="p">,</span>
    <span class="n">_strip</span><span class="p">,</span> <span class="n">_strip_af</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.functions.combinatorial.factorials</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">sieve</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">has_variety</span><span class="p">,</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">uniq</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.randtest</span> <span class="kn">import</span> <span class="n">_randrange</span>

<span class="n">rmul</span> <span class="o">=</span> <span class="n">Permutation</span><span class="o">.</span><span class="n">rmul_with_af</span>
<span class="n">_af_new</span> <span class="o">=</span> <span class="n">Permutation</span><span class="o">.</span><span class="n">_af_new</span>


<div class="viewcode-block" id="PermutationGroup"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup">[docs]</a><span class="k">class</span> <span class="nc">PermutationGroup</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The class defining a Permutation group.</span>

<span class="sd">    PermutationGroup([p1, p2, ..., pn]) returns the permutation group</span>
<span class="sd">    generated by the list of permutations. This group can be supplied</span>
<span class="sd">    to Polyhedron if one desires to decorate the elements to which the</span>
<span class="sd">    indices of the permutation refer.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import Cycle</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.polyhedron import Polyhedron</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>

<span class="sd">    The permutations corresponding to motion of the front, right and</span>
<span class="sd">    bottom face of a 2x2 Rubik&#39;s cube are defined:</span>

<span class="sd">    &gt;&gt;&gt; F = Permutation(2, 19, 21, 8)(3, 17, 20, 10)(4, 6, 7, 5)</span>
<span class="sd">    &gt;&gt;&gt; R = Permutation(1, 5, 21, 14)(3, 7, 23, 12)(8, 10, 11, 9)</span>
<span class="sd">    &gt;&gt;&gt; D = Permutation(6, 18, 14, 10)(7, 19, 15, 11)(20, 22, 23, 21)</span>

<span class="sd">    These are passed as permutations to PermutationGroup:</span>

<span class="sd">    &gt;&gt;&gt; G = PermutationGroup(F, R, D)</span>
<span class="sd">    &gt;&gt;&gt; G.order()</span>
<span class="sd">    3674160</span>

<span class="sd">    The group can be supplied to a Polyhedron in order to track the</span>
<span class="sd">    objects being moved. An example involving the 2x2 Rubik&#39;s cube is</span>
<span class="sd">    given there, but here is a simple demonstration:</span>

<span class="sd">    &gt;&gt;&gt; a = Permutation(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; b = Permutation(1, 0)</span>
<span class="sd">    &gt;&gt;&gt; G = PermutationGroup(a, b)</span>
<span class="sd">    &gt;&gt;&gt; P = Polyhedron(list(&#39;ABC&#39;), pgroup=G)</span>
<span class="sd">    &gt;&gt;&gt; P.corners</span>
<span class="sd">    (A, B, C)</span>
<span class="sd">    &gt;&gt;&gt; P.rotate(0) # apply permutation 0</span>
<span class="sd">    &gt;&gt;&gt; P.corners</span>
<span class="sd">    (A, C, B)</span>
<span class="sd">    &gt;&gt;&gt; P.reset()</span>
<span class="sd">    &gt;&gt;&gt; P.corners</span>
<span class="sd">    (A, B, C)</span>

<span class="sd">    Or one can make a permutation as a product of selected permutations</span>
<span class="sd">    and apply them to an iterable directly:</span>

<span class="sd">    &gt;&gt;&gt; P10 = G.make_perm([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; P10(&#39;ABC&#39;)</span>
<span class="sd">    [&#39;C&#39;, &#39;A&#39;, &#39;B&#39;]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.combinatorics.polyhedron.Polyhedron,</span>
<span class="sd">    sympy.combinatorics.permutations.Permutation</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">    &quot;Handbook of Computational Group Theory&quot;</span>

<span class="sd">    [2] Seress, A.</span>
<span class="sd">    &quot;Permutation Group Algorithms&quot;</span>

<span class="sd">    [3] http://en.wikipedia.org/wiki/Schreier_vector</span>

<span class="sd">    [4] http://en.wikipedia.org/wiki/Nielsen_transformation</span>
<span class="sd">    #Product_replacement_algorithm</span>

<span class="sd">    [5] Frank Celler, Charles R.Leedham-Green, Scott H.Murray,</span>
<span class="sd">    Alice C.Niemeyer, and E.A.O&#39;Brien. &quot;Generating Random</span>
<span class="sd">    Elements of a Finite Group&quot;</span>

<span class="sd">    [6] http://en.wikipedia.org/wiki/Block_%28permutation_group_theory%29</span>

<span class="sd">    [7] http://www.algorithmist.com/index.php/Union_Find</span>

<span class="sd">    [8] http://en.wikipedia.org/wiki/Multiply_transitive_group#Multiply_transitive_groups</span>

<span class="sd">    [9] http://en.wikipedia.org/wiki/Center_%28group_theory%29</span>

<span class="sd">    [10] http://en.wikipedia.org/wiki/Centralizer_and_normalizer</span>

<span class="sd">    [11] http://groupprops.subwiki.org/wiki/Derived_subgroup</span>

<span class="sd">    [12] http://en.wikipedia.org/wiki/Nilpotent_group</span>

<span class="sd">    [13] http://www.math.colostate.edu/~hulpke/CGT/cgtnotes.pdf</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The default constructor. Accepts Cycle and Permutation forms.</span>
<span class="sd">        Removes duplicates unless ``dups`` keyword is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;must supply one or more permutations &#39;</span>
            <span class="s">&#39;to define the group&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Cycle</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">Permutation</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">has_variety</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;degree&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">degree</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">degree</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">degree</span><span class="p">:</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;dups&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">([</span><span class="n">_af_new</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]))</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_generators</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_abelian</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_transitive</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_sym</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_alt</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_primitive</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_nilpotent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_solvable</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_trivial</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_transitivity_degree</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_max_div</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_generators</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_degree</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_generators</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>

        <span class="c"># these attributes are assigned after running schreier_sims</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_strong_gens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_basic_orbits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_transversals</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># these attributes are assigned after running _random_pr_init</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_random_gens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_generators</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if self and other have the same generators.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; p = Permutation(0, 1, 2, 3, 4, 5)</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([p, p**2])</span>
<span class="sd">        &gt;&gt;&gt; H = PermutationGroup([p**2, p])</span>
<span class="sd">        &gt;&gt;&gt; G.generators == H.generators</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; G == H</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PermutationGroup</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">generators</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">PermutationGroup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the direct product of two permutation groups as a permutation</span>
<span class="sd">        group.</span>

<span class="sd">        This implementation realizes the direct product by shifting</span>
<span class="sd">        the index set for the generators of the second group: so if we have</span>
<span class="sd">        G acting on n1 points and H acting on n2 points, G*H acts on n1 + n2</span>
<span class="sd">        points.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import CyclicGroup</span>
<span class="sd">        &gt;&gt;&gt; G = CyclicGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; H = G*G</span>
<span class="sd">        &gt;&gt;&gt; H</span>
<span class="sd">        PermutationGroup([</span>
<span class="sd">            Permutation(9)(0, 1, 2, 3, 4),</span>
<span class="sd">            Permutation(5, 6, 7, 8, 9)])</span>
<span class="sd">        &gt;&gt;&gt; H.order()</span>
<span class="sd">        25</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">gens2</span> <span class="o">=</span> <span class="p">[</span><span class="n">perm</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_degree</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gens2</span><span class="p">)):</span>
            <span class="n">gens2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">n1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gens2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">gens2</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">gen</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens2</span><span class="p">]</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="p">[</span><span class="n">gen</span> <span class="o">+</span> <span class="n">end</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens1</span><span class="p">]</span>
        <span class="n">together</span> <span class="o">=</span> <span class="n">gens1</span> <span class="o">+</span> <span class="n">gens2</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">_af_new</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">together</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_random_pr_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_random_prec_n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Initialize random generators for the product replacement algorithm.</span>

<span class="sd">        The implementation uses a modification of the original product</span>
<span class="sd">        replacement algorithm due to Leedham-Green, as described in [1],</span>
<span class="sd">        pp. 69-71; also, see [2], pp. 27-29 for a detailed theoretical</span>
<span class="sd">        analysis of the original product replacement algorithm, and [4].</span>

<span class="sd">        The product replacement algorithm is used for producing random,</span>
<span class="sd">        uniformly distributed elements of a group ``G`` with a set of generators</span>
<span class="sd">        ``S``. For the initialization ``_random_pr_init``, a list ``R`` of</span>
<span class="sd">        ``\max\{r, |S|\}`` group generators is created as the attribute</span>
<span class="sd">        ``G._random_gens``, repeating elements of ``S`` if necessary, and the</span>
<span class="sd">        identity element of ``G`` is appended to ``R`` - we shall refer to this</span>
<span class="sd">        last element as the accumulator. Then the function ``random_pr()``</span>
<span class="sd">        is called ``n`` times, randomizing the list ``R`` while preserving</span>
<span class="sd">        the generation of ``G`` by ``R``. The function ``random_pr()`` itself</span>
<span class="sd">        takes two random elements ``g, h`` among all elements of ``R`` but</span>
<span class="sd">        the accumulator and replaces ``g`` with a randomly chosen element</span>
<span class="sd">        from ``\{gh, g(~h), hg, (~h)g\}``. Then the accumulator is multiplied</span>
<span class="sd">        by whatever ``g`` was replaced by. The new value of the accumulator is</span>
<span class="sd">        then returned by ``random_pr()``.</span>

<span class="sd">        The elements returned will eventually (for ``n`` large enough) become</span>
<span class="sd">        uniformly distributed across ``G`` ([5]). For practical purposes however,</span>
<span class="sd">        the values ``n = 50, r = 11`` are suggested in [1].</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        THIS FUNCTION HAS SIDE EFFECTS: it changes the attribute</span>
<span class="sd">        self._random_gens</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        random_pr</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">random_gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">random_gens</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
                <span class="n">random_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">])</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg</span><span class="p">)</span>
        <span class="n">random_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_gens</span> <span class="o">=</span> <span class="n">random_gens</span>

        <span class="c"># handle randomized input for testing purposes</span>
        <span class="k">if</span> <span class="n">_random_prec_n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">(</span><span class="n">_random_prec</span><span class="o">=</span><span class="n">_random_prec_n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_union_find_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">ranks</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">not_rep</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges two classes in a union-find data structure.</span>

<span class="sd">        Used in the implementation of Atkinson&#39;s algorithm as suggested in [1],</span>
<span class="sd">        pp. 83-87. The class merging process uses union by rank as an</span>
<span class="sd">        optimization. ([7])</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,</span>
<span class="sd">        ``parents``, the list of class sizes, ``ranks``, and the list of</span>
<span class="sd">        elements that are not representatives, ``not_rep``, are changed due to</span>
<span class="sd">        class merging.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minimal_block, _union_find_rep</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">        &quot;Handbook of computational group theory&quot;</span>

<span class="sd">        [7] http://www.algorithmist.com/index.php/Union_Find</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rep_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_rep</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
        <span class="n">rep_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_rep</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rep_first</span> <span class="o">!=</span> <span class="n">rep_second</span><span class="p">:</span>
            <span class="c"># union by rank</span>
            <span class="k">if</span> <span class="n">ranks</span><span class="p">[</span><span class="n">rep_first</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ranks</span><span class="p">[</span><span class="n">rep_second</span><span class="p">]:</span>
                <span class="n">new_1</span><span class="p">,</span> <span class="n">new_2</span> <span class="o">=</span> <span class="n">rep_first</span><span class="p">,</span> <span class="n">rep_second</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_1</span><span class="p">,</span> <span class="n">new_2</span> <span class="o">=</span> <span class="n">rep_second</span><span class="p">,</span> <span class="n">rep_first</span>
            <span class="n">total_rank</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">[</span><span class="n">new_1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ranks</span><span class="p">[</span><span class="n">new_2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">total_rank</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_div</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">new_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_1</span>
            <span class="n">ranks</span><span class="p">[</span><span class="n">new_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rank</span>
            <span class="n">not_rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_2</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_union_find_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find representative of a class in a union-find data structure.</span>

<span class="sd">        Used in the implementation of Atkinson&#39;s algorithm as suggested in [1],</span>
<span class="sd">        pp. 83-87. After the representative of the class to which ``num``</span>
<span class="sd">        belongs is found, path compression is performed as an optimization</span>
<span class="sd">        ([7]).</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives,</span>
<span class="sd">        ``parents``, is altered due to path compression.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minimal_block, _union_find_merge</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        [1] Holt, D., Eick, B., O&#39;Brien, E.</span>
<span class="sd">        &quot;Handbook of computational group theory&quot;</span>

<span class="sd">        [7] http://www.algorithmist.com/index.php/Union_Find</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rep</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">num</span><span class="p">,</span> <span class="n">parents</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">rep</span><span class="p">:</span>
            <span class="n">rep</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">rep</span><span class="p">]</span>
        <span class="c"># path compression</span>
        <span class="n">temp</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">num</span><span class="p">,</span> <span class="n">parents</span><span class="p">[</span><span class="n">num</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">rep</span><span class="p">:</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">rep</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rep</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.base"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.base">[docs]</a>    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a base from the Schreier-Sims algorithm.</span>

<span class="sd">        For a permutation group ``G``, a base is a sequence of points</span>
<span class="sd">        ``B = (b_1, b_2, ..., b_k)`` such that no element of ``G`` apart</span>
<span class="sd">        from the identity fixes all the points in ``B``. The concepts of</span>
<span class="sd">        a base and strong generating set and their applications are</span>
<span class="sd">        discussed in depth in [1], pp. 87-89 and [2], pp. 55-57.</span>

<span class="sd">        An alternative way to think of ``B`` is that it gives the</span>
<span class="sd">        indices of the stabilizer cosets that contain more than the</span>
<span class="sd">        identity permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([Permutation(0, 1, 3)(2, 4)])</span>
<span class="sd">        &gt;&gt;&gt; G.base</span>
<span class="sd">        [0, 2]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        strong_gens, basic_transversals, basic_orbits, basic_stabilizers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
</div>
<div class="viewcode-block" id="PermutationGroup.baseswap"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.baseswap">[docs]</a>    <span class="k">def</span> <span class="nf">baseswap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">randomized</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">transversals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">basic_orbits</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">strong_gens_distr</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Swap two consecutive base points in base and strong generating set.</span>

<span class="sd">        If a base for a group ``G`` is given by ``(b_1, b_2, ..., b_k)``, this</span>
<span class="sd">        function returns a base ``(b_1, b_2, ..., b_{i+1}, b_i, ..., b_k)``,</span>
<span class="sd">        where ``i`` is given by ``pos``, and a strong generating set relative</span>
<span class="sd">        to that base. The original base and strong generating set are not</span>
<span class="sd">        modified.</span>

<span class="sd">        The randomized version (default) is of Las Vegas type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        base, strong_gens</span>
<span class="sd">            The base and strong generating set.</span>
<span class="sd">        pos</span>
<span class="sd">            The position at which swapping is performed.</span>
<span class="sd">        randomized</span>
<span class="sd">            A switch between randomized and deterministic version.</span>
<span class="sd">        transversals</span>
<span class="sd">            The transversals for the basic orbits, if known.</span>
<span class="sd">        basic_orbits</span>
<span class="sd">            The basic orbits, if known.</span>
<span class="sd">        strong_gens_distr</span>
<span class="sd">            The strong generators distributed by basic stabilizers, if known.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        (base, strong_gens)</span>
<span class="sd">            ``base`` is the new base, and ``strong_gens`` is a generating set</span>
<span class="sd">            relative to it.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; S.schreier_sims()</span>
<span class="sd">        &gt;&gt;&gt; S.base</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">        &gt;&gt;&gt; base, gens = S.baseswap(S.base, S.strong_gens, 1, randomized=False)</span>
<span class="sd">        &gt;&gt;&gt; base, gens</span>
<span class="sd">        ([0, 2, 1],</span>
<span class="sd">        [Permutation(0, 1, 2, 3), Permutation(3)(0, 1), Permutation(1, 3, 2),</span>
<span class="sd">         Permutation(2, 3), Permutation(1, 3)])</span>

<span class="sd">        check that base, gens is a BSGS</span>

<span class="sd">        &gt;&gt;&gt; S1 = PermutationGroup(gens)</span>
<span class="sd">        &gt;&gt;&gt; _verify_bsgs(S1, base, gens)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        schreier_sims</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The deterministic version of the algorithm is discussed in</span>
<span class="sd">        [1], pp. 102-103; the randomized version is discussed in [1], p.103, and</span>
<span class="sd">        [2], p.98. It is of Las Vegas type.</span>
<span class="sd">        Notice that [1] contains a mistake in the pseudocode and</span>
<span class="sd">        discussion of BASESWAP: on line 3 of the pseudocode,</span>
<span class="sd">        ``|\beta_{i+1}^{\left\langle T\right\rangle}|`` should be replaced by</span>
<span class="sd">        ``|\beta_{i}^{\left\langle T\right\rangle}|``, and the same for the</span>
<span class="sd">        discussion of the algorithm.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># construct the basic orbits, generators for the stabilizer chain</span>
        <span class="c"># and transversal elements from whatever was provided</span>
        <span class="n">transversals</span><span class="p">,</span> <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">strong_gens_distr</span> <span class="o">=</span> \
            <span class="n">_handle_precomputed_bsgs</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">,</span> <span class="n">transversals</span><span class="p">,</span>
                                 <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">strong_gens_distr</span><span class="p">)</span>
        <span class="n">base_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="c"># size of orbit of base[pos] under the stabilizer we seek to insert</span>
        <span class="c"># in the stabilizer chain at position pos + 1</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> \
            <span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="c"># initialize the wanted stabilizer by a subgroup</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">base_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">][:]</span>
        <span class="c"># randomized version</span>
        <span class="k">if</span> <span class="n">randomized</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">stab_pos</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">schreier_vector</span> <span class="o">=</span> <span class="n">stab_pos</span><span class="o">.</span><span class="n">schreier_vector</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c"># add random elements of the stabilizer until they generate it</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">]))</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">stab_pos</span><span class="o">.</span><span class="n">random_stab</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                           <span class="n">schreier_vector</span><span class="o">=</span><span class="n">schreier_vector</span><span class="p">)</span>
                <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="c"># deterministic version</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Gamma</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="n">Gamma</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Gamma</span><span class="p">:</span>
                <span class="n">Gamma</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c"># add elements of the stabilizer until they generate it by</span>
            <span class="c"># ruling out member of the basic orbit of base[pos] along the way</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">]))</span> <span class="o">!=</span> <span class="n">size</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">Gamma</span><span class="p">)</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">gamma</span><span class="p">]</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_array_form</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="c"># (~x)(base[pos + 1])</span>
                <span class="k">if</span> <span class="n">temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">Gamma</span> <span class="o">=</span> <span class="n">Gamma</span> <span class="o">-</span> <span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">temp</span><span class="p">]</span>
                    <span class="n">el</span> <span class="o">=</span> <span class="n">rmul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">el</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">]):</span>
                        <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                        <span class="n">Gamma</span> <span class="o">=</span> <span class="n">Gamma</span> <span class="o">-</span> <span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">base</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
        <span class="c"># build the new base and strong generating set</span>
        <span class="n">strong_gens_new_distr</span> <span class="o">=</span> <span class="n">strong_gens_distr</span><span class="p">[:]</span>
        <span class="n">strong_gens_new_distr</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>
        <span class="n">base_new</span> <span class="o">=</span> <span class="n">base</span><span class="p">[:]</span>
        <span class="n">base_new</span><span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="n">base_new</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_new</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">base_new</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">strong_gens_new</span> <span class="o">=</span> <span class="n">_strong_gens_from_distr</span><span class="p">(</span><span class="n">strong_gens_new_distr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">T</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">strong_gens_new</span><span class="p">:</span>
                <span class="n">strong_gens_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base_new</span><span class="p">,</span> <span class="n">strong_gens_new</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.basic_orbits"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits">[docs]</a>    <span class="k">def</span> <span class="nf">basic_orbits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the basic orbits relative to a base and strong generating set.</span>

<span class="sd">        If ``(b_1, b_2, ..., b_k)`` is a base for a group ``G``, and</span>
<span class="sd">        ``G^{(i)} = G_{b_1, b_2, ..., b_{i-1}}`` is the ``i``-th basic stabilizer</span>
<span class="sd">        (so that ``G^{(1)} = G``), the ``i``-th basic orbit relative to this base</span>
<span class="sd">        is the orbit of ``b_i`` under ``G^{(i)}``. See [1], pp. 87-89 for more</span>
<span class="sd">        information.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; S.basic_orbits</span>
<span class="sd">        [[0, 1, 2, 3], [1, 2, 3], [2, 3]]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        base, strong_gens, basic_transversals, basic_stabilizers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.basic_stabilizers"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers">[docs]</a>    <span class="k">def</span> <span class="nf">basic_stabilizers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a chain of stabilizers relative to a base and strong generating</span>
<span class="sd">        set.</span>

<span class="sd">        The ``i``-th basic stabilizer ``G^{(i)}`` relative to a base</span>
<span class="sd">        ``(b_1, b_2, ..., b_k)`` is ``G_{b_1, b_2, ..., b_{i-1}}``. For more</span>
<span class="sd">        information, see [1], pp. 87-89.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup</span>
<span class="sd">        &gt;&gt;&gt; A = AlternatingGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; A.schreier_sims()</span>
<span class="sd">        &gt;&gt;&gt; A.base</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; for g in A.basic_stabilizers:</span>
<span class="sd">        ...     print g</span>
<span class="sd">        ...</span>
<span class="sd">        PermutationGroup([</span>
<span class="sd">            Permutation(3)(0, 1, 2),</span>
<span class="sd">            Permutation(1, 2, 3)])</span>
<span class="sd">        PermutationGroup([</span>
<span class="sd">            Permutation(1, 2, 3)])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        base, strong_gens, basic_orbits, basic_transversals</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="n">strong_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strong_gens</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
        <span class="n">strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">)</span>
        <span class="n">basic_stabilizers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">gens</span> <span class="ow">in</span> <span class="n">strong_gens_distr</span><span class="p">:</span>
            <span class="n">basic_stabilizers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">basic_stabilizers</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.basic_transversals"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals">[docs]</a>    <span class="k">def</span> <span class="nf">basic_transversals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return basic transversals relative to a base and strong generating set.</span>

<span class="sd">        The basic transversals are transversals of the basic orbits. They</span>
<span class="sd">        are provided as a list of dictionaries, each dictionary having</span>
<span class="sd">        keys - the elements of one of the basic orbits, and values - the</span>
<span class="sd">        corresponding transversal elements. See [1], pp. 87-89 for more</span>
<span class="sd">        information.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup</span>
<span class="sd">        &gt;&gt;&gt; A = AlternatingGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; A.basic_transversals</span>
<span class="sd">        [{0: Permutation(3),</span>
<span class="sd">          1: Permutation(3)(0, 1, 2),</span>
<span class="sd">          2: Permutation(3)(0, 2, 1),</span>
<span class="sd">          3: Permutation(0, 3, 1)},</span>
<span class="sd">         {1: Permutation(3),</span>
<span class="sd">          2: Permutation(1, 2, 3),</span>
<span class="sd">          3: Permutation(1, 3, 2)}]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        strong_gens, base, basic_orbits, basic_stabilizers</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span>
</div>
<div class="viewcode-block" id="PermutationGroup.center"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.center">[docs]</a>    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Return the center of a permutation group.</span>

<span class="sd">        The center for a group ``G`` is defined as</span>
<span class="sd">        ``Z(G) = \{z\in G | \forall g\in G, zg = gz \}``,</span>
<span class="sd">        the set of elements of ``G`` that commute with all elements of ``G``.</span>
<span class="sd">        It is equal to the centralizer of ``G`` inside ``G``, and is naturally a</span>
<span class="sd">        subgroup of ``G`` ([9]).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; G = D.center()</span>
<span class="sd">        &gt;&gt;&gt; G.order()</span>
<span class="sd">        2</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        centralizer</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        This is a naive implementation that is a straightforward application</span>
<span class="sd">        of ``.centralizer()``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">centralizer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.centralizer"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.centralizer">[docs]</a>    <span class="k">def</span> <span class="nf">centralizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Return the centralizer of a group/set/element.</span>

<span class="sd">        The centralizer of a set of permutations ``S`` inside</span>
<span class="sd">        a group ``G`` is the set of elements of ``G`` that commute with all</span>
<span class="sd">        elements of ``S``::</span>

<span class="sd">            ``C_G(S) = \{ g \in G | gs = sg \forall s \in S\}`` ([10])</span>

<span class="sd">        Usually, ``S`` is a subset of ``G``, but if ``G`` is a proper subgroup of</span>
<span class="sd">        the full symmetric group, we allow for ``S`` to have elements outside</span>
<span class="sd">        ``G``.</span>

<span class="sd">        It is naturally a subgroup of ``G``; the centralizer of a permutation</span>
<span class="sd">        group is equal to the centralizer of any set of generators for that</span>
<span class="sd">        group, since any element commuting with the generators commutes with</span>
<span class="sd">        any product of the  generators.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        other</span>
<span class="sd">            a permutation group/list of permutations/single permutation</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,</span>
<span class="sd">        ... CyclicGroup)</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(6)</span>
<span class="sd">        &gt;&gt;&gt; C = CyclicGroup(6)</span>
<span class="sd">        &gt;&gt;&gt; H = S.centralizer(C)</span>
<span class="sd">        &gt;&gt;&gt; H.is_subgroup(C)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        subgroup_search</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The implementation is an application of ``.subgroup_search()`` with</span>
<span class="sd">        tests using a specific base for the group ``G``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;generators&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">is_trivial</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_trivial</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="n">identity</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>
            <span class="n">orbits</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">orbits</span><span class="p">()</span>
            <span class="n">num_orbits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbits</span><span class="p">)</span>
            <span class="n">orbits</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">long_base</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">orbit_reps</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">num_orbits</span>
            <span class="n">orbit_reps_indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">num_orbits</span>
            <span class="n">orbit_descr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">degree</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_orbits</span><span class="p">):</span>
                <span class="n">orbit</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">orbits</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">orbit_reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">orbit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">orbit_reps_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">long_base</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">orbit</span><span class="p">:</span>
                    <span class="n">orbit_descr</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">long_base</span> <span class="o">=</span> <span class="n">long_base</span> <span class="o">+</span> <span class="n">orbit</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims_incremental</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">long_base</span><span class="p">)</span>
            <span class="n">strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">identity</span><span class="p">]:</span>
                    <span class="k">break</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
            <span class="n">base_len</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_orbits</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">base</span><span class="p">[</span><span class="n">base_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">orbits</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="k">break</span>
            <span class="n">rel_orbits</span> <span class="o">=</span> <span class="n">orbits</span><span class="p">[:</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">num_rel_orbits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_orbits</span><span class="p">)</span>
            <span class="n">transversals</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">num_rel_orbits</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rel_orbits</span><span class="p">):</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="n">orbit_reps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">transversals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">orbit_transversal</span><span class="p">(</span><span class="n">rep</span><span class="p">,</span> <span class="n">pairs</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
            <span class="n">trivial_test</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">True</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_len</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="ow">in</span> <span class="n">orbit_reps</span><span class="p">:</span>
                    <span class="n">tests</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">trivial_test</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">computed_words</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">):</span>
                        <span class="n">g</span> <span class="o">=</span> <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
                        <span class="n">rep_orb_index</span> <span class="o">=</span> <span class="n">orbit_descr</span><span class="p">[</span><span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span>
                        <span class="n">rep</span> <span class="o">=</span> <span class="n">orbit_reps</span><span class="p">[</span><span class="n">rep_orb_index</span><span class="p">]</span>
                        <span class="n">im</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span>
                        <span class="n">im_rep</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">rep</span><span class="p">]</span>
                        <span class="n">tr_el</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">rep_orb_index</span><span class="p">][</span><span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span>
                        <span class="c"># using the definition of transversal,</span>
                        <span class="c"># base[l]^g = rep^(tr_el*g);</span>
                        <span class="c"># if g belongs to the centralizer, then</span>
                        <span class="c"># base[l]^g = (rep^g)^tr_el</span>
                        <span class="k">return</span> <span class="n">im</span> <span class="o">==</span> <span class="n">tr_el</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">im_rep</span><span class="p">]</span>
                    <span class="n">tests</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">test</span>

            <span class="k">def</span> <span class="nf">prop</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">rmul</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span> <span class="o">==</span> \
                       <span class="p">[</span><span class="n">rmul</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subgroup_search</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">,</span>
                                        <span class="n">strong_gens</span><span class="o">=</span><span class="n">strong_gens</span><span class="p">,</span> <span class="n">tests</span><span class="o">=</span><span class="n">tests</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;__getitem__&#39;</span><span class="p">):</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">centralizer</span><span class="p">(</span><span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;array_form&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">centralizer</span><span class="p">(</span><span class="n">PermutationGroup</span><span class="p">([</span><span class="n">other</span><span class="p">]))</span>
</div>
<div class="viewcode-block" id="PermutationGroup.commutator"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.commutator">[docs]</a>    <span class="k">def</span> <span class="nf">commutator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the commutator of two subgroups.</span>

<span class="sd">        For a permutation group ``K`` and subgroups ``G``, ``H``, the</span>
<span class="sd">        commutator of ``G`` and ``H`` is defined as the group generated</span>
<span class="sd">        by all the commutators ``[g, h] = hgh^{-1}g^{-1}`` for ``g`` in ``G`` and</span>
<span class="sd">        ``h`` in ``H``. It is naturally a subgroup of ``K`` ([1], p.27).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,</span>
<span class="sd">        ... AlternatingGroup)</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; A = AlternatingGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; G = S.commutator(S, A)</span>
<span class="sd">        &gt;&gt;&gt; G.is_subgroup(A)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        derived_subgroup</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The commutator of two subgroups ``H, G`` is equal to the normal closure</span>
<span class="sd">        of the commutators of all the generators, i.e. ``hgh^{-1}g^{-1}`` for ``h``</span>
<span class="sd">        a generator of ``H`` and ``g`` a generator of ``G`` ([1], p.28)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ggens</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">hgens</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">commutators</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ggen</span> <span class="ow">in</span> <span class="n">ggens</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hgen</span> <span class="ow">in</span> <span class="n">hgens</span><span class="p">:</span>
                <span class="n">commutator</span> <span class="o">=</span> <span class="n">rmul</span><span class="p">(</span><span class="n">hgen</span><span class="p">,</span> <span class="n">ggen</span><span class="p">,</span> <span class="o">~</span><span class="n">hgen</span><span class="p">,</span> <span class="o">~</span><span class="n">ggen</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">commutator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">commutators</span><span class="p">:</span>
                    <span class="n">commutators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">commutator</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_closure</span><span class="p">(</span><span class="n">commutators</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
<div class="viewcode-block" id="PermutationGroup.coset_factor"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.coset_factor">[docs]</a>    <span class="k">def</span> <span class="nf">coset_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">factor_index</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``G``&#39;s (self&#39;s) coset factorization of ``g``</span>

<span class="sd">        If ``g`` is an element of ``G`` then it can be written as the product</span>
<span class="sd">        of permutations drawn from the Schreier-Sims coset decomposition,</span>

<span class="sd">        The permutations returned in ``f`` are those for which</span>
<span class="sd">        the product gives ``g``: ``g = f[n]*...f[1]*f[0]`` where ``n = len(B)``</span>
<span class="sd">        and ``B = G.base``. f[i] is one of the permutations in</span>
<span class="sd">        ``self._basic_orbits[i]``.</span>

<span class="sd">        If factor_index==True,</span>
<span class="sd">        returns a tuple ``[b[0],..,b[n]]``, where ``b[i]``</span>
<span class="sd">        belongs to ``self._basic_orbits[i]``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>

<span class="sd">        Define g:</span>

<span class="sd">        &gt;&gt;&gt; g = Permutation(7)(1, 2, 4)(3, 6, 5)</span>

<span class="sd">        Confirm that it is an element of G:</span>

<span class="sd">        &gt;&gt;&gt; G.contains(g)</span>
<span class="sd">        True</span>

<span class="sd">        Thus, it can be written as a product of factors (up to</span>
<span class="sd">        3) drawn from u. See below that a factor from u1 and u2</span>
<span class="sd">        and the Identity permutation have been used:</span>

<span class="sd">        &gt;&gt;&gt; f = G.coset_factor(g)</span>
<span class="sd">        &gt;&gt;&gt; f[2]*f[1]*f[0] == g</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; f1 = G.coset_factor(g, True); f1</span>
<span class="sd">        [0, 4, 4]</span>
<span class="sd">        &gt;&gt;&gt; tr = G.basic_transversals</span>
<span class="sd">        &gt;&gt;&gt; f[0] == tr[0][f1[0]]</span>
<span class="sd">        True</span>

<span class="sd">        If g is not an element of G then [] is returned:</span>

<span class="sd">        &gt;&gt;&gt; c = Permutation(5, 6, 7)</span>
<span class="sd">        &gt;&gt;&gt; G.coset_factor(c)</span>
<span class="sd">        []</span>

<span class="sd">        see util._strip</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">Cycle</span><span class="p">,</span> <span class="n">Permutation</span><span class="p">)):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span><span class="p">:</span>
            <span class="c"># this could either adjust the size or return [] immediately</span>
            <span class="c"># but we don&#39;t choose between the two and just signal a possible</span>
            <span class="c"># error</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;g should be the same size as permutations of G&#39;</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_degree</span><span class="p">)</span>
        <span class="n">basic_orbits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_orbits</span>
        <span class="n">transversals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">g</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)):</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">beta</span> <span class="o">==</span> <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">beta</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">beta</span><span class="p">]</span><span class="o">.</span><span class="n">_array_form</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">_af_invert</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">h</span><span class="p">)</span>
            <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">I</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">factor_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">factors</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_transversals</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="n">tr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">factors</span>
</div>
<div class="viewcode-block" id="PermutationGroup.coset_rank"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.coset_rank">[docs]</a>    <span class="k">def</span> <span class="nf">coset_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;rank using Schreier-Sims representation</span>

<span class="sd">        The coset rank of ``g`` is the ordering number in which</span>
<span class="sd">        it appears in the lexicographic listing according to the</span>
<span class="sd">        coset decomposition</span>

<span class="sd">        The ordering is the same as in G.generate(method=&#39;coset&#39;).</span>
<span class="sd">        If ``g`` does not belong to the group it returns None.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation(0, 1, 3, 7, 6, 4)(2, 5)</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation(0, 1, 3, 2)(4, 5, 7, 6)</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; c = Permutation(7)(2, 4)(3, 5)</span>
<span class="sd">        &gt;&gt;&gt; G.coset_rank(c)</span>
<span class="sd">        16</span>
<span class="sd">        &gt;&gt;&gt; G.coset_unrank(16)</span>
<span class="sd">        Permutation(7)(2, 4)(3, 5)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        coset_factor</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_factor</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">factors</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">transversals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
        <span class="n">basic_orbits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">factors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">rank</span> <span class="o">+=</span> <span class="n">b</span><span class="o">*</span><span class="n">j</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">rank</span>
</div>
<div class="viewcode-block" id="PermutationGroup.coset_unrank"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.coset_unrank">[docs]</a>    <span class="k">def</span> <span class="nf">coset_unrank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;unrank using Schreier-Sims representation</span>

<span class="sd">        coset_unrank is the inverse operation of coset_rank</span>
<span class="sd">        if 0 &lt;= rank &lt; order; otherwise it returns None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rank</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base</span>
        <span class="n">transversals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span>
        <span class="n">basic_orbits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">rank</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_af_rmuln</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">h</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.degree"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.degree">[docs]</a>    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the size of the permutations in the group.</span>

<span class="sd">        The number of permutations comprising the group is given by</span>
<span class="sd">        len(group); the number of permutations that can be generated</span>
<span class="sd">        by the group is given by group.order().</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a])</span>
<span class="sd">        &gt;&gt;&gt; G.degree</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; len(G)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; G.order()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; list(G.generate())</span>
<span class="sd">        [Permutation(2), Permutation(2)(0, 1)]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span>
</div>
<div class="viewcode-block" id="PermutationGroup.derived_series"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.derived_series">[docs]</a>    <span class="k">def</span> <span class="nf">derived_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return the derived series for the group.</span>

<span class="sd">        The derived series for a group ``G`` is defined as</span>
<span class="sd">        ``G = G_0 &gt; G_1 &gt; G_2 &gt; \ldots`` where ``G_i = [G_{i-1}, G_{i-1}]``,</span>
<span class="sd">        i.e. ``G_i`` is the derived subgroup of ``G_{i-1}``, for</span>
<span class="sd">        ``i\in\mathbb{N}``. When we have ``G_k = G_{k-1}`` for some</span>
<span class="sd">        ``k\in\mathbb{N}``, the series terminates.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        A list of permutation groups containing the members of the derived</span>
<span class="sd">        series in the order ``G = G_0, G_1, G_2, \ldots``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,</span>
<span class="sd">        ... AlternatingGroup, DihedralGroup)</span>
<span class="sd">        &gt;&gt;&gt; A = AlternatingGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; len(A.derived_series())</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; len(S.derived_series())</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; S.derived_series()[1].is_subgroup(AlternatingGroup(4))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; S.derived_series()[2].is_subgroup(DihedralGroup(2))</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        derived_subgroup</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_subgroup</span><span class="p">()</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">current</span><span class="o">.</span><span class="n">is_subgroup</span><span class="p">(</span><span class="nb">next</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">next</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="nb">next</span>
            <span class="nb">next</span> <span class="o">=</span> <span class="nb">next</span><span class="o">.</span><span class="n">derived_subgroup</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
<div class="viewcode-block" id="PermutationGroup.derived_subgroup"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup">[docs]</a>    <span class="k">def</span> <span class="nf">derived_subgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the derived subgroup.</span>

<span class="sd">        The derived subgroup, or commutator subgroup is the subgroup generated</span>
<span class="sd">        by all commutators ``[g, h] = hgh^{-1}g^{-1}`` for ``g, h\in G`` ; it is</span>
<span class="sd">        equal to the normal closure of the set of commutators of the generators</span>
<span class="sd">        ([1], p.28, [11]).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 0, 2, 4, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0, 1, 3, 2, 4])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; C = G.derived_subgroup()</span>
<span class="sd">        &gt;&gt;&gt; list(C.generate(af=True))</span>
<span class="sd">        [[0, 1, 2, 3, 4], [0, 1, 3, 4, 2], [0, 1, 4, 2, 3]]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        derived_series</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">gens_inv</span> <span class="o">=</span> <span class="p">[</span><span class="n">_af_invert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">]</span>
        <span class="n">set_commutators</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rng</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">p1</span><span class="p">[</span><span class="n">k</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">p1</span><span class="p">[</span><span class="n">p2</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
                <span class="n">ct</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ct</span> <span class="ow">in</span> <span class="n">set_commutators</span><span class="p">:</span>
                    <span class="n">set_commutators</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
        <span class="n">cms</span> <span class="o">=</span> <span class="p">[</span><span class="n">_af_new</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">set_commutators</span><span class="p">]</span>
        <span class="n">G2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_closure</span><span class="p">(</span><span class="n">cms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G2</span>
</div>
<div class="viewcode-block" id="PermutationGroup.generate"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;coset&quot;</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return iterator to generate the elements of the group</span>

<span class="sd">        Iteration is done with one of these methods::</span>

<span class="sd">          method=&#39;coset&#39;  using the Schreier-Sims coset representation</span>
<span class="sd">          method=&#39;dimino&#39; using the Dimino method</span>

<span class="sd">        If af = True it yields the array form of the permutations</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.polyhedron import tetrahedron</span>

<span class="sd">        The permutation group given in the tetrahedron object is not</span>
<span class="sd">        true groups:</span>

<span class="sd">        &gt;&gt;&gt; G = tetrahedron.pgroup</span>
<span class="sd">        &gt;&gt;&gt; G.is_group()</span>
<span class="sd">        False</span>

<span class="sd">        But the group generated by the permutations in the tetrahedron</span>
<span class="sd">        pgroup -- even the first two -- is a proper group:</span>

<span class="sd">        &gt;&gt;&gt; H = PermutationGroup(G[0], G[1])</span>
<span class="sd">        &gt;&gt;&gt; J = PermutationGroup(list(H.generate())); J</span>
<span class="sd">        PermutationGroup([</span>
<span class="sd">            Permutation(0, 1)(2, 3),</span>
<span class="sd">            Permutation(3),</span>
<span class="sd">            Permutation(1, 2, 3),</span>
<span class="sd">            Permutation(1, 3, 2),</span>
<span class="sd">            Permutation(0, 3, 1),</span>
<span class="sd">            Permutation(0, 2, 3),</span>
<span class="sd">            Permutation(0, 3)(1, 2),</span>
<span class="sd">            Permutation(0, 1, 3),</span>
<span class="sd">            Permutation(3)(0, 2, 1),</span>
<span class="sd">            Permutation(0, 3, 2),</span>
<span class="sd">            Permutation(3)(0, 1, 2),</span>
<span class="sd">            Permutation(0, 2)(1, 3)])</span>
<span class="sd">        &gt;&gt;&gt; _.is_group()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;coset&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_schreier_sims</span><span class="p">(</span><span class="n">af</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;dimino&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_dimino</span><span class="p">(</span><span class="n">af</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;No generation defined for </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.generate_dimino"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.generate_dimino">[docs]</a>    <span class="k">def</span> <span class="nf">generate_dimino</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield group elements using Dimino&#39;s algorithm</span>

<span class="sd">        If af == True it yields the array form of the permutations</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        [1] The Implementation of Various Algorithms for Permutation Groups in</span>
<span class="sd">        the Computer Algebra System: AXIOM, N.J. Doye, M.Sc. Thesis</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; g = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; list(g.generate_dimino(af=True))</span>
<span class="sd">        [[0, 1, 2, 3], [0, 2, 1, 3], [0, 2, 3, 1],</span>
<span class="sd">         [0, 1, 3, 2], [0, 3, 2, 1], [0, 3, 1, 2]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idn</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">element_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">idn</span><span class="p">]</span>
        <span class="n">set_element_list</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idn</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">idn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">idn</span><span class="p">)</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)):</span>
            <span class="c"># D elements of the subgroup G_i generated by gens[:i]</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">element_list</span><span class="p">[:]</span>
            <span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="n">idn</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">N</span>
                <span class="n">N</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">ag</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ag</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set_element_list</span><span class="p">:</span>
                            <span class="c"># produce G_i*g</span>
                            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">D</span><span class="p">:</span>
                                <span class="n">order</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="n">ap</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ag</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
                                    <span class="k">yield</span> <span class="n">ap</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">p</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
                                    <span class="k">yield</span> <span class="n">p</span>
                                <span class="n">element_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
                                <span class="n">set_element_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
                                <span class="n">N</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">element_list</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.generate_schreier_sims"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.generate_schreier_sims">[docs]</a>    <span class="k">def</span> <span class="nf">generate_schreier_sims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yield group elements using the Schreier-Sims representation</span>
<span class="sd">        in coset_rank order</span>

<span class="sd">        If af = True it yields the array form of the permutations</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0, 2, 3, 1])</span>
<span class="sd">        &gt;&gt;&gt; g = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; list(g.generate_schreier_sims(af=True))</span>
<span class="sd">        [[0, 1, 2, 3], [0, 2, 1, 3], [0, 3, 2, 1],</span>
<span class="sd">         [0, 1, 3, 2], [0, 2, 3, 1], [0, 3, 1, 2]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_transversals</span>
        <span class="n">basic_orbits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">x</span><span class="o">.</span><span class="n">_array_form</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">x</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_array_form</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="n">u</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
        <span class="n">basic_orbits</span> <span class="o">=</span> <span class="n">basic_orbits</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c"># stg stack of group elements</span>
        <span class="n">stg</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">posmax</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">posmax</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n1</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># backtrack when finished iterating over coset</span>
            <span class="k">if</span> <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">posmax</span><span class="p">[</span><span class="n">h</span><span class="p">]:</span>
                <span class="c">#count_b += 1</span>
                <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">StopIteration</span>
                <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">h</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">stg</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">continue</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]]]</span><span class="o">.</span><span class="n">_array_form</span><span class="p">,</span> <span class="n">stg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pos</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">h</span> <span class="o">==</span> <span class="n">n1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_array_form</span><span class="p">,</span> <span class="n">stg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">yield</span> <span class="n">p</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_array_form</span><span class="p">,</span> <span class="n">stg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">p1</span>
                <span class="n">stg</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">h</span> <span class="o">-=</span> <span class="mi">1</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.generators"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.generators">[docs]</a>    <span class="k">def</span> <span class="nf">generators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the generators of the group.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.generators</span>
<span class="sd">        [Permutation(1, 2), Permutation(2)(0, 1)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generators</span>
</div>
<div class="viewcode-block" id="PermutationGroup.contains"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if permutation ``g`` belong to self, ``G``.</span>

<span class="sd">        If ``g`` is an element of ``G`` it can be written as a product</span>
<span class="sd">        of factors drawn from the cosets of ``G``&#39;s stabilizers. To see</span>
<span class="sd">        if ``g`` is one of the actual generators defining the group use</span>
<span class="sd">        ``G.has(g)``.</span>

<span class="sd">        If ``strict`` is not True, ``g`` will be resized, if necessary,</span>
<span class="sd">        to match the size of permutations in ``self``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>

<span class="sd">        &gt;&gt;&gt; a = Permutation(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation(2, 3, 1)</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup(a, b, degree=5)</span>
<span class="sd">        &gt;&gt;&gt; G.contains(G[0]) # trivial check</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; elem = Permutation([[2, 3]], size=5)</span>
<span class="sd">        &gt;&gt;&gt; G.contains(elem)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; G.contains(Permutation(4)(0, 1, 2, 3))</span>
<span class="sd">        False</span>

<span class="sd">        If strict is False, a permutation will be resized, if</span>
<span class="sd">        necessary:</span>

<span class="sd">        &gt;&gt;&gt; H = PermutationGroup(Permutation(5))</span>
<span class="sd">        &gt;&gt;&gt; H.contains(Permutation(3))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; H.contains(Permutation(3), strict=False)</span>
<span class="sd">        True</span>

<span class="sd">        To test if a given permutation is present in the group:</span>

<span class="sd">        &gt;&gt;&gt; elem in G.generators</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; G.has(elem)</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        coset_factor, has, in</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">Permutation</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coset_factor</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">array_form</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.is_abelian"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_abelian">[docs]</a>    <span class="k">def</span> <span class="nf">is_abelian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if the group is Abelian.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.is_abelian</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a])</span>
<span class="sd">        &gt;&gt;&gt; G.is_abelian</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_abelian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_abelian</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_abelian</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_af_commutes_with</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_is_abelian</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_alt_sym"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym">[docs]</a>    <span class="k">def</span> <span class="nf">is_alt_sym</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">_random_prec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Monte Carlo test for the symmetric/alternating group for degrees</span>
<span class="sd">        &gt;= 8.</span>

<span class="sd">        More specifically, it is one-sided Monte Carlo with the</span>
<span class="sd">        answer True (i.e., G is symmetric/alternating) guaranteed to be</span>
<span class="sd">        correct, and the answer False being incorrect with probability eps.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The algorithm itself uses some nontrivial results from group theory and</span>
<span class="sd">        number theory:</span>
<span class="sd">        1) If a transitive group ``G`` of degree ``n`` contains an element</span>
<span class="sd">        with a cycle of length ``n/2 &lt; p &lt; n-2`` for ``p`` a prime, ``G`` is the</span>
<span class="sd">        symmetric or alternating group ([1], pp. 81-82)</span>
<span class="sd">        2) The proportion of elements in the symmetric/alternating group having</span>
<span class="sd">        the property described in 1) is approximately ``\log(2)/\log(n)``</span>
<span class="sd">        ([1], p.82; [2], pp. 226-227).</span>
<span class="sd">        The helper function ``_check_cycles_alt_sym`` is used to</span>
<span class="sd">        go over the cycles in a permutation and look for ones satisfying 1).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(10)</span>
<span class="sd">        &gt;&gt;&gt; D.is_alt_sym()</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _check_cycles_alt_sym</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_random_prec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_transitive</span><span class="p">():</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">17</span><span class="p">:</span>
                <span class="n">c_n</span> <span class="o">=</span> <span class="mf">0.34</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_n</span> <span class="o">=</span> <span class="mf">0.57</span>
            <span class="n">d_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_n</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">N_eps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">log</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span><span class="o">/</span><span class="n">d_n</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_eps</span><span class="p">):</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">_check_cycles_alt_sym</span><span class="p">(</span><span class="n">perm</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;N_eps&#39;</span><span class="p">]):</span>
                <span class="n">perm</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">_check_cycles_alt_sym</span><span class="p">(</span><span class="n">perm</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">return</span> <span class="bp">False</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.is_nilpotent"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_nilpotent">[docs]</a>    <span class="k">def</span> <span class="nf">is_nilpotent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if the group is nilpotent.</span>

<span class="sd">        A group ``G`` is nilpotent if it has a central series of finite length.</span>
<span class="sd">        Alternatively, ``G`` is nilpotent if its lower central series terminates</span>
<span class="sd">        with the trivial group. Every nilpotent group is also solvable</span>
<span class="sd">        ([1], p.29, [12]).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,</span>
<span class="sd">        ... CyclicGroup)</span>
<span class="sd">        &gt;&gt;&gt; C = CyclicGroup(6)</span>
<span class="sd">        &gt;&gt;&gt; C.is_nilpotent</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; S.is_nilpotent</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        lower_central_series, is_solvable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_nilpotent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">lcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_central_series</span><span class="p">()</span>
            <span class="n">terminator</span> <span class="o">=</span> <span class="n">lcs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">lcs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="n">terminator</span><span class="o">.</span><span class="n">generators</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="n">identity</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">identity</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_solvable</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_nilpotent</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_nilpotent</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_nilpotent</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_normal"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_normal">[docs]</a>    <span class="k">def</span> <span class="nf">is_normal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if G=self is a normal subgroup of gr.</span>

<span class="sd">        G is normal in gr if</span>
<span class="sd">        for each g2 in G, g1 in gr, g = g1*g2*g1**-1 belongs to G</span>
<span class="sd">        It is sufficient to check this for each g1 in gr.generator and</span>
<span class="sd">        g2 g2 in G.generator</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 2, 0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G1 = PermutationGroup([a, Permutation([2, 0, 1])])</span>
<span class="sd">        &gt;&gt;&gt; G1.is_normal(G)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gens2</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">gens1</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">gr</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">g1</span> <span class="ow">in</span> <span class="n">gens1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">g2</span> <span class="ow">in</span> <span class="n">gens2</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">_af_rmuln</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">_af_invert</span><span class="p">(</span><span class="n">g1</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_factor</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_primitive"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_primitive">[docs]</a>    <span class="k">def</span> <span class="nf">is_primitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">randomized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if a group is primitive.</span>

<span class="sd">        A permutation group ``G`` acting on a set ``S`` is called primitive if</span>
<span class="sd">        ``S`` contains no nontrivial block under the action of ``G``</span>
<span class="sd">        (a block is nontrivial if its cardinality is more than ``1``).</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The algorithm is described in [1], p.83, and uses the function</span>
<span class="sd">        minimal_block to search for blocks of the form ``\{0, k\}`` for ``k``</span>
<span class="sd">        ranging over representatives for the orbits of ``G_0``, the stabilizer of</span>
<span class="sd">        ``0``. This algorithm has complexity ``O(n^2)`` where ``n`` is the degree</span>
<span class="sd">        of the group, and will perform badly if ``G_0`` is small.</span>

<span class="sd">        There are two implementations offered: one finds ``G_0``</span>
<span class="sd">        deterministically using the function ``stabilizer``, and the other</span>
<span class="sd">        (default) produces random elements of ``G_0`` using ``random_stab``,</span>
<span class="sd">        hoping that they generate a subgroup of ``G_0`` with not too many more</span>
<span class="sd">        orbits than G_0 (this is suggested in [1], p.83). Behavior is changed</span>
<span class="sd">        by the ``randomized`` flag.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(10)</span>
<span class="sd">        &gt;&gt;&gt; D.is_primitive()</span>
<span class="sd">        False</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minimal_block, random_stab</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_primitive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_primitive</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="k">if</span> <span class="n">randomized</span><span class="p">:</span>
            <span class="n">random_stab_gens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_vector</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="n">random_stab_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_stab</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="n">stab</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">random_stab_gens</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stabilizer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">orbits</span> <span class="o">=</span> <span class="n">stab</span><span class="o">.</span><span class="n">orbits</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbits</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimal_block</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_primitive</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_primitive</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.is_solvable"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_solvable">[docs]</a>    <span class="k">def</span> <span class="nf">is_solvable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if the group is solvable.</span>

<span class="sd">        ``G`` is solvable if its derived series terminates with the trivial</span>
<span class="sd">        group ([1], p.29).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(3)</span>
<span class="sd">        &gt;&gt;&gt; S.is_solvable</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        is_nilpotent, derived_series</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_solvable</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_series</span><span class="p">()</span>
            <span class="n">terminator</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="n">terminator</span><span class="o">.</span><span class="n">generators</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="n">identity</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">identity</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_solvable</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_solvable</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_solvable</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_subgroup"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_subgroup">[docs]</a>    <span class="k">def</span> <span class="nf">is_subgroup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if all elements of self belong to G.</span>

<span class="sd">        If ``strict`` is False then if ``self``&#39;s degree is smaller</span>
<span class="sd">        than ``G``&#39;s, the elements will be resized to have the same degree.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation, PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,</span>
<span class="sd">        ...    CyclicGroup)</span>

<span class="sd">        Testing is strict by default: the degree of each group must be the</span>
<span class="sd">        same:</span>

<span class="sd">        &gt;&gt;&gt; p = Permutation(0, 1, 2, 3, 4, 5)</span>
<span class="sd">        &gt;&gt;&gt; G1 = PermutationGroup([Permutation(0, 1, 2), Permutation(0, 1)])</span>
<span class="sd">        &gt;&gt;&gt; G2 = PermutationGroup([Permutation(0, 2), Permutation(0, 1, 2)])</span>
<span class="sd">        &gt;&gt;&gt; G3 = PermutationGroup([p, p**2])</span>
<span class="sd">        &gt;&gt;&gt; assert G1.order() == G2.order() == G3.order() == 6</span>
<span class="sd">        &gt;&gt;&gt; G1.is_subgroup(G2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; G1.is_subgroup(G3)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; G3.is_subgroup(PermutationGroup(G3[1]))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; G3.is_subgroup(PermutationGroup(G3[0]))</span>
<span class="sd">        True</span>

<span class="sd">        To ignore the size, set ``strict`` to False:</span>

<span class="sd">        &gt;&gt;&gt; S3 = SymmetricGroup(3)</span>
<span class="sd">        &gt;&gt;&gt; S5 = SymmetricGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; S3.is_subgroup(S5, strict=False)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; C7 = CyclicGroup(7)</span>
<span class="sd">        &gt;&gt;&gt; G = S5*C7</span>
<span class="sd">        &gt;&gt;&gt; S5.is_subgroup(G, False)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; C7.is_subgroup(G, 0)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">PermutationGroup</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">G</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">==</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span> <span class="o">&lt;</span> <span class="n">G</span><span class="o">.</span><span class="n">degree</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">strict</span><span class="p">):</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_transitive"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_transitive">[docs]</a>    <span class="k">def</span> <span class="nf">is_transitive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if the group is transitive.</span>

<span class="sd">        A group is transitive if it has a single orbit.</span>

<span class="sd">        If ``strict`` is False the group is transitive if it has</span>
<span class="sd">        a single orbit of length different from 1.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([2, 0, 1, 3])</span>
<span class="sd">        &gt;&gt;&gt; G1 = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G1.is_transitive()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; G1.is_transitive(strict=False)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; c = Permutation([2, 3, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; G2 = PermutationGroup([a, c])</span>
<span class="sd">        &gt;&gt;&gt; G2.is_transitive()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; d = Permutation([1,0,2,3])</span>
<span class="sd">        &gt;&gt;&gt; e = Permutation([0,1,3,2])</span>
<span class="sd">        &gt;&gt;&gt; G3 = PermutationGroup([d, e])</span>
<span class="sd">        &gt;&gt;&gt; G3.is_transitive() or G3.is_transitive(strict=False)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transitive</span><span class="p">:</span>  <span class="c"># strict or not, if True then True</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transitive</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transitive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># we only store strict=True</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transitive</span>

            <span class="n">ans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orbit</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_transitive</span> <span class="o">=</span> <span class="n">ans</span>
            <span class="k">return</span> <span class="n">ans</span>

        <span class="n">got_orb</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbits</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">got_orb</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="n">got_orb</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">got_orb</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.is_trivial"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_trivial">[docs]</a>    <span class="k">def</span> <span class="nf">is_trivial</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Test if the group is the trivial group.</span>

<span class="sd">        This is true if the group contains only the identity permutation.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([Permutation([0, 1, 2])])</span>
<span class="sd">        &gt;&gt;&gt; G.is_trivial</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_trivial</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_trivial</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Identity</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_trivial</span>
</div>
<div class="viewcode-block" id="PermutationGroup.lower_central_series"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.lower_central_series">[docs]</a>    <span class="k">def</span> <span class="nf">lower_central_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return the lower central series for the group.</span>

<span class="sd">        The lower central series for a group ``G`` is the series</span>
<span class="sd">        ``G = G_0 &gt; G_1 &gt; G_2 &gt; \ldots`` where</span>
<span class="sd">        ``G_k = [G, G_{k-1}]``, i.e. every term after the first is equal to the</span>
<span class="sd">        commutator of ``G`` and the previous term in ``G1`` ([1], p.29).</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        A list of permutation groups in the order</span>
<span class="sd">        ``G = G_0, G_1, G_2, \ldots``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import (AlternatingGroup,</span>
<span class="sd">        ... DihedralGroup)</span>
<span class="sd">        &gt;&gt;&gt; A = AlternatingGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; len(A.lower_central_series())</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; A.lower_central_series()[1].is_subgroup(DihedralGroup(2))</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        commutator, derived_series</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commutator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">current</span><span class="o">.</span><span class="n">is_subgroup</span><span class="p">(</span><span class="nb">next</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">next</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="nb">next</span>
            <span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">commutator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.max_div"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.max_div">[docs]</a>    <span class="k">def</span> <span class="nf">max_div</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Maximum proper divisor of the degree of a permutation group.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Obviously, this is the degree divided by its minimal proper divisor</span>
<span class="sd">        (larger than ``1``, if one exists). As it is guaranteed to be prime,</span>
<span class="sd">        the ``sieve`` from ``sympy.ntheory`` is used.</span>
<span class="sd">        This function is also used as an optimization tool for the functions</span>
<span class="sd">        ``minimal_block`` and ``_union_find_merge``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([Permutation([0,2,1,3])])</span>
<span class="sd">        &gt;&gt;&gt; G.max_div</span>
<span class="sd">        2</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        minimal_block, _union_find_merge</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_div</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_div</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sieve</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="n">x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_div</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="PermutationGroup.minimal_block"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.minimal_block">[docs]</a>    <span class="k">def</span> <span class="nf">minimal_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;For a transitive group, finds the block system generated by</span>
<span class="sd">        ``points``.</span>

<span class="sd">        If a group ``G`` acts on a set ``S``, a nonempty subset ``B`` of ``S``</span>
<span class="sd">        is called a block under the action of ``G`` if for all ``g`` in ``G``</span>
<span class="sd">        we have ``gB = B`` (``g`` fixes ``B``) or ``gB`` and ``B`` have no</span>
<span class="sd">        common points (``g`` moves ``B`` entirely). ([1], p.23; [6]).</span>

<span class="sd">        The distinct translates ``gB`` of a block ``B`` for ``g`` in ``G``</span>
<span class="sd">        partition the set ``S`` and this set of translates is known as a block</span>
<span class="sd">        system. Moreover, we obviously have that all blocks in the partition</span>
<span class="sd">        have the same size, hence the block size divides ``|S|`` ([1], p.23).</span>
<span class="sd">        A ``G``-congruence is an equivalence relation ``~`` on the set ``S``</span>
<span class="sd">        such that ``a ~ b`` implies ``g(a) ~ g(b)`` for all ``g`` in ``G``.</span>
<span class="sd">        For a transitive group, the equivalence classes of a ``G``-congruence</span>
<span class="sd">        and the blocks of a block system are the same thing ([1], p.23).</span>

<span class="sd">        The algorithm below checks the group for transitivity, and then finds</span>
<span class="sd">        the ``G``-congruence generated by the pairs ``(p_0, p_1), (p_0, p_2),</span>
<span class="sd">        ..., (p_0,p_{k-1})`` which is the same as finding the maximal block</span>
<span class="sd">        system (i.e., the one with minimum block size) such that</span>
<span class="sd">        ``p_0, ..., p_{k-1}`` are in the same block ([1], p.83).</span>

<span class="sd">        It is an implementation of Atkinson&#39;s algorithm, as suggested in [1],</span>
<span class="sd">        and manipulates an equivalence relation on the set ``S`` using a</span>
<span class="sd">        union-find data structure. The running time is just above</span>
<span class="sd">        ``O(|points||S|)``. ([1], pp. 83-87; [7]).</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(10)</span>
<span class="sd">        &gt;&gt;&gt; D.minimal_block([0,5])</span>
<span class="sd">        [0, 6, 2, 8, 4, 0, 6, 2, 8, 4]</span>
<span class="sd">        &gt;&gt;&gt; D.minimal_block([0,1])</span>
<span class="sd">        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _union_find_rep, _union_find_merge, is_transitive, is_primitive</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_transitive</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="c"># initialize the list of equivalence class representatives</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">not_rep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c"># the block size must divide the degree of the group</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_div</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">not_rep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ranks</span><span class="p">[</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">len_not_rep</span> <span class="o">=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len_not_rep</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">not_rep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="c"># find has side effects: performs path compression on the list</span>
                <span class="c"># of representatives</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_rep</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
                <span class="c"># union has side effects: performs union by rank on the list</span>
                <span class="c"># of representatives</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_merge</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="n">temp</span><span class="p">),</span> <span class="n">gen</span><span class="p">(</span><span class="n">delta</span><span class="p">),</span> <span class="n">ranks</span><span class="p">,</span>
                                              <span class="n">parents</span><span class="p">,</span> <span class="n">not_rep</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">temp</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
                <span class="n">len_not_rep</span> <span class="o">+=</span> <span class="n">temp</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c"># force path compression to get the final state of the equivalence</span>
            <span class="c"># relation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_union_find_rep</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">parents</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parents</span>
</div>
<div class="viewcode-block" id="PermutationGroup.normal_closure"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.normal_closure">[docs]</a>    <span class="k">def</span> <span class="nf">normal_closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return the normal closure of a subgroup/set of permutations.</span>

<span class="sd">        If ``S`` is a subset of a group ``G``, the normal closure of ``A`` in ``G``</span>
<span class="sd">        is defined as the intersection of all normal subgroups of ``G`` that</span>
<span class="sd">        contain ``A`` ([1], p.14). Alternatively, it is the group generated by</span>
<span class="sd">        the conjugates ``x^{-1}yx`` for ``x`` a generator of ``G`` and ``y`` a</span>
<span class="sd">        generator of the subgroup ``\left\langle S\right\rangle`` generated by</span>
<span class="sd">        ``S`` (for some chosen generating set for ``\left\langle S\right\rangle``)</span>
<span class="sd">        ([1], p.73).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        other</span>
<span class="sd">            a subgroup/list of permutations/single permutation</span>
<span class="sd">        k</span>
<span class="sd">            an implementation-specific parameter that determines the number</span>
<span class="sd">            of conjugates that are adjoined to ``other`` at once</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,</span>
<span class="sd">        ... CyclicGroup, AlternatingGroup)</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; C = CyclicGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; G = S.normal_closure(C)</span>
<span class="sd">        &gt;&gt;&gt; G.order()</span>
<span class="sd">        60</span>
<span class="sd">        &gt;&gt;&gt; G.is_subgroup(AlternatingGroup(5))</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        commutator, derived_subgroup, random_pr</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The algorithm is described in [1], pp. 73-74; it makes use of the</span>
<span class="sd">        generation of random elements for permutation groups by the product</span>
<span class="sd">        replacement algorithm.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;generators&#39;</span><span class="p">):</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="n">identity</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">g</span> <span class="o">==</span> <span class="n">identity</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">generators</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">generators</span><span class="p">[:])</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">schreier_sims_incremental</span><span class="p">()</span>
            <span class="n">strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">)</span>
            <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">basic_transversals</span> <span class="o">=</span> \
                <span class="n">_orbits_transversals_from_bsgs</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens_distr</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_random_pr_init</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

            <span class="n">_loop</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="n">_loop</span><span class="p">:</span>
                <span class="n">Z</span><span class="o">.</span><span class="n">_random_pr_init</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
                    <span class="n">conj</span> <span class="o">=</span> <span class="n">h</span><span class="o">^</span><span class="n">g</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">_strip</span><span class="p">(</span><span class="n">conj</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">basic_transversals</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">identity</span> <span class="ow">or</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">gens</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">generators</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conj</span><span class="p">)</span>
                        <span class="n">Z</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>
                        <span class="n">strong_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conj</span><span class="p">)</span>
                        <span class="n">temp_base</span><span class="p">,</span> <span class="n">temp_strong_gens</span> <span class="o">=</span> \
                            <span class="n">Z</span><span class="o">.</span><span class="n">schreier_sims_incremental</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">)</span>
                        <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span> <span class="o">=</span> <span class="n">temp_base</span><span class="p">,</span> <span class="n">temp_strong_gens</span>
                        <span class="n">strong_gens_distr</span> <span class="o">=</span> \
                            <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">)</span>
                        <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">basic_transversals</span> <span class="o">=</span> \
                            <span class="n">_orbits_transversals_from_bsgs</span><span class="p">(</span><span class="n">base</span><span class="p">,</span>
                                <span class="n">strong_gens_distr</span><span class="p">)</span>
                <span class="n">_loop</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">Z</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
                        <span class="n">conj</span> <span class="o">=</span> <span class="n">h</span><span class="o">^</span><span class="n">g</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">_strip</span><span class="p">(</span><span class="n">conj</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">basic_orbits</span><span class="p">,</span>
                                     <span class="n">basic_transversals</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">identity</span> <span class="ow">or</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">_loop</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">_loop</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">return</span> <span class="n">Z</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;__getitem__&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_closure</span><span class="p">(</span><span class="n">PermutationGroup</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;array_form&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">normal_closure</span><span class="p">(</span><span class="n">PermutationGroup</span><span class="p">([</span><span class="n">other</span><span class="p">]))</span>
</div>
<div class="viewcode-block" id="PermutationGroup.orbit"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.orbit">[docs]</a>    <span class="k">def</span> <span class="nf">orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;tuples&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Compute the orbit of alpha ``\{g(\alpha) | g \in G\}`` as a set.</span>

<span class="sd">        The time complexity of the algorithm used here is ``O(|Orb|*r)`` where</span>
<span class="sd">        ``|Orb|`` is the size of the orbit and ``r`` is the number of generators of</span>
<span class="sd">        the group. For a more detailed analysis, see [1], p.78, [2], pp. 19-21.</span>
<span class="sd">        Here alpha can be a single point, or a list of points.</span>

<span class="sd">        If alpha is a single point, the ordinary orbit is computed.</span>
<span class="sd">        if alpha is a list of points, there are three available options:</span>

<span class="sd">        &#39;union&#39; - computes the union of the orbits of the points in the list</span>
<span class="sd">        &#39;tuples&#39; - computes the orbit of the list interpreted as an ordered</span>
<span class="sd">        tuple under the group action ( i.e., g((1,2,3)) = (g(1), g(2), g(3)) )</span>
<span class="sd">        &#39;sets&#39; - computes the orbit of the list interpreted as a sets</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1,2,0,4,5,6,3])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a])</span>
<span class="sd">        &gt;&gt;&gt; G.orbit(0)</span>
<span class="sd">        set([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; G.orbit([0,4], &#39;union&#39;)</span>
<span class="sd">        set([0, 1, 2, 3, 4, 5, 6])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        orbit_transversal</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_orbit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.orbit_rep"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.orbit_rep">[docs]</a>    <span class="k">def</span> <span class="nf">orbit_rep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">schreier_vector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a group element which sends ``alpha`` to ``beta``.</span>

<span class="sd">        If ``beta`` is not in the orbit of ``alpha``, the function returns</span>
<span class="sd">        ``False``. This implementation makes use of the schreier vector.</span>
<span class="sd">        For a proof of correctness, see [1], p.80</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup</span>
<span class="sd">        &gt;&gt;&gt; G = AlternatingGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; G.orbit_rep(0, 4)</span>
<span class="sd">        Permutation(0, 4, 1, 2, 3)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        schreier_vector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">schreier_vector</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">schreier_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_vector</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">schreier_vector</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">schreier_vector</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">]</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gens</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span> <span class="c"># beta = (~gens[k])(beta)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">schreier_vector</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">_af_rmuln</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_degree</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="PermutationGroup.orbit_transversal"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.orbit_transversal">[docs]</a>    <span class="k">def</span> <span class="nf">orbit_transversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">pairs</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Computes a transversal for the orbit of ``alpha`` as a set.</span>

<span class="sd">        For a permutation group ``G``, a transversal for the orbit</span>
<span class="sd">        ``Orb = \{g(\alpha) | g \in G\}`` is a set</span>
<span class="sd">        ``\{g_\beta | g_\beta(\alpha) = \beta\}`` for ``\beta \in Orb``.</span>
<span class="sd">        Note that there may be more than one possible transversal.</span>
<span class="sd">        If ``pairs`` is set to ``True``, it returns the list of pairs</span>
<span class="sd">        ``(\beta, g_\beta)``. For a proof of correctness, see [1], p.79</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; G = DihedralGroup(6)</span>
<span class="sd">        &gt;&gt;&gt; G.orbit_transversal(0)</span>
<span class="sd">        [Permutation(5),</span>
<span class="sd">         Permutation(0, 1, 2, 3, 4, 5),</span>
<span class="sd">         Permutation(0, 5)(1, 4)(2, 3),</span>
<span class="sd">         Permutation(0, 2, 4)(1, 3, 5),</span>
<span class="sd">         Permutation(5)(0, 4)(1, 3),</span>
<span class="sd">         Permutation(0, 3)(1, 4)(2, 5)]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        orbit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_orbit_transversal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_degree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">pairs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.orbits"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.orbits">[docs]</a>    <span class="k">def</span> <span class="nf">orbits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the orbits of self, ordered according to lowest element</span>
<span class="sd">        in each orbit.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation(1,5)(2,3)(4,0,6)</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation(1,5)(3,4)(2,6,0)</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.orbits()</span>
<span class="sd">        [set([0, 2, 3, 4, 6]), set([1, 5])]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_orbits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_degree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generators</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.order"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.order">[docs]</a>    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the order of the group: the number of permutations that</span>
<span class="sd">        can be generated from elements of the group.</span>

<span class="sd">        The number of permutations comprising the group is given by</span>
<span class="sd">        len(group); the length of each permutation in the group is</span>
<span class="sd">        given by group.size.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>

<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a])</span>
<span class="sd">        &gt;&gt;&gt; G.degree</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; len(G)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; G.order()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; list(G.generate())</span>
<span class="sd">        [Permutation(2), Permutation(2)(0, 1)]</span>

<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.order()</span>
<span class="sd">        6</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        degree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_sym</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_alt</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degree</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order</span>

        <span class="n">basic_transversals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basic_transversals</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">basic_transversals</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">*=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_order</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span> <span class="n">m</span>
</div>
<div class="viewcode-block" id="PermutationGroup.pointwise_stabilizer"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.pointwise_stabilizer">[docs]</a>    <span class="k">def</span> <span class="nf">pointwise_stabilizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return the pointwise stabilizer for a set of points.</span>

<span class="sd">        For a permutation group ``G`` and a set of points</span>
<span class="sd">        ``\{p_1, p_2,\ldots, p_k\}``, the pointwise stabilizer of</span>
<span class="sd">        ``p_1, p_2, \ldots, p_k`` is defined as</span>
<span class="sd">        ``G_{p_1,\ldots, p_k} =</span>
<span class="sd">        \{g\in G | g(p_i) = p_i \forall i\in\{1, 2,\ldots,k\}\} ([1],p20).</span>
<span class="sd">        It is a subgroup of ``G``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(7)</span>
<span class="sd">        &gt;&gt;&gt; Stab = S.pointwise_stabilizer([2, 3, 5])</span>
<span class="sd">        &gt;&gt;&gt; Stab.is_subgroup(S.stabilizer(2).stabilizer(3).stabilizer(5))</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        stabilizer, schreier_sims_incremental</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        When incremental == True,</span>
<span class="sd">        rather than the obvious implementation using successive calls to</span>
<span class="sd">        .stabilizer(), this uses the incremental Schreier-Sims algorithm</span>
<span class="sd">        to obtain a base with starting segment - the given points.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">incremental</span><span class="p">:</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims_incremental</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
            <span class="n">stab_gens</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">strong_gens</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">[</span><span class="n">gen</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span> <span class="o">==</span> <span class="n">points</span><span class="p">:</span>
                    <span class="n">stab_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stab_gens</span><span class="p">:</span>
                <span class="n">stab_gens</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">stab_gens</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generators</span>
            <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                <span class="n">gens</span> <span class="o">=</span> <span class="n">_stabilizer</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">gens</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.make_perm"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.make_perm">[docs]</a>    <span class="k">def</span> <span class="nf">make_perm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply ``n`` randomly selected permutations from</span>
<span class="sd">        pgroup together, starting with the identity</span>
<span class="sd">        permutation. If ``n`` is a list of integers, those</span>
<span class="sd">        integers will be used to select the permutations and they</span>
<span class="sd">        will be applied in L to R order: make_perm((A, B, C)) will</span>
<span class="sd">        give CBA(I) where I is the identity permutation.</span>

<span class="sd">        ``seed`` is used to set the seed for the random selection</span>
<span class="sd">        of permutations from pgroup. If this is a list of integers,</span>
<span class="sd">        the corresponding permutations from pgroup will be selected</span>
<span class="sd">        in the order give. This is mainly used for testing purposes.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a, b = [Permutation([1, 0, 3, 2]), Permutation([1, 3, 0, 2])]</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.make_perm(1, [0])</span>
<span class="sd">        Permutation(0, 1)(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; G.make_perm(3, [0, 1, 0])</span>
<span class="sd">        Permutation(0, 2, 3, 1)</span>
<span class="sd">        &gt;&gt;&gt; G.make_perm([0, 1, 0])</span>
<span class="sd">        Permutation(0, 2, 3, 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        random</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;If n is a sequence, seed should be None&#39;</span><span class="p">)</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;n must be an integer or a sequence.&#39;</span><span class="p">)</span>
        <span class="n">randrange</span> <span class="o">=</span> <span class="n">_randrange</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c"># start with the identity permutation</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">randrange</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">rmul</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="PermutationGroup.random"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.random">[docs]</a>    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random group element</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coset_unrank</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">af</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.random_pr"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.random_pr">[docs]</a>    <span class="k">def</span> <span class="nf">random_pr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gen_count</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">_random_prec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random group element using product replacement.</span>

<span class="sd">        For the details of the product replacement algorithm, see</span>
<span class="sd">        ``_random_pr_init`` In ``random_pr`` the actual &#39;product replacement&#39;</span>
<span class="sd">        is performed. Notice that if the attribute ``_random_gens``</span>
<span class="sd">        is empty, it needs to be initialized by ``_random_pr_init``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        _random_pr_init</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_gens</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_random_pr_init</span><span class="p">(</span><span class="n">gen_count</span><span class="p">,</span> <span class="n">iterations</span><span class="p">)</span>
        <span class="n">random_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_gens</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">random_gens</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c"># handle randomized input for testing purposes</span>
        <span class="k">if</span> <span class="n">_random_prec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">choice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">]</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;t&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;e&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">_af_pow</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">e</span><span class="p">))</span>
            <span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">_af_pow</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">e</span><span class="p">),</span> <span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
            <span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">random_gens</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="PermutationGroup.random_stab"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.random_stab">[docs]</a>    <span class="k">def</span> <span class="nf">random_stab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">schreier_vector</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">_random_prec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Random element from the stabilizer of ``alpha``.</span>

<span class="sd">        The schreier vector for ``alpha`` is an optional argument used</span>
<span class="sd">        for speeding up repeated calls. The algorithm is described in [1], p.81</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        random_pr, orbit_rep</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">schreier_vector</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">schreier_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_vector</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_random_prec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">rand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rand</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;rand&#39;</span><span class="p">]</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbit_rep</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">schreier_vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rmul</span><span class="p">(</span><span class="o">~</span><span class="n">h</span><span class="p">,</span> <span class="n">rand</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PermutationGroup.schreier_sims"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims">[docs]</a>    <span class="k">def</span> <span class="nf">schreier_sims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Schreier-Sims algorithm.</span>

<span class="sd">        It computes the generators of the chain of stabilizers</span>
<span class="sd">        G &gt; G_{b_1} &gt; .. &gt; G_{b1,..,b_r} &gt; 1</span>
<span class="sd">        in which G_{b_1,..,b_i} stabilizes b_1,..,b_i,</span>
<span class="sd">        and the corresponding ``s`` cosets.</span>
<span class="sd">        An element of the group can be written as the product</span>
<span class="sd">        h_1*..*h_s.</span>

<span class="sd">        We use the incremental Schreier-Sims algorithm.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a, b])</span>
<span class="sd">        &gt;&gt;&gt; G.schreier_sims()</span>
<span class="sd">        &gt;&gt;&gt; G.basic_transversals</span>
<span class="sd">        [{0: Permutation(2)(0, 1), 1: Permutation(2), 2: Permutation(1, 2)},</span>
<span class="sd">         {0: Permutation(2), 2: Permutation(0, 2)}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims_incremental</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base</span> <span class="o">=</span> <span class="n">base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strong_gens</span> <span class="o">=</span> <span class="n">strong_gens</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">base</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span>

        <span class="n">strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">)</span>
        <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">transversals</span> <span class="o">=</span> <span class="n">_orbits_transversals_from_bsgs</span><span class="p">(</span><span class="n">base</span><span class="p">,</span>\
                <span class="n">strong_gens_distr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transversals</span> <span class="o">=</span> <span class="n">transversals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basic_orbits</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">basic_orbits</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="PermutationGroup.schreier_sims_incremental"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_incremental">[docs]</a>    <span class="k">def</span> <span class="nf">schreier_sims_incremental</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">gens</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extend a sequence of points and generating set to a base and strong</span>
<span class="sd">        generating set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        base</span>
<span class="sd">            The sequence of points to be extended to a base. Optional</span>
<span class="sd">            parameter with default value ``[]``.</span>
<span class="sd">        gens</span>
<span class="sd">            The generating set to be extended to a strong generating set</span>
<span class="sd">            relative to the base obtained. Optional parameter with default</span>
<span class="sd">            value ``self.generators``.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        (base, strong_gens)</span>
<span class="sd">            ``base`` is the base obtained, and ``strong_gens`` is the strong</span>
<span class="sd">            generating set relative to it. The original parameters ``base``,</span>
<span class="sd">            ``gens`` remain unchanged.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import AlternatingGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs</span>
<span class="sd">        &gt;&gt;&gt; A = AlternatingGroup(7)</span>
<span class="sd">        &gt;&gt;&gt; base = [2, 3]</span>
<span class="sd">        &gt;&gt;&gt; seq = [2, 3]</span>
<span class="sd">        &gt;&gt;&gt; base, strong_gens = A.schreier_sims_incremental(base=seq)</span>
<span class="sd">        &gt;&gt;&gt; _verify_bsgs(A, base, strong_gens)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; base[:2]</span>
<span class="sd">        [2, 3]</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        This version of the Schreier-Sims algorithm runs in polynomial time.</span>
<span class="sd">        There are certain assumptions in the implementation - if the trivial</span>
<span class="sd">        group is provided, ``base`` and ``gens`` are returned immediately,</span>
<span class="sd">        as any sequence of points is a base for the trivial group. If the</span>
<span class="sd">        identity is present in the generators ``gens``, it is removed as</span>
<span class="sd">        it is a redundant generator.</span>
<span class="sd">        The implementation is described in [1], pp. 90-93.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        schreier_sims, schreier_sims_random</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">gens</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">[:]</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">id_af</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
        <span class="c"># handle the trivial group</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Identity</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base</span><span class="p">,</span> <span class="n">gens</span>
        <span class="c"># prevent side effects</span>
        <span class="n">_base</span><span class="p">,</span> <span class="n">_gens</span> <span class="o">=</span> <span class="n">base</span><span class="p">[:],</span> <span class="n">gens</span><span class="p">[:]</span>
        <span class="c"># remove the identity as a generator</span>
        <span class="n">_gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_gens</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Identity</span><span class="p">]</span>
        <span class="c"># make sure no generator fixes all base points</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">_gens</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">gen</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_base</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">id_af</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">gen</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="bp">None</span>  <span class="c"># can this ever happen?</span>
                <span class="n">_base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="c"># distribute generators according to basic stabilizers</span>
        <span class="n">strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">_base</span><span class="p">,</span> <span class="n">_gens</span><span class="p">)</span>
        <span class="c"># initialize the basic stabilizers, basic orbits and basic transversals</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">transversals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">base_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_base</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_len</span><span class="p">):</span>
            <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_orbit_transversal</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">_base</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pairs</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
            <span class="n">orbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c"># main loop: amend the stabilizer chain until we have generators</span>
        <span class="c"># for all stabilizers</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">base_len</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># this flag is used to continue with the main loop from inside</span>
            <span class="c"># a nested loop</span>
            <span class="n">continue_i</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c"># test the generators for being a strong generating set</span>
            <span class="n">db</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">beta</span><span class="p">,</span> <span class="n">u_beta</span> <span class="ow">in</span> <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">gb</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">beta</span><span class="p">]</span>
                    <span class="n">u1</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">gb</span><span class="p">]</span>
                    <span class="n">g1</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">_array_form</span><span class="p">,</span> <span class="n">u_beta</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">g1</span> <span class="o">!=</span> <span class="n">u1</span><span class="p">:</span>
                        <span class="c"># test if the schreier generator is in the i+1-th</span>
                        <span class="c"># would-be basic stabilizer</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">u1_inv</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">gb</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="n">u1_inv</span> <span class="o">=</span> <span class="n">db</span><span class="p">[</span><span class="n">gb</span><span class="p">]</span> <span class="o">=</span> <span class="n">_af_invert</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
                        <span class="n">schreier_gen</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">u1_inv</span><span class="p">,</span> <span class="n">g1</span><span class="p">)</span>
                        <span class="n">h</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">_strip_af</span><span class="p">(</span><span class="n">schreier_gen</span><span class="p">,</span> <span class="n">_base</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">transversals</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">base_len</span><span class="p">:</span>
                            <span class="c"># new strong generator h at level j</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">elif</span> <span class="n">h</span><span class="p">:</span>
                            <span class="c"># h fixes all base points</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="n">moved</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="k">while</span> <span class="n">h</span><span class="p">[</span><span class="n">moved</span><span class="p">]</span> <span class="o">==</span> <span class="n">moved</span><span class="p">:</span>
                                <span class="n">moved</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">_base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moved</span><span class="p">)</span>
                            <span class="n">base_len</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">strong_gens_distr</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="c"># if a new strong generator is found, update the</span>
                            <span class="c"># data structures and start over</span>
                            <span class="n">h</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                                <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                                <span class="n">transversals</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span>\
                                <span class="nb">dict</span><span class="p">(</span><span class="n">_orbit_transversal</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">l</span><span class="p">],</span>
                                    <span class="n">_base</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">pairs</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                                <span class="n">orbs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
                            <span class="c"># continue main loop using the flag</span>
                            <span class="n">continue_i</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">continue_i</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">continue_i</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">continue_i</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="c"># build the strong generating set</span>
        <span class="n">strong_gens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">gens</span> <span class="ow">in</span> <span class="n">strong_gens_distr</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">strong_gens</span><span class="p">:</span>
                    <span class="n">strong_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_base</span><span class="p">,</span> <span class="n">strong_gens</span>
</div>
<div class="viewcode-block" id="PermutationGroup.schreier_sims_random"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_random">[docs]</a>    <span class="k">def</span> <span class="nf">schreier_sims_random</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">gens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">consec_succ</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                             <span class="n">_random_prec</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Randomized Schreier-Sims algorithm.</span>

<span class="sd">        The randomized Schreier-Sims algorithm takes the sequence ``base``</span>
<span class="sd">        and the generating set ``gens``, and extends ``base`` to a base, and</span>
<span class="sd">        ``gens`` to a strong generating set relative to that base with</span>
<span class="sd">        probability of a wrong answer at most ``2^{-consec\_succ}``,</span>
<span class="sd">        provided the random generators are sufficiently random.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        base</span>
<span class="sd">            The sequence to be extended to a base.</span>
<span class="sd">        gens</span>
<span class="sd">            The generating set to be extended to a strong generating set.</span>
<span class="sd">        consec_succ</span>
<span class="sd">            The parameter defining the probability of a wrong answer.</span>
<span class="sd">        _random_prec</span>
<span class="sd">            An internal parameter used for testing purposes.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        (base, strong_gens)</span>
<span class="sd">            ``base`` is the base and ``strong_gens`` is the strong generating</span>
<span class="sd">            set relative to it.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import SymmetricGroup</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(5)</span>
<span class="sd">        &gt;&gt;&gt; base, strong_gens = S.schreier_sims_random(consec_succ=5)</span>
<span class="sd">        &gt;&gt;&gt; _verify_bsgs(S, base, strong_gens) #doctest: +SKIP</span>
<span class="sd">        True</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The algorithm is described in detail in [1], pp. 97-98. It extends</span>
<span class="sd">        the orbits ``orbs`` and the permutation groups ``stabs`` to</span>
<span class="sd">        basic orbits and basic stabilizers for the base and strong generating</span>
<span class="sd">        set produced in the end.</span>
<span class="sd">        The idea of the extension process</span>
<span class="sd">        is to &quot;sift&quot; random group elements through the stabilizer chain</span>
<span class="sd">        and amend the stabilizers/orbits along the way when a sift</span>
<span class="sd">        is not successful.</span>
<span class="sd">        The helper function ``_strip`` is used to attempt</span>
<span class="sd">        to decompose a random group element according to the current</span>
<span class="sd">        state of the stabilizer chain and report whether the element was</span>
<span class="sd">        fully decomposed (successful sift) or not (unsuccessful sift). In</span>
<span class="sd">        the latter case, the level at which the sift failed is reported and</span>
<span class="sd">        used to amend ``stabs``, ``base``, ``gens`` and ``orbs`` accordingly.</span>
<span class="sd">        The halting condition is for ``consec_succ`` consecutive successful</span>
<span class="sd">        sifts to pass. This makes sure that the current ``base`` and ``gens``</span>
<span class="sd">        form a BSGS with probability at least ``1 - 1/\text{consec\_succ}``.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        schreier_sims</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">gens</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">base_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="c"># make sure no generator fixes all base points</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">base</span><span class="p">):</span>
                <span class="n">new</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">gen</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">new</span><span class="p">]</span> <span class="o">==</span> <span class="n">new</span><span class="p">:</span>
                    <span class="n">new</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
                <span class="n">base_len</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c"># distribute generators according to basic stabilizers</span>
        <span class="n">strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">gens</span><span class="p">)</span>
        <span class="c"># initialize the basic stabilizers, basic transversals and basic orbits</span>
        <span class="n">transversals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_len</span><span class="p">):</span>
            <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_orbit_transversal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pairs</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
            <span class="n">orbs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="c"># initialize the number of consecutive elements sifted</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># start sifting random elements while the number of consecutive sifts</span>
        <span class="c"># is less than consec_succ</span>
        <span class="k">while</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">consec_succ</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_random_prec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_pr</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">_random_prec</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">_strip</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">transversals</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c"># determine whether a new base point is needed</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">base_len</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">h</span><span class="o">.</span><span class="n">is_Identity</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">moved</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">while</span> <span class="n">h</span><span class="p">(</span><span class="n">moved</span><span class="p">)</span> <span class="o">==</span> <span class="n">moved</span><span class="p">:</span>
                    <span class="n">moved</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">base</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moved</span><span class="p">)</span>
                <span class="n">base_len</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">strong_gens_distr</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="c"># if the element doesn&#39;t sift, amend the strong generators and</span>
            <span class="c"># associated stabilizers and orbits</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                    <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                    <span class="n">transversals</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_orbit_transversal</span><span class="p">(</span><span class="n">n</span><span class="p">,</span>
                        <span class="n">strong_gens_distr</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">pairs</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                    <span class="n">orbs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c"># build the strong generating set</span>
        <span class="n">strong_gens</span> <span class="o">=</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">strong_gens_distr</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">strong_gens</span><span class="p">:</span>
                <span class="n">strong_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span>
</div>
<div class="viewcode-block" id="PermutationGroup.schreier_vector"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.schreier_vector">[docs]</a>    <span class="k">def</span> <span class="nf">schreier_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the schreier vector for ``alpha``.</span>

<span class="sd">        The Schreier vector efficiently stores information</span>
<span class="sd">        about the orbit of ``alpha``. It can later be used to quickly obtain</span>
<span class="sd">        elements of the group that send ``alpha`` to a particular element</span>
<span class="sd">        in the orbit. Notice that the Schreier vector depends on the order</span>
<span class="sd">        in which the group generators are listed. For a definition, see [3].</span>
<span class="sd">        Since list indices start from zero, we adopt the convention to use</span>
<span class="sd">        &quot;None&quot; instead of 0 to signify that an element doesn&#39;t belong</span>
<span class="sd">        to the orbit.</span>
<span class="sd">        For the algorithm and its correctness, see [2], pp.78-80.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([2,4,6,3,1,5,0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([0,1,3,5,4,6,2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a,b])</span>
<span class="sd">        &gt;&gt;&gt; G.schreier_vector(0)</span>
<span class="sd">        [-1, None, 0, 1, None, 1, 0]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        orbit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">v</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">orb</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="n">used</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_array_form</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                    <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">v</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">v</span>
</div>
<div class="viewcode-block" id="PermutationGroup.stabilizer"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.stabilizer">[docs]</a>    <span class="k">def</span> <span class="nf">stabilizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Return the stabilizer subgroup of ``alpha``.</span>

<span class="sd">        The stabilizer of ``\alpha`` is the group ``G_\alpha =</span>
<span class="sd">        \{g \in G | g(\alpha) = \alpha\}``.</span>
<span class="sd">        For a proof of correctness, see [1], p.79.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; G = DihedralGroup(6)</span>
<span class="sd">        &gt;&gt;&gt; G.stabilizer(5)</span>
<span class="sd">        PermutationGroup([</span>
<span class="sd">            Permutation(5)(0, 4)(1, 3),</span>
<span class="sd">            Permutation(5)])</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        orbit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PermGroup</span><span class="p">(</span><span class="n">_stabilizer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_degree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generators</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.strong_gens"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.strong_gens">[docs]</a>    <span class="k">def</span> <span class="nf">strong_gens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a strong generating set from the Schreier-Sims algorithm.</span>

<span class="sd">        A generating set ``S = \{g_1, g_2, ..., g_t\}`` for a permutation group</span>
<span class="sd">        ``G`` is a strong generating set relative to the sequence of points</span>
<span class="sd">        (referred to as a &quot;base&quot;) ``(b_1, b_2, ..., b_k)`` if, for</span>
<span class="sd">        ``1 \leq i \leq k`` we have that the intersection of the pointwise</span>
<span class="sd">        stabilizer ``G^{(i+1)} := G_{b_1, b_2, ..., b_i}`` with ``S`` generates</span>
<span class="sd">        the pointwise stabilizer ``G^{(i+1)}``. The concepts of a base and</span>
<span class="sd">        strong generating set and their applications are discussed in depth</span>
<span class="sd">        in [1], pp. 87-89 and [2], pp. 55-57.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">        &gt;&gt;&gt; D = DihedralGroup(4)</span>
<span class="sd">        &gt;&gt;&gt; D.strong_gens</span>
<span class="sd">        [Permutation(0, 1, 2, 3), Permutation(0, 3)(1, 2), Permutation(1, 3)]</span>
<span class="sd">        &gt;&gt;&gt; D.base</span>
<span class="sd">        [0, 1]</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        base, basic_transversals, basic_orbits, basic_stabilizers</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strong_gens</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strong_gens</span>
</div>
<div class="viewcode-block" id="PermutationGroup.subgroup_search"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.subgroup_search">[docs]</a>    <span class="k">def</span> <span class="nf">subgroup_search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">strong_gens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tests</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">init_subgroup</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the subgroup of all elements satisfying the property ``prop``.</span>

<span class="sd">        This is done by a depth-first search with respect to base images that</span>
<span class="sd">        uses several tests to prune the search tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        prop</span>
<span class="sd">            The property to be used. Has to be callable on group elements</span>
<span class="sd">            and always return ``True`` or ``False``. It is assumed that</span>
<span class="sd">            all group elements satisfying ``prop`` indeed form a subgroup.</span>
<span class="sd">        base</span>
<span class="sd">            A base for the supergroup.</span>
<span class="sd">        strong_gens</span>
<span class="sd">            A strong generating set for the supergroup.</span>
<span class="sd">        tests</span>
<span class="sd">            A list of callables of length equal to the length of ``base``.</span>
<span class="sd">            These are used to rule out group elements by partial base images,</span>
<span class="sd">            so that ``tests[l](g)`` returns False if the element ``g`` is known</span>
<span class="sd">            not to satisfy prop base on where g sends the first ``l + 1`` base</span>
<span class="sd">            points.</span>
<span class="sd">        init_subgroup</span>
<span class="sd">            if a subgroup of the sought group is</span>
<span class="sd">            known in advance, it can be passed to the function as this</span>
<span class="sd">            parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        =======</span>

<span class="sd">        res</span>
<span class="sd">            The subgroup of all elements satisfying ``prop``. The generating</span>
<span class="sd">            set for this group is guaranteed to be a strong generating set</span>
<span class="sd">            relative to the base ``base``.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.named_groups import (SymmetricGroup,</span>
<span class="sd">        ... AlternatingGroup)</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.testutil import _verify_bsgs</span>
<span class="sd">        &gt;&gt;&gt; S = SymmetricGroup(7)</span>
<span class="sd">        &gt;&gt;&gt; prop_even = lambda x: x.is_even</span>
<span class="sd">        &gt;&gt;&gt; base, strong_gens = S.schreier_sims_incremental()</span>
<span class="sd">        &gt;&gt;&gt; G = S.subgroup_search(prop_even, base=base, strong_gens=strong_gens)</span>
<span class="sd">        &gt;&gt;&gt; G.is_subgroup(AlternatingGroup(7))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; _verify_bsgs(G, base, G.generators)</span>
<span class="sd">        True</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        This function is extremely lenghty and complicated and will require</span>
<span class="sd">        some careful attention. The implementation is described in</span>
<span class="sd">        [1], pp. 114-117, and the comments for the code here follow the lines</span>
<span class="sd">        of the pseudocode in the book for clarity.</span>

<span class="sd">        The complexity is exponential in general, since the search process by</span>
<span class="sd">        itself visits all members of the supergroup. However, there are a lot</span>
<span class="sd">        of tests which are used to prune the search tree, and users can define</span>
<span class="sd">        their own tests via the ``tests`` parameter, so in practice, and for</span>
<span class="sd">        some computations, it&#39;s not terrible.</span>

<span class="sd">        A crucial part in the procedure is the frequent base change performed</span>
<span class="sd">        (this is line 11 in the pseudocode) in order to obtain a new basic</span>
<span class="sd">        stabilizer. The book mentiones that this can be done by using</span>
<span class="sd">        ``.baseswap(...)``, however the current imlementation uses a more</span>
<span class="sd">        straightforward way to find the next basic stabilizer - calling the</span>
<span class="sd">        function ``.stabilizer(...)`` on the previous basic stabilizer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># initialize BSGS and basic group properties</span>
        <span class="k">def</span> <span class="nf">get_reps</span><span class="p">(</span><span class="n">orbits</span><span class="p">):</span>
            <span class="c"># get the minimal element in the base ordering</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">base_ordering</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> \
              <span class="k">for</span> <span class="n">orbit</span> <span class="ow">in</span> <span class="n">orbits</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">update_nu</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
            <span class="n">temp_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span>\
                         <span class="nb">len</span><span class="p">(</span><span class="n">res_basic_orbits_init_base</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="c"># this corresponds to the element larger than all points</span>
            <span class="k">if</span> <span class="n">temp_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">]):</span>
                <span class="n">nu</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_ordering</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nu</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">temp_index</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schreier_sims_incremental</span><span class="p">()</span>
        <span class="n">base_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">degree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
        <span class="n">identity</span> <span class="o">=</span> <span class="n">_af_new</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">))</span>
        <span class="n">base_ordering</span> <span class="o">=</span> <span class="n">_base_ordering</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
        <span class="c"># add an element larger than all points</span>
        <span class="n">base_ordering</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
        <span class="c"># add an element smaller than all points</span>
        <span class="n">base_ordering</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c"># compute BSGS-related structures</span>
        <span class="n">strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">strong_gens</span><span class="p">)</span>
        <span class="n">basic_orbits</span><span class="p">,</span> <span class="n">transversals</span> <span class="o">=</span> <span class="n">_orbits_transversals_from_bsgs</span><span class="p">(</span><span class="n">base</span><span class="p">,</span>
                                     <span class="n">strong_gens_distr</span><span class="p">)</span>
        <span class="c"># handle subgroup initialization and tests</span>
        <span class="k">if</span> <span class="n">init_subgroup</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">init_subgroup</span> <span class="o">=</span> <span class="n">PermutationGroup</span><span class="p">([</span><span class="n">identity</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">tests</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">trivial_test</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">True</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_len</span><span class="p">):</span>
                <span class="n">tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trivial_test</span><span class="p">)</span>
        <span class="c"># line 1: more initializations.</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">init_subgroup</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">base_len</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">base_len</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c"># line 2: set the base for K to the base for G</span>
        <span class="n">res_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">[:]</span>
        <span class="c"># line 3: compute BSGS and related structures for K</span>
        <span class="n">res_base</span><span class="p">,</span> <span class="n">res_strong_gens</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">schreier_sims_incremental</span><span class="p">(</span>
            <span class="n">base</span><span class="o">=</span><span class="n">res_base</span><span class="p">)</span>
        <span class="n">res_strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">res_base</span><span class="p">,</span>
                                <span class="n">res_strong_gens</span><span class="p">)</span>
        <span class="n">res_generators</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">generators</span>
        <span class="n">res_basic_orbits_init_base</span> <span class="o">=</span> \
        <span class="p">[</span><span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">res_strong_gens_distr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res_base</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>\
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_len</span><span class="p">)]</span>
        <span class="c"># initialize orbit representatives</span>
        <span class="n">orbit_reps</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="c"># line 4: orbit representatives for f-th basic stabilizer of K</span>
        <span class="n">orbits</span> <span class="o">=</span> <span class="n">_orbits</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">res_strong_gens_distr</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
        <span class="n">orbit_reps</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_reps</span><span class="p">(</span><span class="n">orbits</span><span class="p">)</span>
        <span class="c"># line 5: remove the base point from the representatives to avoid</span>
        <span class="c"># getting the identity element as a generator for K</span>
        <span class="n">orbit_reps</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
        <span class="c"># line 6: more initializations</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">identity</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="n">sorted_orbits</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_len</span><span class="p">):</span>
            <span class="n">sorted_orbits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="n">i</span><span class="p">][:]</span>
            <span class="n">sorted_orbits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="n">base_ordering</span><span class="p">[</span><span class="n">point</span><span class="p">])</span>
        <span class="c"># line 7: initializations</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="c"># this corresponds to the element smaller than all points</span>
        <span class="n">mu</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">update_nu</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="c"># initialize computed words</span>
        <span class="n">computed_words</span> <span class="o">=</span> <span class="p">[</span><span class="n">identity</span><span class="p">]</span><span class="o">*</span><span class="n">base_len</span>
        <span class="c"># line 8: main loop</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># apply all the tests</span>
            <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">base_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> \
                <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="ow">in</span> <span class="n">orbit_reps</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="ow">and</span> \
                <span class="n">base_ordering</span><span class="p">[</span><span class="n">mu</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">&lt;</span> \
                <span class="n">base_ordering</span><span class="p">[</span><span class="n">computed_words</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">])]</span> <span class="o">&lt;</span> \
                <span class="n">base_ordering</span><span class="p">[</span><span class="n">nu</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="ow">and</span> \
                    <span class="n">tests</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">computed_words</span><span class="p">):</span>
                <span class="c"># line 11: change the (partial) base of K</span>
                <span class="n">new_point</span> <span class="o">=</span> <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                <span class="n">res_base</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_point</span>
                <span class="n">new_stab_gens</span> <span class="o">=</span> <span class="n">_stabilizer</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">res_strong_gens_distr</span><span class="p">[</span><span class="n">l</span><span class="p">],</span>
                        <span class="n">new_point</span><span class="p">)</span>
                <span class="n">res_strong_gens_distr</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_stab_gens</span>
                <span class="c"># line 12: calculate minimal orbit representatives for the</span>
                <span class="c"># l+1-th basic stabilizer</span>
                <span class="n">orbits</span> <span class="o">=</span> <span class="n">_orbits</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">new_stab_gens</span><span class="p">)</span>
                <span class="n">orbit_reps</span><span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_reps</span><span class="p">(</span><span class="n">orbits</span><span class="p">)</span>
                <span class="c"># line 13: amend sorted orbits</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">temp_orbit</span> <span class="o">=</span> <span class="p">[</span><span class="n">computed_words</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">](</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span>
                             <span class="ow">in</span> <span class="n">basic_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span>
                <span class="n">temp_orbit</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">point</span><span class="p">:</span> <span class="n">base_ordering</span><span class="p">[</span><span class="n">point</span><span class="p">])</span>
                <span class="n">sorted_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp_orbit</span>
                <span class="c"># lines 14 and 15: update variables used minimality tests</span>
                <span class="n">new_mu</span> <span class="o">=</span> <span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="ow">in</span> <span class="n">res_basic_orbits_init_base</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">candidate</span> <span class="o">=</span> <span class="n">computed_words</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">base_ordering</span><span class="p">[</span><span class="n">candidate</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">base_ordering</span><span class="p">[</span><span class="n">new_mu</span><span class="p">]:</span>
                            <span class="n">new_mu</span> <span class="o">=</span> <span class="n">candidate</span>
                <span class="n">mu</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_mu</span>
                <span class="n">update_nu</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="c"># line 16: determine the new transversal element</span>
                <span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">temp_point</span> <span class="o">=</span> <span class="n">sorted_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_array_form</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">temp_point</span><span class="p">)</span>
                <span class="n">u</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">gamma</span><span class="p">]</span>
                <span class="c"># update computed words</span>
                <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmul</span><span class="p">(</span><span class="n">computed_words</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="c"># lines 17 &amp; 18: apply the tests to the group element found</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="n">temp_point</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">base_len</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> \
                <span class="n">base_ordering</span><span class="p">[</span><span class="n">mu</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="o">&lt;</span> \
                <span class="n">base_ordering</span><span class="p">[</span><span class="n">temp_point</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">base_ordering</span><span class="p">[</span><span class="n">nu</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span> <span class="ow">and</span> \
                <span class="n">temp_point</span> <span class="ow">in</span> <span class="n">orbit_reps</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="ow">and</span> \
                <span class="n">tests</span><span class="p">[</span><span class="n">l</span><span class="p">](</span><span class="n">computed_words</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">prop</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
                <span class="c"># line 19: reset the base of K</span>
                <span class="n">res_generators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="n">res_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">[:]</span>
                <span class="c"># line 20: recalculate basic orbits (and transversals)</span>
                <span class="n">res_strong_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="n">res_strong_gens_distr</span> <span class="o">=</span> <span class="n">_distribute_gens_by_base</span><span class="p">(</span><span class="n">res_base</span><span class="p">,</span>
                                                          <span class="n">res_strong_gens</span><span class="p">)</span>
                <span class="n">res_basic_orbits_init_base</span> <span class="o">=</span> \
                <span class="p">[</span><span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">res_strong_gens_distr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res_base</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> \
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_len</span><span class="p">)]</span>
                <span class="c"># line 21: recalculate orbit representatives</span>
                <span class="c"># line 22: reset the search depth</span>
                <span class="n">orbit_reps</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_reps</span><span class="p">(</span><span class="n">orbits</span><span class="p">)</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">f</span>
            <span class="c"># line 23: go up the tree until in the first branch not fully</span>
            <span class="c"># searched</span>
            <span class="k">while</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c"># line 24: if the entire tree is traversed, return K</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">PermutationGroup</span><span class="p">(</span><span class="n">res_generators</span><span class="p">)</span>
            <span class="c"># lines 25-27: update orbit representatives</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">:</span>
                <span class="c"># line 26</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">l</span>
                <span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c"># line 27</span>
                <span class="n">temp_orbits</span> <span class="o">=</span> <span class="n">_orbits</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">res_strong_gens_distr</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>
                <span class="n">orbit_reps</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_reps</span><span class="p">(</span><span class="n">temp_orbits</span><span class="p">)</span>
                <span class="c"># line 28: update variables used for minimality testing</span>
                <span class="n">mu</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">temp_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basic_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> \
                    <span class="nb">len</span><span class="p">(</span><span class="n">res_basic_orbits_init_base</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">temp_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">]):</span>
                    <span class="n">nu</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_ordering</span><span class="p">[</span><span class="n">degree</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nu</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">temp_index</span><span class="p">]</span>
            <span class="c"># line 29: set the next element from the current branch and update</span>
            <span class="c"># accorndingly</span>
            <span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">gamma</span>  <span class="o">=</span> <span class="n">sorted_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gamma</span> <span class="o">=</span> <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_array_form</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sorted_orbits</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">c</span><span class="p">[</span><span class="n">l</span><span class="p">]])</span>

            <span class="n">u</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">transversals</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">gamma</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">computed_words</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmul</span><span class="p">(</span><span class="n">computed_words</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="PermutationGroup.transitivity_degree"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.transitivity_degree">[docs]</a>    <span class="k">def</span> <span class="nf">transitivity_degree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the degree of transitivity of the group.</span>

<span class="sd">        A permutation group ``G`` acting on ``\Omega = \{0, 1, ..., n-1\}`` is</span>
<span class="sd">        ``k``-fold transitive, if, for any k points</span>
<span class="sd">        ``(a_1, a_2, ..., a_k)\in\Omega`` and any k points</span>
<span class="sd">        ``(b_1, b_2, ..., b_k)\in\Omega`` there exists ``g\in G`` such that</span>
<span class="sd">        ``g(a_1)=b_1, g(a_2)=b_2, ..., g(a_k)=b_k``</span>
<span class="sd">        The degree of transitivity of ``G`` is the maximum ``k`` such that</span>
<span class="sd">        ``G`` is ``k``-fold transitive. ([8])</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">        &gt;&gt;&gt; a = Permutation([1, 2, 0])</span>
<span class="sd">        &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">        &gt;&gt;&gt; G = PermutationGroup([a,b])</span>
<span class="sd">        &gt;&gt;&gt; G.transitivity_degree</span>
<span class="sd">        3</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>
<span class="sd">        is_transitive, orbit</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitivity_degree</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">degree</span>
            <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="c"># if G is k-transitive, a tuple (a_0,..,a_k)</span>
            <span class="c"># can be brought to (b_0,...,b_(k-1), b_k)</span>
            <span class="c"># where b_0,...,b_(k-1) are fixed points;</span>
            <span class="c"># consider the group G_k which stabilizes b_0,...,b_(k-1)</span>
            <span class="c"># if G_k is transitive on the subset excluding b_0,...,b_(k-1)</span>
            <span class="c"># then G is (k+1)-transitive</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">orb</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">orbit</span><span class="p">((</span><span class="n">i</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transitivity_degree</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">return</span> <span class="n">i</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">stabilizer</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transitivity_degree</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transitivity_degree</span>
</div>
<div class="viewcode-block" id="PermutationGroup.is_group"><a class="viewcode-back" href="../../../modules/combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup.is_group">[docs]</a>    <span class="k">def</span> <span class="nf">is_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the group meets three criteria: identity is present,</span>
<span class="sd">        the inverse of every element is also an element, and the product of</span>
<span class="sd">        any two elements is also an element. If any of the tests fail, False</span>
<span class="sd">        is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">        &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics import PermutationGroup</span>
<span class="sd">        &gt;&gt;&gt; from sympy.combinatorics.polyhedron import tetrahedron</span>

<span class="sd">        The permutation group given in the tetrahedron object is not</span>
<span class="sd">        a true group:</span>

<span class="sd">        &gt;&gt;&gt; G = tetrahedron.pgroup</span>
<span class="sd">        &gt;&gt;&gt; G.is_group()</span>
<span class="sd">        False</span>

<span class="sd">        But the group generated by the permutations in the tetrahedron</span>
<span class="sd">        pgroup is a proper group:</span>

<span class="sd">        &gt;&gt;&gt; H = PermutationGroup(list(G.generate()))</span>
<span class="sd">        &gt;&gt;&gt; H.is_group()</span>
<span class="sd">        True</span>

<span class="sd">        The identity permutation is present:</span>

<span class="sd">        &gt;&gt;&gt; H.has(Permutation(G.degree - 1))</span>
<span class="sd">        True</span>

<span class="sd">        The product of any two elements from the group is also in the group:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import TableForm</span>
<span class="sd">        &gt;&gt;&gt; g = list(H)</span>
<span class="sd">        &gt;&gt;&gt; n = len(g)</span>
<span class="sd">        &gt;&gt;&gt; m = []</span>
<span class="sd">        &gt;&gt;&gt; for i in g:</span>
<span class="sd">        ...     m.append([g.index(i*H) for H in g])</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; TableForm(m, headings=[range(n), range(n)], wipe_zeros=False)</span>
<span class="sd">           | 0  1  2  3  4  5  6  7  8  9  10 11</span>
<span class="sd">        ----------------------------------------</span>
<span class="sd">         0 | 11 0  8  10 6  2  7  4  5  3  9  1</span>
<span class="sd">         1 | 0  1  2  3  4  5  6  7  8  9  10 11</span>
<span class="sd">         2 | 6  2  7  4  5  3  9  1  11 0  8  10</span>
<span class="sd">         3 | 5  3  9  1  11 0  8  10 6  2  7  4</span>
<span class="sd">         4 | 3  4  0  2  10 6  11 8  9  7  1  5</span>
<span class="sd">         5 | 4  5  6  7  8  9  10 11 0  1  2  3</span>
<span class="sd">         6 | 10 6  11 8  9  7  1  5  3  4  0  2</span>
<span class="sd">         7 | 9  7  1  5  3  4  0  2  10 6  11 8</span>
<span class="sd">         8 | 7  8  4  6  2  10 3  0  1  11 5  9</span>
<span class="sd">         9 | 8  9  10 11 0  1  2  3  4  5  6  7</span>
<span class="sd">        10 | 2  10 3  0  1  11 5  9  7  8  4  6</span>
<span class="sd">        11 | 1  11 5  9  7  8  4  6  2  10 3  0</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        The entries in the table give the element in the group corresponding</span>
<span class="sd">        to the product of a given column element and row element:</span>

<span class="sd">        &gt;&gt;&gt; g[3]*g[2] == g[9]</span>
<span class="sd">        True</span>

<span class="sd">        The inverse of every element is also in the group:</span>

<span class="sd">        &gt;&gt;&gt; TableForm([[g.index(~gi) for gi in g]], headings=[[], range(n)],</span>
<span class="sd">        ...    wipe_zeros=False)</span>
<span class="sd">        0  1 2 3 4  5 6 7 8 9 10 11</span>
<span class="sd">        ---------------------------</span>
<span class="sd">        11 1 7 3 10 9 6 2 8 5 4  0</span>

<span class="sd">        So we see that g[1] and g[3] are equivalent to their inverse while</span>
<span class="sd">        g[7] == ~g[2].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># identity present</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">degree</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g</span> <span class="o">==</span> <span class="n">I</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># associativity already holds: a*(b*c) == (a*b)*c for permutations</span>

        <span class="c"># inverse of each is present</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">~</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># closure</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</div></div>
<span class="k">def</span> <span class="nf">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;tuples&#39;</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Compute the orbit of alpha ``\{g(\alpha) | g \in G\}`` as a set.</span>

<span class="sd">    The time complexity of the algorithm used here is ``O(|Orb|*r)`` where</span>
<span class="sd">    ``|Orb|`` is the size of the orbit and ``r`` is the number of generators of</span>
<span class="sd">    the group. For a more detailed analysis, see [1], p.78, [2], pp. 19-21.</span>
<span class="sd">    Here alpha can be a single point, or a list of points.</span>

<span class="sd">    If alpha is a single point, the ordinary orbit is computed.</span>
<span class="sd">    if alpha is a list of points, there are three available options:</span>

<span class="sd">    &#39;union&#39; - computes the union of the orbits of the points in the list</span>
<span class="sd">    &#39;tuples&#39; - computes the orbit of the list interpreted as an ordered</span>
<span class="sd">    tuple under the group action ( i.e., g((1,2,3)) = (g(1), g(2), g(3)) )</span>
<span class="sd">    &#39;sets&#39; - computes the orbit of the list interpreted as a sets</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup, _orbit</span>
<span class="sd">    &gt;&gt;&gt; a = Permutation([1,2,0,4,5,6,3])</span>
<span class="sd">    &gt;&gt;&gt; G = PermutationGroup([a])</span>
<span class="sd">    &gt;&gt;&gt; _orbit(G.degree, G.generators, 0)</span>
<span class="sd">    set([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; _orbit(G.degree, G.generators, [0, 4], &#39;union&#39;)</span>
<span class="sd">    set([0, 1, 2, 3, 4, 5, 6])</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    orbit, orbit_transversal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s">&#39;__getitem__&#39;</span><span class="p">):</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>

    <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">generators</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;union&#39;</span><span class="p">:</span>
        <span class="n">orb</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">degree</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">:</span>
            <span class="n">used</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">gen</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                    <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;tuples&#39;</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">orb</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
        <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">alpha</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">gen</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used</span><span class="p">:</span>
                    <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                    <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="s">&#39;sets&#39;</span><span class="p">:</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">orb</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
        <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">alpha</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="n">gen</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">temp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used</span><span class="p">:</span>
                    <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                    <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">_orbits</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">generators</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the orbits of G.</span>

<span class="sd">    If rep=False it returns a list of sets else it returns a list of</span>
<span class="sd">    representatives of the orbits</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.permutations import Permutation</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.perm_groups import PermutationGroup, _orbits</span>
<span class="sd">    &gt;&gt;&gt; a = Permutation([0, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; b = Permutation([1, 0, 2])</span>
<span class="sd">    &gt;&gt;&gt; _orbits(a.size, [a, b])</span>
<span class="sd">    [set([0, 1, 2])]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c"># elements that have already appeared in orbits</span>
    <span class="n">orbs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sorted_I</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sorted_I</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">I</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">sorted_I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">orb</span> <span class="o">=</span> <span class="n">_orbit</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">orbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span>
        <span class="c"># remove all indices that are in this orbit</span>
        <span class="n">I</span> <span class="o">-=</span> <span class="n">orb</span>
        <span class="n">sorted_I</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_I</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">orbs</span>

<span class="k">def</span> <span class="nf">_orbit_transversal</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">pairs</span><span class="p">,</span> <span class="n">af</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Computes a transversal for the orbit of ``alpha`` as a set.</span>

<span class="sd">    generators   generators of the group ``G``</span>

<span class="sd">    For a permutation group ``G``, a transversal for the orbit</span>
<span class="sd">    ``Orb = \{g(\alpha) | g \in G\}`` is a set</span>
<span class="sd">    ``\{g_\beta | g_\beta(\alpha) = \beta\}`` for ``\beta \in Orb``.</span>
<span class="sd">    Note that there may be more than one possible transversal.</span>
<span class="sd">    If ``pairs`` is set to ``True``, it returns the list of pairs</span>
<span class="sd">    ``(\beta, g_\beta)``. For a proof of correctness, see [1], p.79</span>

<span class="sd">    if af is True, the transversal elements are given in array form</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.perm_groups import _orbit_transversal</span>
<span class="sd">    &gt;&gt;&gt; G = DihedralGroup(6)</span>
<span class="sd">    &gt;&gt;&gt; _orbit_transversal(G.degree, G.generators, 0, False)</span>
<span class="sd">        [Permutation(5),</span>
<span class="sd">         Permutation(0, 1, 2, 3, 4, 5),</span>
<span class="sd">         Permutation(0, 5)(1, 4)(2, 3),</span>
<span class="sd">         Permutation(0, 2, 4)(1, 3, 5),</span>
<span class="sd">         Permutation(5)(0, 4)(1, 3),</span>
<span class="sd">         Permutation(0, 3)(1, 4)(2, 5)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">))]</span>
    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">degree</span>
    <span class="n">used</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">generators</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">px</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">gen</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">tr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">temp</span><span class="p">,</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">px</span><span class="p">)))</span>
                <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="n">pairs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">af</span><span class="p">:</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tr</span>

    <span class="k">if</span> <span class="n">af</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">y</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">_af_new</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">_stabilizer</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Return the stabilizer subgroup of ``alpha``.</span>

<span class="sd">    The stabilizer of ``\alpha`` is the group ``G_\alpha =</span>
<span class="sd">    \{g \in G | g(\alpha) = \alpha\}``.</span>
<span class="sd">    For a proof of correctness, see [1], p.79.</span>

<span class="sd">    degree       degree of G</span>
<span class="sd">    generators   generators of G</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics import Permutation</span>
<span class="sd">    &gt;&gt;&gt; Permutation.print_cyclic = True</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.perm_groups import _stabilizer</span>
<span class="sd">    &gt;&gt;&gt; from sympy.combinatorics.named_groups import DihedralGroup</span>
<span class="sd">    &gt;&gt;&gt; G = DihedralGroup(6)</span>
<span class="sd">    &gt;&gt;&gt; _stabilizer(G.degree, G.generators, 5)</span>
<span class="sd">    [Permutation(5)(0, 4)(1, 3), Permutation(5)]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    orbit</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">orb</span> <span class="o">=</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]</span>
    <span class="n">table</span> <span class="o">=</span> <span class="p">{</span><span class="n">alpha</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">)}</span>
    <span class="n">table_inv</span> <span class="o">=</span> <span class="p">{</span><span class="n">alpha</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span><span class="p">)}</span>
    <span class="n">used</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">degree</span>
    <span class="n">used</span><span class="p">[</span><span class="n">alpha</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_array_form</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">generators</span><span class="p">]</span>
    <span class="n">stab_gens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">orb</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">gen</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">gen_temp</span> <span class="o">=</span> <span class="n">_af_rmul</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
                <span class="n">table</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">gen_temp</span>
                <span class="n">table_inv</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="n">_af_invert</span><span class="p">(</span><span class="n">gen_temp</span><span class="p">)</span>
                <span class="n">used</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">schreier_gen</span> <span class="o">=</span> <span class="n">_af_rmuln</span><span class="p">(</span><span class="n">table_inv</span><span class="p">[</span><span class="n">temp</span><span class="p">],</span> <span class="n">gen</span><span class="p">,</span> <span class="n">table</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">schreier_gen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stab_gens</span><span class="p">:</span>
                    <span class="n">stab_gens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">schreier_gen</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_af_new</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stab_gens</span><span class="p">]</span>

<span class="n">PermGroup</span> <span class="o">=</span> <span class="n">PermutationGroup</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li>
          <li><a href="../combinatorics.html" >sympy.combinatorics</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Jun 29, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>