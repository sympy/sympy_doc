<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" /><link rel="next" title="PDE" href="pde.html" /><link rel="prev" title="Inequality Solvers" href="inequalities.html" />
        <link rel="canonical" href="https://docs.sympy.org/latest/modules/solvers/ode.html" />

    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/><!-- Generated with Sphinx 6.2.1 and Furo 2023.03.27 -->
        <title>ODE - SymPy 1.13.dev documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=fad236701ea90a88636c2a8c73b44ae642ed2a53" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #52833A;
  --color-brand-content: #307748;
  --color-sidebar-background: #3B5526;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-link-text: #FFFFFF;
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-sidebar-link-text--top-level: #FFFFFF;
  --color-sidebar-item-background--hover: var(--color-brand-primary);
  --color-sidebar-item-expander-background--hover: var(--color-brand-primary);
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #000000bd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --color-foreground-secondary: #53555B;
  --color-admonition-title-background--seealso: #CCCCCC;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #CCCCCC;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-code-background: hsl(80deg 100% 95%);
  --code-font-size: var(--font-size--small);
  --font-stack--monospace: DejaVu Sans Mono,"SFMono-Regular",Menlo,Consolas,Monaco,Liberation Mono,Lucida Console,monospace;;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-brand-primary: #33CB33;
  --color-brand-content: #1DBD1D;
  --color-sidebar-background: #3B5526;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-link-text: #FFFFFF;
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-sidebar-link-text--top-level: #FFFFFF;
  --color-sidebar-item-background--hover: #52833A;
  --color-sidebar-item-expander-background--hover: #52833A;
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --color-foreground-secondary: #9DA1AC;
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-code-background: hsl(80deg 100% 95%);
  --code-font-size: var(--font-size--small);
  --font-stack--monospace: DejaVu Sans Mono,"SFMono-Regular",Menlo,Consolas,Monaco,Liberation Mono,Lucida Console,monospace;;
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-problematic: #B30000;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  --color-brand-primary: #33CB33;
  --color-brand-content: #1DBD1D;
  --color-sidebar-background: #3B5526;
  --color-sidebar-background-border: var(--color-background-primary);
  --color-sidebar-link-text: #FFFFFF;
  --color-sidebar-brand-text: var(--color-sidebar-link-text--top-level);
  --color-sidebar-link-text--top-level: #FFFFFF;
  --color-sidebar-item-background--hover: #52833A;
  --color-sidebar-item-expander-background--hover: #52833A;
  --color-link-underline--hover: var(--color-link);
  --color-api-keyword: #FFFFFFbd;
  --color-api-name: var(--color-brand-content);
  --color-api-pre-name: var(--color-brand-content);
  --api-font-size: var(--font-size--normal);
  --color-foreground-secondary: #9DA1AC;
  --color-admonition-title-background--seealso: #555555;
  --color-admonition-title--seealso: black;
  --color-admonition-title-background--note: #555555;
  --color-admonition-title--note: black;
  --color-admonition-title-background--warning: var(--color-problematic);
  --color-admonition-title--warning: white;
  --admonition-font-size: var(--font-size--normal);
  --admonition-title-font-size: var(--font-size--normal);
  --color-code-background: hsl(80deg 100% 95%);
  --code-font-size: var(--font-size--small);
  --font-stack--monospace: DejaVu Sans Mono,"SFMono-Regular",Menlo,Consolas,Monaco,Liberation Mono,Lucida Console,monospace;;
  --color-api-overall: #FFFFFF90;
  --color-api-paren: #FFFFFF90;
  --color-problematic: #B30000;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">SymPy 1.13.dev documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><div class="sidebar-scroll"><a class="sidebar-brand" href="../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../../_static/sympylogo.png" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">SymPy 1.13.dev documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../tutorials/intro-tutorial/index.html">Introductory Tutorial</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/intro-tutorial/preliminaries.html">Preliminaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/intro-tutorial/intro.html">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/intro-tutorial/gotchas.html">Gotchas</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../tutorials/intro-tutorial/features.html">SymPy Features</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/intro-tutorial/basic_operations.html">Basic Operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/intro-tutorial/printing.html">Printing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/intro-tutorial/simplification.html">Simplification</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/intro-tutorial/calculus.html">Calculus</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/intro-tutorial/solvers.html">Solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/intro-tutorial/matrices.html">Matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/intro-tutorial/manipulation.html">Advanced Expression Manipulation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/intro-tutorial/next.html">What’s Next</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../guides/index.html">How-to Guides</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../guides/assumptions.html">Assumptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guides/booleans.html">Symbolic and fuzzy booleans</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guides/custom-functions.html">Writing Custom Functions</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../guides/solving/index.html">Solve Equations</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/solving-guidance.html">Solving Guidance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/solve-equation-algebraically.html">Solve an Equation Algebraically</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/solve-system-of-equations-algebraically.html">Solve a System of Equations Algebraically</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/solve-numerically.html">Solve One or a System of Equations Numerically</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/solve-ode.html">Solve an Ordinary Differential Equation (ODE) Algebraically</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/find-roots-polynomial.html">Find the Roots of a Polynomial Algebraically or Numerically</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/solve-matrix-equation.html">Solve a Matrix Equation Algebraically</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/reduce-inequalities-algebraically.html">Reduce One or a System of Inequalities for a Single Variable Algebraically</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guides/solving/solve-diophantine-equation.html">Solve a Diophantine Equation Algebraically</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../citing.html">Citing SymPy</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../explanation/index.html">Explanations</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../explanation/gotchas.html">Gotchas and Pitfalls</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../explanation/solve_output.html">Solve Output by Type</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../explanation/special_topics/index.html">SymPy Special Topics</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../explanation/special_topics/finite_diff_derivatives.html">Finite Difference Approximations to Derivatives</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../explanation/special_topics/classification.html">Classification of SymPy objects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../explanation/active-deprecations.html">List of active deprecations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../explanation/glossary.html">Glossary</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../reference/index.html">API Reference</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current has-children"><a class="reference internal" href="../../reference/public/basics/index.html">Basics</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l3 has-children"><a class="reference internal" href="../assumptions/index.html">Assumptions</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../assumptions/ask.html">Ask</a></li>
<li class="toctree-l4"><a class="reference internal" href="../assumptions/assume.html">Assume</a></li>
<li class="toctree-l4"><a class="reference internal" href="../assumptions/refine.html">Refine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../assumptions/predicates.html">Predicates</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../calculus/index.html">Calculus</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../combinatorics/index.html">Combinatorics</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/partitions.html">Partitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/permutations.html">Permutations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/perm_groups.html">Permutation Groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/polyhedron.html">Polyhedron</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/prufer.html">Prufer Sequences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/subsets.html">Subsets</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/graycode.html">Gray Code</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/named_groups.html">Named Groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/galois.html">Galois Groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/group_numbers.html">Nilpotent, Abelian and Cyclic Numbers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/util.html">Utilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/group_constructs.html">Group constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/testutil.html">Test Utilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/tensor_can.html">Tensor Canonicalization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/fp_groups.html">Finitely Presented Groups</a></li>
<li class="toctree-l4"><a class="reference internal" href="../combinatorics/pc_groups.html">Polycyclic Groups</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../functions/index.html">Functions</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../functions/elementary.html">Elementary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../functions/combinatorial.html">Combinatorial</a></li>
<li class="toctree-l4"><a class="reference internal" href="../functions/combinatorial.html#enumeration">Enumeration</a></li>
<li class="toctree-l4"><a class="reference internal" href="../functions/special.html">Special</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../integrals/index.html">Integrals</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../integrals/g-functions.html">Computing Integrals using Meijer G-Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../integrals/integrals.html">Integrals</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../series/index.html">Series</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../series/series.html">Series Expansions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../series/sequences.html">Sequences</a></li>
<li class="toctree-l4"><a class="reference internal" href="../series/fourier.html">Fourier Series</a></li>
<li class="toctree-l4"><a class="reference internal" href="../series/formal.html">Formal Power Series</a></li>
<li class="toctree-l4"><a class="reference internal" href="../series/limitseq.html">Limits of Sequences</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../simplify/index.html">Simplify</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../simplify/simplify.html">Simplify</a></li>
<li class="toctree-l4"><a class="reference internal" href="../simplify/hyperexpand.html">Hypergeometric Expansion</a></li>
<li class="toctree-l4"><a class="reference internal" href="../simplify/fu.html">Hongguang Fu’s Trigonometric Simplification</a></li>
</ul>
</li>
<li class="toctree-l3 current has-children"><a class="reference internal" href="index.html">Solvers</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="diophantine.html">Diophantine</a></li>
<li class="toctree-l4"><a class="reference internal" href="inequalities.html">Inequality Solvers</a></li>
<li class="toctree-l4 current current-page"><a class="current reference internal" href="#">ODE</a></li>
<li class="toctree-l4"><a class="reference internal" href="pde.html">PDE</a></li>
<li class="toctree-l4"><a class="reference internal" href="solvers.html">Solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="solveset.html">Solveset</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../abc.html">abc</a></li>
<li class="toctree-l3"><a class="reference internal" href="../algebras.html">Algebras</a></li>
<li class="toctree-l3"><a class="reference internal" href="../concrete.html">Concrete</a></li>
<li class="toctree-l3"><a class="reference internal" href="../core.html">Core</a></li>
<li class="toctree-l3"><a class="reference internal" href="../discrete.html">Discrete</a></li>
<li class="toctree-l3"><a class="reference internal" href="../evalf.html">Numerical Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../numeric-computation.html">Numeric Computation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../rewriting.html">Term Rewriting</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../reference/public/codegeneration/index.html">Code Generation</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../codegen.html">Code Generation</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../reference/public/logic/index.html">Logic</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" role="switch" type="checkbox"/><label for="toctree-checkbox-18"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../logic.html">Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../sets.html">Sets</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../reference/public/matrices/index.html">Matrices</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" role="switch" type="checkbox"/><label for="toctree-checkbox-19"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../matrices/index.html">Matrices</a><input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" role="switch" type="checkbox"/><label for="toctree-checkbox-20"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../matrices/matrices.html">Matrices (linear algebra)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../matrices/common.html">Common Matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../matrices/dense.html">Dense Matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../matrices/sparse.html">Sparse Matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../matrices/sparsetools.html">Sparse Tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="../matrices/immutablematrices.html">Immutable Matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../matrices/expressions.html">Matrix Expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../matrices/normalforms.html">Matrix Normal Forms</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../tensor/index.html">Tensor</a><input class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" role="switch" type="checkbox"/><label for="toctree-checkbox-21"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../tensor/array.html">N-dim array</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tensor/array_expressions.html">N-dim array expressions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tensor/indexed.html">Indexed Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tensor/index_methods.html">Methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tensor/tensor.html">Tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="../tensor/toperators.html">Tensor Operators</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../vector/index.html">Vector</a><input class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" role="switch" type="checkbox"/><label for="toctree-checkbox-22"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../vector/intro.html">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="../vector/basics.html">Basic Implementation details</a></li>
<li class="toctree-l4"><a class="reference internal" href="../vector/coordsys.html">More about Coordinate Systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../vector/fields.html">Scalar and Vector Field Functionality</a></li>
<li class="toctree-l4"><a class="reference internal" href="../vector/examples.html">General examples of usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="../vector/vector_integration.html">Applications of Vector Integrals</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../vector/api/index.html">Vector API</a><input class="toctree-checkbox" id="toctree-checkbox-23" name="toctree-checkbox-23" role="switch" type="checkbox"/><label for="toctree-checkbox-23"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../vector/api/classes.html">Essential Classes in sympy.vector (docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../vector/api/orienterclasses.html">Orienter classes (docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../vector/api/vectorfunctions.html">Essential Functions in sympy.vector (docstrings)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../reference/public/numbertheory/index.html">Number Theory</a><input class="toctree-checkbox" id="toctree-checkbox-24" name="toctree-checkbox-24" role="switch" type="checkbox"/><label for="toctree-checkbox-24"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../ntheory.html">Number Theory</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../reference/public/physics/index.html">Physics</a><input class="toctree-checkbox" id="toctree-checkbox-25" name="toctree-checkbox-25" role="switch" type="checkbox"/><label for="toctree-checkbox-25"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../physics/hydrogen.html">Hydrogen Wavefunctions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics/matrices.html">Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics/paulialgebra.html">Pauli Algebra</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics/qho_1d.html">Quantum Harmonic Oscillator in 1-D</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics/sho.html">Quantum Harmonic Oscillator in 3-D</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics/secondquant.html">Second Quantization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics/wigner.html">Wigner Symbols</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../physics/units/index.html">Unit systems</a><input class="toctree-checkbox" id="toctree-checkbox-26" name="toctree-checkbox-26" role="switch" type="checkbox"/><label for="toctree-checkbox-26"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../physics/units/philosophy.html">Philosophy behind unit systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/units/examples.html">More examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/units/dimensions.html">Dimensions and dimension systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/units/prefixes.html">Unit prefixes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/units/unitsystem.html">Units and unit systems</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/units/quantities.html">Physical quantities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../physics/hep/index.html">High energy physics</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../physics/vector/index.html">The Physics Vector Module</a><input class="toctree-checkbox" id="toctree-checkbox-27" name="toctree-checkbox-27" role="switch" type="checkbox"/><label for="toctree-checkbox-27"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../physics/vector/vectors.html">Vector &amp; ReferenceFrame</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/vector/kinematics.html">Vector: Kinematics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/vector/advanced.html">Potential Issues/Advanced Topics/Future Features in Physics/Vector Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/vector/fields.html">Scalar and Vector Field Functionality</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../physics/vector/api/index.html">Physics Vector API</a><input class="toctree-checkbox" id="toctree-checkbox-28" name="toctree-checkbox-28" role="switch" type="checkbox"/><label for="toctree-checkbox-28"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../physics/vector/api/classes.html">Essential Classes</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/vector/api/kinematics.html">Kinematics (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/vector/api/printing.html">Printing (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/vector/api/functions.html">Essential Functions (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/vector/api/fieldfunctions.html">Docstrings for basic field functions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../physics/mechanics/index.html">Classical Mechanics</a><input class="toctree-checkbox" id="toctree-checkbox-29" name="toctree-checkbox-29" role="switch" type="checkbox"/><label for="toctree-checkbox-29"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/masses.html">Masses, Inertias, Particles and Rigid Bodies in Physics/Mechanics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/kane.html">Kane’s Method in Physics/Mechanics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/lagrange.html">Lagrange’s Method in Physics/Mechanics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/joints.html">Joints Framework in Physics/Mechanics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/symsystem.html">Symbolic Systems in Physics/Mechanics</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../physics/mechanics/linearize.html">Linearization in Physics/Mechanics</a><input class="toctree-checkbox" id="toctree-checkbox-30" name="toctree-checkbox-30" role="switch" type="checkbox"/><label for="toctree-checkbox-30"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/examples/lin_pend_nonmin_example.html">Nonminimal Coordinates Pendulum</a></li>
</ul>
</li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../physics/mechanics/examples.html">Examples for Physics/Mechanics</a><input class="toctree-checkbox" id="toctree-checkbox-31" name="toctree-checkbox-31" role="switch" type="checkbox"/><label for="toctree-checkbox-31"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5 has-children"><a class="reference internal" href="../physics/mechanics/examples/rollingdisc_example.html">A rolling disc</a><input class="toctree-checkbox" id="toctree-checkbox-32" name="toctree-checkbox-32" role="switch" type="checkbox"/><label for="toctree-checkbox-32"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l6"><a class="reference internal" href="../physics/mechanics/examples/rollingdisc_example_kane.html">A rolling disc, with Kane’s method</a></li>
<li class="toctree-l6"><a class="reference internal" href="../physics/mechanics/examples/rollingdisc_example_kane_constraints.html">A rolling disc, with Kane’s method and constraint forces</a></li>
<li class="toctree-l6"><a class="reference internal" href="../physics/mechanics/examples/rollingdisc_example_lagrange.html">A rolling disc using Lagrange’s Method</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/examples/bicycle_example.html">A bicycle</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/examples/lin_pend_nonmin_example.html">Nonminimal Coordinates Pendulum</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/examples/multi_degree_freedom_holonomic_system.html">Multi Degree of Freedom Holonomic System</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/examples/four_bar_linkage_example.html">A four bar linkage</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/advanced.html">Potential Issues/Advanced Topics/Future Features in Physics/Mechanics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/reference.html">References for Physics/Mechanics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/autolev_parser.html">Autolev Parser</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/mechanics/sympy_mechanics_for_autolev_users.html">SymPy Mechanics for Autolev Users</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../physics/mechanics/api/index.html">Mechanics API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-33" name="toctree-checkbox-33" role="switch" type="checkbox"/><label for="toctree-checkbox-33"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/api/part_bod.html">Bodies, Inertias, Loads &amp; Other Functions (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/api/body.html">Body (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/api/kane_lagrange.html">Kane’s Method &amp; Lagrange’s Method (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/api/joint.html">Joints Framework (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/api/system.html">SymbolicSystem (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/api/linearize.html">Linearization (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/api/expr_manip.html">Expression Manipulation (Docstrings)</a></li>
<li class="toctree-l5"><a class="reference internal" href="../physics/mechanics/api/printing.html">Printing (Docstrings)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../physics/quantum/index.html">Quantum Mechanics</a><input class="toctree-checkbox" id="toctree-checkbox-34" name="toctree-checkbox-34" role="switch" type="checkbox"/><label for="toctree-checkbox-34"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/anticommutator.html">Anticommutator</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/cg.html">Clebsch-Gordan Coefficients</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/commutator.html">Commutator</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/constants.html">Constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/dagger.html">Dagger</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/innerproduct.html">Inner Product</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/tensorproduct.html">Tensor Product</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/cartesian.html">Cartesian Operators and States</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/hilbert.html">Hilbert Space</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/operator.html">Operator</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/operatorset.html">Operator/State Helper Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/qapply.html">Qapply</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/represent.html">Represent</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/spin.html">Spin</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/state.html">State</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/circuitplot.html">Circuit Plot</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/gate.html">Gates</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/grover.html">Grover’s Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/qft.html">QFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/qubit.html">Qubit</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/shor.html">Shor’s Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/quantum/piab.html">Particle in a Box</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../physics/optics/index.html">Optics Module</a><input class="toctree-checkbox" id="toctree-checkbox-35" name="toctree-checkbox-35" role="switch" type="checkbox"/><label for="toctree-checkbox-35"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../physics/optics/gaussopt.html">Gaussian Optics</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/optics/medium.html">Medium</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/optics/polarization.html">Polarization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/optics/utils.html">Utilities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/optics/waves.html">Waves</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../physics/control/index.html">Control Module</a><input class="toctree-checkbox" id="toctree-checkbox-36" name="toctree-checkbox-36" role="switch" type="checkbox"/><label for="toctree-checkbox-36"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../physics/control/control.html">Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/control/lti.html">Control API</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/control/control_plots.html">Control System Plots</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../physics/continuum_mechanics/index.html">Continuum Mechanics</a><input class="toctree-checkbox" id="toctree-checkbox-37" name="toctree-checkbox-37" role="switch" type="checkbox"/><label for="toctree-checkbox-37"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../physics/continuum_mechanics/beam.html">Beam (Docstrings)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/continuum_mechanics/beam_problems.html">Solving Beam Bending Problems using Singularity Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics/continuum_mechanics/truss.html">Truss (Docstrings)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../reference/public/utilities/index.html">Utilities</a><input class="toctree-checkbox" id="toctree-checkbox-38" name="toctree-checkbox-38" role="switch" type="checkbox"/><label for="toctree-checkbox-38"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../testing/index.html">Testing</a><input class="toctree-checkbox" id="toctree-checkbox-39" name="toctree-checkbox-39" role="switch" type="checkbox"/><label for="toctree-checkbox-39"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../testing/pytest.html">pytest</a></li>
<li class="toctree-l4"><a class="reference internal" href="../testing/randtest.html">Randomised Testing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../testing/runtests.html">Run Tests</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../utilities/index.html">Utilities</a><input class="toctree-checkbox" id="toctree-checkbox-40" name="toctree-checkbox-40" role="switch" type="checkbox"/><label for="toctree-checkbox-40"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../utilities/autowrap.html">Autowrap Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/codegen.html">Codegen</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/decorator.html">Decorator</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/enumerative.html">Enumerative</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/exceptions.html">Exceptions and Warnings</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/iterables.html">Iterables</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/lambdify.html">Lambdify</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/memoization.html">Memoization</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/misc.html">Miscellaneous</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/pkgdata.html">PKGDATA</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/source.html">Source Code Inspection</a></li>
<li class="toctree-l4"><a class="reference internal" href="../utilities/timeutils.html">Timing Utilities</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../interactive.html">Interactive</a></li>
<li class="toctree-l3"><a class="reference internal" href="../parsing.html">Parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../printing.html">Printing</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../reference/public/topics/index.html">Topics</a><input class="toctree-checkbox" id="toctree-checkbox-41" name="toctree-checkbox-41" role="switch" type="checkbox"/><label for="toctree-checkbox-41"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../geometry/index.html">Geometry</a><input class="toctree-checkbox" id="toctree-checkbox-42" name="toctree-checkbox-42" role="switch" type="checkbox"/><label for="toctree-checkbox-42"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../geometry/entities.html">Entities</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geometry/utils.html">Utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geometry/points.html">Points</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geometry/lines.html">Lines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geometry/curves.html">Curves</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geometry/ellipses.html">Ellipses</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geometry/polygons.html">Polygons</a></li>
<li class="toctree-l4"><a class="reference internal" href="../geometry/plane.html">Plane</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../holonomic/index.html">Holonomic</a><input class="toctree-checkbox" id="toctree-checkbox-43" name="toctree-checkbox-43" role="switch" type="checkbox"/><label for="toctree-checkbox-43"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../holonomic/about.html">About Holonomic Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../holonomic/represent.html">Representation of holonomic functions in SymPy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../holonomic/operations.html">Operations on holonomic functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../holonomic/convert.html">Converting other representations to holonomic</a></li>
<li class="toctree-l4"><a class="reference internal" href="../holonomic/uses.html">Uses and Current limitations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../holonomic/internal.html">Internal API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../liealgebras/index.html">Lie Algebra</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../polys/index.html">Polynomial Manipulation</a><input class="toctree-checkbox" id="toctree-checkbox-44" name="toctree-checkbox-44" role="switch" type="checkbox"/><label for="toctree-checkbox-44"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../polys/basics.html">Basic functionality of the module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/wester.html">Examples from Wester’s Article</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/reference.html">Polynomials Manipulation Module Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/agca.html">AGCA - Algebraic Geometry and Commutative Algebra Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/domainsintro.html">Introducing the Domains of the poly module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/domainsref.html">Reference docs for the Poly Domains</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/internals.html">Internals of the Polynomial Manipulation Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/ringseries.html">Series Manipulation using Polynomials</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/literature.html">Literature</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/solvers.html">Poly solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/domainmatrix.html">Introducing the domainmatrix of the poly module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../polys/numberfields.html">Number Fields</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../categories.html">Category Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crypto.html">Cryptography</a></li>
<li class="toctree-l3"><a class="reference internal" href="../diffgeom.html">Differential Geometry</a></li>
<li class="toctree-l3"><a class="reference internal" href="../plotting.html">Plotting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../stats.html">Stats</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../contributing/index.html">Contributing</a><input class="toctree-checkbox" id="toctree-checkbox-45" name="toctree-checkbox-45" role="switch" type="checkbox"/><label for="toctree-checkbox-45"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/introduction-to-contributing.html">Introduction to Contributing</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../contributing/new-contributors-guide/index.html">Guide for New Contributors</a><input class="toctree-checkbox" id="toctree-checkbox-46" name="toctree-checkbox-46" role="switch" type="checkbox"/><label for="toctree-checkbox-46"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../contributing/new-contributors-guide/dev-setup.html">Setup Development Environment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../contributing/new-contributors-guide/workflow-process.html">Development Workflow Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../contributing/new-contributors-guide/writing-tests.html">Writing Tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../contributing/new-contributors-guide/build-docs.html">Building the Documentation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/dependencies.html">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/debug.html">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/docstring.html">SymPy Docstrings Style Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/documentation-style-guide.html">Docstring Style Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/deprecations.html">Deprecation Policy</a></li>
</ul>
</li>
</ul>

</div><!-- Versions Menu. In order to work, there should be a file called versions.json one level up from the documentation listing the "dev" and "latest" version numbers, like
{
    "latest": "1.10",
    "dev": "1.11.dev"
}
-->
<div class="sidebar-tree sidebar-versions">
  <h5 class="versions-header">Documentation Version</h4>
</div>

<!-- Make sure jquery is loaded (we would put this as a separate .js, but it uses jinja templates in some of the variables) -->
<script src="../../_static/jquery.js"></script>
<script>
  var versions_json_loc = "../../../versions.json";

  function add_version_menu(json_loc) {
      var menu = document.createElement("ul");
      var thisversion = "dev"
      $.getJSON(json_loc, function(versions) {
          for (var key in versions) {
              if (key != "latest" && key != "dev") {
                  console.error("Invalid key in versions.json", key);
              } else {
                  var version = document.createElement("li")
                  version.className = "sidebar-versions-l1 sidebar-versions-" + key + "-l1";
                  if (key == thisversion){
                      version.className += " current-version";
                  }
                  var a = document.createElement("a");
                  a.className = "reference internal";
                  a.innerHTML = "SymPy " + versions[key] + " (" + key + " version)";
                  a.title = key + " version";
                  a.href = "https://docs.sympy.org/" + key + "/modules/solvers/ode.html";
                  version.appendChild(a);
                  menu.appendChild(version);
              }
          }
      }).done(function() {
          console.log("versions.json read successfully");
      }).fail(function() {
          var version = document.createElement("li")
          version.className = "sidebar-versions-l1 sidebar-versions-latest-l1";
          var d = document.createElement("div");
          d.className = "versions-not-found"
          d.innerHTML = "Other Versions Not Found";
          d.title = "The version selection menu is only available for the documentation published on docs.sympy.org";
          version.appendChild(d);
          menu.appendChild(version);
          console.error("Could not read versions.json");
      }).always(function() {
          $(".sidebar-versions").append(menu)
      });
  };

  $( document ).ready( add_version_menu(versions_json_loc));
</script></div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="ode">
<span id="ode-docs"></span><h1>ODE<a class="headerlink" href="#ode" title="Permalink to this heading">#</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a beginner-friendly guide focused on solving ODEs, refer to
<a class="reference internal" href="../../guides/solving/solve-ode.html#solving-guide-ode"><span class="std std-ref">Solve an Ordinary Differential Equation (ODE) Algebraically</span></a>.</p>
</div>
<span class="target" id="module-sympy.solvers.ode"></span><section id="user-functions">
<h2>User Functions<a class="headerlink" href="#user-functions" title="Permalink to this heading">#</a></h2>
<p>These are functions that are imported into the global namespace with <code class="docutils literal notranslate"><span class="pre">from</span>
<span class="pre">sympy</span> <span class="pre">import</span> <span class="pre">*</span></code>.  These functions (unlike <a class="reference internal" href="#hint-functions">Hint Functions</a>, below) are
intended for use by ordinary users of SymPy.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.dsolve">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">dsolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L356-L640"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.dsolve" title="Permalink to this definition">#</a></dt>
<dd><p>Solves any (supported) kind of ordinary differential equation and
system of ordinary differential equations.</p>
<p class="rubric">For Single Ordinary Differential Equation</p>
<p>It is classified under this when number of equation in <code class="docutils literal notranslate"><span class="pre">eq</span></code> is one.
<strong>Usage</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span> <span class="pre">hint)</span></code> -&gt; Solve ordinary differential equation
<code class="docutils literal notranslate"><span class="pre">eq</span></code> for function <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>, using method <code class="docutils literal notranslate"><span class="pre">hint</span></code>.</p>
</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">eq</span></code> can be any supported ordinary differential equation (see the</dt><dd><p><a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code></a> docstring for supported methods).
This can either be an <a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></a>,
or an expression, which is assumed to be equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">f(x)</span></code> is a function of one variable whose derivatives in that</dt><dd><p>variable make up the ordinary differential equation <code class="docutils literal notranslate"><span class="pre">eq</span></code>.  In
many cases it is not necessary to provide this; it will be
autodetected (and an error raised if it could not be detected).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">hint</span></code> is the solving method that you want dsolve to use.  Use</dt><dd><p><code class="docutils literal notranslate"><span class="pre">classify_ode(eq,</span> <span class="pre">f(x))</span></code> to get all of the possible hints for an
ODE.  The default hint, <code class="docutils literal notranslate"><span class="pre">default</span></code>, will use whatever hint is
returned first by <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>.  See
Hints below for more options that you can use for hint.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">simplify</span></code> enables simplification by</dt><dd><p><a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a>.  See its docstring for more
information.  Turn this off, for example, to disable solving of
solutions for <code class="docutils literal notranslate"><span class="pre">func</span></code> or simplification of arbitrary constants.
It will still integrate with this hint. Note that the solution may
contain more arbitrary constants than the order of the ODE with
this option enabled.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">xi</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code> are the infinitesimal functions of an ordinary</dt><dd><p>differential equation. They are the infinitesimals of the Lie group
of point transformations for which the differential equation is
invariant. The user can specify values for the infinitesimals. If
nothing is specified, <code class="docutils literal notranslate"><span class="pre">xi</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code> are calculated using
<a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">infinitesimals()</span></code></a> with the help of various
heuristics.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">ics</span></code> is the set of initial/boundary conditions for the differential equation.</dt><dd><p>It should be given in the form of <code class="docutils literal notranslate"><span class="pre">{f(x0):</span> <span class="pre">x1,</span> <span class="pre">f(x).diff(x).subs(x,</span> <span class="pre">x2):</span>
<span class="pre">x3}</span></code> and so on.  For power series solutions, if no initial
conditions are specified <code class="docutils literal notranslate"><span class="pre">f(0)</span></code> is assumed to be <code class="docutils literal notranslate"><span class="pre">C0</span></code> and the power
series solution is calculated about 0.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">x0</span></code> is the point about which the power series solution of a differential</dt><dd><p>equation is to be evaluated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">n</span></code> gives the exponent of the dependent variable up to which the power series</dt><dd><p>solution of a differential equation is to be evaluated.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>Aside from the various solving methods, there are also some meta-hints
that you can pass to <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">default</span></code>:</dt><dd><p>This uses whatever hint is returned first by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>. This is the
default argument to <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all</span></code>:</dt><dd><p>To make <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> apply all
relevant classification hints, use <code class="docutils literal notranslate"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&quot;all&quot;)</span></code>.  This will return a dictionary of
<code class="docutils literal notranslate"><span class="pre">hint:solution</span></code> terms.  If a hint causes dsolve to raise the
<code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>, value of that hint’s key will be the
exception object raised.  The dictionary will also include
some special keys:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">order</span></code>: The order of the ODE.  See also
<a class="reference internal" href="solvers.html#sympy.solvers.deutils.ode_order" title="sympy.solvers.deutils.ode_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_order()</span></code></a> in
<code class="docutils literal notranslate"><span class="pre">deutils.py</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">best</span></code>: The simplest hint; what would be returned by
<code class="docutils literal notranslate"><span class="pre">best</span></code> below.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">best_hint</span></code>: The hint that would produce the solution
given by <code class="docutils literal notranslate"><span class="pre">best</span></code>.  If more than one hint produces the best
solution, the first one in the tuple returned by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> is chosen.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">default</span></code>: The solution that would be returned by default.
This is the one produced by the hint that appears first in
the tuple returned by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>.</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>:</dt><dd><p>This is the same as <code class="docutils literal notranslate"><span class="pre">all</span></code>, except if a hint also has a
corresponding <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint, it only returns the
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint.  This is useful if <code class="docutils literal notranslate"><span class="pre">all</span></code> causes
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> to hang because of a
difficult or impossible integral.  This meta-hint will also be
much faster than <code class="docutils literal notranslate"><span class="pre">all</span></code>, because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> is an expensive
routine.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">best</span></code>:</dt><dd><p>To have <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> try all methods
and return the simplest one.  This takes into account whether
the solution is solvable in the function, whether it contains
any Integral classes (i.e.  unevaluatable integrals), and
which one is the shortest in size.</p>
</dd>
</dl>
<p>See also the <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> docstring for
more info on hints, and the <a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code></a> docstring for
a list of all supported hints.</p>
</div></blockquote>
<p><strong>Tips</strong></p>
<blockquote>
<div><ul>
<li><p>You can declare the derivative of an unknown function this way:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span> <span class="c1"># x is the independent variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># f is a function of x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># f_ will be the derivative of f with respect to x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>See <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code> for many tests, which serves also as a set of
examples for how to use <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> always returns an
<a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></a> class (except for the
case when the hint is <code class="docutils literal notranslate"><span class="pre">all</span></code> or <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>).  If possible, it
solves the solution explicitly for the function being solved for.
Otherwise, it returns an implicit solution.</p></li>
<li><p>Arbitrary constants are symbols named <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, and so on.</p></li>
<li><p>Because all solutions should be mathematically equivalent, some
hints may return the exact same result for an ODE. Often, though,
two different hints will return the same solution formatted
differently.  The two should be equivalent. Also note that sometimes
the values of the arbitrary constants in two different solutions may
not be the same, because one constant may have “absorbed” other
constants into it.</p></li>
<li><p>Do <code class="docutils literal notranslate"><span class="pre">help(ode.ode_&lt;hintname&gt;)</span></code> to get help more information on a
specific hint, where <code class="docutils literal notranslate"><span class="pre">&lt;hintname&gt;</span></code> is the name of a hint without
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code>.</p></li>
</ul>
</div></blockquote>
<p class="rubric">For System Of Ordinary Differential Equations</p>
<dl class="simple">
<dt><strong>Usage</strong></dt><dd><p><code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">func)</span></code> -&gt; Solve a system of ordinary differential
equations <code class="docutils literal notranslate"><span class="pre">eq</span></code> for <code class="docutils literal notranslate"><span class="pre">func</span></code> being list of functions including
<span class="math notranslate nohighlight">\(x(t)\)</span>, <span class="math notranslate nohighlight">\(y(t)\)</span>, <span class="math notranslate nohighlight">\(z(t)\)</span> where number of functions in the list depends
upon the number of equations provided in <code class="docutils literal notranslate"><span class="pre">eq</span></code>.</p>
</dd>
</dl>
<p><strong>Details</strong></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">eq</span></code> can be any supported system of ordinary differential equations
This can either be an <a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></a>,
or an expression, which is assumed to be equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">func</span></code> holds <code class="docutils literal notranslate"><span class="pre">x(t)</span></code> and <code class="docutils literal notranslate"><span class="pre">y(t)</span></code> being functions of one variable which
together with some of their derivatives make up the system of ordinary
differential equation <code class="docutils literal notranslate"><span class="pre">eq</span></code>. It is not necessary to provide this; it
will be autodetected (and an error raised if it could not be detected).</p>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>The hints are formed by parameters returned by classify_sysode, combining
them give hints name used later for forming method name.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">Eq(f(x), C1*sin(3*x) + C2*cos(3*x))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">12</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">21</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[Eq(x(t), C1*x0(t) + C2*x0(t)*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)**2, t)),</span>
<span class="go">Eq(y(t), C1*y0(t) + C2*(y0(t)*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)**2, t) +</span>
<span class="go">exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0(t)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">{Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t))), Eq(y(t), -1/(C1 - cos(t)))}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.systems.dsolve_system">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.systems.</span></span><span class="sig-name descname"><span class="pre">dsolve_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/systems.py#L1970-L2135"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.systems.dsolve_system" title="Permalink to this definition">#</a></dt>
<dd><p>Solves any(supported) system of Ordinary Differential Equations</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>eqs</strong> : List</p>
<blockquote>
<div><p>system of ODEs to be solved</p>
</div></blockquote>
<p><strong>funcs</strong> : List or None</p>
<blockquote>
<div><p>List of dependent variables that make up the system of ODEs</p>
</div></blockquote>
<p><strong>t</strong> : Symbol or None</p>
<blockquote>
<div><p>Independent variable in the system of ODEs</p>
</div></blockquote>
<p><strong>ics</strong> : Dict or None</p>
<blockquote>
<div><p>Set of initial boundary/conditions for the system of ODEs</p>
</div></blockquote>
<p><strong>doit</strong> : Boolean</p>
<blockquote>
<div><p>Evaluate the solutions if True. Default value is True. Can be
set to false if the integral evaluation takes too much time and/or
is not required.</p>
</div></blockquote>
<p><strong>simplify: Boolean</strong></p>
<blockquote>
<div><p>Simplify the solutions for the systems. Default value is True.
Can be set to false if simplification takes too much time and/or
is not required.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List of List of Equations</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>When the system of ODEs is not solvable by this function.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote>
<div><p>When the parameters passed are not in the required form.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This function takes a system of ODEs as an input, determines if the
it is solvable by this function, and returns the solution if found any.</p>
<p>This function can handle:
1. Linear, First Order, Constant coefficient homogeneous system of ODEs
2. Linear, First Order, Constant coefficient non-homogeneous system of ODEs
3. Linear, First Order, non-constant coefficient homogeneous system of ODEs
4. Linear, First Order, non-constant coefficient non-homogeneous system of ODEs
5. Any implicit system which can be divided into system of ODEs which is of the above 4 forms
6. Any higher order linear system of ODEs that can be reduced to one of the 5 forms of systems described above.</p>
<p>The types of systems described above are not limited by the number of equations, i.e. this
function can solve the above types irrespective of the number of equations in the system passed.
But, the bigger the system, the more time it will take to solve the system.</p>
<p>This function returns a list of solutions. Each solution is a list of equations where LHS is
the dependent variable and RHS is an expression in terms of the independent variable.</p>
<p>Among the non constant coefficient types, not all the systems are solvable by this function. Only
those which have either a coefficient matrix with a commutative antiderivative or those systems which
may be divided further so that the divided systems may have coefficient matrix with commutative antiderivative.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">dsolve_system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;f g&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve_system</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>
<span class="go">[[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]]</span>
</pre></div>
</div>
<p>You can also pass the initial conditions for the system of ODEs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve_system</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">ics</span><span class="o">=</span><span class="p">{</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="mi">0</span><span class="p">})</span>
<span class="go">[[Eq(f(x), exp(x)/2 + exp(-x)/2), Eq(g(x), exp(x)/2 - exp(-x)/2)]]</span>
</pre></div>
</div>
<p>Optionally, you can pass the dependent variables and the independent
variable for which the system is to be solved:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve_system</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="o">=</span><span class="n">funcs</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[Eq(f(x), -C1*exp(-x) + C2*exp(x)), Eq(g(x), C1*exp(-x) + C2*exp(x))]]</span>
</pre></div>
</div>
<p>Lets look at an implicit system of ODEs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve_system</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>
<span class="go">[[Eq(f(x), C1 - C2*exp(x)), Eq(g(x), C2*exp(x))], [Eq(f(x), C1 + C2*exp(x)), Eq(g(x), C2*exp(x))]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.classify_ode">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">classify_ode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L812-L1133"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.classify_ode" title="Permalink to this definition">#</a></dt>
<dd><p>Returns a tuple of possible <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>
classifications for an ODE.</p>
<p>The tuple is ordered so that first item is the classification that
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> uses to solve the ODE by default.  In
general, classifications at the near the beginning of the list will
produce better solutions faster than those near the end, thought there are
always exceptions.  To make <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> use a
different classification, use <code class="docutils literal notranslate"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&lt;classification&gt;)</span></code>.  See also the
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> docstring for different meta-hints
you can use.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dict</span></code> is true, <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> will
return a dictionary of <code class="docutils literal notranslate"><span class="pre">hint:match</span></code> expression terms. This is intended
for internal use by <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.  Note that
because dictionaries are ordered arbitrarily, this will most likely not be
in the same order as the tuple.</p>
<p>You can get help on different hints by executing
<code class="docutils literal notranslate"><span class="pre">help(ode.ode_hintname)</span></code>, where <code class="docutils literal notranslate"><span class="pre">hintname</span></code> is the name of the hint
without <code class="docutils literal notranslate"><span class="pre">_Integral</span></code>.</p>
<p>See <a class="reference internal" href="#sympy.solvers.ode.allhints" title="sympy.solvers.ode.allhints"><code class="xref py py-data docutils literal notranslate"><span class="pre">allhints</span></code></a> or the
<a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code></a> docstring for a list of all supported hints
that can be returned from <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>.</p>
<p class="rubric">Notes</p>
<p>These are remarks on hint names.</p>
<p><code class="docutils literal notranslate"><span class="pre">_Integral</span></code></p>
<blockquote>
<div><p>If a classification has <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> at the end, it will return the
expression with an unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>
class in it.  Note that a hint may do this anyway if
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> cannot do the integral,
though just using an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> will do so much faster.  Indeed, an
<code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint will always be faster than its corresponding hint
without <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> is an expensive routine.
If <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> hangs, it is probably because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a> is hanging on a tough or
impossible integral.  Try using an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint or
<code class="docutils literal notranslate"><span class="pre">all_Integral</span></code> to get it return something.</p>
<p>Note that some hints do not have <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> counterparts. This is
because <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.integrate" title="sympy.integrals.integrals.integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">integrate()</span></code></a> is not used in
solving the ODE for those method. For example, <span class="math notranslate nohighlight">\(n\)</span>th order linear
homogeneous ODEs with constant coefficients do not require integration
to solve, so there is no
<code class="docutils literal notranslate"><span class="pre">nth_linear_homogeneous_constant_coeff_Integrate</span></code> hint. You can
easily evaluate any unevaluated
<a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>s in an expression by
doing <code class="docutils literal notranslate"><span class="pre">expr.doit()</span></code>.</p>
</div></blockquote>
<p>Ordinals</p>
<blockquote>
<div><p>Some hints contain an ordinal such as <code class="docutils literal notranslate"><span class="pre">1st_linear</span></code>.  This is to help
differentiate them from other hints, as well as from other methods
that may not be implemented yet. If a hint has <code class="docutils literal notranslate"><span class="pre">nth</span></code> in it, such as
the <code class="docutils literal notranslate"><span class="pre">nth_linear</span></code> hints, this means that the method used to applies
to ODEs of any order.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">indep</span></code> and <code class="docutils literal notranslate"><span class="pre">dep</span></code></p>
<blockquote>
<div><p>Some hints contain the words <code class="docutils literal notranslate"><span class="pre">indep</span></code> or <code class="docutils literal notranslate"><span class="pre">dep</span></code>.  These reference
the independent variable and the dependent function, respectively. For
example, if an ODE is in terms of <span class="math notranslate nohighlight">\(f(x)\)</span>, then <code class="docutils literal notranslate"><span class="pre">indep</span></code> will refer to
<span class="math notranslate nohighlight">\(x\)</span> and <code class="docutils literal notranslate"><span class="pre">dep</span></code> will refer to <span class="math notranslate nohighlight">\(f\)</span>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">subs</span></code></p>
<blockquote>
<div><p>If a hints has the word <code class="docutils literal notranslate"><span class="pre">subs</span></code> in it, it means that the ODE is solved
by substituting the expression given after the word <code class="docutils literal notranslate"><span class="pre">subs</span></code> for a
single dummy variable.  This is usually in terms of <code class="docutils literal notranslate"><span class="pre">indep</span></code> and
<code class="docutils literal notranslate"><span class="pre">dep</span></code> as above.  The substituted expression will be written only in
characters allowed for names of Python objects, meaning operators will
be spelled out.  For example, <code class="docutils literal notranslate"><span class="pre">indep</span></code>/<code class="docutils literal notranslate"><span class="pre">dep</span></code> will be written as
<code class="docutils literal notranslate"><span class="pre">indep_div_dep</span></code>.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">coeff</span></code></p>
<blockquote>
<div><p>The word <code class="docutils literal notranslate"><span class="pre">coeff</span></code> in a hint refers to the coefficients of something
in the ODE, usually of the derivative terms.  See the docstring for
the individual methods for more info (<code class="docutils literal notranslate"><span class="pre">help(ode)</span></code>).  This is
contrast to <code class="docutils literal notranslate"><span class="pre">coefficients</span></code>, as in <code class="docutils literal notranslate"><span class="pre">undetermined_coefficients</span></code>,
which refers to the common name of a method.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">_best</span></code></p>
<blockquote>
<div><p>Methods that have more than one fundamental way to solve will have a
hint for each sub-method and a <code class="docutils literal notranslate"><span class="pre">_best</span></code> meta-classification. This
will evaluate all hints and return the best, using the same
considerations as the normal <code class="docutils literal notranslate"><span class="pre">best</span></code> meta-hint.</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">classify_ode</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(&#39;nth_algebraic&#39;,</span>
<span class="go">&#39;separable&#39;,</span>
<span class="go">&#39;1st_exact&#39;,</span>
<span class="go">&#39;1st_linear&#39;,</span>
<span class="go">&#39;Bernoulli&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_best&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;,</span>
<span class="go">&#39;1st_power_series&#39;, &#39;lie_group&#39;, &#39;nth_linear_constant_coeff_homogeneous&#39;,</span>
<span class="go">&#39;nth_linear_euler_eq_homogeneous&#39;,</span>
<span class="go">&#39;nth_algebraic_Integral&#39;, &#39;separable_Integral&#39;, &#39;1st_exact_Integral&#39;,</span>
<span class="go">&#39;1st_linear_Integral&#39;, &#39;Bernoulli_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(&#39;factorable&#39;, &#39;nth_linear_constant_coeff_undetermined_coefficients&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.checkodesol">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">checkodesol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solve_for_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/subscheck.py#L48-L288"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.checkodesol" title="Permalink to this definition">#</a></dt>
<dd><p>Substitutes <code class="docutils literal notranslate"><span class="pre">sol</span></code> into <code class="docutils literal notranslate"><span class="pre">ode</span></code> and checks that the result is <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>This works when <code class="docutils literal notranslate"><span class="pre">func</span></code> is one function, like <span class="math notranslate nohighlight">\(f(x)\)</span> or a list of
functions like <span class="math notranslate nohighlight">\([f(x), g(x)]\)</span> when <span class="math notranslate nohighlight">\(ode\)</span> is a system of ODEs.  <code class="docutils literal notranslate"><span class="pre">sol</span></code> can
be a single solution or a list of solutions.  Each solution may be an
<a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equality</span></code></a> that the solution satisfies,
e.g. <code class="docutils literal notranslate"><span class="pre">Eq(f(x),</span> <span class="pre">C1),</span> <span class="pre">Eq(f(x)</span> <span class="pre">+</span> <span class="pre">C1,</span> <span class="pre">0)</span></code>; or simply an
<a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal notranslate"><span class="pre">Expr</span></code></a>, e.g. <code class="docutils literal notranslate"><span class="pre">f(x)</span> <span class="pre">-</span> <span class="pre">C1</span></code>. In most cases it
will not be necessary to explicitly identify the function, but if the
function cannot be inferred from the original equation it can be supplied
through the <code class="docutils literal notranslate"><span class="pre">func</span></code> argument.</p>
<p>If a sequence of solutions is passed, the same sort of container will be
used to return the result for each solution.</p>
<p>It tries the following methods, in order, until it finds zero equivalence:</p>
<ol class="arabic simple">
<li><p>Substitute the solution for <span class="math notranslate nohighlight">\(f\)</span> in the original equation.  This only
works if <code class="docutils literal notranslate"><span class="pre">ode</span></code> is solved for <span class="math notranslate nohighlight">\(f\)</span>.  It will attempt to solve it first
unless <code class="docutils literal notranslate"><span class="pre">solve_for_func</span> <span class="pre">==</span> <span class="pre">False</span></code>.</p></li>
<li><p>Take <span class="math notranslate nohighlight">\(n\)</span> derivatives of the solution, where <span class="math notranslate nohighlight">\(n\)</span> is the order of
<code class="docutils literal notranslate"><span class="pre">ode</span></code>, and check to see if that is equal to the solution.  This only
works on exact ODEs.</p></li>
<li><p>Take the 1st, 2nd, …, <span class="math notranslate nohighlight">\(n\)</span>th derivatives of the solution, each time
solving for the derivative of <span class="math notranslate nohighlight">\(f\)</span> of that order (this will always be
possible because <span class="math notranslate nohighlight">\(f\)</span> is a linear operator). Then back substitute each
derivative into <code class="docutils literal notranslate"><span class="pre">ode</span></code> in reverse order.</p></li>
</ol>
<p>This function returns a tuple.  The first item in the tuple is <code class="docutils literal notranslate"><span class="pre">True</span></code> if
the substitution results in <code class="docutils literal notranslate"><span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise. The second
item in the tuple is what the substitution results in.  It should always
be <code class="docutils literal notranslate"><span class="pre">0</span></code> if the first item is <code class="docutils literal notranslate"><span class="pre">True</span></code>. Sometimes this function will
return <code class="docutils literal notranslate"><span class="pre">False</span></code> even when an expression is identically equal to <code class="docutils literal notranslate"><span class="pre">0</span></code>.
This happens when <a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.simplify" title="sympy.simplify.simplify.simplify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">simplify()</span></code></a> does not
reduce the expression to <code class="docutils literal notranslate"><span class="pre">0</span></code>.  If an expression returned by this
function vanishes identically, then <code class="docutils literal notranslate"><span class="pre">sol</span></code> really is a solution to
the <code class="docutils literal notranslate"><span class="pre">ode</span></code>.</p>
<p>If this function seems to hang, it is probably because of a hard
simplification.</p>
<p>To use this function to test, test the first item of the tuple.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">checkodesol</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Derivative</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,C1,C2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;f g&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">(True, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(False, 2)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C2</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, [0, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.homogeneous_order">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">homogeneous_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2187-L2275"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.homogeneous_order" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the order <span class="math notranslate nohighlight">\(n\)</span> if <span class="math notranslate nohighlight">\(g\)</span> is homogeneous and <code class="docutils literal notranslate"><span class="pre">None</span></code> if it is not
homogeneous.</p>
<p>Determines if a function is homogeneous and if so of what order.  A
function <span class="math notranslate nohighlight">\(f(x, y, \cdots)\)</span> is homogeneous of order <span class="math notranslate nohighlight">\(n\)</span> if <span class="math notranslate nohighlight">\(f(t x, t y,
\cdots) = t^n f(x, y, \cdots)\)</span>.</p>
<p>If the function is of two variables, <span class="math notranslate nohighlight">\(F(x, y)\)</span>, then <span class="math notranslate nohighlight">\(f\)</span> being homogeneous
of any order is equivalent to being able to rewrite <span class="math notranslate nohighlight">\(F(x, y)\)</span> as <span class="math notranslate nohighlight">\(G(x/y)\)</span>
or <span class="math notranslate nohighlight">\(H(y/x)\)</span>.  This fact is used to solve 1st order ordinary differential
equations whose coefficients are homogeneous of the same order (see the
docstrings of
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep" title="sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffSubsDepDivIndep</span></code></a> and
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep" title="sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffSubsIndepDivDep</span></code></a>).</p>
<p>Symbols can be functions, but every argument of the function must be a
symbol, and the arguments of the function that appear in the expression
must match those given in the list of symbols.  If a declared function
appears with different arguments than given in the list of symbols,
<code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">homogeneous_order</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.infinitesimals">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">infinitesimals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L163-L304"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.infinitesimals" title="Permalink to this definition">#</a></dt>
<dd><p>The infinitesimal functions of an ordinary differential equation, <span class="math notranslate nohighlight">\(\xi(x,y)\)</span>
and <span class="math notranslate nohighlight">\(\eta(x,y)\)</span>, are the infinitesimals of the Lie group of point transformations
for which the differential equation is invariant. So, the ODE <span class="math notranslate nohighlight">\(y'=f(x,y)\)</span>
would admit a Lie group <span class="math notranslate nohighlight">\(x^*=X(x,y;\varepsilon)=x+\varepsilon\xi(x,y)\)</span>,
<span class="math notranslate nohighlight">\(y^*=Y(x,y;\varepsilon)=y+\varepsilon\eta(x,y)\)</span> such that <span class="math notranslate nohighlight">\((y^*)'=f(x^*, y^*)\)</span>.
A change of coordinates, to <span class="math notranslate nohighlight">\(r(x,y)\)</span> and <span class="math notranslate nohighlight">\(s(x,y)\)</span>, can be performed so this Lie group
becomes the translation group, <span class="math notranslate nohighlight">\(r^*=r\)</span> and <span class="math notranslate nohighlight">\(s^*=s+\varepsilon\)</span>.
They are tangents to the coordinate curves of the new system.</p>
<p>Consider the transformation <span class="math notranslate nohighlight">\((x, y) \to (X, Y)\)</span> such that the
differential equation remains invariant. <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span> are the tangents to
the transformed coordinates <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>, at <span class="math notranslate nohighlight">\(\varepsilon=0\)</span>.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \xi,
\left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \eta,\]</div>
</div>
<p>The infinitesimals can be found by solving the following PDE:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">,</span> <span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># dy/dx = h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">h</span>
<span class="gp">... </span><span class="o">-</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xi</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">/d               d           \                     d              2       d</span>
<span class="go">|--(eta(x, y)) - --(xi(x, y))|*h(x, y) - eta(x, y)*--(h(x, y)) - h (x, y)*--(x</span>
<span class="go">\dy              dx          /                     dy                     dy</span>

<span class="go">                    d             d</span>
<span class="go">i(x, y)) - xi(x, y)*--(h(x, y)) + --(eta(x, y)) = 0</span>
<span class="go">                    dx            dx</span>
</pre></div>
</div>
<p>Solving the above mentioned PDE is not trivial, and can be solved only by
making intelligent assumptions for <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span> (heuristics). Once an
infinitesimal is found, the attempt to find more heuristics stops. This is done to
optimise the speed of solving the differential equation. If a list of all the
infinitesimals is needed, <code class="docutils literal notranslate"><span class="pre">hint</span></code> should be flagged as <code class="docutils literal notranslate"><span class="pre">all</span></code>, which gives
the complete list of infinitesimals. If the infinitesimals for a particular
heuristic needs to be found, it can be passed as a flag to <code class="docutils literal notranslate"><span class="pre">hint</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.lie_group</span> <span class="kn">import</span> <span class="n">infinitesimals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infinitesimals</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[{eta(x, f(x)): exp(x**3/3), xi(x, f(x)): 0}]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.checkinfsol">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">checkinfsol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">infinitesimals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2791-L2865"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.checkinfsol" title="Permalink to this definition">#</a></dt>
<dd><p>This function is used to check if the given infinitesimals are the
actual infinitesimals of the given first order differential equation.
This method is specific to the Lie Group Solver of ODEs.</p>
<p>As of now, it simply checks, by substituting the infinitesimals in the
partial differential equation.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x}\right)*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y} = 0\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(\eta\)</span>, and <span class="math notranslate nohighlight">\(\xi\)</span> are the infinitesimals and <span class="math notranslate nohighlight">\(h(x,y) = \frac{dy}{dx}\)</span></p>
<p>The infinitesimals should be given in the form of a list of dicts
<code class="docutils literal notranslate"><span class="pre">[{xi(x,</span> <span class="pre">y):</span> <span class="pre">inf,</span> <span class="pre">eta(x,</span> <span class="pre">y):</span> <span class="pre">inf}]</span></code>, corresponding to the
output of the function infinitesimals. It returns a list
of values of the form <code class="docutils literal notranslate"><span class="pre">[(True/False,</span> <span class="pre">sol)]</span></code> where <code class="docutils literal notranslate"><span class="pre">sol</span></code> is the value
obtained after substituting the infinitesimals in the PDE. If it
is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then <code class="docutils literal notranslate"><span class="pre">sol</span></code> would be 0.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.constantsimp">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">constantsimp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constants</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L1916-L2041"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.constantsimp" title="Permalink to this definition">#</a></dt>
<dd><p>Simplifies an expression with arbitrary constants in it.</p>
<p>This function is written specifically to work with
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, and is not intended for general use.</p>
<p>Simplification is done by “absorbing” the arbitrary constants into other
arbitrary constants, numbers, and symbols that they are not independent
of.</p>
<p>The symbols must all have the same name with numbers after it, for
example, <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, <code class="docutils literal notranslate"><span class="pre">C3</span></code>.  The <code class="docutils literal notranslate"><span class="pre">symbolname</span></code> here would be
‘<code class="docutils literal notranslate"><span class="pre">C</span></code>’, the <code class="docutils literal notranslate"><span class="pre">startnumber</span></code> would be 1, and the <code class="docutils literal notranslate"><span class="pre">endnumber</span></code> would be 3.
If the arbitrary constants are independent of the variable <code class="docutils literal notranslate"><span class="pre">x</span></code>, then the
independent symbol would be <code class="docutils literal notranslate"><span class="pre">x</span></code>.  There is no need to specify the
dependent function, such as <code class="docutils literal notranslate"><span class="pre">f(x)</span></code>, because it already has the
independent symbol, <code class="docutils literal notranslate"><span class="pre">x</span></code>, in it.</p>
<p>Because terms are “absorbed” into arbitrary constants and because
constants are renumbered after simplifying, the arbitrary constants in
expr are not necessarily equal to the ones of the same name in the
returned result.</p>
<p>If two or more arbitrary constants are added, multiplied, or raised to the
power of each other, they are first absorbed together into a single
arbitrary constant.  Then the new constant is combined into other terms if
necessary.</p>
<p>Absorption of constants is done with limited assistance:</p>
<ol class="arabic simple">
<li><p>terms of <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code></a>s are collected to try join
constants so <span class="math notranslate nohighlight">\(e^x (C_1 \cos(x) + C_2 \cos(x))\)</span> will simplify to <span class="math notranslate nohighlight">\(e^x
C_1 \cos(x)\)</span>;</p></li>
<li><p>powers with exponents that are <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal notranslate"><span class="pre">Add</span></code></a>s are
expanded so <span class="math notranslate nohighlight">\(e^{C_1 + x}\)</span> will be simplified to <span class="math notranslate nohighlight">\(C_1 e^x\)</span>.</p></li>
</ol>
<p>Use <a class="reference internal" href="#sympy.solvers.ode.ode.constant_renumber" title="sympy.solvers.ode.ode.constant_renumber"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constant_renumber()</span></code></a> to renumber constants
after simplification or else arbitrary numbers on constants may appear,
e.g. <span class="math notranslate nohighlight">\(C_1 + C_3 x\)</span>.</p>
<p>In rare cases, a single constant can be “simplified” into two constants.
Every differential equation solution should have as many arbitrary
constants as the order of the differential equation.  The result here will
be technically correct, but it may, for example, have <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> in
an expression, when <span class="math notranslate nohighlight">\(C_1\)</span> is actually equal to <span class="math notranslate nohighlight">\(C_2\)</span>.  Use your discretion
in such situations, and also take advantage of the ability to use hints in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">constantsimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C1, C2, C3, x, y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1 + x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span><span class="o">*</span><span class="n">C2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">C2</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1 + C3*x</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="hint-functions">
<span id="hints"></span><h2>Hint Functions<a class="headerlink" href="#hint-functions" title="Permalink to this heading">#</a></h2>
<p>These functions are intended for internal use by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> and others.  Unlike <a class="reference internal" href="#user-functions">User Functions</a>,
above, these are not intended for every-day use by ordinary SymPy users.
Instead, functions such as <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> should be used.
Nonetheless, these functions contain useful information in their docstrings on
the various ODE solving methods. For this reason, they are documented here.</p>
<dl class="py data">
<dt class="sig sig-object py" id="sympy.solvers.ode.allhints">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.</span></span><span class="sig-name descname"><span class="pre">allhints</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">('factorable',</span> <span class="pre">'nth_algebraic',</span> <span class="pre">'separable',</span> <span class="pre">'1st_exact',</span> <span class="pre">'1st_linear',</span> <span class="pre">'Bernoulli',</span> <span class="pre">'1st_rational_riccati',</span> <span class="pre">'Riccati_special_minus2',</span> <span class="pre">'1st_homogeneous_coeff_best',</span> <span class="pre">'1st_homogeneous_coeff_subs_indep_div_dep',</span> <span class="pre">'1st_homogeneous_coeff_subs_dep_div_indep',</span> <span class="pre">'almost_linear',</span> <span class="pre">'linear_coefficients',</span> <span class="pre">'separable_reduced',</span> <span class="pre">'1st_power_series',</span> <span class="pre">'lie_group',</span> <span class="pre">'nth_linear_constant_coeff_homogeneous',</span> <span class="pre">'nth_linear_euler_eq_homogeneous',</span> <span class="pre">'nth_linear_constant_coeff_undetermined_coefficients',</span> <span class="pre">'nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients',</span> <span class="pre">'nth_linear_constant_coeff_variation_of_parameters',</span> <span class="pre">'nth_linear_euler_eq_nonhomogeneous_variation_of_parameters',</span> <span class="pre">'Liouville',</span> <span class="pre">'2nd_linear_airy',</span> <span class="pre">'2nd_linear_bessel',</span> <span class="pre">'2nd_hypergeometric',</span> <span class="pre">'2nd_hypergeometric_Integral',</span> <span class="pre">'nth_order_reducible',</span> <span class="pre">'2nd_power_series_ordinary',</span> <span class="pre">'2nd_power_series_regular',</span> <span class="pre">'nth_algebraic_Integral',</span> <span class="pre">'separable_Integral',</span> <span class="pre">'1st_exact_Integral',</span> <span class="pre">'1st_linear_Integral',</span> <span class="pre">'Bernoulli_Integral',</span> <span class="pre">'1st_homogeneous_coeff_subs_indep_div_dep_Integral',</span> <span class="pre">'1st_homogeneous_coeff_subs_dep_div_indep_Integral',</span> <span class="pre">'almost_linear_Integral',</span> <span class="pre">'linear_coefficients_Integral',</span> <span class="pre">'separable_reduced_Integral',</span> <span class="pre">'nth_linear_constant_coeff_variation_of_parameters_Integral',</span> <span class="pre">'nth_linear_euler_eq_nonhomogeneous_variation_of_parameters_Integral',</span> <span class="pre">'Liouville_Integral',</span> <span class="pre">'2nd_nonlinear_autonomous_conserved',</span> <span class="pre">'2nd_nonlinear_autonomous_conserved_Integral')</span></em><a class="headerlink" href="#sympy.solvers.ode.allhints" title="Permalink to this definition">#</a></dt>
<dd><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable’s items.</p>
<p>If the argument is a tuple, the return value is the same object.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode.odesimp">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">odesimp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hint</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L1563-L1696"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode.odesimp" title="Permalink to this definition">#</a></dt>
<dd><p>Simplifies solutions of ODEs, including trying to solve for <code class="docutils literal notranslate"><span class="pre">func</span></code> and
running <a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code></a>.</p>
<p>It may use knowledge of the type of solution that the hint returns to
apply additional simplifications.</p>
<p>It also attempts to integrate any <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>s
in the expression, if the hint is not an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hint.</p>
<p>This function should have no effect on expressions returned by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, as
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> already calls
<a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a>, but the individual hint functions
do not call <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> (because the
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> wrapper does).  Therefore, this
function is designed for mainly internal use.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">odesimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,u2,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">                        x</span>
<span class="go">                       ----</span>
<span class="go">                       f(x)</span>
<span class="go">                         /</span>
<span class="go">                        |</span>
<span class="go">                        |   /        1   \</span>
<span class="go">                        |  -|u1 + -------|</span>
<span class="go">                        |   |        /1 \|</span>
<span class="go">                        |   |     sin|--||</span>
<span class="go">                        |   \        \u1//</span>
<span class="go">log(f(x)) = log(C1) +   |  ---------------- d(u1)</span>
<span class="go">                        |          2</span>
<span class="go">                        |        u1</span>
<span class="go">                        |</span>
<span class="go">                       /</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">odesimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">},</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span>
<span class="gp">... </span><span class="p">))</span> 
<span class="go">    x</span>
<span class="go">--------- = C1</span>
<span class="go">   /f(x)\</span>
<span class="go">tan|----|</span>
<span class="go">   \2*x /</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode.constant_renumber">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">constant_renumber</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">newconstants</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2044-L2165"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode.constant_renumber" title="Permalink to this definition">#</a></dt>
<dd><p>Renumber arbitrary constants in <code class="docutils literal notranslate"><span class="pre">expr</span></code> to use the symbol names as given
in <code class="docutils literal notranslate"><span class="pre">newconstants</span></code>. In the process, this reorders expression terms in a
standard way.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">newconstants</span></code> is not provided then the new constant names will be
<code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code> etc. Otherwise <code class="docutils literal notranslate"><span class="pre">newconstants</span></code> should be an iterable
giving the new symbols to use for the constants in order.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">variables</span></code> argument is a list of non-constant symbols. All other
free symbols found in <code class="docutils literal notranslate"><span class="pre">expr</span></code> are assumed to be constants and will be
renumbered. If <code class="docutils literal notranslate"><span class="pre">variables</span></code> is not given then any numbered symbol
beginning with <code class="docutils literal notranslate"><span class="pre">C</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">C1</span></code>) is assumed to be a constant.</p>
<p>Symbols are renumbered based on <code class="docutils literal notranslate"><span class="pre">.sort_key()</span></code>, so they should be
numbered roughly in the order that they appear in the final, printed
expression.  Note that this ordering is based in part on hashes, so it can
produce different results on different machines.</p>
<p>The structure of this function is very similar to that of
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">constant_renumber</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,C1:4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">C1*x**2  + C2*x + C3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
<span class="go">C1 + C2*x + C3*x**2</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">variables</span></code> argument specifies which are constants so that the
other symbols will not be renumbered:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="go">C1*x**2  + C2 + C3*x</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">newconstants</span></code> argument is used to specify what symbols to use when
replacing the constants:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">newconstants</span><span class="o">=</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;E1:4&#39;</span><span class="p">))</span>
<span class="go">E1 + E2*x + E3*x**2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode.ode_sol_simplicity">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">ode_sol_simplicity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trysolving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L1699-L1820"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_sol_simplicity" title="Permalink to this definition">#</a></dt>
<dd><p>Returns an extended integer representing how simple a solution to an ODE
is.</p>
<p>The following things are considered, in order from most simple to least:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>, but can be if passed to solve (e.g.,
a solution returned by <code class="docutils literal notranslate"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">simplify=False</span></code>).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code>, then base the result on the
length of <code class="docutils literal notranslate"><span class="pre">sol</span></code>, as computed by <code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> has any unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a>s,
this will automatically be considered less simple than any of the above.</p></li>
</ul>
<p>This function returns an integer such that if solution A is simpler than
solution B by above metric, then <code class="docutils literal notranslate"><span class="pre">ode_sol_simplicity(sola,</span> <span class="pre">func)</span> <span class="pre">&lt;</span>
<span class="pre">ode_sol_simplicity(solb,</span> <span class="pre">func)</span></code>.</p>
<p>Currently, the following are the numbers returned, but if the heuristic is
ever improved, this may change.  Only the ordering is guaranteed.</p>
<div class="table-wrapper docutils container">
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Simplicity</p></th>
<th class="head"><p>Return</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> solved for <code class="docutils literal notranslate"><span class="pre">func</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-2</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> not solved for <code class="docutils literal notranslate"><span class="pre">func</span></code> but can be</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">-1</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> is not solved nor solvable for
<code class="docutils literal notranslate"><span class="pre">func</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">sol</span></code> contains an
<a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integral</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">oo</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<p><code class="docutils literal notranslate"><span class="pre">oo</span></code> here means the SymPy infinity, which should compare greater than
any integer.</p>
<p>If you already know <a class="reference internal" href="solvers.html#sympy.solvers.solvers.solve" title="sympy.solvers.solvers.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a> cannot solve
<code class="docutils literal notranslate"><span class="pre">sol</span></code>, you can use <code class="docutils literal notranslate"><span class="pre">trysolving=False</span></code> to skip that step, which is the
only potentially slow step.  For example,
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">simplify=False</span></code> flag
should do this.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sol</span></code> is a list of solutions, if the worst solution in the list
returns <code class="docutils literal notranslate"><span class="pre">oo</span></code> it returns that, otherwise it returns <code class="docutils literal notranslate"><span class="pre">len(str(sol))</span></code>,
that is, the length of the string representation of the whole list.</p>
<p class="rubric">Examples</p>
<p>This function is designed to be passed to <code class="docutils literal notranslate"><span class="pre">min</span></code> as the key argument,
such as <code class="docutils literal notranslate"><span class="pre">min(listofsolutions,</span> <span class="pre">key=lambda</span> <span class="pre">i:</span> <span class="pre">ode_sol_simplicity(i,</span>
<span class="pre">f(x)))</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.ode</span> <span class="kn">import</span> <span class="n">ode_sol_simplicity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, C1, C2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">C2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">]]</span>
<span class="go">[28, 35]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">Eq(f(x)/tan(f(x)/(2*x)), C1)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.Factorable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">Factorable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L839-L909"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.Factorable" title="Permalink to this definition">#</a></dt>
<dd><p>Solves equations having a solvable factor.</p>
<p>This function is used to solve the equation having factors. Factors may be of type algebraic or ode. It
will try to solve each factor independently. Factors will be solved by calling dsolve. We will return the
list of solutions.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">                                -x</span>
<span class="go">[f(x) = 2, f(x) = -2, f(x) = C1*e  ]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.FirstExact">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">FirstExact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L443-L569"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.FirstExact" title="Permalink to this definition">#</a></dt>
<dd><p>Solves 1st order exact ordinary differential equations.</p>
<p>A 1st order differential equation is called exact if it is the total
differential of a function. That is, the differential equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0\]</div>
</div>
<p>is exact if there is some function <span class="math notranslate nohighlight">\(F(x, y)\)</span> such that <span class="math notranslate nohighlight">\(P(x, y) =
\partial{}F/\partial{}x\)</span> and <span class="math notranslate nohighlight">\(Q(x, y) = \partial{}F/\partial{}y\)</span>.  It can
be shown that a necessary and sufficient condition for a first order ODE
to be exact is that <span class="math notranslate nohighlight">\(\partial{}P/\partial{}y = \partial{}Q/\partial{}x\)</span>.
Then, the solution will be as given below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y,t,x0,y0,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Integral</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">Integral</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">))),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">            x                y</span>
<span class="go">            /                /</span>
<span class="go">           |                |</span>
<span class="go">F(x, y) =  |  P(t, y) dt +  |  Q(x0, t) dt = C1</span>
<span class="go">           |                |</span>
<span class="go">          /                /</span>
<span class="go">          x0               y0</span>
</pre></div>
</div>
<p>Where the first partials of <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> exist and are continuous in a
simply connected region.</p>
<p>A note: SymPy currently has no way to represent inert substitution on an
expression, so the hint <code class="docutils literal notranslate"><span class="pre">1st_exact_Integral</span></code> will return an integral
with <span class="math notranslate nohighlight">\(dy\)</span>.  This is supposed to represent the function that you are
solving for.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">Eq(x*cos(f(x)) + f(x)**3/3, C1)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Exact_differential_equation">https://en.wikipedia.org/wiki/Exact_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 73</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.HomogeneousCoeffBest">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">HomogeneousCoeffBest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L1687-L1747"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.HomogeneousCoeffBest" title="Permalink to this definition">#</a></dt>
<dd><p>Returns the best solution to an ODE from the two hints
<code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></code> and
<code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></code>.</p>
<p>This is as determined by <a class="reference internal" href="#sympy.solvers.ode.ode.ode_sol_simplicity" title="sympy.solvers.ode.ode.ode_sol_simplicity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_sol_simplicity()</span></code></a>.</p>
<p>See the
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep" title="sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffSubsIndepDivDep</span></code></a>
and
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep" title="sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffSubsDepDivIndep</span></code></a>
docstrings for more information on these hints.  Note that there is no
<code class="docutils literal notranslate"><span class="pre">ode_1st_homogeneous_coeff_best_Integral</span></code> hint.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_best&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Homogeneous_differential_equation">https://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">HomogeneousCoeffSubsDepDivIndep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L1438-L1559"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep" title="Permalink to this definition">#</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <span class="math notranslate nohighlight">\(u_1 = \frac{\text{&lt;dependent
variable&gt;}}{\text{&lt;independent variable&gt;}}\)</span>.</p>
<p>This is a differential equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
</div>
<p>such that <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> are homogeneous and of the same order.  A function
<span class="math notranslate nohighlight">\(F(x, y)\)</span> is homogeneous of order <span class="math notranslate nohighlight">\(n\)</span> if <span class="math notranslate nohighlight">\(F(x t, y t) = t^n F(x, y)\)</span>.
Equivalently, <span class="math notranslate nohighlight">\(F(x, y)\)</span> can be rewritten as <span class="math notranslate nohighlight">\(G(y/x)\)</span> or <span class="math notranslate nohighlight">\(H(x/y)\)</span>.  See
also the docstring of <a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code></a>.</p>
<p>If the coefficients <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <span class="math notranslate nohighlight">\(y = u_1 x\)</span> (i.e. <span class="math notranslate nohighlight">\(u_1 = y/x\)</span>) will turn the differential
equation into an equation separable in the variables <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(u\)</span>.  If
<span class="math notranslate nohighlight">\(h(u_1)\)</span> is the function that results from making the substitution <span class="math notranslate nohighlight">\(u_1 =
f(x)/x\)</span> on <span class="math notranslate nohighlight">\(P(x, f(x))\)</span> and <span class="math notranslate nohighlight">\(g(u_2)\)</span> is the function that results from the
substitution on <span class="math notranslate nohighlight">\(Q(x, f(x))\)</span> in the differential equation <span class="math notranslate nohighlight">\(P(x, f(x)) +
Q(x, f(x)) f'(x) = 0\)</span>, then the general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> /f(x)\    /f(x)\ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \ x  /    \ x  / dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;</span><span class="p">))</span>
<span class="go">               f(x)</span>
<span class="go">               ----</span>
<span class="go">                x</span>
<span class="go">                 /</span>
<span class="go">                |</span>
<span class="go">                |       -h(u1)</span>
<span class="go">log(x) = C1 +   |  ---------------- d(u1)</span>
<span class="go">                |  u1*h(u1) + g(u1)</span>
<span class="go">                |</span>
<span class="go">               /</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(u_1 h(u_1) + g(u_1) \ne 0\)</span> and <span class="math notranslate nohighlight">\(x \ne 0\)</span>.</p>
<p>See also the docstrings of
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffBest" title="sympy.solvers.ode.single.HomogeneousCoeffBest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffBest</span></code></a> and
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep" title="sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffSubsIndepDivDep</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                      /          3   \</span>
<span class="go">                      |3*f(x)   f (x)|</span>
<span class="go">                   log|------ + -----|</span>
<span class="go">                      |  x         3 |</span>
<span class="go">                      \           x  /</span>
<span class="go">log(x) = log(C1) - -------------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Homogeneous_differential_equation">https://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">HomogeneousCoeffSubsIndepDivDep</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L1562-L1684"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep" title="Permalink to this definition">#</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <span class="math notranslate nohighlight">\(u_2 = \frac{\text{&lt;independent
variable&gt;}}{\text{&lt;dependent variable&gt;}}\)</span>.</p>
<p>This is a differential equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
</div>
<p>such that <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> are homogeneous and of the same order.  A function
<span class="math notranslate nohighlight">\(F(x, y)\)</span> is homogeneous of order <span class="math notranslate nohighlight">\(n\)</span> if <span class="math notranslate nohighlight">\(F(x t, y t) = t^n F(x, y)\)</span>.
Equivalently, <span class="math notranslate nohighlight">\(F(x, y)\)</span> can be rewritten as <span class="math notranslate nohighlight">\(G(y/x)\)</span> or <span class="math notranslate nohighlight">\(H(x/y)\)</span>.  See
also the docstring of <a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code></a>.</p>
<p>If the coefficients <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(Q\)</span> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <span class="math notranslate nohighlight">\(x = u_2 y\)</span> (i.e. <span class="math notranslate nohighlight">\(u_2 = x/y\)</span>) will turn the differential
equation into an equation separable in the variables <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(u_2\)</span>.  If
<span class="math notranslate nohighlight">\(h(u_2)\)</span> is the function that results from making the substitution <span class="math notranslate nohighlight">\(u_2 =
x/f(x)\)</span> on <span class="math notranslate nohighlight">\(P(x, f(x))\)</span> and <span class="math notranslate nohighlight">\(g(u_2)\)</span> is the function that results from the
substitution on <span class="math notranslate nohighlight">\(Q(x, f(x))\)</span> in the differential equation <span class="math notranslate nohighlight">\(P(x, f(x)) +
Q(x, f(x)) f'(x) = 0\)</span>, then the general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> / x  \    / x  \ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \f(x)/    \f(x)/ dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">))</span>
<span class="go">             x</span>
<span class="go">            ----</span>
<span class="go">            f(x)</span>
<span class="go">              /</span>
<span class="go">             |</span>
<span class="go">             |       -g(u1)</span>
<span class="go">             |  ---------------- d(u1)</span>
<span class="go">             |  u1*g(u1) + h(u1)</span>
<span class="go">             |</span>
<span class="go">            /</span>

<span class="go">f(x) = C1*e</span>
</pre></div>
</div>
<p>Where <span class="math notranslate nohighlight">\(u_1 g(u_1) + h(u_1) \ne 0\)</span> and <span class="math notranslate nohighlight">\(f(x) \ne 0\)</span>.</p>
<p>See also the docstrings of
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffBest" title="sympy.solvers.ode.single.HomogeneousCoeffBest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffBest</span></code></a> and
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep" title="sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffSubsDepDivIndep</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Homogeneous_differential_equation">https://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.FirstLinear">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">FirstLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L572-L643"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.FirstLinear" title="Permalink to this definition">#</a></dt>
<dd><p>Solves 1st order linear differential equations.</p>
<p>These are differential equations of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[dy/dx + P(x) y = Q(x)\text{.}\]</div>
</div>
<p>These kinds of differential equations can be solved in a general way.  The
integrating factor <span class="math notranslate nohighlight">\(e^{\int P(x) \,dx}\)</span> will turn the equation into a
separable equation.  The general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_linear_Integral&#39;</span><span class="p">))</span>
<span class="go">        /       /                   \</span>
<span class="go">        |      |                    |</span>
<span class="go">        |      |         /          |     /</span>
<span class="go">        |      |        |           |    |</span>
<span class="go">        |      |        | P(x) dx   |  - | P(x) dx</span>
<span class="go">        |      |        |           |    |</span>
<span class="go">        |      |       /            |   /</span>
<span class="go">f(x) = |C1 +  | Q(x)*e           dx|*e</span>
<span class="go">        |      |                    |</span>
<span class="go">        \     /                     /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;1st_linear&#39;</span><span class="p">))</span>
<span class="go">f(x) = x*(C1 - cos(x))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Linear_differential_equation#First-order_equation_with_variable_coefficients">https://en.wikipedia.org/wiki/Linear_differential_equation#First-order_equation_with_variable_coefficients</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 92</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.RationalRiccati">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">RationalRiccati</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L976-L1043"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.RationalRiccati" title="Permalink to this definition">#</a></dt>
<dd><p>Gives general solutions to the first order Riccati differential
equations that have atleast one rational particular solution.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' = b_0(x) + b_1(x) y + b_2(x) y^2\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(b_0\)</span>, <span class="math notranslate nohighlight">\(b_1\)</span> and <span class="math notranslate nohighlight">\(b_2\)</span> are rational functions of <span class="math notranslate nohighlight">\(x\)</span>
with <span class="math notranslate nohighlight">\(b_2 \ne 0\)</span> (<span class="math notranslate nohighlight">\(b_2 = 0\)</span> would make it a Bernoulli equation).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">checkodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s2">&quot;1st_rational_riccati&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span>
<span class="go">Eq(f(x), (4*C1 - 5*x**9 - 4)/(x**2*(C1 + x**9 - 1)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, 0)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Riccati ODE:  <a class="reference external" href="https://en.wikipedia.org/wiki/Riccati_equation">https://en.wikipedia.org/wiki/Riccati_equation</a></p></li>
<li><p>N. Thieu Vo - Rational and Algebraic Solutions of First-Order Algebraic ODEs:
Algorithm 11, pp. 78 - <a class="reference external" href="https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf">https://www3.risc.jku.at/publications/download/risc_5387/PhDThesisThieu.pdf</a></p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.SecondLinearAiry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">SecondLinearAiry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2789-L2841"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.SecondLinearAiry" title="Permalink to this definition">#</a></dt>
<dd><p>Gives solution of the Airy differential equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{d^2y}{dx^2} + (a + b x) y(x) = 0\]</div>
</div>
<p>in terms of Airy special functions airyai and airybi.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">Eq(f(x), C1*airyai(x) + C2*airybi(x))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.SecondLinearBessel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">SecondLinearBessel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2669-L2786"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.SecondLinearBessel" title="Permalink to this definition">#</a></dt>
<dd><p>Gives solution of the Bessel differential equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x^2 \frac{d^2y}{dx^2} + x \frac{dy}{dx} y(x) + (x^2-n^2) y(x)\]</div>
</div>
<p>if <span class="math notranslate nohighlight">\(n\)</span> is integer then the solution is of the form <code class="docutils literal notranslate"><span class="pre">Eq(f(x),</span> <span class="pre">C0</span> <span class="pre">besselj(n,x)</span>
<span class="pre">+</span> <span class="pre">C1</span> <span class="pre">bessely(n,x))</span></code> as both the solutions are linearly independent else if
<span class="math notranslate nohighlight">\(n\)</span> is a fraction then the solution is of the form <code class="docutils literal notranslate"><span class="pre">Eq(f(x),</span> <span class="pre">C0</span> <span class="pre">besselj(n,x)</span>
<span class="pre">+</span> <span class="pre">C1</span> <span class="pre">besselj(-n,x))</span></code> which can also transform into <code class="docutils literal notranslate"><span class="pre">Eq(f(x),</span> <span class="pre">C0</span> <span class="pre">besselj(n,x)</span>
<span class="pre">+</span> <span class="pre">C1</span> <span class="pre">bessely(n,x))</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">Eq(f(x), C1*besselj(v, x) + C2*bessely(v, x))</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p><a class="reference external" href="https://math24.net/bessel-differential-equation.html">https://math24.net/bessel-differential-equation.html</a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.Bernoulli">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">Bernoulli</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L732-L836"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.Bernoulli" title="Permalink to this definition">#</a></dt>
<dd><p>Solves Bernoulli differential equations.</p>
<p>These are equations of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[dy/dx + P(x) y = Q(x) y^n\text{, }n \ne 1`\text{.}\]</div>
</div>
<p>The substitution <span class="math notranslate nohighlight">\(w = 1/y^{1-n}\)</span> will transform an equation of this form
into one that is linear (see the docstring of
<a class="reference internal" href="#sympy.solvers.ode.single.FirstLinear" title="sympy.solvers.ode.single.FirstLinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FirstLinear</span></code></a>).  The general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d                n</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)*f (x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Bernoulli_Integral&#39;</span><span class="p">),</span> <span class="n">num_columns</span><span class="o">=</span><span class="mi">110</span><span class="p">)</span>
<span class="go">                                                                                                        -1</span>
<span class="go">                                                                                                       -----</span>
<span class="go">                                                                                                       n - 1</span>
<span class="go">       //         /                                 /                            \                    \</span>
<span class="go">       ||        |                                 |                             |                    |</span>
<span class="go">       ||        |                  /              |                  /          |            /       |</span>
<span class="go">       ||        |                 |               |                 |           |           |        |</span>
<span class="go">       ||        |       -(n - 1)* | P(x) dx       |       -(n - 1)* | P(x) dx   |  (n - 1)* | P(x) dx|</span>
<span class="go">       ||        |                 |               |                 |           |           |        |</span>
<span class="go">       ||        |                /                |                /            |          /         |</span>
<span class="go">f(x) = ||C1 - n* | Q(x)*e                    dx +  | Q(x)*e                    dx|*e                  |</span>
<span class="go">       ||        |                                 |                             |                    |</span>
<span class="go">       \\       /                                 /                              /                    /</span>
</pre></div>
</div>
<p>Note that the equation is separable when <span class="math notranslate nohighlight">\(n = 1\)</span> (see the docstring of
<a class="reference internal" href="#sympy.solvers.ode.single.Separable" title="sympy.solvers.ode.single.Separable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Separable</span></code></a>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go">f(x)</span>
<span class="go">    /</span>
<span class="go">|                /</span>
<span class="go">|  1            |</span>
<span class="go">|  - dy = C1 +  | (-P(x) + Q(x)) dx</span>
<span class="go">|  y            |</span>
<span class="go">|              /</span>
<span class="go">/</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Bernoulli&#39;</span><span class="p">))</span>
<span class="go">                1</span>
<span class="go">f(x) =  -----------------</span>
<span class="go">        C1*x + log(x) + 1</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Bernoulli_differential_equation">https://en.wikipedia.org/wiki/Bernoulli_differential_equation</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 95</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.Liouville">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">Liouville</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L1107-L1200"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.Liouville" title="Permalink to this definition">#</a></dt>
<dd><p>Solves 2nd order Liouville differential equations.</p>
<p>The general form of a Liouville ODE is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{d^2 y}{dx^2} + g(y) \left(\!
\frac{dy}{dx}\!\right)^2 + h(x)
\frac{dy}{dx}\text{.}\]</div>
</div>
<p>The general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                  2                    2</span>
<span class="go">        /d       \         d          d</span>
<span class="go">g(f(x))*|--(f(x))|  + h(x)*--(f(x)) + ---(f(x)) = 0</span>
<span class="go">        \dx      /         dx           2</span>
<span class="go">                                      dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Liouville_Integral&#39;</span><span class="p">))</span>
<span class="go">                                  f(x)</span>
<span class="go">          /                     /</span>
<span class="go">         |                     |</span>
<span class="go">         |     /               |     /</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |  - | h(x) dx        |    | g(y) dy</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |   /                 |   /</span>
<span class="go">C1 + C2* | e            dx +   |  e           dy = 0</span>
<span class="go">         |                     |</span>
<span class="go">        /                     /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Liouville&#39;</span><span class="p">))</span>
<span class="go">           ________________           ________________</span>
<span class="go">[f(x) = -\/ C1 + C2*log(x) , f(x) = \/ C1 + C2*log(x) ]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Goldstein and Braun, “Advanced Methods for the Solution of Differential
Equations”, pp. 98</p></li>
<li><p><a class="reference external" href="https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville">https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville</a></p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.RiccatiSpecial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">RiccatiSpecial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L912-L973"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.RiccatiSpecial" title="Permalink to this definition">#</a></dt>
<dd><p>The general Riccati equation has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}\]</div>
</div>
<p>While it does not have a general solution [1], the “special” form, <span class="math notranslate nohighlight">\(dy/dx
= a y^2 - b x^c\)</span>, does have solutions in many cases [2].  This routine
returns a solution for <span class="math notranslate nohighlight">\(a(dy/dx) = b y^2 + c y/x + d/x^2\)</span> that is obtained
by using a suitable change of variables to reduce it to the special form
and is valid when neither <span class="math notranslate nohighlight">\(a\)</span> nor <span class="math notranslate nohighlight">\(b\)</span> are zero and either <span class="math notranslate nohighlight">\(c\)</span> or <span class="math notranslate nohighlight">\(d\)</span> is
zero.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">checkodesol</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s2">&quot;Riccati_special_minus2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">        /                                 /        __________________       \\</span>
<span class="go">        |           __________________    |       /                2        ||</span>
<span class="go">        |          /                2     |     \/  4*b*d - (a + c)  *log(x)||</span>
<span class="go">       -|a + c - \/  4*b*d - (a + c)  *tan|C1 + ----------------------------||</span>
<span class="go">        \                                 \                 2*a             //</span>
<span class="go">f(x) = ------------------------------------------------------------------------</span>
<span class="go">                                        2*b*x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati">https://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati</a></p></li>
<li><p><a class="reference external" href="https://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf">https://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf</a> -
<a class="reference external" href="https://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf">https://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf</a></p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.NthLinearConstantCoeffHomogeneous">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">NthLinearConstantCoeffHomogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2100-L2191"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthLinearConstantCoeffHomogeneous" title="Permalink to this definition">#</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear homogeneous differential equation with
constant coefficients.</p>
<p>This is an equation of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = 0\text{.}\]</div>
</div>
<p>These equations can be solved in a general manner, by taking the roots of
the characteristic equation <span class="math notranslate nohighlight">\(a_n m^n + a_{n-1} m^{n-1} + \cdots + a_1 m +
a_0 = 0\)</span>.  The solution will then be the sum of <span class="math notranslate nohighlight">\(C_n x^i e^{r x}\)</span> terms,
for each where <span class="math notranslate nohighlight">\(C_n\)</span> is an arbitrary constant, <span class="math notranslate nohighlight">\(r\)</span> is a root of the
characteristic equation and <span class="math notranslate nohighlight">\(i\)</span> is one of each from 0 to the multiplicity
of the root - 1 (for example, a root 3 of multiplicity 2 would create the
terms <span class="math notranslate nohighlight">\(C_1 e^{3 x} + C_2 x e^{3 x}\)</span>).  The exponential is usually expanded
for complex roots using Euler’s equation <span class="math notranslate nohighlight">\(e^{I x} = \cos(x) + I \sin(x)\)</span>.
Complex roots always come in conjugate pairs in polynomials with real
coefficients, so the two roots will be represented (after simplifying the
constants) as <span class="math notranslate nohighlight">\(e^{a x} \left(C_1 \cos(b x) + C_2 \sin(b x)\right)\)</span>.</p>
<p>If SymPy cannot find exact roots to the characteristic equation, a
<a class="reference internal" href="../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf" title="sympy.polys.rootoftools.ComplexRootOf"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComplexRootOf</span></code></a> instance will be return
instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">Eq(f(x), C5*exp(x*CRootOf(_x**5 + 10*_x - 2, 0))</span>
<span class="go">+ (C1*sin(x*im(CRootOf(_x**5 + 10*_x - 2, 1)))</span>
<span class="go">+ C2*cos(x*im(CRootOf(_x**5 + 10*_x - 2, 1))))*exp(x*re(CRootOf(_x**5 + 10*_x - 2, 1)))</span>
<span class="go">+ (C3*sin(x*im(CRootOf(_x**5 + 10*_x - 2, 3)))</span>
<span class="go">+ C4*cos(x*im(CRootOf(_x**5 + 10*_x - 2, 3))))*exp(x*re(CRootOf(_x**5 + 10*_x - 2, 3))))</span>
</pre></div>
</div>
<p>Note that because this method does not involve integration, there is no
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_homogeneous_Integral</span></code> hint.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">))</span>
<span class="go">                    x                            -2*x</span>
<span class="go">f(x) = (C1 + C2*x)*e  + (C3*sin(x) + C4*cos(x))*e</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Linear_differential_equation">https://en.wikipedia.org/wiki/Linear_differential_equation</a> section:
Nonhomogeneous_equation_with_constant_coefficients</p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 211</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.NthLinearConstantCoeffUndeterminedCoefficients">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">NthLinearConstantCoeffUndeterminedCoefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2296-L2386"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthLinearConstantCoeffUndeterminedCoefficients" title="Permalink to this definition">#</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear differential equation with constant
coefficients using the method of undetermined coefficients.</p>
<p>This method works on differential equations of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = P(x)\text{,}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(P(x)\)</span> is a function that has a finite number of linearly
independent derivatives.</p>
<p>Functions that fit this requirement are finite sums functions of the form
<span class="math notranslate nohighlight">\(a x^i e^{b x} \sin(c x + d)\)</span> or <span class="math notranslate nohighlight">\(a x^i e^{b x} \cos(c x + d)\)</span>, where <span class="math notranslate nohighlight">\(i\)</span>
is a non-negative integer and <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> are constants.  For
example any polynomial in <span class="math notranslate nohighlight">\(x\)</span>, functions like <span class="math notranslate nohighlight">\(x^2 e^{2 x}\)</span>, <span class="math notranslate nohighlight">\(x \sin(x)\)</span>,
and <span class="math notranslate nohighlight">\(e^x \cos(x)\)</span> can all be used.  Products of <span class="math notranslate nohighlight">\(\sin\)</span>’s and <span class="math notranslate nohighlight">\(\cos\)</span>’s have
a finite number of derivatives, because they can be expanded into <span class="math notranslate nohighlight">\(\sin(a
x)\)</span> and <span class="math notranslate nohighlight">\(\cos(b x)\)</span> terms.  However, SymPy currently cannot do that
expansion, so you will need to manually rewrite the expression in terms of
the above to use this method.  So, for example, you will need to manually
convert <span class="math notranslate nohighlight">\(\sin^2(x)\)</span> into <span class="math notranslate nohighlight">\((1 + \cos(2 x))/2\)</span> to properly apply the method
of undetermined coefficients on it.</p>
<p>This method works by creating a trial function from the expression and all
of its linear independent derivatives and substituting them into the
original ODE.  The coefficients for each term will be a system of linear
equations, which are be solved for and substituted, giving the solution.
If any of the trial functions are linearly dependent on the solution to
the homogeneous equation, they are multiplied by sufficient <span class="math notranslate nohighlight">\(x\)</span> to make
them linearly independent.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">4</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;</span><span class="p">))</span>
<span class="go">       /       /      3\\</span>
<span class="go">       |       |     x ||  -x   4*sin(2*x)   3*cos(2*x)</span>
<span class="go">f(x) = |C1 + x*|C2 + --||*e   - ---------- + ----------</span>
<span class="go">       \       \     3 //           25           25</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients">https://en.wikipedia.org/wiki/Method_of_undetermined_coefficients</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 221</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.NthLinearConstantCoeffVariationOfParameters">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">NthLinearConstantCoeffVariationOfParameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2194-L2293"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthLinearConstantCoeffVariationOfParameters" title="Permalink to this definition">#</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear differential equation with constant
coefficients using the method of variation of parameters.</p>
<p>This method works on any differential equations of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0
f(x) = P(x)\text{.}\]</div>
</div>
<p>This method works by assuming that the particular solution takes the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{x=1}^{n} c_i(x) y_i(x)\text{,}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(y_i\)</span> is the <span class="math notranslate nohighlight">\(i\)</span>th solution to the homogeneous equation.  The
solution is then solved using Wronskian’s and Cramer’s Rule.  The
particular solution is given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx
\right) y_i(x) \text{,}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(W(x)\)</span> is the Wronskian of the fundamental system (the system of <span class="math notranslate nohighlight">\(n\)</span>
linearly independent solutions to the homogeneous equation), and <span class="math notranslate nohighlight">\(W_i(x)\)</span>
is the Wronskian of the fundamental system with the <span class="math notranslate nohighlight">\(i\)</span>th column replaced
with <span class="math notranslate nohighlight">\([0, 0, \cdots, 0, P(x)]\)</span>.</p>
<p>This method is general enough to solve any <span class="math notranslate nohighlight">\(n\)</span>th order inhomogeneous
linear differential equation with constant coefficients, but sometimes
SymPy cannot simplify the Wronskian well enough to integrate it.  If this
method hangs, try using the
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_variation_of_parameters_Integral</span></code> hint and
simplifying the integrals manually.  Also, prefer using
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></code> when it
applies, because it does not use integration, making it faster and more
reliable.</p>
<p>Warning, using simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters’ in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> may cause it to hang, because it will
not attempt to simplify the Wronskian before integrating.  It is
recommended that you only use simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters_Integral’ for this
method, especially if the solution to the homogeneous equation has
trigonometric functions in it.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;</span><span class="p">))</span>
<span class="go">       /       /       /     x*log(x)   11*x\\\  x</span>
<span class="go">f(x) = |C1 + x*|C2 + x*|C3 + -------- - ----|||*e</span>
<span class="go">       \       \       \        6        36 ///</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Variation_of_parameters">https://en.wikipedia.org/wiki/Variation_of_parameters</a></p></li>
<li><p><a class="reference external" href="https://planetmath.org/VariationOfParameters">https://planetmath.org/VariationOfParameters</a></p></li>
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 233</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.NthLinearEulerEqHomogeneous">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">NthLinearEulerEqHomogeneous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2389-L2482"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthLinearEulerEqHomogeneous" title="Permalink to this definition">#</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear homogeneous variable-coefficient
Cauchy-Euler equidimensional ordinary differential equation.</p>
<p>This is an equation with form <span class="math notranslate nohighlight">\(0 = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
\cdots\)</span>.</p>
<p>These equations can be solved in a general manner, by substituting
solutions of the form <span class="math notranslate nohighlight">\(f(x) = x^r\)</span>, and deriving a characteristic equation
for <span class="math notranslate nohighlight">\(r\)</span>.  When there are repeated roots, we include extra terms of the
form <span class="math notranslate nohighlight">\(C_{r k} \ln^k(x) x^r\)</span>, where <span class="math notranslate nohighlight">\(C_{r k}\)</span> is an arbitrary integration
constant, <span class="math notranslate nohighlight">\(r\)</span> is a root of the characteristic equation, and <span class="math notranslate nohighlight">\(k\)</span> ranges
over the multiplicity of <span class="math notranslate nohighlight">\(r\)</span>.  In the cases where the roots are complex,
solutions of the form <span class="math notranslate nohighlight">\(C_1 x^a \sin(b \log(x)) + C_2 x^a \cos(b \log(x))\)</span>
are returned, based on expansions with Euler’s formula.  The general
solution is the sum of the terms found.  If SymPy cannot find exact roots
to the characteristic equation, a
<a class="reference internal" href="../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf" title="sympy.polys.rootoftools.ComplexRootOf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ComplexRootOf</span></code></a> instance will be returned
instead.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_euler_eq_homogeneous&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">Eq(f(x), sqrt(x)*(C1 + C2*log(x)))</span>
</pre></div>
</div>
<p>Note that because this method does not involve integration, there is no
<code class="docutils literal notranslate"><span class="pre">nth_linear_euler_eq_homogeneous_Integral</span></code> hint.</p>
<p>The following is for internal use:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'sol'</span></code> returns the solution to the ODE.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'list'</span></code> returns a list of linearly independent solutions,
corresponding to the fundamental solution set, for use with non
homogeneous solution methods like variation of parameters and
undetermined coefficients.  Note that, though the solutions should be
linearly independent, this function does not explicitly check that.  You
can do <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">simplify(wronskian(sollist))</span> <span class="pre">!=</span> <span class="pre">0</span></code> to check for linear
independence.  Also, <code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">len(sollist)</span> <span class="pre">==</span> <span class="pre">order</span></code> will need to pass.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'both'</span></code>, return a dictionary <code class="docutils literal notranslate"><span class="pre">{'sol':</span> <span class="pre">&lt;solution</span> <span class="pre">to</span> <span class="pre">ODE&gt;,</span>
<span class="pre">'list':</span> <span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">linearly</span> <span class="pre">independent</span> <span class="pre">solutions&gt;}</span></code>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_euler_eq_homogeneous&#39;</span><span class="p">))</span>
<span class="go">        2</span>
<span class="go">f(x) = x *(C1 + C2*x)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation">https://en.wikipedia.org/wiki/Cauchy%E2%80%93Euler_equation</a></p></li>
<li><p>C. Bender &amp; S. Orszag, “Advanced Mathematical Methods for Scientists and
Engineers”, Springer 1999, pp. 12</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.NthLinearEulerEqNonhomogeneousVariationOfParameters">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">NthLinearEulerEqNonhomogeneousVariationOfParameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2485-L2571"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthLinearEulerEqNonhomogeneousVariationOfParameters" title="Permalink to this definition">#</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear non homogeneous Cauchy-Euler equidimensional
ordinary differential equation using variation of parameters.</p>
<p>This is an equation with form <span class="math notranslate nohighlight">\(g(x) = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
\cdots\)</span>.</p>
<p>This method works by assuming that the particular solution takes the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{x=1}^{n} c_i(x) y_i(x) {a_n} {x^n} \text{, }\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(y_i\)</span> is the <span class="math notranslate nohighlight">\(i\)</span>th solution to the homogeneous equation.  The
solution is then solved using Wronskian’s and Cramer’s Rule.  The
particular solution is given by multiplying eq given below with <span class="math notranslate nohighlight">\(a_n x^{n}\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \, dx
\right) y_i(x) \text{, }\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(W(x)\)</span> is the Wronskian of the fundamental system (the system of <span class="math notranslate nohighlight">\(n\)</span>
linearly independent solutions to the homogeneous equation), and <span class="math notranslate nohighlight">\(W_i(x)\)</span>
is the Wronskian of the fundamental system with the <span class="math notranslate nohighlight">\(i\)</span>th column replaced
with <span class="math notranslate nohighlight">\([0, 0, \cdots, 0, \frac{x^{- n}}{a_n} g{\left(x \right)}]\)</span>.</p>
<p>This method is general enough to solve any <span class="math notranslate nohighlight">\(n\)</span>th order inhomogeneous
linear differential equation, but sometimes SymPy cannot simplify the
Wronskian well enough to integrate it.  If this method hangs, try using the
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_variation_of_parameters_Integral</span></code> hint and
simplifying the integrals manually.  Also, prefer using
<code class="docutils literal notranslate"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></code> when it
applies, because it does not use integration, making it faster and more
reliable.</p>
<p>Warning, using simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters’ in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> may cause it to hang, because it will
not attempt to simplify the Wronskian before integrating.  It is
recommended that you only use simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters_Integral’ for this
method, especially if the solution to the homogeneous equation has
trigonometric functions in it.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_euler_eq_nonhomogeneous_variation_of_parameters&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="go">Eq(f(x), C1*x + C2*x**2 + x**4/6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.NthLinearEulerEqNonhomogeneousUndeterminedCoefficients">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">NthLinearEulerEqNonhomogeneousUndeterminedCoefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2574-L2666"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthLinearEulerEqNonhomogeneousUndeterminedCoefficients" title="Permalink to this definition">#</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order linear non homogeneous Cauchy-Euler equidimensional
ordinary differential equation using undetermined coefficients.</p>
<p>This is an equation with form <span class="math notranslate nohighlight">\(g(x) = a_0 f(x) + a_1 x f'(x) + a_2 x^2 f''(x)
\cdots\)</span>.</p>
<p>These equations can be solved in a general manner, by substituting
solutions of the form <span class="math notranslate nohighlight">\(x = exp(t)\)</span>, and deriving a characteristic equation
of form <span class="math notranslate nohighlight">\(g(exp(t)) = b_0 f(t) + b_1 f'(t) + b_2 f''(t) \cdots\)</span> which can
be then solved by nth_linear_constant_coeff_undetermined_coefficients if
g(exp(t)) has finite number of linearly independent derivatives.</p>
<p>Functions that fit this requirement are finite sums functions of the form
<span class="math notranslate nohighlight">\(a x^i e^{b x} \sin(c x + d)\)</span> or <span class="math notranslate nohighlight">\(a x^i e^{b x} \cos(c x + d)\)</span>, where <span class="math notranslate nohighlight">\(i\)</span>
is a non-negative integer and <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(c\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> are constants.  For
example any polynomial in <span class="math notranslate nohighlight">\(x\)</span>, functions like <span class="math notranslate nohighlight">\(x^2 e^{2 x}\)</span>, <span class="math notranslate nohighlight">\(x \sin(x)\)</span>,
and <span class="math notranslate nohighlight">\(e^x \cos(x)\)</span> can all be used.  Products of <span class="math notranslate nohighlight">\(\sin\)</span>’s and <span class="math notranslate nohighlight">\(\cos\)</span>’s have
a finite number of derivatives, because they can be expanded into <span class="math notranslate nohighlight">\(\sin(a
x)\)</span> and <span class="math notranslate nohighlight">\(\cos(b x)\)</span> terms.  However, SymPy currently cannot do that
expansion, so you will need to manually rewrite the expression in terms of
the above to use this method.  So, for example, you will need to manually
convert <span class="math notranslate nohighlight">\(\sin^2(x)\)</span> into <span class="math notranslate nohighlight">\((1 + \cos(2 x))/2\)</span> to properly apply the method
of undetermined coefficients on it.</p>
<p>After replacement of x by exp(t), this method works by creating a trial function
from the expression and all of its linear independent derivatives and
substituting them into the original ODE.  The coefficients for each term
will be a system of linear equations, which are be solved for and
substituted, giving the solution. If any of the trial functions are linearly
dependent on the solution to the homogeneous equation, they are multiplied
by sufficient <span class="math notranslate nohighlight">\(x\)</span> to make them linearly independent.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="go">Eq(f(x), C1*x + C2*x**2 + log(x)/2 + 3/4)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.NthAlgebraic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">NthAlgebraic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L341-L440"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthAlgebraic" title="Permalink to this definition">#</a></dt>
<dd><p>Solves an <span class="math notranslate nohighlight">\(n\)</span>th order ordinary differential equation using algebra and
integrals.</p>
<p>There is no general form for the kind of equation that this can solve. The
the equation is solved algebraically treating differentiation as an
invertible algebraic function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_algebraic&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), 0), Eq(f(x), C1 - x), Eq(f(x), C1 + x)]</span>
</pre></div>
</div>
<p>Note that this solver can return algebraic solutions that do not have any
integration constants (f(x) = 0 in the above example).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.NthOrderReducible">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">NthOrderReducible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L1932-L2011"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.NthOrderReducible" title="Permalink to this definition">#</a></dt>
<dd><p>Solves ODEs that only involve derivatives of the dependent variable using
a substitution of the form <span class="math notranslate nohighlight">\(f^n(x) = g(x)\)</span>.</p>
<p>For example any second order ODE of the form <span class="math notranslate nohighlight">\(f''(x) = h(f'(x), x)\)</span> can be
transformed into a pair of 1st order ODEs <span class="math notranslate nohighlight">\(g'(x) = h(g(x), x)\)</span> and
<span class="math notranslate nohighlight">\(f'(x) = g(x)\)</span>. Usually the 1st order ODE for <span class="math notranslate nohighlight">\(g\)</span> is easier to solve. If
that gives an explicit solution for <span class="math notranslate nohighlight">\(g\)</span> then <span class="math notranslate nohighlight">\(f\)</span> is found simply by
integration.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_order_reducible&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">Eq(f(x), C1 - sqrt(-1/C2)*log(-C2*sqrt(-1/C2) + x) + sqrt(-1/C2)*log(C2*sqrt(-1/C2) + x))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.Separable">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">Separable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L1203-L1296"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.Separable" title="Permalink to this definition">#</a></dt>
<dd><p>Solves separable 1st order differential equations.</p>
<p>This is any differential equation that can be written as <span class="math notranslate nohighlight">\(P(y)
\tfrac{dy}{dx} = Q(x)\)</span>.  The solution can then just be found by
rearranging terms and integrating: <span class="math notranslate nohighlight">\(\int P(y) \,dy = \int Q(x) \,dx\)</span>.
This hint uses <a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.separatevars" title="sympy.simplify.simplify.separatevars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.simplify.simplify.separatevars()</span></code></a> as its back
end, so if a separable equation is not caught by this solver, it is most
likely the fault of that function.
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.separatevars" title="sympy.simplify.simplify.separatevars"><code class="xref py py-meth docutils literal notranslate"><span class="pre">separatevars()</span></code></a> is
smart enough to do most expansion and factoring necessary to convert a
separable equation <span class="math notranslate nohighlight">\(F(x, y)\)</span> into the proper form <span class="math notranslate nohighlight">\(P(x)\cdot{}Q(y)\)</span>.  The
general solution is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">             d</span>
<span class="go">a(x)*b(f(x))*--(f(x)) = c(x)*d(f(x))</span>
<span class="go">             dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go">     f(x)</span>
<span class="go">   /                  /</span>
<span class="go">  |                  |</span>
<span class="go">  |  b(y)            | c(x)</span>
<span class="go">  |  ---- dy = C1 +  | ---- dx</span>
<span class="go">  |  d(y)            | a(x)</span>
<span class="go">  |                  |</span>
<span class="go"> /                  /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">   /   2       \         2</span>
<span class="go">log\3*f (x) - 1/        x</span>
<span class="go">---------------- = C1 + --</span>
<span class="go">       6                2</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 52</p></li>
</ul>
<p># indirect doctest</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.AlmostLinear">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">AlmostLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L646-L729"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.AlmostLinear" title="Permalink to this definition">#</a></dt>
<dd><p>Solves an almost-linear differential equation.</p>
<p>The general form of an almost linear differential equation is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a(x) g'(f(x)) f'(x) + b(x) g(f(x)) + c(x)\]</div>
</div>
<p>Here <span class="math notranslate nohighlight">\(f(x)\)</span> is the function to be solved for (the dependent variable).
The substitution <span class="math notranslate nohighlight">\(g(f(x)) = u(x)\)</span> leads to a linear differential equation
for <span class="math notranslate nohighlight">\(u(x)\)</span> of the form <span class="math notranslate nohighlight">\(a(x) u' + b(x) u + c(x) = 0\)</span>. This can be solved
for <span class="math notranslate nohighlight">\(u(x)\)</span> by the <span class="math notranslate nohighlight">\(first_linear\)</span> hint and then <span class="math notranslate nohighlight">\(f(x)\)</span> is found by solving
<span class="math notranslate nohighlight">\(g(f(x)) = u(x)\)</span>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">Eq(f(x), (C1 - Ei(x))*exp(-x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">                    -x</span>
<span class="go">f(x) = (C1 - Ei(x))*e</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">example</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
<span class="go">                    d</span>
<span class="go">sin(f(x)) + cos(f(x))*--(f(x)) + 1</span>
<span class="go">                    dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">                /    -x    \             /    -x    \</span>
<span class="go">[f(x) = pi - asin\C1*e   - 1/, f(x) = asin\C1*e   - 1/]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.ode.single.FirstLinear" title="sympy.solvers.ode.single.FirstLinear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.single.FirstLinear</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.LinearCoefficients">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">LinearCoefficients</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L1750-L1929"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.LinearCoefficients" title="Permalink to this definition">#</a></dt>
<dd><p>Solves a differential equation with linear coefficients.</p>
<p>The general form of a differential equation with linear coefficients is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y +
c_2}\!\right) = 0\text{,}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(a_1\)</span>, <span class="math notranslate nohighlight">\(b_1\)</span>, <span class="math notranslate nohighlight">\(c_1\)</span>, <span class="math notranslate nohighlight">\(a_2\)</span>, <span class="math notranslate nohighlight">\(b_2\)</span>, <span class="math notranslate nohighlight">\(c_2\)</span> are constants and <span class="math notranslate nohighlight">\(a_1 b_2
- a_2 b_1 \ne 0\)</span>.</p>
<p>This can be solved by substituting:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}x = x' + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1 b_2}\\y = y' + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1
    b_2}\text{.}\end{aligned}\end{align} \]</div>
</div>
<p>This substitution reduces the equation to a homogeneous differential
equation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;linear_coefficients&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -x - sqrt(C1 + 7*x**2) - 1), Eq(f(x), -x + sqrt(C1 + 7*x**2) - 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;linear_coefficients&#39;</span><span class="p">))</span>
<span class="go">                  ___________                     ___________</span>
<span class="go">               /         2                     /         2</span>
<span class="go">[f(x) = -x - \/  C1 + 7*x   - 1, f(x) = -x + \/  C1 + 7*x   - 1]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffBest" title="sympy.solvers.ode.single.HomogeneousCoeffBest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.single.HomogeneousCoeffBest</span></code></a>, <a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep" title="sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep</span></code></a>, <a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep" title="sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.SeparableReduced">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">SeparableReduced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L1299-L1435"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.SeparableReduced" title="Permalink to this definition">#</a></dt>
<dd><p>Solves a differential equation that can be reduced to the separable form.</p>
<p>The general form of this equation is</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' + (y/x) H(x^n y) = 0\text{}.\]</div>
</div>
<p>This can be solved by substituting <span class="math notranslate nohighlight">\(u(y) = x^n y\)</span>.  The equation then
reduces to the separable form <span class="math notranslate nohighlight">\(\frac{u'}{u (\mathrm{power} - H(u))} -
\frac{1}{x} = 0\)</span>.</p>
<p>The general solution is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                 / n     \</span>
<span class="go">d          f(x)*g\x *f(x)/</span>
<span class="go">--(f(x)) + ---------------</span>
<span class="go">dx                x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go"> n</span>
<span class="go">x *f(x)</span>
<span class="go">  /</span>
<span class="go"> |</span>
<span class="go"> |         1</span>
<span class="go"> |    ------------ dy = C1 + log(x)</span>
<span class="go"> |    y*(n - g(y))</span>
<span class="go"> |</span>
<span class="go"> /</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), (1 - sqrt(C1*x**2 + 1))/x), Eq(f(x), (sqrt(C1*x**2 + 1) + 1)/x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go">               ___________            ___________</span>
<span class="go">              /     2                /     2</span>
<span class="go">        1 - \/  C1*x  + 1          \/  C1*x  + 1  + 1</span>
<span class="go">[f(x) = ------------------, f(x) = ------------------]</span>
<span class="go">                x                          x</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.ode.single.Separable" title="sympy.solvers.ode.single.Separable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.single.Separable</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.LieGroup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">LieGroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2844-L2945"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.LieGroup" title="Permalink to this definition">#</a></dt>
<dd><p>This hint implements the Lie group method of solving first order differential
equations. The aim is to convert the given differential equation from the
given coordinate system into another coordinate system where it becomes
invariant under the one-parameter Lie group of translations. The converted
ODE can be easily solved by quadrature. It makes use of the
<a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.solvers.ode.infinitesimals()</span></code></a> function which returns the
infinitesimals of the transformation.</p>
<p>The coordinates <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(s\)</span> can be found by solving the following Partial
Differential Equations.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\xi\frac{\partial r}{\partial x} + \eta\frac{\partial r}{\partial y}
= 0\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\xi\frac{\partial s}{\partial x} + \eta\frac{\partial s}{\partial y}
= 1\]</div>
</div>
<p>The differential equation becomes separable in the new coordinate system</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{ds}{dr} = \frac{\frac{\partial s}{\partial x} +
h(x, y)\frac{\partial s}{\partial y}}{
\frac{\partial r}{\partial x} + h(x, y)\frac{\partial r}{\partial y}}\]</div>
</div>
<p>After finding the solution by integration, it is then converted back to the original
coordinate system by substituting <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(s\)</span> in terms of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> again.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;lie_group&#39;</span><span class="p">))</span>
<span class="go">       /      2\    2</span>
<span class="go">       |     x |  -x</span>
<span class="go">f(x) = |C1 + --|*e</span>
<span class="go">       \     2 /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</p></li>
</ul>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.solvers.ode.single.SecondHypergeometric">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.single.</span></span><span class="sig-name descname"><span class="pre">SecondHypergeometric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ode_problem</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/single.py#L2014-L2097"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.single.SecondHypergeometric" title="Permalink to this definition">#</a></dt>
<dd><p>Solves 2nd order linear differential equations.</p>
<p>It computes special function solutions which can be expressed using the
2F1, 1F1 or 0F1 hypergeometric functions.</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y'' + A(x) y' + B(x) y = 0\text{,}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rational functions.</p>
<p>These kinds of differential equations have solution of non-Liouvillian form.</p>
<p>Given linear ODE can be obtained from 2F1 given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[(x^2 - x) y'' + ((a + b + 1) x - c) y' + b a y = 0\text{,}\]</div>
</div>
<p>where {a, b, c} are arbitrary constants.</p>
<p class="rubric">Notes</p>
<p>The algorithm should find any solution of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y = P(x) _pF_q(..; ..;\frac{\alpha x^k + \beta}{\gamma x^k + \delta})\text{,}\]</div>
</div>
<p>where pFq is any of 2F1, 1F1 or 0F1 and <span class="math notranslate nohighlight">\(P\)</span> is an “arbitrary function”.
Currently only the 2F1 case is implemented in SymPy but the other cases are
described in the paper and could be implemented in future (contributions
welcome!).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;2nd_hypergeometric&#39;</span><span class="p">))</span>
<span class="go">                                    _</span>
<span class="go">       /        /           4  \\  |_  /-1, -1 |  \</span>
<span class="go">       |C1 + C2*|log(x) + -----||* |   |       | x|</span>
<span class="go">       \        \         x + 1// 2  1 \  1    |  /</span>
<span class="go">f(x) = --------------------------------------------</span>
<span class="go">                                3</span>
<span class="go">                         (x - 1)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>“Non-Liouvillian solutions for second order linear ODEs” by L. Chan, E.S. Cheb-Terrab</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode.ode_1st_power_series">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">ode_1st_power_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2717-L2788"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_1st_power_series" title="Permalink to this definition">#</a></dt>
<dd><p>The power series solution is a method which gives the Taylor series expansion
to the solution of a differential equation.</p>
<p>For a first order differential equation <span class="math notranslate nohighlight">\(\frac{dy}{dx} = h(x, y)\)</span>, a power
series solution exists at a point <span class="math notranslate nohighlight">\(x = x_{0}\)</span> if <span class="math notranslate nohighlight">\(h(x, y)\)</span> is analytic at <span class="math notranslate nohighlight">\(x_{0}\)</span>.
The solution is given by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y(x) = y(x_{0}) + \sum_{n = 1}^{\infty} \frac{F_{n}(x_{0},b)(x - x_{0})^n}{n!},\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(y(x_{0}) = b\)</span> is the value of y at the initial value of <span class="math notranslate nohighlight">\(x_{0}\)</span>.
To compute the values of the <span class="math notranslate nohighlight">\(F_{n}(x_{0},b)\)</span> the following algorithm is
followed, until the required number of terms are generated.</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(F_1 = h(x_{0}, b)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F_{n+1} = \frac{\partial F_{n}}{\partial x} + \frac{\partial F_{n}}{\partial y}F_{1}\)</span></p></li>
</ol>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_power_series&#39;</span><span class="p">))</span>
<span class="go">                       3       4       5</span>
<span class="go">                   C1*x    C1*x    C1*x     / 6\</span>
<span class="go">f(x) = C1 + C1*x - ----- + ----- + ----- + O\x /</span>
<span class="go">                     6       24      60</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Travis W. Walker, Analytic power series technique for solving first-order
differential equations, p.p 17, 18</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode.ode_2nd_power_series_ordinary">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">ode_2nd_power_series_ordinary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2278-L2420"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_2nd_power_series_ordinary" title="Permalink to this definition">#</a></dt>
<dd><p>Gives a power series solution to a second order homogeneous differential
equation with polynomial coefficients at an ordinary point. A homogeneous
differential equation is of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) y(x) = 0\]</div>
</div>
<p>For simplicity it is assumed that <span class="math notranslate nohighlight">\(P(x)\)</span>, <span class="math notranslate nohighlight">\(Q(x)\)</span> and <span class="math notranslate nohighlight">\(R(x)\)</span> are polynomials,
it is sufficient that <span class="math notranslate nohighlight">\(\frac{Q(x)}{P(x)}\)</span> and <span class="math notranslate nohighlight">\(\frac{R(x)}{P(x)}\)</span> exists at
<span class="math notranslate nohighlight">\(x_{0}\)</span>. A recurrence relation is obtained by substituting <span class="math notranslate nohighlight">\(y\)</span> as <span class="math notranslate nohighlight">\(\sum_{n=0}^\infty a_{n}x^{n}\)</span>,
in the differential equation, and equating the nth term. Using this relation
various terms can be generated.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;2nd_power_series_ordinary&#39;</span><span class="p">))</span>
<span class="go">          / 4    2    \        /     2\</span>
<span class="go">          |x    x     |        |    x |    / 6\</span>
<span class="go">f(x) = C2*|-- - -- + 1| + C1*x*|1 - --| + O\x /</span>
<span class="go">          \24   2     /        \    6 /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p><a class="reference external" href="https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx">https://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx</a></p></li>
<li><p>George E. Simmons, “Differential Equations with Applications and
Historical Notes”, p.p 176 - 184</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode.ode_2nd_power_series_regular">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">ode_2nd_power_series_regular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">match</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2423-L2543"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode.ode_2nd_power_series_regular" title="Permalink to this definition">#</a></dt>
<dd><p>Gives a power series solution to a second order homogeneous differential
equation with polynomial coefficients at a regular point. A second order
homogeneous differential equation is of the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) y(x) = 0\]</div>
</div>
<p>A point is said to regular singular at <span class="math notranslate nohighlight">\(x0\)</span> if <span class="math notranslate nohighlight">\(x - x0\frac{Q(x)}{P(x)}\)</span>
and <span class="math notranslate nohighlight">\((x - x0)^{2}\frac{R(x)}{P(x)}\)</span> are analytic at <span class="math notranslate nohighlight">\(x0\)</span>. For simplicity
<span class="math notranslate nohighlight">\(P(x)\)</span>, <span class="math notranslate nohighlight">\(Q(x)\)</span> and <span class="math notranslate nohighlight">\(R(x)\)</span> are assumed to be polynomials. The algorithm for
finding the power series solutions is:</p>
<ol class="arabic simple">
<li><p>Try expressing <span class="math notranslate nohighlight">\((x - x0)P(x)\)</span> and <span class="math notranslate nohighlight">\(((x - x0)^{2})Q(x)\)</span> as power series
solutions about x0. Find <span class="math notranslate nohighlight">\(p0\)</span> and <span class="math notranslate nohighlight">\(q0\)</span> which are the constants of the
power series expansions.</p></li>
<li><p>Solve the indicial equation <span class="math notranslate nohighlight">\(f(m) = m(m - 1) + m*p0 + q0\)</span>, to obtain the
roots <span class="math notranslate nohighlight">\(m1\)</span> and <span class="math notranslate nohighlight">\(m2\)</span> of the indicial equation.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(m1 - m2\)</span> is a non integer there exists two series solutions. If
<span class="math notranslate nohighlight">\(m1 = m2\)</span>, there exists only one solution. If <span class="math notranslate nohighlight">\(m1 - m2\)</span> is an integer,
then the existence of one solution is confirmed. The other solution may
or may not exist.</p></li>
</ol>
<p>The power series solution is of the form <span class="math notranslate nohighlight">\(x^{m}\sum_{n=0}^\infty a_{n}x^{n}\)</span>. The
coefficients are determined by the following recurrence relation.
<span class="math notranslate nohighlight">\(a_{n} = -\frac{\sum_{k=0}^{n-1} q_{n-k} + (m + k)p_{n-k}}{f(m + n)}\)</span>. For the case
in which <span class="math notranslate nohighlight">\(m1 - m2\)</span> is an integer, it can be seen from the recurrence relation
that for the lower root <span class="math notranslate nohighlight">\(m\)</span>, when <span class="math notranslate nohighlight">\(n\)</span> equals the difference of both the
roots, the denominator becomes zero. So if the numerator is not equal to zero,
a second series solution exists.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;2nd_power_series_regular&#39;</span><span class="p">))</span>
<span class="go">                              /    6    4    2    \</span>
<span class="go">                              |   x    x    x     |</span>
<span class="go">          /  4    2    \   C1*|- --- + -- - -- + 1|</span>
<span class="go">          | x    x     |      \  720   24   2     /    / 6\</span>
<span class="go">f(x) = C2*|--- - -- + 1| + ------------------------ + O\x /</span>
<span class="go">          \120   6     /              x</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><p>George E. Simmons, “Differential Equations with Applications and
Historical Notes”, p.p 176 - 184</p></li>
</ul>
</dd></dl>

</section>
<section id="lie-heuristics">
<h2>Lie heuristics<a class="headerlink" href="#lie-heuristics" title="Permalink to this heading">#</a></h2>
<p>These functions are intended for internal use of the Lie Group Solver.
Nonetheless, they contain useful information in their docstrings on the
algorithms implemented for the various heuristics.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_abaco1_simple">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco1_simple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L307-L408"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco1_simple" title="Permalink to this definition">#</a></dt>
<dd><p>The first heuristic uses the following four sets of
assumptions on <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\xi = 0, \eta = f(x)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\xi = 0, \eta = f(y)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\xi = f(x), \eta = 0\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\xi = f(y), \eta = 0\]</div>
</div>
<p>The success of this heuristic is determined by algebraic factorisation.
For the first assumption <span class="math notranslate nohighlight">\(\xi = 0\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span> to be a function of <span class="math notranslate nohighlight">\(x\)</span>, the PDE</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x})*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi*\frac{\partial h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0\]</div>
</div>
<p>reduces to <span class="math notranslate nohighlight">\(f'(x) - f\frac{\partial h}{\partial y} = 0\)</span>
If <span class="math notranslate nohighlight">\(\frac{\partial h}{\partial y}\)</span> is a function of <span class="math notranslate nohighlight">\(x\)</span>, then this can usually
be integrated easily. A similar idea is applied to the other 3 assumptions as well.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_abaco1_product">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco1_product</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L410-L481"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco1_product" title="Permalink to this definition">#</a></dt>
<dd><p>The second heuristic uses the following two assumptions on <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\eta = 0, \xi = f(x)*g(y)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\eta = f(x)*g(y), \xi = 0\]</div>
</div>
<p>The first assumption of this heuristic holds good if
<span class="math notranslate nohighlight">\(\frac{1}{h^{2}}\frac{\partial^2}{\partial x \partial y}\log(h)\)</span> is
separable in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, then the separated factors containing <span class="math notranslate nohighlight">\(x\)</span>
is <span class="math notranslate nohighlight">\(f(x)\)</span>, and <span class="math notranslate nohighlight">\(g(y)\)</span> is obtained by</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[e^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}\]</div>
</div>
<p>provided <span class="math notranslate nohighlight">\(f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\)</span> is a function
of <span class="math notranslate nohighlight">\(y\)</span> only.</p>
<p>The second assumption holds good if <span class="math notranslate nohighlight">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math notranslate nohighlight">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first assumption
satisfies. After obtaining <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(g(y)\)</span>, the coordinates are again
interchanged, to get <span class="math notranslate nohighlight">\(\eta\)</span> as <span class="math notranslate nohighlight">\(f(x)*g(y)\)</span></p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_bivariate">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_bivariate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L483-L553"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_bivariate" title="Permalink to this definition">#</a></dt>
<dd><p>The third heuristic assumes the infinitesimals <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span>
to be bi-variate polynomials in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. The assumption made here
for the logic below is that <span class="math notranslate nohighlight">\(h\)</span> is a rational function in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>
though that may not be necessary for the infinitesimals to be
bivariate polynomials. The coefficients of the infinitesimals
are found out by substituting them in the PDE and grouping similar terms
that are polynomials and since they form a linear system, solve and check
for non trivial solutions. The degree of the assumed bivariates
are increased till a certain maximum value.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Lie Groups and Differential Equations
pp. 327 - pp. 329</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_chi">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_chi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L555-L624"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_chi" title="Permalink to this definition">#</a></dt>
<dd><p>The aim of the fourth heuristic is to find the function <span class="math notranslate nohighlight">\(\chi(x, y)\)</span>
that satisfies the PDE <span class="math notranslate nohighlight">\(\frac{d\chi}{dx} + h\frac{d\chi}{dx}
- \frac{\partial h}{\partial y}\chi = 0\)</span>.</p>
<p>This assumes <span class="math notranslate nohighlight">\(\chi\)</span> to be a bivariate polynomial in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. By intuition,
<span class="math notranslate nohighlight">\(h\)</span> should be a rational function in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. The method used here is
to substitute a general binomial for <span class="math notranslate nohighlight">\(\chi\)</span> up to a certain maximum degree
is reached. The coefficients of the polynomials, are calculated by by collecting
terms of the same order in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>After finding <span class="math notranslate nohighlight">\(\chi\)</span>, the next step is to use <span class="math notranslate nohighlight">\(\eta = \xi*h + \chi\)</span>, to
determine <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span>. This can be done by dividing <span class="math notranslate nohighlight">\(\chi\)</span> by <span class="math notranslate nohighlight">\(h\)</span>
which would give <span class="math notranslate nohighlight">\(-\xi\)</span> as the quotient and <span class="math notranslate nohighlight">\(\eta\)</span> as the remainder.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_abaco2_similar">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco2_similar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L716-L821"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco2_similar" title="Permalink to this definition">#</a></dt>
<dd><p>This heuristic uses the following two assumptions on <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\eta = g(x), \xi = f(x)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\eta = f(y), \xi = g(y)\]</div>
</div>
<p>For the first assumption,</p>
<ol class="arabic">
<li><p>First <span class="math notranslate nohighlight">\(\frac{\frac{\partial h}{\partial y}}{\frac{\partial^{2} h}{
\partial yy}}\)</span> is calculated. Let us say this value is A</p></li>
<li><p>If this is constant, then <span class="math notranslate nohighlight">\(h\)</span> is matched to the form <span class="math notranslate nohighlight">\(A(x) + B(x)e^{
\frac{y}{C}}\)</span> then, <span class="math notranslate nohighlight">\(\frac{e^{\int \frac{A(x)}{C} \,dx}}{B(x)}\)</span> gives <span class="math notranslate nohighlight">\(f(x)\)</span>
and <span class="math notranslate nohighlight">\(A(x)*f(x)\)</span> gives <span class="math notranslate nohighlight">\(g(x)\)</span></p></li>
<li><p>Otherwise <span class="math notranslate nohighlight">\(\frac{\frac{\partial A}{\partial X}}{\frac{\partial A}{
\partial Y}} = \gamma\)</span> is calculated. If</p>
<p>a] <span class="math notranslate nohighlight">\(\gamma\)</span> is a function of <span class="math notranslate nohighlight">\(x\)</span> alone</p>
<p>b] <span class="math notranslate nohighlight">\(\frac{\gamma\frac{\partial h}{\partial y} - \gamma'(x) - \frac{
\partial h}{\partial x}}{h + \gamma} = G\)</span> is a function of <span class="math notranslate nohighlight">\(x\)</span> alone.
then, <span class="math notranslate nohighlight">\(e^{\int G \,dx}\)</span> gives <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(-\gamma*f(x)\)</span> gives <span class="math notranslate nohighlight">\(g(x)\)</span></p>
</li>
</ol>
<p>The second assumption holds good if <span class="math notranslate nohighlight">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math notranslate nohighlight">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first assumption
satisfies. After obtaining <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(g(x)\)</span>, the coordinates are again
interchanged, to get <span class="math notranslate nohighlight">\(\xi\)</span> as <span class="math notranslate nohighlight">\(f(x^*)\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span> as <span class="math notranslate nohighlight">\(g(y^*)\)</span></p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_function_sum">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_function_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L626-L714"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_function_sum" title="Permalink to this definition">#</a></dt>
<dd><p>This heuristic uses the following two assumptions on <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\eta = 0, \xi = f(x) + g(y)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\eta = f(x) + g(y), \xi = 0\]</div>
</div>
<p>The first assumption of this heuristic holds good if</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{\partial}{\partial y}[(h\frac{\partial^{2}}{
\partial x^{2}}(h^{-1}))^{-1}]\]</div>
</div>
<p>is separable in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>,</p>
<ol class="arabic simple">
<li><p>The separated factors containing <span class="math notranslate nohighlight">\(y\)</span> is <span class="math notranslate nohighlight">\(\frac{\partial g}{\partial y}\)</span>.
From this <span class="math notranslate nohighlight">\(g(y)\)</span> can be determined.</p></li>
<li><p>The separated factors containing <span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(f''(x)\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(h\frac{\partial^{2}}{\partial x^{2}}(h^{-1})\)</span> equals
<span class="math notranslate nohighlight">\(\frac{f''(x)}{f(x) + g(y)}\)</span>. From this <span class="math notranslate nohighlight">\(f(x)\)</span> can be determined.</p></li>
</ol>
<p>The second assumption holds good if <span class="math notranslate nohighlight">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math notranslate nohighlight">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first
assumption satisfies. After obtaining <span class="math notranslate nohighlight">\(f(x)\)</span> and <span class="math notranslate nohighlight">\(g(y)\)</span>, the coordinates
are again interchanged, to get <span class="math notranslate nohighlight">\(\eta\)</span> as <span class="math notranslate nohighlight">\(f(x) + g(y)\)</span>.</p>
<p>For both assumptions, the constant factors are separated among <span class="math notranslate nohighlight">\(g(y)\)</span>
and <span class="math notranslate nohighlight">\(f''(x)\)</span>, such that <span class="math notranslate nohighlight">\(f''(x)\)</span> obtained from 3] is the same as that
obtained from 2]. If not possible, then this heuristic fails.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_unknown">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco2_unique_unknown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L824-L899"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_unknown" title="Permalink to this definition">#</a></dt>
<dd><p>This heuristic assumes the presence of unknown functions or known functions
with non-integer powers.</p>
<ol class="arabic">
<li><p>A list of all functions and non-integer powers containing x and y</p></li>
<li><p>Loop over each element <span class="math notranslate nohighlight">\(f\)</span> in the list, find <span class="math notranslate nohighlight">\(\frac{\frac{\partial f}{\partial x}}{
\frac{\partial f}{\partial x}} = R\)</span></p>
<p>If it is separable in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>, let <span class="math notranslate nohighlight">\(X\)</span> be the factors containing <span class="math notranslate nohighlight">\(x\)</span>. Then</p>
<dl class="simple">
<dt>a] Check if <span class="math notranslate nohighlight">\(\xi = X\)</span> and <span class="math notranslate nohighlight">\(\eta = -\frac{X}{R}\)</span> satisfy the PDE. If yes, then return</dt><dd><p><span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
</dd>
<dt>b] Check if <span class="math notranslate nohighlight">\(\xi = \frac{-R}{X}\)</span> and <span class="math notranslate nohighlight">\(\eta = -\frac{1}{X}\)</span> satisfy the PDE.</dt><dd><p>If yes, then return <span class="math notranslate nohighlight">\(\xi\)</span> and <span class="math notranslate nohighlight">\(\eta\)</span></p>
</dd>
</dl>
<p>If not, then check if</p>
<p>a] <span class="math notranslate nohighlight">\(\xi = -R,\eta = 1\)</span></p>
<p>b] <span class="math notranslate nohighlight">\(\xi = 1, \eta = -\frac{1}{R}\)</span></p>
<p>are solutions.</p>
</li>
</ol>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_general">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_abaco2_unique_general</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L902-L974"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_general" title="Permalink to this definition">#</a></dt>
<dd><p>This heuristic finds if infinitesimals of the form <span class="math notranslate nohighlight">\(\eta = f(x)\)</span>, <span class="math notranslate nohighlight">\(\xi = g(y)\)</span>
without making any assumptions on <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>The complete sequence of steps is given in the paper mentioned below.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.lie_group.lie_heuristic_linear">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.lie_group.</span></span><span class="sig-name descname"><span class="pre">lie_heuristic_linear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">match</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/lie_group.py#L977-L1047"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.lie_group.lie_heuristic_linear" title="Permalink to this definition">#</a></dt>
<dd><p>This heuristic assumes</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\xi = ax + by + c\)</span> and</p></li>
<li><p><span class="math notranslate nohighlight">\(\eta = fx + gy + h\)</span></p></li>
</ol>
<p>After substituting the following assumptions in the determining PDE, it
reduces to</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x}
- (fx + gy + c)\frac{\partial h}{\partial y}\]</div>
</div>
<p>Solving the reduced PDE obtained, using the method of characteristics, becomes
impractical. The method followed is grouping similar terms and solving the system
of linear equations obtained. The difference between the bivariate heuristic is that
<span class="math notranslate nohighlight">\(h\)</span> need not be a rational function in this case.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><p>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</p></li>
</ul>
</dd></dl>

</section>
<section id="rational-riccati-solver">
<h2>Rational Riccati Solver<a class="headerlink" href="#rational-riccati-solver" title="Permalink to this heading">#</a></h2>
<p>These functions are intended for internal use to solve a first order Riccati
differential equation with atleast one rational particular solution.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.riccati_normal">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">riccati_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L216-L233"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.riccati_normal" title="Permalink to this definition">#</a></dt>
<dd><p>Given a solution <span class="math notranslate nohighlight">\(w(x)\)</span> to the equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[w'(x) = b_0(x) + b_1(x)*w(x) + b_2(x)*w(x)^2\]</div>
</div>
<p>and rational function coefficients <span class="math notranslate nohighlight">\(b_1(x)\)</span> and
<span class="math notranslate nohighlight">\(b_2(x)\)</span>, this function transforms the solution to
give a solution <span class="math notranslate nohighlight">\(y(x)\)</span> for its corresponding normal
Riccati ODE</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y'(x) + y(x)^2 = a(x)\]</div>
</div>
<p>using the transformation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y(x) = -b_2(x)*w(x) - b'_2(x)/(2*b_2(x)) - b_1(x)/2\]</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.riccati_inverse_normal">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">riccati_inverse_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L236-L246"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.riccati_inverse_normal" title="Permalink to this definition">#</a></dt>
<dd><p>Inverse transforming the solution to the normal
Riccati ODE to get the solution to the Riccati ODE.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.riccati_reduced">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">riccati_reduced</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L249-L263"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.riccati_reduced" title="Permalink to this definition">#</a></dt>
<dd><p>Convert a Riccati ODE into its corresponding
normal Riccati ODE.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.construct_c">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">construct_c</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">den</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">muls</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L461-L485"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.construct_c" title="Permalink to this definition">#</a></dt>
<dd><p>Helper function to calculate the coefficients
in the c-vector for each pole.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.construct_d">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">construct_d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">den</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_inf</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L546-L569"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.construct_d" title="Permalink to this definition">#</a></dt>
<dd><p>Helper function to calculate the coefficients
in the d-vector based on the valuation of the
function at oo.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.rational_laurent_series">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">rational_laurent_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">den</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L572-L648"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.rational_laurent_series" title="Permalink to this definition">#</a></dt>
<dd><p>The function computes the Laurent series coefficients
of a rational function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num: A Poly object that is the numerator of `f(x)`.</strong></p>
<p><strong>den: A Poly object that is the denominator of `f(x)`.</strong></p>
<p><strong>x: The variable of expansion of the series.</strong></p>
<p><strong>r: The point of expansion of the series.</strong></p>
<p><strong>m: Multiplicity of r if r is a pole of `f(x)`. Should</strong></p>
<p><strong>be zero otherwise.</strong></p>
<p><strong>n: Order of the term upto which the series is expanded.</strong></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>series: A dictionary that has power of the term as key</p>
<p>and coefficient of that term as value.</p>
<p>Below is a basic outline of how the Laurent series of a</p>
<p>rational function <span class="math notranslate nohighlight">\(f(x)\)</span> about <span class="math notranslate nohighlight">\(x_0\)</span> is being calculated -</p>
<ol class="arabic simple">
<li><p>Substitute <span class="math notranslate nohighlight">\(x + x_0\)</span> in place of <span class="math notranslate nohighlight">\(x\)</span>. If <span class="math notranslate nohighlight">\(x_0\)</span></p></li>
</ol>
<p>is a pole of <span class="math notranslate nohighlight">\(f(x)\)</span>, multiply the expression by <span class="math notranslate nohighlight">\(x^m\)</span></p>
<p>where <span class="math notranslate nohighlight">\(m\)</span> is the multiplicity of <span class="math notranslate nohighlight">\(x_0\)</span>. Denote the</p>
<p>the resulting expression as g(x). We do this substitution</p>
<p>so that we can now find the Laurent series of g(x) about</p>
<p><span class="math notranslate nohighlight">\(x = 0\)</span>.</p>
<ol class="arabic simple" start="2">
<li><p>We can then assume that the Laurent series of <span class="math notranslate nohighlight">\(g(x)\)</span></p></li>
</ol>
<p>takes the following form -</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[g(x) = \frac{num(x)}{den(x)} = \sum_{m = 0}^{\infty} a_m x^m\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(a_m\)</span> denotes the Laurent series coefficients.</p>
<ol class="arabic simple" start="3">
<li><p>Multiply the denominator to the RHS of the equation</p></li>
</ol>
<p>and form a recurrence relation for the coefficients <span class="math notranslate nohighlight">\(a_m\)</span>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.compute_m_ybar">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">compute_m_ybar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">choice</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L650-L676"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.compute_m_ybar" title="Permalink to this definition">#</a></dt>
<dd><p>Helper function to calculate -</p>
<p>1. m - The degree bound for the polynomial
solution that must be found for the auxiliary
differential equation.</p>
<p>2. ybar - Part of the solution which can be
computed using the poles, c and d vectors.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.solve_aux_eq">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">solve_aux_eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dena</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deny</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L679-L703"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.solve_aux_eq" title="Permalink to this definition">#</a></dt>
<dd><p>Helper function to find a polynomial solution
of degree m for the auxiliary differential
equation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.remove_redundant_sols">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">remove_redundant_sols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sol1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sol2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L706-L734"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.remove_redundant_sols" title="Permalink to this definition">#</a></dt>
<dd><p>Helper function to remove redundant
solutions to the differential equation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.get_gen_sol_from_part_sol">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">get_gen_sol_from_part_sol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">part_sols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L737-L792"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.get_gen_sol_from_part_sol" title="Permalink to this definition">#</a></dt>
<dd><p>”
Helper function which computes the general
solution for a Riccati ODE from its particular
solutions.</p>
<p>There are 3 cases to find the general solution
from the particular solutions for a Riccati ODE
depending on the number of particular solution(s)
we have - 1, 2 or 3.</p>
<p>For more information, see Section 6 of
“Methods of Solution of the Riccati Differential Equation”
by D. R. Haaheim and F. M. Stein</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.riccati.solve_riccati">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.riccati.</span></span><span class="sig-name descname"><span class="pre">solve_riccati</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gensol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/riccati.py#L795-L893"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.riccati.solve_riccati" title="Permalink to this definition">#</a></dt>
<dd><p>The main function that gives particular/general
solutions to Riccati ODEs that have atleast 1
rational particular solution.</p>
</dd></dl>

</section>
<section id="system-of-odes">
<h2>System of ODEs<a class="headerlink" href="#system-of-odes" title="Permalink to this heading">#</a></h2>
<p>These functions are intended for internal use by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> for system of differential equations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._linear_2eq_order1_type6">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_linear_2eq_order1_type6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2903-L2954"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._linear_2eq_order1_type6" title="Permalink to this definition">#</a></dt>
<dd><p>The equations of this type of ode are .</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = f(t) x + g(t) y\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' = a [f(t) + a h(t)] x + a [g(t) - h(t)] y\]</div>
</div>
<p>This is solved by first multiplying the first equation by <span class="math notranslate nohighlight">\(-a\)</span> and adding
it to the second equation to obtain</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' - a x' = -a h(t) (y - a x)\]</div>
</div>
<p>Setting <span class="math notranslate nohighlight">\(U = y - ax\)</span> and integrating the equation we arrive at</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y - ax = C_1 e^{-a \int h(t) \,dt}\]</div>
</div>
<p>and on substituting the value of y in first equation give rise to first order ODEs. After solving for
<span class="math notranslate nohighlight">\(x\)</span>, we can obtain <span class="math notranslate nohighlight">\(y\)</span> by substituting the value of <span class="math notranslate nohighlight">\(x\)</span> in second equation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._linear_2eq_order1_type7">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_linear_2eq_order1_type7</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2956-L3015"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._linear_2eq_order1_type7" title="Permalink to this definition">#</a></dt>
<dd><p>The equations of this type of ode are .</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = f(t) x + g(t) y\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' = h(t) x + p(t) y\]</div>
</div>
<p>Differentiating the first equation and substituting the value of <span class="math notranslate nohighlight">\(y\)</span>
from second equation will give a second-order linear equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[g x'' - (fg + gp + g') x' + (fgp - g^{2} h + f g' - f' g) x = 0\]</div>
</div>
<p>This above equation can be easily integrated if following conditions are satisfied.</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(fgp - g^{2} h + f g' - f' g = 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(fgp - g^{2} h + f g' - f' g = ag, fg + gp + g' = bg\)</span></p></li>
</ol>
<p>If first condition is satisfied then it is solved by current dsolve solver and in second case it becomes
a constant coefficient differential equation which is also solved by current solver.</p>
<p>Otherwise if the above condition fails then,
a particular solution is assumed as <span class="math notranslate nohighlight">\(x = x_0(t)\)</span> and <span class="math notranslate nohighlight">\(y = y_0(t)\)</span>
Then the general solution is expressed as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x = C_1 x_0(t) + C_2 x_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y = C_1 y_0(t) + C_2 [\frac{F(t) P(t)}{x_0(t)} + y_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt]\]</div>
</div>
<p>where C1 and C2 are arbitrary constants and</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[F(t) = e^{\int f(t) \,dt}, P(t) = e^{\int p(t) \,dt}\]</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.systems.linear_ode_to_matrix">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.systems.</span></span><span class="sig-name descname"><span class="pre">linear_ode_to_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/systems.py#L342-L488"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.systems.linear_ode_to_matrix" title="Permalink to this definition">#</a></dt>
<dd><p>Convert a linear system of ODEs to matrix form</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>eqs</strong> : list of SymPy expressions or equalities</p>
<blockquote>
<div><p>The equations as expressions (assumed equal to zero).</p>
</div></blockquote>
<p><strong>funcs</strong> : list of applied functions</p>
<blockquote>
<div><p>The dependent variables of the system of ODEs.</p>
</div></blockquote>
<p><strong>t</strong> : symbol</p>
<blockquote>
<div><p>The independent variable.</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote>
<div><p>The order of the system of ODEs.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The tuple <code class="docutils literal notranslate"><span class="pre">(As,</span> <span class="pre">b)</span></code> where <code class="docutils literal notranslate"><span class="pre">As</span></code> is a tuple of matrices and <code class="docutils literal notranslate"><span class="pre">b</span></code> is the</p>
<p>the matrix representing the rhs of the matrix equation.</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ODEOrderError</strong></p>
<blockquote>
<div><p>When the system of ODEs have an order greater than what was specified</p>
</div></blockquote>
<p><strong>ODENonlinearError</strong></p>
<blockquote>
<div><p>When the system of ODEs is nonlinear</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>Express a system of linear ordinary differential equations as a single
matrix differential equation [1]. For example the system <span class="math notranslate nohighlight">\(x' = x + y + 1\)</span>
and <span class="math notranslate nohighlight">\(y' = x - y\)</span> can be represented as</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A_1 X' = A_0 X + b\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(A_1\)</span> and <span class="math notranslate nohighlight">\(A_0\)</span> are <span class="math notranslate nohighlight">\(2 \times 2\)</span> matrices and <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(X'\)</span> are
<span class="math notranslate nohighlight">\(2 \times 1\)</span> matrices with <span class="math notranslate nohighlight">\(X = [x, y]^T\)</span>.</p>
<p>Higher-order systems are represented with additional matrices e.g. a
second-order system would look like</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A_2 X'' =  A_1 X' + A_0 X  + b\]</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">linear_ode_to_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We can create a system of linear ODEs like</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 1st order system</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">linear_ode_to_matrix</span></code> can represent this as a matrix
differential equation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A0</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A1</span>
<span class="go">Matrix([</span>
<span class="go">[1, 0],</span>
<span class="go">[0, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A0</span>
<span class="go">Matrix([</span>
<span class="go">[1, 1],</span>
<span class="go">[1,  -1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[1],</span>
<span class="go">[0]])</span>
</pre></div>
</div>
<p>The original equations can be recovered from these matrices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs_mat</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">eq</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">eq</span><span class="o">.</span><span class="n">rhs</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">eqs</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A1</span> <span class="o">*</span> <span class="n">X</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">A0</span> <span class="o">*</span> <span class="n">X</span> <span class="o">-</span> <span class="n">b</span> <span class="o">==</span> <span class="n">eqs_mat</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If the system of equations has a maximum order greater than the
order of the system specified, a ODEOrderError exception is raised.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ODEOrderError</span>: <span class="n">Cannot represent system in 1-order form</span>
</pre></div>
</div>
<p>If the system of equations is nonlinear, then ODENonlinearError is
raised.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ODENonlinearError</span>: <span class="n">The system of ODEs is nonlinear.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="solveset.html#sympy.solvers.solveset.linear_eq_to_matrix" title="sympy.solvers.solveset.linear_eq_to_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_eq_to_matrix</span></code></a></dt><dd><p>for systems of linear algebraic equations.</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r821" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">R821</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_differential_equation">https://en.wikipedia.org/wiki/Matrix_differential_equation</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.systems.canonical_odes">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.systems.</span></span><span class="sig-name descname"><span class="pre">canonical_odes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/systems.py#L1009-L1078"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.systems.canonical_odes" title="Permalink to this definition">#</a></dt>
<dd><p>Function that solves for highest order derivatives in a system</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>eqs</strong> : List</p>
<blockquote>
<div><p>List of the ODEs</p>
</div></blockquote>
<p><strong>funcs</strong> : List</p>
<blockquote>
<div><p>List of dependent variables</p>
</div></blockquote>
<p><strong>t</strong> : Symbol</p>
<blockquote>
<div><p>Independent variable</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List</p>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This function inputs a system of ODEs and based on the system,
the dependent variables and their highest order, returns the system
in the following form:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[X'(t) = A(t) X(t) + b(t)\]</div>
</div>
<p>Here, <span class="math notranslate nohighlight">\(X(t)\)</span> is the vector of dependent variables of lower order, <span class="math notranslate nohighlight">\(A(t)\)</span> is
the coefficient matrix, <span class="math notranslate nohighlight">\(b(t)\)</span> is the non-homogeneous term and <span class="math notranslate nohighlight">\(X'(t)\)</span> is the
vector of dependent variables in their respective highest order. We use the term
canonical form to imply the system of ODEs which is of the above form.</p>
<p>If the system passed has a non-linear term with multiple solutions, then a list of
systems is returned in its canonical form.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">canonical_odes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;f g&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">7</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">12</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">20</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">canonical_eqs</span> <span class="o">=</span> <span class="n">canonical_odes</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">canonical_eqs</span>
<span class="go">[[Eq(Derivative(f(x), x), 7*f(x) + 12*g(x)), Eq(Derivative(g(x), x), 20*f(x) - g(x))]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">canonical_system</span> <span class="o">=</span> <span class="n">canonical_odes</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">canonical_system</span>
<span class="go">[[Eq(Derivative(f(x), x), -1), Eq(Derivative(g(x), x), y*f(x))], [Eq(Derivative(f(x), x), 3), Eq(Derivative(g(x), x), y*f(x))]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.systems.linodesolve_type">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.systems.</span></span><span class="sig-name descname"><span class="pre">linodesolve_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/systems.py#L203-L312"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.systems.linodesolve_type" title="Permalink to this definition">#</a></dt>
<dd><p>Helper function that determines the type of the system of ODEs for solving with <a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve" title="sympy.solvers.ode.systems.linodesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve()</span></code></a></p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> : Matrix</p>
<blockquote>
<div><p>Coefficient matrix of the system of ODEs</p>
</div></blockquote>
<p><strong>b</strong> : Matrix or None</p>
<blockquote>
<div><p>Non-homogeneous term of the system. The default value is None.
If this argument is None, then the system is assumed to be homogeneous.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Dict</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>When the coefficient matrix does not have a commutative antiderivative</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This function takes in the coefficient matrix and/or the non-homogeneous term
and returns the type of the equation that can be solved by <a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve" title="sympy.solvers.ode.systems.linodesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve()</span></code></a>.</p>
<p>If the system is constant coefficient homogeneous, then “type1” is returned</p>
<p>If the system is constant coefficient non-homogeneous, then “type2” is returned</p>
<p>If the system is non-constant coefficient homogeneous, then “type3” is returned</p>
<p>If the system is non-constant coefficient non-homogeneous, then “type4” is returned</p>
<p>If the system has a non-constant coefficient matrix which can be factorized into constant
coefficient matrix, then “type5” or “type6” is returned for when the system is homogeneous or
non-homogeneous respectively.</p>
<p>Note that, if the system of ODEs is of “type3” or “type4”, then along with the type,
the commutative antiderivative of the coefficient matrix is also returned.</p>
<p>If the system cannot be solved by <a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve" title="sympy.solvers.ode.systems.linodesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve()</span></code></a>, then
NotImplementedError is raised.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">linodesolve_type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="go">{&#39;antiderivative&#39;: None, &#39;type_of_equation&#39;: &#39;type1&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="go">{&#39;antiderivative&#39;: None, &#39;type_of_equation&#39;: &#39;type2&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A_t</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="go">{&#39;antiderivative&#39;: Matrix([</span>
<span class="go">[      t, t**2/2],</span>
<span class="go">[-t**2/2,      t]]), &#39;type_of_equation&#39;: &#39;type3&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="go">{&#39;antiderivative&#39;: Matrix([</span>
<span class="go">[      t, t**2/2],</span>
<span class="go">[-t**2/2,      t]]), &#39;type_of_equation&#39;: &#39;type4&#39;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A_non_commutative</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A_non_commutative</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">NotImplementedError</span><span class="w">:</span>
<span class="x">The system does not have a commutative antiderivative, it cannot be</span>
<span class="x">solved by linodesolve.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve" title="sympy.solvers.ode.systems.linodesolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linodesolve</span></code></a></dt><dd><p>Function for which linodesolve_type gets the information</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.systems.matrix_exp_jordan_form">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.systems.</span></span><span class="sig-name descname"><span class="pre">matrix_exp_jordan_form</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/systems.py#L566-L681"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.systems.matrix_exp_jordan_form" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix exponential <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> for the matrix <em>A</em> and scalar <em>t</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> : Matrix</p>
<blockquote>
<div><p>The matrix <span class="math notranslate nohighlight">\(A\)</span> in the expression <span class="math notranslate nohighlight">\(\exp(A*t)\)</span></p>
</div></blockquote>
<p><strong>t</strong> : Symbol</p>
<blockquote>
<div><p>The independent variable</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>Returns the Jordan form of the <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> along with the matrix <span class="math notranslate nohighlight">\(P\)</span> such that:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\exp(A*t) = P * expJ * P^{-1}\]</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">matrix_exp</span><span class="p">,</span> <span class="n">matrix_exp_jordan_form</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We will consider a 2x2 defective matrix. This shows that our method
works even for defective matrices.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
<p>It can be observed that this function gives us the Jordan normal form
and the required invertible matrix P.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">expJ</span> <span class="o">=</span> <span class="n">matrix_exp_jordan_form</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, it is shown that P and expJ returned by this function is correct
as they satisfy the formula: P * expJ * P_inverse = exp(A*t).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">*</span> <span class="n">expJ</span> <span class="o">*</span> <span class="n">P</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="o">==</span> <span class="n">matrix_exp</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r822" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">R822</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Defective_matrix">https://en.wikipedia.org/wiki/Defective_matrix</a></p>
</div>
<div class="citation" id="r823" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">R823</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Jordan_matrix">https://en.wikipedia.org/wiki/Jordan_matrix</a></p>
</div>
<div class="citation" id="r824" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">R824</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Jordan_normal_form">https://en.wikipedia.org/wiki/Jordan_normal_form</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.systems.matrix_exp">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.systems.</span></span><span class="sig-name descname"><span class="pre">matrix_exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/systems.py#L491-L563"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.systems.matrix_exp" title="Permalink to this definition">#</a></dt>
<dd><p>Matrix exponential <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> for the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> and scalar <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> : Matrix</p>
<blockquote>
<div><p>The matrix <span class="math notranslate nohighlight">\(A\)</span> in the expression <span class="math notranslate nohighlight">\(\exp(A*t)\)</span></p>
</div></blockquote>
<p><strong>t</strong> : Symbol</p>
<blockquote>
<div><p>The independent variable</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This functions returns the <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> by doing a simple
matrix multiplication:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\exp(A*t) = P * expJ * P^{-1}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(expJ\)</span> is <span class="math notranslate nohighlight">\(\exp(J*t)\)</span>. <span class="math notranslate nohighlight">\(J\)</span> is the Jordan normal
form of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(P\)</span> is matrix such that:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A = P * J * P^{-1}\]</div>
</div>
<p>The matrix exponential <span class="math notranslate nohighlight">\(\exp(A*t)\)</span> appears in the solution of linear
differential equations. For example if <span class="math notranslate nohighlight">\(x\)</span> is a vector and <span class="math notranslate nohighlight">\(A\)</span> is a matrix
then the initial value problem</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{dx(t)}{dt} = A \times x(t),   x(0) = x0\]</div>
</div>
<p>has the unique solution</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x(t) = \exp(A t) x0\]</div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">matrix_exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We will consider a 2x2 matrix for comupting the exponential</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[2  -5]</span>
<span class="go">[     ]</span>
<span class="go">[2  -4]</span>
</pre></div>
</div>
<p>Now, exp(A*t) is given as follows:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">matrix_exp</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
<span class="go">[   -t           -t                    -t              ]</span>
<span class="go">[3*e  *sin(t) + e  *cos(t)         -5*e  *sin(t)       ]</span>
<span class="go">[                                                      ]</span>
<span class="go">[         -t                     -t           -t       ]</span>
<span class="go">[      2*e  *sin(t)         - 3*e  *sin(t) + e  *cos(t)]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.matrix_exp_jordan_form" title="sympy.solvers.ode.systems.matrix_exp_jordan_form"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matrix_exp_jordan_form</span></code></a></dt><dd><p>For exponential of Jordan normal form</p>
</dd>
</dl>
</div>
<p class="rubric">References</p>
<div role="list" class="citation-list">
<div class="citation" id="r825" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">R825</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Jordan_normal_form">https://en.wikipedia.org/wiki/Jordan_normal_form</a></p>
</div>
<div class="citation" id="r826" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">R826</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_exponential">https://en.wikipedia.org/wiki/Matrix_exponential</a></p>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.systems.linodesolve">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.systems.</span></span><span class="sig-name descname"><span class="pre">linodesolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">doit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/systems.py#L685-L1001"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.systems.linodesolve" title="Permalink to this definition">#</a></dt>
<dd><p>System of n equations linear first-order differential equations</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>A</strong> : Matrix</p>
<blockquote>
<div><p>Coefficient matrix of the system of linear first order ODEs.</p>
</div></blockquote>
<p><strong>t</strong> : Symbol</p>
<blockquote>
<div><p>Independent variable in the system of ODEs.</p>
</div></blockquote>
<p><strong>b</strong> : Matrix or None</p>
<blockquote>
<div><p>Non-homogeneous term in the system of ODEs. If None is passed,
a homogeneous system of ODEs is assumed.</p>
</div></blockquote>
<p><strong>B</strong> : Matrix or None</p>
<blockquote>
<div><p>Antiderivative of the coefficient matrix. If the antiderivative
is not passed and the solution requires the term, then the solver
would compute it internally.</p>
</div></blockquote>
<p><strong>type</strong> : String</p>
<blockquote>
<div><p>Type of the system of ODEs passed. Depending on the type, the
solution is evaluated. The type values allowed and the corresponding
system it solves are: “type1” for constant coefficient homogeneous
“type2” for constant coefficient non-homogeneous, “type3” for non-constant
coefficient homogeneous, “type4” for non-constant coefficient non-homogeneous,
“type5” and “type6” for non-constant coefficient homogeneous and non-homogeneous
systems respectively where the coefficient matrix can be factorized to a constant
coefficient matrix.
The default value is “auto” which will let the solver decide the correct type of
the system passed.</p>
</div></blockquote>
<p><strong>doit</strong> : Boolean</p>
<blockquote>
<div><p>Evaluate the solution if True, default value is False</p>
</div></blockquote>
<p><strong>tau: Expression</strong></p>
<blockquote>
<div><p>Used to substitute for the value of <span class="math notranslate nohighlight">\(t\)</span> after we get the solution of the system.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>List</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong></p>
<blockquote>
<div><p>This error is raised when the coefficient matrix, non-homogeneous term
or the antiderivative, if passed, are not a matrix or
do not have correct dimensions</p>
</div></blockquote>
<p><strong>NonSquareMatrixError</strong></p>
<blockquote>
<div><p>When the coefficient matrix or its antiderivative, if passed is not a
square matrix</p>
</div></blockquote>
<p><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>If the coefficient matrix does not have a commutative antiderivative</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>This solver solves the system of ODEs of the following form:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[X'(t) = A(t) X(t) +  b(t)\]</div>
</div>
<p>Here, <span class="math notranslate nohighlight">\(A(t)\)</span> is the coefficient matrix, <span class="math notranslate nohighlight">\(X(t)\)</span> is the vector of n independent variables,
<span class="math notranslate nohighlight">\(b(t)\)</span> is the non-homogeneous term and <span class="math notranslate nohighlight">\(X'(t)\)</span> is the derivative of <span class="math notranslate nohighlight">\(X(t)\)</span></p>
<p>Depending on the properties of <span class="math notranslate nohighlight">\(A(t)\)</span> and <span class="math notranslate nohighlight">\(b(t)\)</span>, this solver evaluates the solution
differently.</p>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is constant coefficient matrix and <span class="math notranslate nohighlight">\(b(t)\)</span> is zero vector i.e. system is homogeneous,
the system is “type1”. The solution is:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[X(t) = \exp(A t) C\]</div>
</div>
<p>Here, <span class="math notranslate nohighlight">\(C\)</span> is a vector of constants and <span class="math notranslate nohighlight">\(A\)</span> is the constant coefficient matrix.</p>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is constant coefficient matrix and <span class="math notranslate nohighlight">\(b(t)\)</span> is non-zero i.e. system is non-homogeneous,
the system is “type2”. The solution is:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[X(t) = e^{A t} ( \int e^{- A t} b \,dt + C)\]</div>
</div>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is coefficient matrix such that its commutative with its antiderivative <span class="math notranslate nohighlight">\(B(t)\)</span> and
<span class="math notranslate nohighlight">\(b(t)\)</span> is a zero vector i.e. system is homogeneous, the system is “type3”. The solution is:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[X(t) = \exp(B(t)) C\]</div>
</div>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is commutative with its antiderivative <span class="math notranslate nohighlight">\(B(t)\)</span> and <span class="math notranslate nohighlight">\(b(t)\)</span> is non-zero i.e. system is
non-homogeneous, the system is “type4”. The solution is:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[X(t) =  e^{B(t)} ( \int e^{-B(t)} b(t) \,dt + C)\]</div>
</div>
<p>When <span class="math notranslate nohighlight">\(A(t)\)</span> is a coefficient matrix such that it can be factorized into a scalar and a constant
coefficient matrix:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[A(t) = f(t) * A\]</div>
</div>
<p>Where <span class="math notranslate nohighlight">\(f(t)\)</span> is a scalar expression in the independent variable <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(A\)</span> is a constant matrix,
then we can do the following substitutions:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[tau = \int f(t) dt, X(t) = Y(tau), b(t) = b(f^{-1}(tau))\]</div>
</div>
<p>Here, the substitution for the non-homogeneous term is done only when its non-zero.
Using these substitutions, our original system becomes:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[Y'(tau) = A * Y(tau) + b(tau)/f(tau)\]</div>
</div>
<p>The above system can be easily solved using the solution for “type1” or “type2” depending
on the homogeneity of the system. After we get the solution for <span class="math notranslate nohighlight">\(Y(tau)\)</span>, we substitute the
solution for <span class="math notranslate nohighlight">\(tau\)</span> as <span class="math notranslate nohighlight">\(t\)</span> to get back <span class="math notranslate nohighlight">\(X(t)\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[X(t) = Y(tau)\]</div>
</div>
<p>Systems of “type5” and “type6” have a commutative antiderivative but we use this solution
because its faster to compute.</p>
<p>The final solution is the general solution for all the four equations since a constant coefficient
matrix is always commutative with its antidervative.</p>
<p>An additional feature of this function is, if someone wants to substitute for value of the independent
variable, they can pass the substitution <span class="math notranslate nohighlight">\(tau\)</span> and the solution will have the independent variable
substituted with the passed expression(<span class="math notranslate nohighlight">\(tau\)</span>).</p>
<p class="rubric">Examples</p>
<p>To solve the system of ODEs using this function directly, several things must be
done in the right order. Wrong inputs to the function will lead to incorrect results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.systems</span> <span class="kn">import</span> <span class="n">canonical_odes</span><span class="p">,</span> <span class="n">linear_ode_to_matrix</span><span class="p">,</span> <span class="n">linodesolve</span><span class="p">,</span> <span class="n">linodesolve_type</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode.subscheck</span> <span class="kn">import</span> <span class="n">checkodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;f, g&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">Function</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;x, a&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
</pre></div>
</div>
<p>Here, it is important to note that before we derive the coefficient matrix, it is
important to get the system of ODEs into the desired form. For that we will use
<a class="reference internal" href="#sympy.solvers.ode.systems.canonical_odes" title="sympy.solvers.ode.systems.canonical_odes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.canonical_odes()</span></code></a>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="n">canonical_odes</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span>
<span class="go">[[Eq(Derivative(f(x), x), a*g(x) + f(x) + 1), Eq(Derivative(g(x), x), a*f(x) - g(x))]]</span>
</pre></div>
</div>
<p>Now, we will use <a class="reference internal" href="#sympy.solvers.ode.systems.linear_ode_to_matrix" title="sympy.solvers.ode.systems.linear_ode_to_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linear_ode_to_matrix()</span></code></a> to get the coefficient matrix and the
non-homogeneous term if it is there.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="n">eqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A0</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">A0</span>
</pre></div>
</div>
<p>We have the coefficient matrices and the non-homogeneous term ready. Now, we can use
<a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve_type" title="sympy.solvers.ode.systems.linodesolve_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve_type()</span></code></a> to get the information for the system of ODEs
to finally pass it to the solver.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system_info</span> <span class="o">=</span> <span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol_vector</span> <span class="o">=</span> <span class="n">linodesolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">system_info</span><span class="p">[</span><span class="s1">&#39;antiderivative&#39;</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="n">system_info</span><span class="p">[</span><span class="s1">&#39;type_of_equation&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Now, we can prove if the solution is correct or not by using <a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.checkodesol()</span></code></a></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">sol_vector</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, [0, 0])</span>
</pre></div>
</div>
<p>We can also use the doit method to evaluate the solutions passed by the function.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol_vector_evaluated</span> <span class="o">=</span> <span class="n">linodesolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;type2&quot;</span><span class="p">,</span> <span class="n">doit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we will look at a system of ODEs which is non-constant.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
</pre></div>
</div>
<p>The system defined above is already in the desired form, so we do not have to convert it.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A0</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_ode_to_matrix</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">A0</span>
</pre></div>
</div>
<p>A user can also pass the commutative antiderivative required for type3 and type4 system of ODEs.
Passing an incorrect one will lead to incorrect results. If the coefficient matrix is not commutative
with its antiderivative, then <a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve_type" title="sympy.solvers.ode.systems.linodesolve_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.solvers.ode.systems.linodesolve_type()</span></code></a> raises a NotImplementedError.
If it does have a commutative antiderivative, then the function just returns the information about the system.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system_info</span> <span class="o">=</span> <span class="n">linodesolve_type</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, we can pass the antiderivative as an argument to get the solution. If the system information is not
passed, then the solver will compute the required arguments internally.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol_vector</span> <span class="o">=</span> <span class="n">linodesolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Once again, we can verify the solution obtained.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="p">[</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">sol_vector</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
<span class="go">(True, [0, 0])</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.linear_ode_to_matrix" title="sympy.solvers.ode.systems.linear_ode_to_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linear_ode_to_matrix</span></code></a></dt><dd><p>Coefficient matrix computation function</p>
</dd>
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.canonical_odes" title="sympy.solvers.ode.systems.canonical_odes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">canonical_odes</span></code></a></dt><dd><p>System of ODEs representation change</p>
</dd>
<dt><a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve_type" title="sympy.solvers.ode.systems.linodesolve_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linodesolve_type</span></code></a></dt><dd><p>Getting information about systems of ODEs to pass in this solver</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type1">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_2eq_order1_type1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3044-L3087"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type1" title="Permalink to this definition">#</a></dt>
<dd><p>Equations:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = x^n F(x,y)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' = g(y) F(x,y)\]</div>
</div>
<p>Solution:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]</div>
</div>
<p>where</p>
<p>if <span class="math notranslate nohighlight">\(n \neq 1\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\varphi = [C_1 + (1-n) \int \frac{1}{g(y)} \,dy]^{\frac{1}{1-n}}\]</div>
</div>
<p>if <span class="math notranslate nohighlight">\(n = 1\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\varphi = C_1 e^{\int \frac{1}{g(y)} \,dy}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type2">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_2eq_order1_type2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3089-L3132"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type2" title="Permalink to this definition">#</a></dt>
<dd><p>Equations:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = e^{\lambda x} F(x,y)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' = g(y) F(x,y)\]</div>
</div>
<p>Solution:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]</div>
</div>
<p>where</p>
<p>if <span class="math notranslate nohighlight">\(\lambda \neq 0\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\varphi = -\frac{1}{\lambda} log(C_1 - \lambda \int \frac{1}{g(y)} \,dy)\]</div>
</div>
<p>if <span class="math notranslate nohighlight">\(\lambda = 0\)</span></p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\varphi = C_1 + \int \frac{1}{g(y)} \,dy\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type3">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_2eq_order1_type3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3134-L3170"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type3" title="Permalink to this definition">#</a></dt>
<dd><p>Autonomous system of general form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = F(x,y)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' = G(x,y)\]</div>
</div>
<p>Assuming <span class="math notranslate nohighlight">\(y = y(x, C_1)\)</span> where <span class="math notranslate nohighlight">\(C_1\)</span> is an arbitrary constant is the general
solution of the first-order equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[F(x,y) y'_x = G(x,y)\]</div>
</div>
<p>Then the general solution of the original system of equations has the form</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\int \frac{1}{F(x,y(x,C_1))} \,dx = t + C_1\]</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type4">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_2eq_order1_type4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3172-L3217"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type4" title="Permalink to this definition">#</a></dt>
<dd><p>Equation:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = f_1(x) g_1(y) \phi(x,y,t)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y' = f_2(x) g_2(y) \phi(x,y,t)\]</div>
</div>
<p>First integral:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\int \frac{f_2(x)}{f_1(x)} \,dx - \int \frac{g_1(y)}{g_2(y)} \,dy = C\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is an arbitrary constant.</p>
<p>On solving the first integral for <span class="math notranslate nohighlight">\(x\)</span> (resp., <span class="math notranslate nohighlight">\(y\)</span> ) and on substituting the
resulting expression into either equation of the original solution, one
arrives at a first-order equation for determining <span class="math notranslate nohighlight">\(y\)</span> (resp., <span class="math notranslate nohighlight">\(x\)</span> ).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_2eq_order1_type5">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_2eq_order1_type5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3219-L3266"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type5" title="Permalink to this definition">#</a></dt>
<dd><p>Clairaut system of ODEs</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x = t x' + F(x',y')\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[y = t y' + G(x',y')\]</div>
</div>
<p>The following are solutions of the system</p>
<p><span class="math notranslate nohighlight">\((i)\)</span> straight lines:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x = C_1 t + F(C_1, C_2), y = C_2 t + G(C_1, C_2)\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants;</p>
<p><span class="math notranslate nohighlight">\((ii)\)</span> envelopes of the above lines;</p>
<p><span class="math notranslate nohighlight">\((iii)\)</span> continuously differentiable lines made up from segments of the lines
<span class="math notranslate nohighlight">\((i)\)</span> and <span class="math notranslate nohighlight">\((ii)\)</span>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type1">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_3eq_order1_type1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3286-L3333"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type1" title="Permalink to this definition">#</a></dt>
<dd><p>Equations:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a x' = (b - c) y z, \enspace b y' = (c - a) z x, \enspace c z' = (a - b) x y\]</div>
</div>
<p>First Integrals:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2} = C_2\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants. On solving the integrals for <span class="math notranslate nohighlight">\(y\)</span> and
<span class="math notranslate nohighlight">\(z\)</span> and on substituting the resulting expressions into the first equation of the
system, we arrives at a separable first-order equation on <span class="math notranslate nohighlight">\(x\)</span>. Similarly doing that
for other two equations, we will arrive at first order equation on <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> too.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf">https://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type2">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_3eq_order1_type2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3336-L3389"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type2" title="Permalink to this definition">#</a></dt>
<dd><p>Equations:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a x' = (b - c) y z f(x, y, z, t)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[b y' = (c - a) z x f(x, y, z, t)\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[c z' = (a - b) x y f(x, y, z, t)\]</div>
</div>
<p>First Integrals:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
</div>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2} = C_2\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are arbitrary constants. On solving the integrals for <span class="math notranslate nohighlight">\(y\)</span> and
<span class="math notranslate nohighlight">\(z\)</span> and on substituting the resulting expressions into the first equation of the
system, we arrives at a first-order differential equations on <span class="math notranslate nohighlight">\(x\)</span>. Similarly doing
that for other two equations we will arrive at first order equation on <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf">https://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type3">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_3eq_order1_type3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3391-L3449"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type3" title="Permalink to this definition">#</a></dt>
<dd><p>Equations:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = c F_2 - b F_3, \enspace y' = a F_3 - c F_1, \enspace z' = b F_1 - a F_2\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(F_n = F_n(x, y, z, t)\)</span>.</p>
<ol class="arabic simple">
<li><p>First Integral:</p></li>
</ol>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a x + b y + c z = C_1,\]</div>
</div>
<p>where C is an arbitrary constant.</p>
<p>2. If we assume function <span class="math notranslate nohighlight">\(F_n\)</span> to be independent of <span class="math notranslate nohighlight">\(t\)</span>,i.e, <span class="math notranslate nohighlight">\(F_n\)</span> = <span class="math notranslate nohighlight">\(F_n (x, y, z)\)</span>
Then, on eliminating <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(z\)</span> from the first two equation of the system, one
arrives at the first-order equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{dy}{dx} = \frac{a F_3 (x, y, z) - c F_1 (x, y, z)}{c F_2 (x, y, z) -
b F_3 (x, y, z)}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(z = \frac{1}{c} (C_1 - a x - b y)\)</span></p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf">https://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type4">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_3eq_order1_type4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3451-L3508"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type4" title="Permalink to this definition">#</a></dt>
<dd><p>Equations:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = c z F_2 - b y F_3, \enspace y' = a x F_3 - c z F_1, \enspace z' = b y F_1 - a x F_2\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(F_n = F_n (x, y, z, t)\)</span></p>
<ol class="arabic simple">
<li><p>First integral:</p></li>
</ol>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is an arbitrary constant.</p>
<p>2. Assuming the function <span class="math notranslate nohighlight">\(F_n\)</span> is independent of <span class="math notranslate nohighlight">\(t\)</span>: <span class="math notranslate nohighlight">\(F_n = F_n (x, y, z)\)</span>. Then on
eliminating <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(z\)</span> from the first two equations of the system, one arrives at
the first-order equation</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\frac{dy}{dx} = \frac{a x F_3 (x, y, z) - c z F_1 (x, y, z)}
{c z F_2 (x, y, z) - b y F_3 (x, y, z)}\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(z = \pm \sqrt{\frac{1}{c} (C_1 - a x^{2} - b y^{2})}\)</span></p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf">https://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._nonlinear_3eq_order1_type5">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_nonlinear_3eq_order1_type5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eq</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L3510-L3559"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type5" title="Permalink to this definition">#</a></dt>
<dd><div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[x' = x (c F_2 - b F_3), \enspace y' = y (a F_3 - c F_1), \enspace z' = z (b F_1 - a F_2)\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(F_n = F_n (x, y, z, t)\)</span> and are arbitrary functions.</p>
<p>First Integral:</p>
<div class="math-wrapper docutils container">
<div class="math notranslate nohighlight">
\[\left|x\right|^{a} \left|y\right|^{b} \left|z\right|^{c} = C_1\]</div>
</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> is an arbitrary constant. If the function <span class="math notranslate nohighlight">\(F_n\)</span> is independent of <span class="math notranslate nohighlight">\(t\)</span>,
then, by eliminating <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(z\)</span> from the first two equations of the system, one
arrives at a first-order equation.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf">https://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf</a></p>
</dd></dl>

</section>
<section id="module-sympy.solvers.ode.ode">
<span id="information-on-the-ode-module"></span><h2>Information on the ode module<a class="headerlink" href="#module-sympy.solvers.ode.ode" title="Permalink to this heading">#</a></h2>
<p>This module contains <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> and different helper
functions that it uses.</p>
<p><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> solves ordinary differential equations.
See the docstring on the various functions for their uses.  Note that partial
differential equations support is in <code class="docutils literal notranslate"><span class="pre">pde.py</span></code>.  Note that hint functions
have docstrings describing their various methods, but they are intended for
internal use.  Use <code class="docutils literal notranslate"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">hint=hint)</span></code> to solve an ODE using a
specific hint.  See also the docstring on
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p>
<p><strong>Functions in this module</strong></p>
<blockquote>
<div><p>These are the user functions in this module:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> - Solves ODEs.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> - Classifies ODEs into
possible hints for <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkodesol()</span></code></a> - Checks if an equation is the
solution to an ODE.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal notranslate"><span class="pre">homogeneous_order()</span></code></a> - Returns the
homogeneous order of an expression.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">infinitesimals()</span></code></a> - Returns the infinitesimals
of the Lie group of point transformations of an ODE, such that it is
invariant.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.checkinfsol" title="sympy.solvers.ode.checkinfsol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkinfsol()</span></code></a> - Checks if the given infinitesimals
are the actual infinitesimals of a first order ODE.</p></li>
</ul>
<p>These are the non-solver helper functions that are for internal use.  The
user should use the various options to
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> to obtain the functionality provided
by these functions:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> - Does all forms of ODE
simplification.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.ode.ode_sol_simplicity" title="sympy.solvers.ode.ode.ode_sol_simplicity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ode_sol_simplicity()</span></code></a> - A key function for
comparing solutions by simplicity.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code></a> - Simplifies arbitrary
constants.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.ode.constant_renumber" title="sympy.solvers.ode.ode.constant_renumber"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constant_renumber()</span></code></a> - Renumber arbitrary
constants.</p></li>
<li><p><a class="reference internal" href="#sympy.solvers.ode.ode._handle_Integral" title="sympy.solvers.ode.ode._handle_Integral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_handle_Integral()</span></code></a> - Evaluate unevaluated
Integrals.</p></li>
</ul>
<p>See also the docstrings of these functions.</p>
</div></blockquote>
<p><strong>Currently implemented solver methods</strong></p>
<p>The following methods are implemented for solving ordinary differential
equations.  See the docstrings of the various hint functions for more
information on each (run <code class="docutils literal notranslate"><span class="pre">help(ode)</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li><p>1st order separable differential equations.</p></li>
<li><p>1st order differential equations whose coefficients or <span class="math notranslate nohighlight">\(dx\)</span> and <span class="math notranslate nohighlight">\(dy\)</span> are
functions homogeneous of the same order.</p></li>
<li><p>1st order exact differential equations.</p></li>
<li><p>1st order linear differential equations.</p></li>
<li><p>1st order Bernoulli differential equations.</p></li>
<li><p>Power series solutions for first order differential equations.</p></li>
<li><p>Lie Group method of solving first order differential equations.</p></li>
<li><p>2nd order Liouville differential equations.</p></li>
<li><p>Power series solutions for second order differential equations
at ordinary and regular singular points.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>th order differential equation that can be solved with algebraic
rearrangement and integration.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>th order linear homogeneous differential equation with constant
coefficients.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>th order linear inhomogeneous differential equation with constant
coefficients using the method of undetermined coefficients.</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span>th order linear inhomogeneous differential equation with constant
coefficients using the method of variation of parameters.</p></li>
</ul>
</div></blockquote>
<p><strong>Philosophy behind this module</strong></p>
<p>This module is designed to make it easy to add new ODE solving methods without
having to mess with the solving code for other methods.  The idea is that
there is a <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> function, which takes in
an ODE and tells you what hints, if any, will solve the ODE.  It does this
without attempting to solve the ODE, so it is fast.  Each solving method is a
hint, and it has its own function, named <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;</span></code>.  That function takes
in the ODE and any match expression gathered by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> and returns a solved result.  If
this result has any integrals in it, the hint function will return an
unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-class docutils literal notranslate"><span class="pre">Integral</span></code></a> class.
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, which is the user wrapper function
around all of this, will then call <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> on
the result, which, among other things, will attempt to solve the equation for
the dependent variable (the function we are solving for), simplify the
arbitrary constants in the expression, and evaluate any integrals, if the hint
allows it.</p>
<p><strong>How to add new solution methods</strong></p>
<p>If you have an ODE that you want <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> to be
able to solve, try to avoid adding special case code here.  Instead, try
finding a general method that will solve your ODE, as well as others.  This
way, the <a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ode</span></code></a> module will become more robust, and
unhindered by special case hacks.  WolphramAlpha and Maple’s
DETools[odeadvisor] function are two resources you can use to classify a
specific ODE.  It is also better for a method to work with an <span class="math notranslate nohighlight">\(n\)</span>th order ODE
instead of only with specific orders, if possible.</p>
<p>To add a new method, there are a few things that you need to do.  First, you
need a hint name for your method.  Try to name your hint so that it is
unambiguous with all other methods, including ones that may not be implemented
yet.  If your method uses integrals, also include a <code class="docutils literal notranslate"><span class="pre">hint_Integral</span></code> hint.
If there is more than one way to solve ODEs with your method, include a hint
for each one, as well as a <code class="docutils literal notranslate"><span class="pre">&lt;hint&gt;_best</span></code> hint.  Your <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;_best()</span></code>
function should choose the best using min with <code class="docutils literal notranslate"><span class="pre">ode_sol_simplicity</span></code> as the
key argument.  See
<a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffBest" title="sympy.solvers.ode.single.HomogeneousCoeffBest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HomogeneousCoeffBest</span></code></a>, for example.
The function that uses your method will be called <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;()</span></code>, so the
hint must only use characters that are allowed in a Python function name
(alphanumeric characters and the underscore ‘<code class="docutils literal notranslate"><span class="pre">_</span></code>’ character).  Include a
function for every hint, except for <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> hints
(<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> takes care of those automatically).
Hint names should be all lowercase, unless a word is commonly capitalized
(such as Integral or Bernoulli).  If you have a hint that you do not want to
run with <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code> that does not have an <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> counterpart (such
as a best hint that would defeat the purpose of <code class="docutils literal notranslate"><span class="pre">all_Integral</span></code>), you will
need to remove it manually in the <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> code.
See also the <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> docstring for
guidelines on writing a hint name.</p>
<p>Determine <em>in general</em> how the solutions returned by your method compare with
other methods that can potentially solve the same ODEs.  Then, put your hints
in the <a class="reference internal" href="#sympy.solvers.ode.allhints" title="sympy.solvers.ode.allhints"><code class="xref py py-data docutils literal notranslate"><span class="pre">allhints</span></code></a> tuple in the order that they
should be called.  The ordering of this tuple determines which hints are
default.  Note that exceptions are ok, because it is easy for the user to
choose individual hints with <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.  In
general, <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> variants should go at the end of the list, and
<code class="docutils literal notranslate"><span class="pre">_best</span></code> variants should go before the various hints they apply to.  For
example, the <code class="docutils literal notranslate"><span class="pre">undetermined_coefficients</span></code> hint comes before the
<code class="docutils literal notranslate"><span class="pre">variation_of_parameters</span></code> hint because, even though variation of parameters
is more general than undetermined coefficients, undetermined coefficients
generally returns cleaner results for the ODEs that it can solve than
variation of parameters does, and it does not require integration, so it is
much faster.</p>
<p>Next, you need to have a match expression or a function that matches the type
of the ODE, which you should put in <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>
(if the match function is more than just a few lines.  It should match the
ODE without solving for it as much as possible, so that
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> remains fast and is not hindered by
bugs in solving code.  Be sure to consider corner cases.  For example, if your
solution method involves dividing by something, make sure you exclude the case
where that division will be 0.</p>
<p>In most cases, the matching of the ODE will also give you the various parts
that you need to solve it.  You should put that in a dictionary (<code class="docutils literal notranslate"><span class="pre">.match()</span></code>
will do this for you), and add that as <code class="docutils literal notranslate"><span class="pre">matching_hints['hint']</span> <span class="pre">=</span> <span class="pre">matchdict</span></code>
in the relevant part of <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a>.
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> will then send this to
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, which will send it to your function as
the <code class="docutils literal notranslate"><span class="pre">match</span></code> argument.  Your function should be named <code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;(eq,</span> <span class="pre">func,</span>
<span class="pre">order,</span> <span class="pre">match)`.</span>&#160; <span class="pre">If</span> <span class="pre">you</span> <span class="pre">need</span> <span class="pre">to</span> <span class="pre">send</span> <span class="pre">more</span> <span class="pre">information,</span> <span class="pre">put</span> <span class="pre">it</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``match</span></code>
dictionary.  For example, if you had to substitute in a dummy variable in
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal notranslate"><span class="pre">classify_ode()</span></code></a> to match the ODE, you will need to
pass it to your function using the <span class="math notranslate nohighlight">\(match\)</span> dict to access it.  You can access
the independent variable using <code class="docutils literal notranslate"><span class="pre">func.args[0]</span></code>, and the dependent variable
(the function you are trying to solve for) as <code class="docutils literal notranslate"><span class="pre">func.func</span></code>.  If, while trying
to solve the ODE, you find that you cannot, raise <code class="docutils literal notranslate"><span class="pre">NotImplementedError</span></code>.
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a> will catch this error with the <code class="docutils literal notranslate"><span class="pre">all</span></code>
meta-hint, rather than causing the whole routine to fail.</p>
<p>Add a docstring to your function that describes the method employed.  Like
with anything else in SymPy, you will need to add a doctest to the docstring,
in addition to real tests in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>.  Try to maintain consistency
with the other hint functions’ docstrings.  Add your method to the list at the
top of this docstring.  Also, add your method to <code class="docutils literal notranslate"><span class="pre">ode.rst</span></code> in the
<code class="docutils literal notranslate"><span class="pre">docs/src</span></code> directory, so that the Sphinx docs will pull its docstring into
the main SymPy documentation.  Be sure to make the Sphinx documentation by
running <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">html</span></code> from within the doc directory to verify that the
docstring formats correctly.</p>
<p>If your solution method involves integrating, use <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.integrals.Integral" title="sympy.integrals.integrals.Integral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Integral</span></code></a> instead of
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">integrate()</span></code></a>.  This allows the user to bypass
hard/slow integration by using the <code class="docutils literal notranslate"><span class="pre">_Integral</span></code> variant of your hint.  In
most cases, calling <a class="reference internal" href="../core.html#sympy.core.basic.Basic.doit" title="sympy.core.basic.Basic.doit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.core.basic.Basic.doit()</span></code></a> will integrate your
solution.  If this is not the case, you will need to write special code in
<a class="reference internal" href="#sympy.solvers.ode.ode._handle_Integral" title="sympy.solvers.ode.ode._handle_Integral"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_handle_Integral()</span></code></a>.  Arbitrary constants should be
symbols named <code class="docutils literal notranslate"><span class="pre">C1</span></code>, <code class="docutils literal notranslate"><span class="pre">C2</span></code>, and so on.  All solution methods should return
an equality instance.  If you need an arbitrary number of arbitrary constants,
you can use <code class="docutils literal notranslate"><span class="pre">constants</span> <span class="pre">=</span> <span class="pre">numbered_symbols(prefix='C',</span> <span class="pre">cls=Symbol,</span> <span class="pre">start=1)</span></code>.
If it is possible to solve for the dependent function in a general way, do so.
Otherwise, do as best as you can, but do not call solve in your
<code class="docutils literal notranslate"><span class="pre">ode_&lt;hint&gt;()</span></code> function.  <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> will attempt
to solve the solution for you, so you do not need to do that.  Lastly, if your
ODE has a common simplification that can be applied to your solutions, you can
add a special case in <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> for it.  For
example, solutions returned from the <code class="docutils literal notranslate"><span class="pre">1st_homogeneous_coeff</span></code> hints often
have many <a class="reference internal" href="../functions/elementary.html#sympy.functions.elementary.exponential.log" title="sympy.functions.elementary.exponential.log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">log</span></code></a> terms, so
<a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> calls
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.logcombine" title="sympy.simplify.simplify.logcombine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">logcombine()</span></code></a> on them (it also helps to write
the arbitrary constant as <code class="docutils literal notranslate"><span class="pre">log(C1)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">C1</span></code> in this case).  Also
consider common ways that you can rearrange your solution to have
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">constantsimp()</span></code></a> take better advantage of it.  It is
better to put simplification in <a class="reference internal" href="#sympy.solvers.ode.ode.odesimp" title="sympy.solvers.ode.ode.odesimp"><code class="xref py py-meth docutils literal notranslate"><span class="pre">odesimp()</span></code></a> than in
your method, because it can then be turned off with the simplify flag in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>.  If you have any extraneous
simplification in your function, be sure to only run it using <code class="docutils literal notranslate"><span class="pre">if</span>
<span class="pre">match.get('simplify',</span> <span class="pre">True):</span></code>, especially if it can be slow or if it can
reduce the domain of the solution.</p>
<p>Finally, as with every contribution to SymPy, your method will need to be
tested.  Add a test for each method in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>.  Follow the
conventions there, i.e., test the solver using <code class="docutils literal notranslate"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span>
<span class="pre">hint=your_hint)</span></code>, and also test the solution using
<a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">checkodesol()</span></code></a> (you can put these in a separate
tests and skip/XFAIL if it runs too slow/does not work).  Be sure to call your
hint specifically in <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dsolve()</span></code></a>, that way the test
will not be broken simply by the introduction of another matching hint.  If your
method works for higher order (&gt;1) ODEs, you will need to run <code class="docutils literal notranslate"><span class="pre">sol</span> <span class="pre">=</span>
<span class="pre">constant_renumber(sol,</span> <span class="pre">'C',</span> <span class="pre">1,</span> <span class="pre">order)</span></code> for each solution, where <code class="docutils literal notranslate"><span class="pre">order</span></code> is
the order of the ODE.  This is because <code class="docutils literal notranslate"><span class="pre">constant_renumber</span></code> renumbers the
arbitrary constants by printing order, which is platform dependent.  Try to
test every corner case of your solver, including a range of orders if it is a
<span class="math notranslate nohighlight">\(n\)</span>th order solver, but if your solver is slow, such as if it involves hard
integration, try to keep the test run time down.</p>
<p>Feel free to refactor existing hints to avoid duplicating code or creating
inconsistencies.  If you can show that your method exactly duplicates an
existing method, including in the simplicity and speed of obtaining the
solutions, then you can remove the old, less general method.  The existing
code is tested extensively in <code class="docutils literal notranslate"><span class="pre">test_ode.py</span></code>, so if anything is broken, one
of those tests will surely fail.</p>
<p>These functions are not intended for end-user use.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.solvers.ode.ode._handle_Integral">
<span class="sig-prename descclassname"><span class="pre">sympy.solvers.ode.ode.</span></span><span class="sig-name descname"><span class="pre">_handle_Integral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hint</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/4bb9b265885609c8974d4ea2cf71e4861a080d60/sympy/solvers/ode/ode.py#L2168-L2181"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.solvers.ode.ode._handle_Integral" title="Permalink to this definition">#</a></dt>
<dd><p>Converts a solution with Integrals in it into an actual solution.</p>
<p>For most hints, this simply runs <code class="docutils literal notranslate"><span class="pre">expr.doit()</span></code>.</p>
</dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="pde.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">PDE</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="inequalities.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Inequality Solvers</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023 SymPy Development Team
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            <div class="last-updated">
              Last updated on May 16, 2023</div>
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/sympy/sympy" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">ODE</a><ul>
<li><a class="reference internal" href="#user-functions">User Functions</a><ul>
<li><a class="reference internal" href="#sympy.solvers.ode.dsolve"><code class="docutils literal notranslate"><span class="pre">dsolve()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.systems.dsolve_system"><code class="docutils literal notranslate"><span class="pre">dsolve_system()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.classify_ode"><code class="docutils literal notranslate"><span class="pre">classify_ode()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.checkodesol"><code class="docutils literal notranslate"><span class="pre">checkodesol()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.homogeneous_order"><code class="docutils literal notranslate"><span class="pre">homogeneous_order()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.infinitesimals"><code class="docutils literal notranslate"><span class="pre">infinitesimals()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.checkinfsol"><code class="docutils literal notranslate"><span class="pre">checkinfsol()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.constantsimp"><code class="docutils literal notranslate"><span class="pre">constantsimp()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hint-functions">Hint Functions</a><ul>
<li><a class="reference internal" href="#sympy.solvers.ode.allhints"><code class="docutils literal notranslate"><span class="pre">allhints</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode.odesimp"><code class="docutils literal notranslate"><span class="pre">odesimp()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode.constant_renumber"><code class="docutils literal notranslate"><span class="pre">constant_renumber()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode.ode_sol_simplicity"><code class="docutils literal notranslate"><span class="pre">ode_sol_simplicity()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.Factorable"><code class="docutils literal notranslate"><span class="pre">Factorable</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.FirstExact"><code class="docutils literal notranslate"><span class="pre">FirstExact</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffBest"><code class="docutils literal notranslate"><span class="pre">HomogeneousCoeffBest</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsDepDivIndep"><code class="docutils literal notranslate"><span class="pre">HomogeneousCoeffSubsDepDivIndep</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.HomogeneousCoeffSubsIndepDivDep"><code class="docutils literal notranslate"><span class="pre">HomogeneousCoeffSubsIndepDivDep</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.FirstLinear"><code class="docutils literal notranslate"><span class="pre">FirstLinear</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.RationalRiccati"><code class="docutils literal notranslate"><span class="pre">RationalRiccati</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.SecondLinearAiry"><code class="docutils literal notranslate"><span class="pre">SecondLinearAiry</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.SecondLinearBessel"><code class="docutils literal notranslate"><span class="pre">SecondLinearBessel</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.Bernoulli"><code class="docutils literal notranslate"><span class="pre">Bernoulli</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.Liouville"><code class="docutils literal notranslate"><span class="pre">Liouville</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.RiccatiSpecial"><code class="docutils literal notranslate"><span class="pre">RiccatiSpecial</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.NthLinearConstantCoeffHomogeneous"><code class="docutils literal notranslate"><span class="pre">NthLinearConstantCoeffHomogeneous</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.NthLinearConstantCoeffUndeterminedCoefficients"><code class="docutils literal notranslate"><span class="pre">NthLinearConstantCoeffUndeterminedCoefficients</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.NthLinearConstantCoeffVariationOfParameters"><code class="docutils literal notranslate"><span class="pre">NthLinearConstantCoeffVariationOfParameters</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.NthLinearEulerEqHomogeneous"><code class="docutils literal notranslate"><span class="pre">NthLinearEulerEqHomogeneous</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.NthLinearEulerEqNonhomogeneousVariationOfParameters"><code class="docutils literal notranslate"><span class="pre">NthLinearEulerEqNonhomogeneousVariationOfParameters</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.NthLinearEulerEqNonhomogeneousUndeterminedCoefficients"><code class="docutils literal notranslate"><span class="pre">NthLinearEulerEqNonhomogeneousUndeterminedCoefficients</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.NthAlgebraic"><code class="docutils literal notranslate"><span class="pre">NthAlgebraic</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.NthOrderReducible"><code class="docutils literal notranslate"><span class="pre">NthOrderReducible</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.Separable"><code class="docutils literal notranslate"><span class="pre">Separable</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.AlmostLinear"><code class="docutils literal notranslate"><span class="pre">AlmostLinear</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.LinearCoefficients"><code class="docutils literal notranslate"><span class="pre">LinearCoefficients</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.SeparableReduced"><code class="docutils literal notranslate"><span class="pre">SeparableReduced</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.LieGroup"><code class="docutils literal notranslate"><span class="pre">LieGroup</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.single.SecondHypergeometric"><code class="docutils literal notranslate"><span class="pre">SecondHypergeometric</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode.ode_1st_power_series"><code class="docutils literal notranslate"><span class="pre">ode_1st_power_series()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode.ode_2nd_power_series_ordinary"><code class="docutils literal notranslate"><span class="pre">ode_2nd_power_series_ordinary()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode.ode_2nd_power_series_regular"><code class="docutils literal notranslate"><span class="pre">ode_2nd_power_series_regular()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#lie-heuristics">Lie heuristics</a><ul>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco1_simple"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_abaco1_simple()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco1_product"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_abaco1_product()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_bivariate"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_bivariate()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_chi"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_chi()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco2_similar"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_abaco2_similar()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_function_sum"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_function_sum()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_unknown"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_abaco2_unique_unknown()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_abaco2_unique_general"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_abaco2_unique_general()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.lie_group.lie_heuristic_linear"><code class="docutils literal notranslate"><span class="pre">lie_heuristic_linear()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#rational-riccati-solver">Rational Riccati Solver</a><ul>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.riccati_normal"><code class="docutils literal notranslate"><span class="pre">riccati_normal()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.riccati_inverse_normal"><code class="docutils literal notranslate"><span class="pre">riccati_inverse_normal()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.riccati_reduced"><code class="docutils literal notranslate"><span class="pre">riccati_reduced()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.construct_c"><code class="docutils literal notranslate"><span class="pre">construct_c()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.construct_d"><code class="docutils literal notranslate"><span class="pre">construct_d()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.rational_laurent_series"><code class="docutils literal notranslate"><span class="pre">rational_laurent_series()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.compute_m_ybar"><code class="docutils literal notranslate"><span class="pre">compute_m_ybar()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.solve_aux_eq"><code class="docutils literal notranslate"><span class="pre">solve_aux_eq()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.remove_redundant_sols"><code class="docutils literal notranslate"><span class="pre">remove_redundant_sols()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.get_gen_sol_from_part_sol"><code class="docutils literal notranslate"><span class="pre">get_gen_sol_from_part_sol()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.riccati.solve_riccati"><code class="docutils literal notranslate"><span class="pre">solve_riccati()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#system-of-odes">System of ODEs</a><ul>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._linear_2eq_order1_type6"><code class="docutils literal notranslate"><span class="pre">_linear_2eq_order1_type6()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._linear_2eq_order1_type7"><code class="docutils literal notranslate"><span class="pre">_linear_2eq_order1_type7()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.systems.linear_ode_to_matrix"><code class="docutils literal notranslate"><span class="pre">linear_ode_to_matrix()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.systems.canonical_odes"><code class="docutils literal notranslate"><span class="pre">canonical_odes()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve_type"><code class="docutils literal notranslate"><span class="pre">linodesolve_type()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.systems.matrix_exp_jordan_form"><code class="docutils literal notranslate"><span class="pre">matrix_exp_jordan_form()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.systems.matrix_exp"><code class="docutils literal notranslate"><span class="pre">matrix_exp()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.systems.linodesolve"><code class="docutils literal notranslate"><span class="pre">linodesolve()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type1"><code class="docutils literal notranslate"><span class="pre">_nonlinear_2eq_order1_type1()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type2"><code class="docutils literal notranslate"><span class="pre">_nonlinear_2eq_order1_type2()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type3"><code class="docutils literal notranslate"><span class="pre">_nonlinear_2eq_order1_type3()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type4"><code class="docutils literal notranslate"><span class="pre">_nonlinear_2eq_order1_type4()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_2eq_order1_type5"><code class="docutils literal notranslate"><span class="pre">_nonlinear_2eq_order1_type5()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type1"><code class="docutils literal notranslate"><span class="pre">_nonlinear_3eq_order1_type1()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type2"><code class="docutils literal notranslate"><span class="pre">_nonlinear_3eq_order1_type2()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type3"><code class="docutils literal notranslate"><span class="pre">_nonlinear_3eq_order1_type3()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type4"><code class="docutils literal notranslate"><span class="pre">_nonlinear_3eq_order1_type4()</span></code></a></li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._nonlinear_3eq_order1_type5"><code class="docutils literal notranslate"><span class="pre">_nonlinear_3eq_order1_type5()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-sympy.solvers.ode.ode">Information on the ode module</a><ul>
<li><a class="reference internal" href="#sympy.solvers.ode.ode._handle_Integral"><code class="docutils literal notranslate"><span class="pre">_handle_Integral()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../_static/jquery.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>