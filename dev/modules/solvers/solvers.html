
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solvers &#8212; SymPy 1.7.dev documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/solvers/solvers.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Solveset" href="solveset.html" />
    <link rel="prev" title="Hongguang Fu’s Trigonometric Simplification" href="../simplify/fu.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="solveset.html" title="Solveset"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../simplify/fu.html" title="Hongguang Fu’s Trigonometric Simplification"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">SymPy Modules Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solvers</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="solvers">
<span id="id1"></span><h1>Solvers<a class="headerlink" href="#solvers" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-sympy.solvers"></span><p>The <em>solvers</em> module in SymPy implements methods for solving equations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is recommended to use <a class="reference internal" href="solveset.html#module-sympy.solvers.solveset" title="sympy.solvers.solveset"><code class="xref py py-func docutils literal notranslate"><span class="pre">solveset()</span></code></a> to solve univariate equations,
<a class="reference internal" href="solveset.html#sympy.solvers.solveset.linsolve" title="sympy.solvers.solveset.linsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">linsolve()</span></code></a> to solve system of linear equations
instead of <a class="reference internal" href="#sympy.solvers.solvers.solve" title="sympy.solvers.solvers.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve()</span></code></a> and <a class="reference internal" href="solveset.html#sympy.solvers.solveset.nonlinsolve" title="sympy.solvers.solveset.nonlinsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonlinsolve()</span></code></a> to
solve system of non linear equations since sooner or later the <a class="reference internal" href="solveset.html#sympy.solvers.solveset.solveset" title="sympy.solvers.solveset.solveset"><code class="xref py py-func docutils literal notranslate"><span class="pre">solveset()</span></code></a>
will take over <a class="reference internal" href="#sympy.solvers.solvers.solve" title="sympy.solvers.solvers.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve()</span></code></a> either internally or externally.</p>
</div>
<div class="section" id="algebraic-equations">
<h2>Algebraic equations<a class="headerlink" href="#algebraic-equations" title="Permalink to this headline">¶</a></h2>
<p>Use <a class="reference internal" href="#sympy.solvers.solvers.solve" title="sympy.solvers.solvers.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve()</span></code></a> to solve algebraic equations. We suppose all equations are equaled to 0,
so solving x**2 == 1 translates into the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="kn">import</span> <span class="n">solve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[-1, 1]</span>
</pre></div>
</div>
<p>The first argument for <a class="reference internal" href="#sympy.solvers.solvers.solve" title="sympy.solvers.solvers.solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">solve()</span></code></a> is an equation (equaled to zero) and the second argument
is the symbol that we want to solve the equation for.</p>
<dl class="py function">
<dt id="sympy.solvers.solvers.solve">
<code class="sig-prename descclassname">sympy.solvers.solvers.</code><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">symbols</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">flags</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solvers.py#L381-L1280"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solvers.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Algebraically solves equations and systems of equations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>f :</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>a single Expr or Poly that must be zero</p></li>
<li><p>an Equality</p></li>
<li><p>a Relational expression</p></li>
<li><p>a Boolean</p></li>
<li><p>iterable of one or more of the above</p></li>
</ul>
</div></blockquote>
<p><strong>symbols</strong> : (object(s) to solve for) specified as</p>
<blockquote>
<div><ul class="simple">
<li><p>none given (other non-numeric objects will be used)</p></li>
<li><p>single symbol</p></li>
<li><p>denested list of symbols
(e.g., <code class="docutils literal notranslate"><span class="pre">solve(f,</span> <span class="pre">x,</span> <span class="pre">y)</span></code>)</p></li>
<li><p>ordered iterable of symbols
(e.g., <code class="docutils literal notranslate"><span class="pre">solve(f,</span> <span class="pre">[x,</span> <span class="pre">y])</span></code>)</p></li>
</ul>
</div></blockquote>
<p><strong>flags :</strong></p>
<blockquote>
<div><dl class="simple">
<dt>dict=True (default is False)</dt><dd><p>Return list (perhaps empty) of solution mappings.</p>
</dd>
<dt>set=True (default is False)</dt><dd><p>Return list of symbols and set of tuple(s) of solution(s).</p>
</dd>
<dt>exclude=[] (default)</dt><dd><p>Do not try to solve for any of the free symbols in exclude;
if expressions are given, the free symbols in them will
be extracted automatically.</p>
</dd>
<dt>check=True (default)</dt><dd><p>If False, do not do any testing of solutions. This can be
useful if you want to include solutions that make any
denominator zero.</p>
</dd>
<dt>numerical=True (default)</dt><dd><p>Do a fast numerical check if <em>f</em> has only one symbol.</p>
</dd>
<dt>minimal=True (default is False)</dt><dd><p>A very fast, minimal testing.</p>
</dd>
<dt>warn=True (default is False)</dt><dd><p>Show a warning if <code class="docutils literal notranslate"><span class="pre">checksol()</span></code> could not conclude.</p>
</dd>
<dt>simplify=True (default)</dt><dd><p>Simplify all but polynomials of order 3 or greater before
returning them and (if check is not False) use the
general simplify function on the solutions and the
expression obtained when they are substituted into the
function which should be zero.</p>
</dd>
<dt>force=True (default is False)</dt><dd><p>Make positive all symbols without assumptions regarding sign.</p>
</dd>
<dt>rational=True (default)</dt><dd><p>Recast Floats as Rational; if this option is not used, the
system containing Floats may fail to solve because of issues
with polys. If rational=None, Floats will be recast as
rationals but the answer will be recast as Floats. If the
flag is False then nothing will be done to the Floats.</p>
</dd>
<dt>manual=True (default is False)</dt><dd><p>Do not use the polys/matrix method to solve a system of
equations, solve them one at a time as you might “manually.”</p>
</dd>
<dt>implicit=True (default is False)</dt><dd><p>Allows <code class="docutils literal notranslate"><span class="pre">solve</span></code> to return a solution for a pattern in terms of
other functions that contain that pattern; this is only
needed if the pattern is inside of some invertible function
like cos, exp, ect.</p>
</dd>
<dt>particular=True (default is False)</dt><dd><p>Instructs <code class="docutils literal notranslate"><span class="pre">solve</span></code> to try to find a particular solution to a linear
system with as many zeros as possible; this is very expensive.</p>
</dd>
<dt>quick=True (default is False)</dt><dd><p>When using particular=True, use a fast heuristic to find a
solution with many zeros (instead of using the very slow method
guaranteed to find the largest number of zeros possible).</p>
</dd>
<dt>cubics=True (default)</dt><dd><p>Return explicit solutions when cubic expressions are encountered.</p>
</dd>
<dt>quartics=True (default)</dt><dd><p>Return explicit solutions when quartic expressions are encountered.</p>
</dd>
<dt>quintics=True (default)</dt><dd><p>Return explicit solutions (if possible) when quintic expressions
are encountered.</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<dl class="simple">
<dt>Currently supported:</dt><dd><ul class="simple">
<li><p>polynomial</p></li>
<li><p>transcendental</p></li>
<li><p>piecewise combinations of the above</p></li>
<li><p>systems of linear and polynomial equations</p></li>
<li><p>systems containing relational expressions</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The output varies according to the input and can be seen by example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Boolean or univariate Relational:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(-oo &lt; x) &amp; (x &lt; 3)</span>
</pre></div>
</div>
<p>To always get a list of solution mappings, use flag dict=True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[{x: 3}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span>
<span class="go">[{x: 3, y: 1}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
<span class="go">1</span>
</pre></div>
</div>
<p>To get a list of <em>symbols</em> and set of solution(s) use flag set=True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([x, y], {(-sqrt(3), 1), (sqrt(3), 1)})</span>
</pre></div>
</div>
<p>Single expression and single symbol that is in the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[y]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([x], {(-y,), (y,)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([x], {(-1,), (1,), (-I,), (I,)})</span>
</pre></div>
</div>
<p>Single expression with no symbol that is in the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Single expression with no symbol given. In this case, all free <em>symbols</em>
will be selected as potential <em>symbols</em> to solve for. If the equation is
univariate then a list of solutions is returned; otherwise - as is the case
when <em>symbols</em> are given as an iterable of length greater than 1 - a list of
mappings will be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">[3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[{x: -y}, {x: y}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[{x: -y}, {x: y}, {z: 0}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[{x: y**2}, {z: 0}]</span>
</pre></div>
</div>
<p>When an object other than a Symbol is given as a symbol, it is
isolated algebraically and an implicit solution may be obtained.
This is mostly provided as a convenience to save you from replacing
the object with a Symbol and solving for that Symbol. It will only
work if the specified object can be replaced with a Symbol using the
subs method:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[x + f(x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[-x + Derivative(f(x), x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([exp(x)], {(-sqrt(-x),), (sqrt(-x),)})</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Indexed</span><span class="p">,</span> <span class="n">IndexedBase</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">IndexedBase</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">eqs</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Indexed</span><span class="p">))</span>
<span class="go">{A[1]: 1, A[2]: 2}</span>
</pre></div>
</div>
<blockquote>
<div><ul>
<li><p>To solve for a symbol implicitly, use implicit=True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[-LambertW(1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">implicit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[-exp(x)]</span>
</pre></div>
</div>
</li>
<li><p>It is possible to solve for anything that can be targeted with
subs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[-sqrt(3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">y</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">{y: -2 + sqrt(3), x + 2: -sqrt(3)}</span>
</pre></div>
</div>
</li>
<li><p>Nothing heroic is done in this implicit solving so you may end up
with a symbol still in the solution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">{y: -sqrt(3)/(x + 3), x + 2: -2*x/(x + 3) - 6/(x + 3) + sqrt(3)/(x + 3)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eqs</span><span class="p">,</span> <span class="n">y</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{x: -y - 4, x*y: -3*y - sqrt(3)}</span>
</pre></div>
</div>
</li>
<li><p>If you attempt to solve for a number remember that the number
you have obtained does not necessarily mean that the value is
equivalent to the expression obtained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[sqrt(2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># /!\ -1 is targeted, too</span>
<span class="go">[x/(y - 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="mi">1</span><span class="p">)]</span>
<span class="go">[-x + y]</span>
</pre></div>
</div>
</li>
<li><p>To solve for a function within a derivative, use <code class="docutils literal notranslate"><span class="pre">dsolve</span></code>.</p></li>
</ul>
</div></blockquote>
<p>Single expression and more than one symbol:</p>
<blockquote>
<div><ul>
<li><p>When there is a linear solution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[(y**2, y)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[(x, x**2)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[{y: x**2}]</span>
</pre></div>
</div>
</li>
<li><p>When undetermined coefficients are identified:</p>
<blockquote>
<div><ul>
<li><p>That are linear:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">{a: -2, b: 2}</span>
</pre></div>
</div>
</li>
<li><p>That are nonlinear:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([a, b], {(-sqrt(2), sqrt(2)), (sqrt(2), -sqrt(2))})</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</li>
<li><p>If there is no linear solution, then the first successful
attempt for a nonlinear solution will be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[{x: -y}, {x: y}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">[{x: 2*LambertW(-y/2)}, {x: 2*LambertW(y/2)}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[(-x*sqrt(exp(x)), x), (x*sqrt(exp(x)), x)]</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>Iterable of one or more of the above:</p>
<blockquote>
<div><ul>
<li><p>Involving relationals or bools:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">Eq(x, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
</li>
<li><p>When the system is linear:</p>
<blockquote>
<div><ul>
<li><p>With a solution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{x: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">15</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{x: -3, y: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">15</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{x: -3, y: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{x: 2 - 5*y, z: 21*y - 6}</span>
</pre></div>
</div>
</li>
<li><p>Without a solution:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">[]</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</li>
<li><p>When the system is not linear:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">([x, y], {(-2, -2), (0, 2), (2, -2)})</span>
</pre></div>
</div>
</li>
<li><p>If no <em>symbols</em> are given, all free <em>symbols</em> will be selected and a
list of mappings returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">])</span>
<span class="go">[{x: 2, y: -4}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">{</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">})</span>
<span class="go">[{x: 2, f(x): -4}]</span>
</pre></div>
</div>
</li>
<li><p>If any equation does not depend on the symbol(s) given, it will be
eliminated from the equation set and an answer may be given
implicitly in terms of variables that were not of interest:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">([</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="mi">3</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{x: y}</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p><strong>Additional Examples</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">solve()</span></code> with check=True (default) will run through the symbol tags to
elimate unwanted solutions. If no assumptions are included, all possible
solutions will be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">solve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[-1, 1]</span>
</pre></div>
</div>
<p>By using the positive tag, only one solution will be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;pos&quot;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">pos</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[1]</span>
</pre></div>
</div>
<p>Assumptions are not checked when <code class="docutils literal notranslate"><span class="pre">solve()</span></code> input involves
relationals or bools.</p>
<p>When the solutions are checked, those that make any denominator zero
are automatically excluded. If you do not want to exclude such solutions,
then use the check=False option:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">limit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># 0 is excluded</span>
<span class="go">[pi]</span>
</pre></div>
</div>
<p>If check=False, then a solution to the numerator being zero is found: x = 0.
In this case, this is a spurious solution since <span class="math notranslate nohighlight">\(\sin(x)/x\)</span> has the well
known limit (without dicontinuity) of 1 at x = 0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[0, pi]</span>
</pre></div>
</div>
<p>In the following case, however, the limit exists and is equal to the
value of x = 0 that is excluded when check=True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">limit</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p><strong>Disabling High-Order Explicit Solutions</strong></p>
<p>When solving polynomial expressions, you might not want explicit solutions
(which can be quite long). If the expression is univariate, <code class="docutils literal notranslate"><span class="pre">CRootOf</span></code>
instances will be returned instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">[-1/((-1/2 - sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)) - (-1/2 -</span>
<span class="go">sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3, -(-1/2 +</span>
<span class="go">sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)/3 - 1/((-1/2 +</span>
<span class="go">sqrt(3)*I/2)*(3*sqrt(69)/2 + 27/2)**(1/3)), -(3*sqrt(69)/2 +</span>
<span class="go">27/2)**(1/3)/3 - 1/(3*sqrt(69)/2 + 27/2)**(1/3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cubics</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[CRootOf(x**3 - x + 1, 0),</span>
<span class="go"> CRootOf(x**3 - x + 1, 1),</span>
<span class="go"> CRootOf(x**3 - x + 1, 2)]</span>
</pre></div>
</div>
<p>If the expression is multivariate, no solution might be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cubics</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Sometimes solutions will be obtained even when a flag is False because the
expression could be factored. In the following example, the equation can
be factored as the product of a linear and a quadratic factor so explicit
solutions (which did not require solving a cubic expression) are obtained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">cubics</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[-1, -1 + sqrt(2), -sqrt(2) - 1]</span>
</pre></div>
</div>
<p><strong>Solving Equations Involving Radicals</strong></p>
<p>Because of SymPy’s use of the principle root, some solutions
to radical equations will be missed unless check=False:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[1/3]</span>
</pre></div>
</div>
<p>In the above example, there is only a single solution to the
equation. Other expressions will yield spurious roots which
must be checked manually; roots which give a negative argument
to odd-powered radicals will also need special checking:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">real_root</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>  <span class="c1"># this gives 2 solutions but misses a 3rd</span>
<span class="go">[CRootOf(7*x**5 - 7*x**3 + 1, 1)**15,</span>
<span class="go">CRootOf(7*x**5 - 7*x**3 + 1, 2)**15]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">]</span>
<span class="go">[0.48, 0.e-110, 0.e-110, 0.052, 0.052]</span>
</pre></div>
</div>
<p>The first solution is negative so <code class="docutils literal notranslate"><span class="pre">real_root</span></code> must be used to see that it
satisfies the expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">real_root</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">0.e-110</span>
</pre></div>
</div>
<p>If the roots of the equation are not real then more care will be
necessary to find the roots, especially for higher order equations.
Consider the following expression:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>We will construct a known value for this expression at x = 3 by selecting
the 1-th root for each radical:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expr1</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">expr1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">solve</span></code> function is unable to find any exact roots to this equation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span> <span class="n">eq1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">solve</span><span class="p">(</span><span class="n">eq1</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">([], [])</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">unrad</span></code>, however, can be used to get a form of the equation
for which numerical roots can be found:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solvers</span> <span class="kn">import</span> <span class="n">unrad</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">nroots</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pvals</span> <span class="o">=</span> <span class="n">nroots</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inversion</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">inversion</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pvals</span><span class="p">]</span>
</pre></div>
</div>
<p>Although <code class="docutils literal notranslate"><span class="pre">eq</span></code> or <code class="docutils literal notranslate"><span class="pre">eq1</span></code> could have been used to find <code class="docutils literal notranslate"><span class="pre">xvals</span></code>, the
solution can only be verified with <code class="docutils literal notranslate"><span class="pre">expr1</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">-</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">xi</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xvals</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">]</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="o">=</span> <span class="n">expr1</span> <span class="o">-</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">xi</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="n">chop</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xvals</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">z1</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-9</span><span class="p">]</span>
<span class="go">[-3.0]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sympy.solvers.recurr.rsolve" title="sympy.solvers.recurr.rsolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve</span></code></a></dt><dd><p>For solving recurrence relationships</p>
</dd>
<dt><a class="reference internal" href="ode.html#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dsolve</span></code></a></dt><dd><p>For solving differential equations</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solvers.solve_linear">
<code class="sig-prename descclassname">sympy.solvers.solvers.</code><code class="sig-name descname">solve_linear</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">lhs</span></em>, <em class="sig-param"><span class="n">rhs</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">exclude</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solvers.py#L1985-L2166"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solvers.solve_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple derived from <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">lhs</span> <span class="pre">-</span> <span class="pre">rhs</span></code> that is one of
the following: <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(symbol,</span> <span class="pre">solution)</span></code>, <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code>.</p>
<p class="rubric">Explanation</p>
<p><code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1)</span></code> meaning that <code class="docutils literal notranslate"><span class="pre">f</span></code> is independent of the symbols in <em>symbols</em>
that are not in <em>exclude</em>.</p>
<p><code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> meaning that there is no solution to the equation amongst the
symbols given. If the first element of the tuple is not zero, then the
function is guaranteed to be dependent on a symbol in <em>symbols</em>.</p>
<p><code class="docutils literal notranslate"><span class="pre">(symbol,</span> <span class="pre">solution)</span></code> where symbol appears linearly in the numerator of
<code class="docutils literal notranslate"><span class="pre">f</span></code>, is in <em>symbols</em> (if given), and is not in <em>exclude</em> (if given). No
simplification is done to <code class="docutils literal notranslate"><span class="pre">f</span></code> other than a <code class="docutils literal notranslate"><span class="pre">mul=True</span></code> expansion, so the
solution will correspond strictly to a unique solution.</p>
<p><code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">d)</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">d</span></code> are the numerator and denominator of <code class="docutils literal notranslate"><span class="pre">f</span></code>
when the numerator was not linear in any symbol of interest; <code class="docutils literal notranslate"><span class="pre">n</span></code> will
never be a symbol unless a solution for that symbol was found (in which case
the second element is the solution, not the denominator).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.core.power</span> <span class="kn">import</span> <span class="n">Pow</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.polys.polytools</span> <span class="kn">import</span> <span class="n">cancel</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> is independent of the symbols in <em>symbols</em> that are not in
<em>exclude</em>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solvers</span> <span class="kn">import</span> <span class="n">solve_linear</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">y</span>  <span class="c1"># = y*(1 - 1) = 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># = 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="go">(0, 1)</span>
</pre></div>
</div>
<p>The variable <code class="docutils literal notranslate"><span class="pre">x</span></code> appears as a linear variable in each of the
following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(x, -y**2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(x, y**(-2))</span>
</pre></div>
</div>
<p>When not linear in <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> then the numerator and denominator are
returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">(x**2 - 3*y**2, y**2)</span>
</pre></div>
</div>
<p>If the numerator of the expression is a symbol, then <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> is
returned if the solution for that symbol would have set any
denominator to 0:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
<span class="go">(x, 1 - 2*x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
<p>But automatic rewriting may cause a symbol in the denominator to
appear in the numerator so a solution will be returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">**-</span><span class="mi">1</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(x, 0)</span>
</pre></div>
</div>
<p>Use an unevaluated expression to avoid this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">x</span></code> is allowed to cancel in the following expression, then it
appears to be linear in <code class="docutils literal notranslate"><span class="pre">x</span></code>, but this sort of cancellation is not
done by <code class="docutils literal notranslate"><span class="pre">solve_linear</span></code> so the solution will always satisfy the
original expression without causing a division by zero error.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">cancel</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
<span class="go">(x, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(x**2*(1 - z**2), x)</span>
</pre></div>
</div>
<p>A list of symbols for which a solution is desired may be given:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>
<span class="go">(y, -x - z)</span>
</pre></div>
</div>
<p>A list of symbols to ignore may also be given:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
<span class="go">(y, -x - z)</span>
</pre></div>
</div>
<p>(A solution for <code class="docutils literal notranslate"><span class="pre">y</span></code> is obtained because it is the first variable
from the canonically sorted list of symbols that had a linear
solution.)</p>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solvers.solve_linear_system">
<code class="sig-prename descclassname">sympy.solvers.solvers.</code><code class="sig-name descname">solve_linear_system</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">system</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">symbols</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">flags</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solvers.py#L2253-L2308"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solvers.solve_linear_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve system of <span class="math notranslate nohighlight">\(N\)</span> linear equations with <span class="math notranslate nohighlight">\(M\)</span> variables, which means
both under- and overdetermined systems are supported.</p>
<p class="rubric">Explanation</p>
<p>The possible number of solutions is zero, one, or infinite. Respectively,
this procedure will return None or a dictionary with solutions. In the
case of underdetermined systems, all arbitrary parameters are skipped.
This may cause a situation in which an empty dictionary is returned.
In that case, all symbols can be assigned arbitrary values.</p>
<p>Input to this function is a <span class="math notranslate nohighlight">\(N\times M + 1\)</span> matrix, which means it has
to be in augmented form. If you prefer to enter <span class="math notranslate nohighlight">\(N\)</span> equations and <span class="math notranslate nohighlight">\(M\)</span>
unknowns then use <code class="docutils literal notranslate"><span class="pre">solve(Neqs,</span> <span class="pre">*Msymbols)</span></code> instead. Note: a local
copy of the matrix is made by this routine so the matrix that is
passed will not be modified.</p>
<p>The algorithm used here is fraction-free Gaussian elimination,
which results, after elimination, in an upper-triangular matrix.
Then solutions are found using back-substitution. This approach
is more efficient and compact than the Gauss-Jordan method.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">solve_linear_system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<p>Solve the following system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">x</span> <span class="o">+</span> <span class="mi">4</span> <span class="n">y</span> <span class="o">==</span>  <span class="mi">2</span>
<span class="o">-</span><span class="mi">2</span> <span class="n">x</span> <span class="o">+</span>   <span class="n">y</span> <span class="o">==</span> <span class="mi">14</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">((</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{x: -6, y: 2}</span>
</pre></div>
</div>
<p>A degenerate system returns an empty dictionary:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">((</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solvers.solve_linear_system_LU">
<code class="sig-prename descclassname">sympy.solvers.solvers.</code><code class="sig-name descname">solve_linear_system_LU</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">matrix</span></em>, <em class="sig-param"><span class="n">syms</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solvers.py#L2358-L2395"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solvers.solve_linear_system_LU" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the augmented matrix system using <code class="docutils literal notranslate"><span class="pre">LUsolve</span></code> and returns a
dictionary in which solutions are keyed to the symbols of <em>syms</em> as ordered.</p>
<p class="rubric">Explanation</p>
<p>The matrix must be invertible.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solvers</span> <span class="kn">import</span> <span class="n">solve_linear_system_LU</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_linear_system_LU</span><span class="p">(</span><span class="n">Matrix</span><span class="p">([</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{x: 1/2, y: 1/4, z: -1/2}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="../matrices/matrices.html#sympy.matrices.matrices.MatrixBase.LUsolve" title="sympy.matrices.matrices.MatrixBase.LUsolve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LUsolve</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solvers.solve_undetermined_coeffs">
<code class="sig-prename descclassname">sympy.solvers.solvers.</code><code class="sig-name descname">solve_undetermined_coeffs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">equ</span></em>, <em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">sym</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">flags</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solvers.py#L2311-L2355"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solvers.solve_undetermined_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve equation of a type <span class="math notranslate nohighlight">\(p(x; a_1, \ldots, a_k) = q(x)\)</span> where both
<span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> are univariate polynomials that depend on <span class="math notranslate nohighlight">\(k\)</span> parameters.</p>
<p class="rubric">Explanation</p>
<p>The result of this function is a dictionary with symbolic values of those
parameters with respect to coefficients in <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p>This function accepts both equations class instances and ordinary
SymPy expressions. Specification of parameters and variables is
obligatory for efficiency and simplicity reasons.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="kn">import</span> <span class="n">solve_undetermined_coeffs</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_undetermined_coeffs</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{a: 1/2, b: -1/2}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_undetermined_coeffs</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{a: 1/c, b: -1/c}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solvers.nsolve">
<code class="sig-prename descclassname">sympy.solvers.solvers.</code><code class="sig-name descname">nsolve</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">dict</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solvers.py#L2758-L2958"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solvers.nsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a nonlinear equation system numerically: <code class="docutils literal notranslate"><span class="pre">nsolve(f,</span> <span class="pre">[args,]</span> <span class="pre">x0,</span>
<span class="pre">modules=['mpmath'],</span> <span class="pre">**kwargs)</span></code>.</p>
<p class="rubric">Explanation</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> is a vector function of symbolic expressions representing the system.
<em>args</em> are the variables. If there is only one variable, this argument can
be omitted. <code class="docutils literal notranslate"><span class="pre">x0</span></code> is a starting vector close to a solution.</p>
<p>Use the modules keyword to specify which modules should be used to
evaluate the function and the Jacobian matrix. Make sure to use a module
that supports matrices. For more information on the syntax, please see the
docstring of <code class="docutils literal notranslate"><span class="pre">lambdify</span></code>.</p>
<p>If the keyword arguments contain <code class="docutils literal notranslate"><span class="pre">dict=True</span></code> (default is False) <code class="docutils literal notranslate"><span class="pre">nsolve</span></code>
will return a list (perhaps empty) of solution mappings. This might be
especially useful if you want to use <code class="docutils literal notranslate"><span class="pre">nsolve</span></code> as a fallback to solve since
using the dict argument for both methods produces return values of
consistent type structure. Please note: to keep this consistent with
<code class="docutils literal notranslate"><span class="pre">solve</span></code>, the solution will be returned in a list even though <code class="docutils literal notranslate"><span class="pre">nsolve</span></code>
(currently at least) only finds one solution at a time.</p>
<p>Overdetermined systems are supported.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">nsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mpmath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x2</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="n">x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x2</span> <span class="o">-</span> <span class="mi">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nsolve</span><span class="p">((</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
<span class="go">Matrix([[-1.19287309935246], [1.27844411169911]])</span>
</pre></div>
</div>
<p>For one-dimensional functions the syntax is simplified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">nsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">3.14159265358979</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">3.14159265358979</span>
</pre></div>
</div>
<p>To solve with higher precision than the default, use the prec argument:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0.739085133215161</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prec</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="go">0.73908513321516064165531208767387340401341175890076</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cos</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">0.73908513321516064165531208767387340401341175890076</span>
</pre></div>
</div>
<p>To solve for complex roots of real functions, a nonreal initial point
must be specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span>
<span class="go">1.4142135623731*I</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mpmath.findroot</span></code> is used and you can find their more extensive
documentation, especially concerning keyword parameters and
available solvers. Note, however, that functions which are very
steep near the root, the verification of the solution may fail. In
this case you should use the flag <code class="docutils literal notranslate"><span class="pre">verify=False</span></code> and
independently verify the solution.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">cosh</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.14</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Could not find root within given tolerance. (1.39267e+230 &gt; 2.1684e-19)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ans</span> <span class="o">=</span> <span class="n">nsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mf">3.14</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span> <span class="n">ans</span>
<span class="go">312.588469032184</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">2.1e+121</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">f</span><span class="o">/</span><span class="n">f</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">7.4e-15</span>
</pre></div>
</div>
<p>One might safely skip the verification if bounds of the root are known
and a bisection method is used:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bounds</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="mf">3.14</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="mf">3.14</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">bounds</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;bisect&#39;</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">315.730061685774</span>
</pre></div>
</div>
<p>Alternatively, a function may be better behaved when the
denominator is ignored. Since this is not always the case, however,
the decision of what function to use is left to the discretion of
the user.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="mf">0.46</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">Could not find root within given tolerance. (10000 &gt; 2.1684e-19)</span>
<span class="go">Try another starting point or tweak arguments.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nsolve</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.46</span><span class="p">)</span>
<span class="go">0.46792545969349058</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solvers.checksol">
<code class="sig-prename descclassname">sympy.solvers.solvers.</code><code class="sig-name descname">checksol</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">symbol</span></em>, <em class="sig-param"><span class="n">sol</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">flags</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solvers.py#L189-L376"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solvers.checksol" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether sol is a solution of equation f == 0.</p>
<p class="rubric">Explanation</p>
<p>Input can be either a single symbol and corresponding value
or a dictionary of symbols and values. When given as a dictionary
and flag <code class="docutils literal notranslate"><span class="pre">simplify=True</span></code>, the values in the dictionary will be
simplified. <em>f</em> can be a single equation or an iterable of equations.
A solution must satisfy all equations in <em>f</em> to be considered valid;
if a solution does not satisfy any equation, False is returned; if one or
more checks are inconclusive (and none are False) then None is returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="kn">import</span> <span class="n">checksol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checksol</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checksol</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checksol</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">5</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To check if an expression is zero using <code class="docutils literal notranslate"><span class="pre">checksol()</span></code>, pass it
as <em>f</em> and send an empty dictionary for <em>symbol</em>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">checksol</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="p">{})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>None is returned if <code class="docutils literal notranslate"><span class="pre">checksol()</span></code> could not conclude.</p>
<dl class="simple">
<dt>flags:</dt><dd><dl class="simple">
<dt>‘numerical=True (default)’</dt><dd><p>do a fast numerical check if <code class="docutils literal notranslate"><span class="pre">f</span></code> has only one symbol.</p>
</dd>
<dt>‘minimal=True (default is False)’</dt><dd><p>a very fast, minimal testing.</p>
</dd>
<dt>‘warn=True (default is False)’</dt><dd><p>show a warning if checksol() could not conclude.</p>
</dd>
<dt>‘simplify=True (default)’</dt><dd><p>simplify solution before substituting into function and
simplify the function before trying specific simplifications</p>
</dd>
<dt>‘force=True (default is False)’</dt><dd><p>make positive all symbols without assumptions regarding sign.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.solvers.unrad">
<code class="sig-prename descclassname">sympy.solvers.solvers.</code><code class="sig-name descname">unrad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">eq</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">syms</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">flags</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/solvers.py#L3151-L3536"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solvers.unrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove radicals with symbolic arguments and return (eq, cov),
None, or raise an error.</p>
<p class="rubric">Explanation</p>
<p>None is returned if there are no radicals to remove.</p>
<p>NotImplementedError is raised if there are radicals and they cannot be
removed or if the relationship between the original symbols and the
change of variable needed to rewrite the system as a polynomial cannot
be solved.</p>
<p>Otherwise the tuple, <code class="docutils literal notranslate"><span class="pre">(eq,</span> <span class="pre">cov)</span></code>, is returned where:</p>
<dl class="simple">
<dt><em>eq</em>, <code class="docutils literal notranslate"><span class="pre">cov</span></code></dt><dd><p><em>eq</em> is an equation without radicals (in the symbol(s) of
interest) whose solutions are a superset of the solutions to the
original expression. <em>eq</em> might be rewritten in terms of a new
variable; the relationship to the original variables is given by
<code class="docutils literal notranslate"><span class="pre">cov</span></code> which is a list containing <code class="docutils literal notranslate"><span class="pre">v</span></code> and <code class="docutils literal notranslate"><span class="pre">v**p</span> <span class="pre">-</span> <span class="pre">b</span></code> where
<code class="docutils literal notranslate"><span class="pre">p</span></code> is the power needed to clear the radical and <code class="docutils literal notranslate"><span class="pre">b</span></code> is the
radical now expressed as a polynomial in the symbols of interest.
For example, for sqrt(2 - x) the tuple would be
<code class="docutils literal notranslate"><span class="pre">(c,</span> <span class="pre">c**2</span> <span class="pre">-</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">x)</span></code>. The solutions of <em>eq</em> will contain
solutions to the original equation (if there are any).</p>
</dd>
<dt><em>syms</em></dt><dd><p>An iterable of symbols which, if provided, will limit the focus of
radical removal: only radicals with one or more of the symbols of
interest will be cleared. All free symbols are used if <em>syms</em> is not
set.</p>
</dd>
</dl>
<p><em>flags</em> are used internally for communication during recursive calls.
Two options are also recognized:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">take</span></code>, when defined, is interpreted as a single-argument function
that returns True if a given Pow should be handled.</p>
</div></blockquote>
<p>Radicals can be removed from an expression if:</p>
<blockquote>
<div><ul class="simple">
<li><p>All bases of the radicals are the same; a change of variables is
done in this case.</p></li>
<li><p>If all radicals appear in one term of the expression.</p></li>
<li><p>There are only four terms with sqrt() factors or there are less than
four terms having sqrt() factors.</p></li>
<li><p>There are only two terms with radicals.</p></li>
</ul>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solvers</span> <span class="kn">import</span> <span class="n">unrad</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">root</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unrad</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">(x**5 - 64, [])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unrad</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">(x**3 - x**2 - 2*x - 1, [])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">root</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unrad</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">(_p**3 + _p**2 - 2, [_p, _p**6 - x])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ordinary-differential-equations-odes">
<h2>Ordinary Differential equations (ODEs)<a class="headerlink" href="#ordinary-differential-equations-odes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="ode.html#ode-docs"><span class="std std-ref">ODE</span></a>.</p>
</div>
<div class="section" id="partial-differential-equations-pdes">
<h2>Partial Differential Equations (PDEs)<a class="headerlink" href="#partial-differential-equations-pdes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="pde.html#pde-docs"><span class="std std-ref">PDE</span></a>.</p>
</div>
<div class="section" id="deutils-utilities-for-solving-ode-s-and-pde-s">
<h2>Deutils (Utilities for solving ODE’s and PDE’s)<a class="headerlink" href="#deutils-utilities-for-solving-ode-s-and-pde-s" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sympy.solvers.deutils.ode_order">
<code class="sig-prename descclassname">sympy.solvers.deutils.</code><code class="sig-name descname">ode_order</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/deutils.py#L95-L134"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.deutils.ode_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of a given differential
equation with respect to func.</p>
<p>This function is implemented recursively.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.deutils</span> <span class="kn">import</span> <span class="n">ode_order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-sympy.solvers.recurr">
<span id="recurrence-equations"></span><h2>Recurrence Equations<a class="headerlink" href="#module-sympy.solvers.recurr" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sympy.solvers.recurr.rsolve">
<code class="sig-prename descclassname">sympy.solvers.recurr.</code><code class="sig-name descname">rsolve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">init</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/recurr.py#L663-L828"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.recurr.rsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve univariate recurrence with rational coefficients.</p>
<p>Given <span class="math notranslate nohighlight">\(k\)</span>-th order linear recurrence <span class="math notranslate nohighlight">\(\operatorname{L} y = f\)</span>,
or equivalently:</p>
<div class="math notranslate nohighlight">
\[a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) +
\cdots + a_{0}(n) y(n) = f(n)\]</div>
<p>where <span class="math notranslate nohighlight">\(a_{i}(n)\)</span>, for <span class="math notranslate nohighlight">\(i=0, \ldots, k\)</span>, are polynomials or rational
functions in <span class="math notranslate nohighlight">\(n\)</span>, and <span class="math notranslate nohighlight">\(f\)</span> is a hypergeometric function or a sum
of a fixed number of pairwise dissimilar hypergeometric terms in
<span class="math notranslate nohighlight">\(n\)</span>, finds all solutions or returns <code class="docutils literal notranslate"><span class="pre">None</span></code>, if none were found.</p>
<p>Initial conditions can be given as a dictionary in two forms:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{</span>&#160; <span class="pre">n_0</span>&#160; <span class="pre">:</span> <span class="pre">v_0,</span>&#160;&#160; <span class="pre">n_1</span>&#160; <span class="pre">:</span> <span class="pre">v_1,</span> <span class="pre">...,</span>&#160;&#160; <span class="pre">n_m</span>&#160; <span class="pre">:</span> <span class="pre">v_m}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{y(n_0)</span> <span class="pre">:</span> <span class="pre">v_0,</span> <span class="pre">y(n_1)</span> <span class="pre">:</span> <span class="pre">v_1,</span> <span class="pre">...,</span> <span class="pre">y(n_m)</span> <span class="pre">:</span> <span class="pre">v_m}</span></code></p></li>
</ol>
</div></blockquote>
<p>or as a list <code class="docutils literal notranslate"><span class="pre">L</span></code> of values:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">[v_0,</span> <span class="pre">v_1,</span> <span class="pre">...,</span> <span class="pre">v_m]</span></code></p>
</div></blockquote>
<p>where <code class="docutils literal notranslate"><span class="pre">L[i]</span> <span class="pre">=</span> <span class="pre">v_i</span></code>, for <span class="math notranslate nohighlight">\(i=0, \ldots, m\)</span>, maps to <span class="math notranslate nohighlight">\(y(n_i)\)</span>.</p>
<p class="rubric">Examples</p>
<p>Lets consider the following recurrence:</p>
<div class="math notranslate nohighlight">
\[(n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) +
2 n (n + 1) y(n) = 0\]</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">rsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="go">2**n*C0 + C1*factorial(n)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="p">{</span><span class="n">y</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span><span class="mi">3</span><span class="p">})</span>
<span class="go">3*2**n - 3*factorial(n)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.recurr.rsolve_poly" title="sympy.solvers.recurr.rsolve_poly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_poly</span></code></a>, <a class="reference internal" href="#sympy.solvers.recurr.rsolve_ratio" title="sympy.solvers.recurr.rsolve_ratio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_ratio</span></code></a>, <a class="reference internal" href="#sympy.solvers.recurr.rsolve_hyper" title="sympy.solvers.recurr.rsolve_hyper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_hyper</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.recurr.rsolve_poly">
<code class="sig-prename descclassname">sympy.solvers.recurr.</code><code class="sig-name descname">rsolve_poly</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">hints</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/recurr.py#L71-L346"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.recurr.rsolve_poly" title="Permalink to this definition">¶</a></dt>
<dd><p>Given linear recurrence operator <span class="math notranslate nohighlight">\(\operatorname{L}\)</span> of order
<span class="math notranslate nohighlight">\(k\)</span> with polynomial coefficients and inhomogeneous equation
<span class="math notranslate nohighlight">\(\operatorname{L} y = f\)</span>, where <span class="math notranslate nohighlight">\(f\)</span> is a polynomial, we seek for
all polynomial solutions over field <span class="math notranslate nohighlight">\(K\)</span> of characteristic zero.</p>
<p>The algorithm performs two basic steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Compute degree <span class="math notranslate nohighlight">\(N\)</span> of the general polynomial solution.</p></li>
<li><p>Find all polynomials of degree <span class="math notranslate nohighlight">\(N\)</span> or less
of <span class="math notranslate nohighlight">\(\operatorname{L} y = f\)</span>.</p></li>
</ol>
</div></blockquote>
<p>There are two methods for computing the polynomial solutions.
If the degree bound is relatively small, i.e. it’s smaller than
or equal to the order of the recurrence, then naive method of
undetermined coefficients is being used. This gives system
of algebraic equations with <span class="math notranslate nohighlight">\(N+1\)</span> unknowns.</p>
<p>In the other case, the algorithm performs transformation of the
initial equation to an equivalent one, for which the system of
algebraic equations has only <span class="math notranslate nohighlight">\(r\)</span> indeterminates. This method is
quite sophisticated (in comparison with the naive one) and was
invented together by Abramov, Bronstein and Petkovsek.</p>
<p>It is possible to generalize the algorithm implemented here to
the case of linear q-difference and differential equations.</p>
<p>Lets say that we would like to compute <span class="math notranslate nohighlight">\(m\)</span>-th Bernoulli polynomial
up to a constant. For this we can use <span class="math notranslate nohighlight">\(b(n+1) - b(n) = m n^{m-1}\)</span>
recurrence, which has solution <span class="math notranslate nohighlight">\(b(n) = B_m + C\)</span>. For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">rsolve_poly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_poly</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="go">C0 + n**4 - 2*n**3 + n**2</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r700"><span class="brackets"><a class="fn-backref" href="#id2">R700</a></span></dt>
<dd><p>S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial
solutions of linear operator equations, in: T. Levelt, ed.,
Proc. ISSAC ‘95, ACM Press, New York, 1995, 290-296.</p>
</dd>
<dt class="label" id="r701"><span class="brackets"><a class="fn-backref" href="#id3">R701</a></span></dt>
<dd><p>M. Petkovsek, Hypergeometric solutions of linear recurrences
with polynomial coefficients, J. Symbolic Computation,
14 (1992), 243-264.</p>
</dd>
<dt class="label" id="r702"><span class="brackets"><a class="fn-backref" href="#id4">R702</a></span></dt>
<dd><ol class="upperalpha simple" start="13">
<li><p>Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.recurr.rsolve_ratio">
<code class="sig-prename descclassname">sympy.solvers.recurr.</code><code class="sig-name descname">rsolve_ratio</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">hints</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/recurr.py#L349-L457"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.recurr.rsolve_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Given linear recurrence operator <span class="math notranslate nohighlight">\(\operatorname{L}\)</span> of order <span class="math notranslate nohighlight">\(k\)</span>
with polynomial coefficients and inhomogeneous equation
<span class="math notranslate nohighlight">\(\operatorname{L} y = f\)</span>, where <span class="math notranslate nohighlight">\(f\)</span> is a polynomial, we seek
for all rational solutions over field <span class="math notranslate nohighlight">\(K\)</span> of characteristic zero.</p>
<p>This procedure accepts only polynomials, however if you are
interested in solving recurrence with rational coefficients
then use <code class="docutils literal notranslate"><span class="pre">rsolve</span></code> which will pre-process the given equation
and run this procedure with polynomial arguments.</p>
<p>The algorithm performs two basic steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Compute polynomial <span class="math notranslate nohighlight">\(v(n)\)</span> which can be used as universal
denominator of any rational solution of equation
<span class="math notranslate nohighlight">\(\operatorname{L} y = f\)</span>.</p></li>
<li><p>Construct new linear difference equation by substitution
<span class="math notranslate nohighlight">\(y(n) = u(n)/v(n)\)</span> and solve it for <span class="math notranslate nohighlight">\(u(n)\)</span> finding all its
polynomial solutions. Return <code class="docutils literal notranslate"><span class="pre">None</span></code> if none were found.</p></li>
</ol>
</div></blockquote>
<p>Algorithm implemented here is a revised version of the original
Abramov’s algorithm, developed in 1989. The new approach is much
simpler to implement and has better overall efficiency. This
method can be easily adapted to q-difference equations case.</p>
<p>Besides finding rational solutions alone, this functions is
an important part of Hyper algorithm were it is used to find
particular solution of inhomogeneous part of a recurrence.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.recurr</span> <span class="kn">import</span> <span class="n">rsolve_ratio</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_ratio</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span><span class="p">,</span>
<span class="gp">... </span><span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">11</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">18</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">13</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">22</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">C2*(2*x - 3)/(2*(x**2 - 1))</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.solvers.recurr.rsolve_hyper" title="sympy.solvers.recurr.rsolve_hyper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsolve_hyper</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r703"><span class="brackets"><a class="fn-backref" href="#id5">R703</a></span></dt>
<dd><p>S. A. Abramov, Rational solutions of linear difference
and q-difference equations with polynomial coefficients,
in: T. Levelt, ed., Proc. ISSAC ‘95, ACM Press, New York,
1995, 285-289</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.recurr.rsolve_hyper">
<code class="sig-prename descclassname">sympy.solvers.recurr.</code><code class="sig-name descname">rsolve_hyper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coeffs</span></em>, <em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">hints</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/recurr.py#L460-L660"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.recurr.rsolve_hyper" title="Permalink to this definition">¶</a></dt>
<dd><p>Given linear recurrence operator <span class="math notranslate nohighlight">\(\operatorname{L}\)</span> of order <span class="math notranslate nohighlight">\(k\)</span>
with polynomial coefficients and inhomogeneous equation
<span class="math notranslate nohighlight">\(\operatorname{L} y = f\)</span> we seek for all hypergeometric solutions
over field <span class="math notranslate nohighlight">\(K\)</span> of characteristic zero.</p>
<p>The inhomogeneous part can be either hypergeometric or a sum
of a fixed number of pairwise dissimilar hypergeometric terms.</p>
<p>The algorithm performs three basic steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Group together similar hypergeometric terms in the
inhomogeneous part of <span class="math notranslate nohighlight">\(\operatorname{L} y = f\)</span>, and find
particular solution using Abramov’s algorithm.</p></li>
<li><p>Compute generating set of <span class="math notranslate nohighlight">\(\operatorname{L}\)</span> and find basis
in it, so that all solutions are linearly independent.</p></li>
<li><p>Form final solution with the number of arbitrary
constants equal to dimension of basis of <span class="math notranslate nohighlight">\(\operatorname{L}\)</span>.</p></li>
</ol>
</div></blockquote>
<p>Term <span class="math notranslate nohighlight">\(a(n)\)</span> is hypergeometric if it is annihilated by first order
linear difference equations with polynomial coefficients or, in
simpler words, if consecutive term ratio is a rational function.</p>
<p>The output of this procedure is a linear combination of fixed
number of hypergeometric terms. However the underlying method
can generate larger class of solutions - D’Alembertian terms.</p>
<p>Note also that this method not only computes the kernel of the
inhomogeneous equation, but also reduces in to a basis so that
solutions generated by this procedure are linearly independent</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers</span> <span class="kn">import</span> <span class="n">rsolve_hyper</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_hyper</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">C0*(1/2 - sqrt(5)/2)**x + C1*(1/2 + sqrt(5)/2)**x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rsolve_hyper</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">C0 + x*(x + 1)/2</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r704"><span class="brackets"><a class="fn-backref" href="#id6">R704</a></span></dt>
<dd><p>M. Petkovsek, Hypergeometric solutions of linear recurrences
with polynomial coefficients, J. Symbolic Computation,
14 (1992), 243-264.</p>
</dd>
<dt class="label" id="r705"><span class="brackets"><a class="fn-backref" href="#id7">R705</a></span></dt>
<dd><ol class="upperalpha simple" start="13">
<li><p>Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.</p></li>
</ol>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="systems-of-polynomial-equations">
<h2>Systems of Polynomial Equations<a class="headerlink" href="#systems-of-polynomial-equations" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="sympy.solvers.polysys.solve_poly_system">
<code class="sig-prename descclassname">sympy.solvers.polysys.</code><code class="sig-name descname">solve_poly_system</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">seq</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">gens</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/polysys.py#L19-L65"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.polysys.solve_poly_system" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a system of polynomial equations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>seq: a list/tuple/set</strong></p>
<blockquote>
<div><p>Listing all the equations that are needed to be solved</p>
</div></blockquote>
<p><strong>gens: generators</strong></p>
<blockquote>
<div><p>generators of the equations in seq for which we want the
solutions</p>
</div></blockquote>
<p><strong>args: Keyword arguments</strong></p>
<blockquote>
<div><p>Special options for solving the equations</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List[Tuple]</p>
<blockquote>
<div><p>A List of tuples. Solutions for symbols that satisfy the
equations listed in seq</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solve_poly_system</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_poly_system</span><span class="p">([</span><span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">[(0, 0), (2, -sqrt(2)), (2, sqrt(2))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.solvers.polysys.solve_triangulated">
<code class="sig-prename descclassname">sympy.solvers.polysys.</code><code class="sig-name descname">solve_triangulated</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">polys</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">gens</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/solvers/polysys.py#L297-L396"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.polysys.solve_triangulated" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a polynomial system using Gianni-Kalkbrenner algorithm.</p>
<p>The algorithm proceeds by computing one Groebner basis in the ground
domain and then by iteratively computing polynomial factorizations in
appropriately constructed algebraic extensions of the ground domain.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>polys: a list/tuple/set</strong></p>
<blockquote>
<div><p>Listing all the equations that are needed to be solved</p>
</div></blockquote>
<p><strong>gens: generators</strong></p>
<blockquote>
<div><p>generators of the equations in polys for which we want the
solutions</p>
</div></blockquote>
<p><strong>args: Keyword arguments</strong></p>
<blockquote>
<div><p>Special options for solving the equations</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List[Tuple]</p>
<blockquote>
<div><p>A List of tuples. Solutions for symbols that satisfy the
equations listed in polys</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.polysys</span> <span class="kn">import</span> <span class="n">solve_triangulated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">solve_triangulated</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">[(0, 0, 1), (0, 1, 0), (1, 0, 0)]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<p>1. Patrizia Gianni, Teo Mora, Algebraic Solution of System of
Polynomial Equations using Groebner Bases, AAECC-5 on Applied Algebra,
Algebraic Algorithms and Error-Correcting Codes, LNCS 356 247–257, 1989</p>
</dd></dl>

</div>
<div class="section" id="diophantine-equations-des">
<h2>Diophantine Equations (DEs)<a class="headerlink" href="#diophantine-equations-des" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="diophantine.html#diophantine-docs"><span class="std std-ref">Diophantine</span></a></p>
</div>
<div class="section" id="inequalities">
<h2>Inequalities<a class="headerlink" href="#inequalities" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="inequalities.html#inequality-docs"><span class="std std-ref">Inequality Solvers</span></a></p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solvers</a><ul>
<li><a class="reference internal" href="#algebraic-equations">Algebraic equations</a></li>
<li><a class="reference internal" href="#ordinary-differential-equations-odes">Ordinary Differential equations (ODEs)</a></li>
<li><a class="reference internal" href="#partial-differential-equations-pdes">Partial Differential Equations (PDEs)</a></li>
<li><a class="reference internal" href="#deutils-utilities-for-solving-ode-s-and-pde-s">Deutils (Utilities for solving ODE’s and PDE’s)</a></li>
<li><a class="reference internal" href="#module-sympy.solvers.recurr">Recurrence Equations</a></li>
<li><a class="reference internal" href="#systems-of-polynomial-equations">Systems of Polynomial Equations</a></li>
<li><a class="reference internal" href="#diophantine-equations-des">Diophantine Equations (DEs)</a></li>
<li><a class="reference internal" href="#inequalities">Inequalities</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../simplify/fu.html"
                        title="previous chapter">Hongguang Fu’s Trigonometric Simplification</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="solveset.html"
                        title="next chapter">Solveset</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/solvers/solvers.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="solveset.html" title="Solveset"
             >next</a> |</li>
        <li class="right" >
          <a href="../simplify/fu.html" title="Hongguang Fu’s Trigonometric Simplification"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solvers</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 SymPy Development Team.
      Last updated on Oct 01, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>