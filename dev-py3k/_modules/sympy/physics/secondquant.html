

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.physics.secondquant &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.physics.secondquant</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Second quantization operators and states for bosons.</span>

<span class="sd">This follow the formulation of Fetter and Welecka, &quot;Quantum Theory</span>
<span class="sd">of Many-Particle Systems.&quot;</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Add</span><span class="p">,</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">cacheit</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span>
                   <span class="n">KroneckerDelta</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span>
                   <span class="n">zeros</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">from</span> <span class="nn">sympy.printing.str</span> <span class="kn">import</span> <span class="n">StrPrinter</span>

<span class="kn">from</span> <span class="nn">sympy.physics.quantum.qexpr</span> <span class="kn">import</span> <span class="n">split_commutative_parts</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">has_dups</span>
<span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">default_sort_key</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;Dagger&#39;</span><span class="p">,</span>
    <span class="s">&#39;KroneckerDelta&#39;</span><span class="p">,</span>
    <span class="s">&#39;BosonicOperator&#39;</span><span class="p">,</span>
    <span class="s">&#39;AnnihilateBoson&#39;</span><span class="p">,</span>
    <span class="s">&#39;CreateBoson&#39;</span><span class="p">,</span>
    <span class="s">&#39;AnnihilateFermion&#39;</span><span class="p">,</span>
    <span class="s">&#39;CreateFermion&#39;</span><span class="p">,</span>
    <span class="s">&#39;FockState&#39;</span><span class="p">,</span>
    <span class="s">&#39;FockStateBra&#39;</span><span class="p">,</span>
    <span class="s">&#39;FockStateKet&#39;</span><span class="p">,</span>
    <span class="s">&#39;FockStateBosonKet&#39;</span><span class="p">,</span>
    <span class="s">&#39;FockStateBosonBra&#39;</span><span class="p">,</span>
    <span class="s">&#39;BBra&#39;</span><span class="p">,</span>
    <span class="s">&#39;BKet&#39;</span><span class="p">,</span>
    <span class="s">&#39;FBra&#39;</span><span class="p">,</span>
    <span class="s">&#39;FKet&#39;</span><span class="p">,</span>
    <span class="s">&#39;F&#39;</span><span class="p">,</span>
    <span class="s">&#39;Fd&#39;</span><span class="p">,</span>
    <span class="s">&#39;B&#39;</span><span class="p">,</span>
    <span class="s">&#39;Bd&#39;</span><span class="p">,</span>
    <span class="s">&#39;apply_operators&#39;</span><span class="p">,</span>
    <span class="s">&#39;InnerProduct&#39;</span><span class="p">,</span>
    <span class="s">&#39;BosonicBasis&#39;</span><span class="p">,</span>
    <span class="s">&#39;VarBosonicBasis&#39;</span><span class="p">,</span>
    <span class="s">&#39;FixedBosonicBasis&#39;</span><span class="p">,</span>
    <span class="s">&#39;Commutator&#39;</span><span class="p">,</span>
    <span class="s">&#39;matrix_rep&#39;</span><span class="p">,</span>
    <span class="s">&#39;contraction&#39;</span><span class="p">,</span>
    <span class="s">&#39;wicks&#39;</span><span class="p">,</span>
    <span class="s">&#39;NO&#39;</span><span class="p">,</span>
    <span class="s">&#39;evaluate_deltas&#39;</span><span class="p">,</span>
    <span class="s">&#39;AntiSymmetricTensor&#39;</span><span class="p">,</span>
    <span class="s">&#39;substitute_dummies&#39;</span><span class="p">,</span>
    <span class="s">&#39;PermutationOperator&#39;</span><span class="p">,</span>
    <span class="s">&#39;simplify_index_permutations&#39;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">class</span> <span class="nc">SecondQuantizationError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">AppliesOnlyToSymbolicIndex</span><span class="p">(</span><span class="n">SecondQuantizationError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ContractionAppliesOnlyToFermions</span><span class="p">(</span><span class="n">SecondQuantizationError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ViolationOfPauliPrinciple</span><span class="p">(</span><span class="n">SecondQuantizationError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">SubstitutionOfAmbigousOperatorFailed</span><span class="p">(</span><span class="n">SecondQuantizationError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">WicksTheoremDoesNotApply</span><span class="p">(</span><span class="n">SecondQuantizationError</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="Dagger"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.Dagger">[docs]</a><span class="k">class</span> <span class="nc">Dagger</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hermitian conjugate of creation/annihilation operators.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import I</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import Dagger, B, Bd</span>
<span class="sd">    &gt;&gt;&gt; Dagger(2*I)</span>
<span class="sd">    -2*I</span>
<span class="sd">    &gt;&gt;&gt; Dagger(B(0))</span>
<span class="sd">    CreateBoson(0)</span>
<span class="sd">    &gt;&gt;&gt; Dagger(Bd(0))</span>
<span class="sd">    AnnihilateBoson(0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">r</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Dagger.eval"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.Dagger.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the Dagger instance.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import I</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import Dagger, B, Bd</span>
<span class="sd">        &gt;&gt;&gt; Dagger(2*I)</span>
<span class="sd">        -2*I</span>
<span class="sd">        &gt;&gt;&gt; Dagger(B(0))</span>
<span class="sd">        CreateBoson(0)</span>
<span class="sd">        &gt;&gt;&gt; Dagger(Bd(0))</span>
<span class="sd">        AnnihilateBoson(0)</span>

<span class="sd">        The eval() method is called automatically.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">_dagger_</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Dagger</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Dagger</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">))))</span>
                <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">arg</span>
                <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">Dagger</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arg</span> <span class="o">==</span> <span class="n">I</span><span class="p">:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="n">arg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
</div>
    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

</div>
<span class="k">class</span> <span class="nc">TensorSymbol</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>

    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">True</span>


<div class="viewcode-block" id="AntiSymmetricTensor"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AntiSymmetricTensor">[docs]</a><span class="k">class</span> <span class="nc">AntiSymmetricTensor</span><span class="p">(</span><span class="n">TensorSymbol</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Stores upper and lower indices in separate Tuple&#39;s.</span>

<span class="sd">    Each group of indices is assumed to be antisymmetric.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import AntiSymmetricTensor</span>
<span class="sd">    &gt;&gt;&gt; i, j = symbols(&#39;i j&#39;, below_fermi=True)</span>
<span class="sd">    &gt;&gt;&gt; a, b = symbols(&#39;a b&#39;, above_fermi=True)</span>
<span class="sd">    &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (a, i), (b, j))</span>
<span class="sd">    AntiSymmetricTensor(v, (a, i), (b, j))</span>
<span class="sd">    &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (i, a), (b, j))</span>
<span class="sd">    -AntiSymmetricTensor(v, (a, i), (b, j))</span>

<span class="sd">    As you can see, the indices are automatically sorted to a canonical form.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nargs</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">):</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">upper</span><span class="p">,</span> <span class="n">signu</span> <span class="o">=</span> <span class="n">_sort_anticommuting_fermions</span><span class="p">(</span>
                <span class="n">upper</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">_sortkey</span><span class="p">)</span>
            <span class="n">lower</span><span class="p">,</span> <span class="n">signl</span> <span class="o">=</span> <span class="n">_sort_anticommuting_fermions</span><span class="p">(</span>
                <span class="n">lower</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">cls</span><span class="o">.</span><span class="n">_sortkey</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">ViolationOfPauliPrinciple</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="n">symbol</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">upper</span><span class="p">)</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">lower</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">signu</span> <span class="o">+</span> <span class="n">signl</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">TensorSymbol</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">TensorSymbol</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_sortkey</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Key for sorting of indices.</span>

<span class="sd">        particle &lt; hole &lt; general</span>

<span class="sd">        FIXME: This is a bottle-neck, can we do it faster?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;above_fermi&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">index</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;below_fermi&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;above_fermi&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">index</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;below_fermi&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">^{</span><span class="si">%s</span><span class="s">}_{</span><span class="si">%s</span><span class="s">}&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span>
            <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
            <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span> <span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="AntiSymmetricTensor.symbol"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AntiSymmetricTensor.symbol">[docs]</a>    <span class="k">def</span> <span class="nf">symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the symbol of the tensor.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import AntiSymmetricTensor</span>
<span class="sd">        &gt;&gt;&gt; i, j = symbols(&#39;i,j&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; a, b = symbols(&#39;a,b&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (a, i), (b, j))</span>
<span class="sd">        AntiSymmetricTensor(v, (a, i), (b, j))</span>
<span class="sd">        &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (a, i), (b, j)).symbol</span>
<span class="sd">        v</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AntiSymmetricTensor.upper"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AntiSymmetricTensor.upper">[docs]</a>    <span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the upper indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import AntiSymmetricTensor</span>
<span class="sd">        &gt;&gt;&gt; i, j = symbols(&#39;i,j&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; a, b = symbols(&#39;a,b&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (a, i), (b, j))</span>
<span class="sd">        AntiSymmetricTensor(v, (a, i), (b, j))</span>
<span class="sd">        &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (a, i), (b, j)).upper</span>
<span class="sd">        (a, i)</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AntiSymmetricTensor.lower"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AntiSymmetricTensor.lower">[docs]</a>    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the lower indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import AntiSymmetricTensor</span>
<span class="sd">        &gt;&gt;&gt; i, j = symbols(&#39;i,j&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; a, b = symbols(&#39;a,b&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (a, i), (b, j))</span>
<span class="sd">        AntiSymmetricTensor(v, (a, i), (b, j))</span>
<span class="sd">        &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (a, i), (b, j)).lower</span>
<span class="sd">        (b, j)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

<div class="viewcode-block" id="AntiSymmetricTensor.doit"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AntiSymmetricTensor.doit">[docs]</a>    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns self.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import AntiSymmetricTensor</span>
<span class="sd">        &gt;&gt;&gt; i, j = symbols(&#39;i,j&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; a, b = symbols(&#39;a,b&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; AntiSymmetricTensor(&#39;v&#39;, (a, i), (b, j)).doit()</span>
<span class="sd">        AntiSymmetricTensor(v, (a, i), (b, j))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

</div></div>
<span class="k">class</span> <span class="nc">SqOperator</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Second Quantization operators.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">op_symbol</span> <span class="o">=</span> <span class="s">&#39;sq&#39;</span>

    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">sympify</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the state index related to this operator.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F, Fd, B, Bd</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>
<span class="sd">        &gt;&gt;&gt; F(p).state</span>
<span class="sd">        p</span>
<span class="sd">        &gt;&gt;&gt; Fd(p).state</span>
<span class="sd">        p</span>
<span class="sd">        &gt;&gt;&gt; B(p).state</span>
<span class="sd">        p</span>
<span class="sd">        &gt;&gt;&gt; Bd(p).state</span>
<span class="sd">        p</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_symbolic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the state is a symbol (as opposed to a number).</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_symbolic</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; F(1).is_symbolic</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        FIXME: hack to prevent crash further up...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">(</span><span class="si">%r</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">op_symbol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies an operator to itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;implement apply_operator in a subclass&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BosonicOperator</span><span class="p">(</span><span class="n">SqOperator</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Annihilator</span><span class="p">(</span><span class="n">SqOperator</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Creator</span><span class="p">(</span><span class="n">SqOperator</span><span class="p">):</span>
    <span class="k">pass</span>


<div class="viewcode-block" id="AnnihilateBoson"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AnnihilateBoson">[docs]</a><span class="k">class</span> <span class="nc">AnnihilateBoson</span><span class="p">(</span><span class="n">BosonicOperator</span><span class="p">,</span> <span class="n">Annihilator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bosonic annihilation operator.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import B</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; B(x)</span>
<span class="sd">    AnnihilateBoson(x)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">op_symbol</span> <span class="o">=</span> <span class="s">&#39;b&#39;</span>

    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CreateBoson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

<div class="viewcode-block" id="AnnihilateBoson.apply_operator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AnnihilateBoson.apply_operator">[docs]</a>    <span class="k">def</span> <span class="nf">apply_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply state to self if self is not symbolic and state is a FockStateKet, else</span>
<span class="sd">        multiply self by state.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import B, BKet</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, n</span>
<span class="sd">        &gt;&gt;&gt; B(x).apply_operator(y)</span>
<span class="sd">        y*AnnihilateBoson(x)</span>
<span class="sd">        &gt;&gt;&gt; B(0).apply_operator(BKet((n,)))</span>
<span class="sd">        sqrt(n)*FockStateBosonKet((n - 1,))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symbolic</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">FockStateKet</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">element</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">amp</span><span class="o">*</span><span class="n">state</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;AnnihilateBoson(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>

</div>
<div class="viewcode-block" id="CreateBoson"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.CreateBoson">[docs]</a><span class="k">class</span> <span class="nc">CreateBoson</span><span class="p">(</span><span class="n">BosonicOperator</span><span class="p">,</span> <span class="n">Creator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bosonic creation operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">op_symbol</span> <span class="o">=</span> <span class="s">&#39;b+&#39;</span>

    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AnnihilateBoson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

<div class="viewcode-block" id="CreateBoson.apply_operator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.CreateBoson.apply_operator">[docs]</a>    <span class="k">def</span> <span class="nf">apply_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply state to self if self is not symbolic and state is a FockStateKet, else</span>
<span class="sd">        multiply self by state.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import B, Dagger, BKet</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, n</span>
<span class="sd">        &gt;&gt;&gt; Dagger(B(x)).apply_operator(y)</span>
<span class="sd">        y*CreateBoson(x)</span>
<span class="sd">        &gt;&gt;&gt; B(0).apply_operator(BKet((n,)))</span>
<span class="sd">        sqrt(n)*FockStateBosonKet((n - 1,))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symbolic</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">FockStateKet</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">element</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">amp</span><span class="o">*</span><span class="n">state</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;CreateBoson(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
</div>
<span class="n">B</span> <span class="o">=</span> <span class="n">AnnihilateBoson</span>
<span class="n">Bd</span> <span class="o">=</span> <span class="n">CreateBoson</span>


<span class="k">class</span> <span class="nc">FermionicOperator</span><span class="p">(</span><span class="n">SqOperator</span><span class="p">):</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_restricted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is this FermionicOperator restricted with respect to fermi level?</span>

<span class="sd">        Return values:</span>
<span class="sd">        1  : restricted to orbits above fermi</span>
<span class="sd">        0  : no restriction</span>
<span class="sd">        -1 : restricted to orbits below fermi</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F, Fd</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_restricted</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; Fd(a).is_restricted</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_restricted</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; Fd(i).is_restricted</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_restricted</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; Fd(p).is_restricted</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assumptions0</span>
        <span class="k">if</span> <span class="n">ass</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;below_fermi&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">ass</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;above_fermi&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_above_fermi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the index of this FermionicOperator allow values above fermi?</span>


<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_above_fermi</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_above_fermi</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_above_fermi</span>
<span class="sd">        True</span>

<span class="sd">        The same applies to creation operators Fd</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;below_fermi&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_below_fermi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the index of this FermionicOperator allow values below fermi?</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_below_fermi</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_below_fermi</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_below_fermi</span>
<span class="sd">        True</span>

<span class="sd">        The same applies to creation operators Fd</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;above_fermi&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_only_below_fermi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the index of this FermionicOperator restricted to values below fermi?</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_only_below_fermi</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_only_below_fermi</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_only_below_fermi</span>
<span class="sd">        False</span>

<span class="sd">        The same applies to creation operators Fd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_below_fermi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_above_fermi</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_only_above_fermi</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the index of this FermionicOperator restricted to values above fermi?</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_only_above_fermi</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_only_above_fermi</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_only_above_fermi</span>
<span class="sd">        False</span>

<span class="sd">        The same applies to creation operators Fd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_above_fermi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_below_fermi</span>

    <span class="k">def</span> <span class="nf">_sortkey</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_only_q_creator</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">h</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_only_q_annihilator</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">4</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">h</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Annihilator</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">h</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Creator</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">h</span>


<div class="viewcode-block" id="AnnihilateFermion"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AnnihilateFermion">[docs]</a><span class="k">class</span> <span class="nc">AnnihilateFermion</span><span class="p">(</span><span class="n">FermionicOperator</span><span class="p">,</span> <span class="n">Annihilator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fermionic annihilation operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">op_symbol</span> <span class="o">=</span> <span class="s">&#39;f&#39;</span>

    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CreateFermion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

<div class="viewcode-block" id="AnnihilateFermion.apply_operator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AnnihilateFermion.apply_operator">[docs]</a>    <span class="k">def</span> <span class="nf">apply_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply state to self if self is not symbolic and state is a FockStateKet, else</span>
<span class="sd">        multiply self by state.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import B, Dagger, BKet</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, n</span>
<span class="sd">        &gt;&gt;&gt; Dagger(B(x)).apply_operator(y)</span>
<span class="sd">        y*CreateBoson(x)</span>
<span class="sd">        &gt;&gt;&gt; B(0).apply_operator(BKet((n,)))</span>
<span class="sd">        sqrt(n)*FockStateBosonKet((n - 1,))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">FockStateFermionKet</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
            <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="n">c_part</span><span class="p">,</span> <span class="n">nc_part</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nc_part</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FockStateFermionKet</span><span class="p">):</span>
                <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
                <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">c_part</span> <span class="o">+</span> <span class="p">[</span><span class="n">nc_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">down</span><span class="p">(</span><span class="n">element</span><span class="p">)]</span> <span class="o">+</span> <span class="n">nc_part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnnihilateFermion.is_q_creator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AnnihilateFermion.is_q_creator">[docs]</a>    <span class="k">def</span> <span class="nf">is_q_creator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Can we create a quasi-particle?  (create hole or create particle)</span>
<span class="sd">        If so, would that be above or below the fermi surface?</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_q_creator</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_q_creator</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_q_creator</span>
<span class="sd">        -1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_below_fermi</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnnihilateFermion.is_q_annihilator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AnnihilateFermion.is_q_annihilator">[docs]</a>    <span class="k">def</span> <span class="nf">is_q_annihilator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Can we destroy a quasi-particle?  (annihilate hole or annihilate particle)</span>
<span class="sd">        If so, would that be above or below the fermi surface?</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=1)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=1)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_q_annihilator</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_q_annihilator</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_q_annihilator</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_above_fermi</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnnihilateFermion.is_only_q_creator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AnnihilateFermion.is_only_q_creator">[docs]</a>    <span class="k">def</span> <span class="nf">is_only_q_creator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always create a quasi-particle?  (create hole or create particle)</span>


<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_only_q_creator</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_only_q_creator</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_only_q_creator</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_only_below_fermi</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="AnnihilateFermion.is_only_q_annihilator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.AnnihilateFermion.is_only_q_annihilator">[docs]</a>    <span class="k">def</span> <span class="nf">is_only_q_annihilator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always destroy a quasi-particle?  (annihilate hole or annihilate particle)</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; F(a).is_only_q_annihilator</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; F(i).is_only_q_annihilator</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; F(p).is_only_q_annihilator</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_only_above_fermi</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;AnnihilateFermion(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>

    <span class="k">def</span> <span class="nf">_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;a_{</span><span class="si">%s</span><span class="s">}&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">name</span>

</div>
<div class="viewcode-block" id="CreateFermion"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.CreateFermion">[docs]</a><span class="k">class</span> <span class="nc">CreateFermion</span><span class="p">(</span><span class="n">FermionicOperator</span><span class="p">,</span> <span class="n">Creator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fermionic creation operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">op_symbol</span> <span class="o">=</span> <span class="s">&#39;f+&#39;</span>

    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AnnihilateFermion</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

<div class="viewcode-block" id="CreateFermion.apply_operator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.CreateFermion.apply_operator">[docs]</a>    <span class="k">def</span> <span class="nf">apply_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply state to self if self is not symbolic and state is a FockStateKet, else</span>
<span class="sd">        multiply self by state.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import B, Dagger, BKet</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, n</span>
<span class="sd">        &gt;&gt;&gt; Dagger(B(x)).apply_operator(y)</span>
<span class="sd">        y*CreateBoson(x)</span>
<span class="sd">        &gt;&gt;&gt; B(0).apply_operator(BKet((n,)))</span>
<span class="sd">        sqrt(n)*FockStateBosonKet((n - 1,))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">FockStateFermionKet</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
            <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="n">c_part</span><span class="p">,</span> <span class="n">nc_part</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nc_part</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FockStateFermionKet</span><span class="p">):</span>
                <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
                <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">c_part</span> <span class="o">+</span> <span class="p">[</span><span class="n">nc_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">up</span><span class="p">(</span><span class="n">element</span><span class="p">)]</span> <span class="o">+</span> <span class="n">nc_part</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="CreateFermion.is_q_creator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.CreateFermion.is_q_creator">[docs]</a>    <span class="k">def</span> <span class="nf">is_q_creator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Can we create a quasi-particle?  (create hole or create particle)</span>
<span class="sd">        If so, would that be above or below the fermi surface?</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import Fd</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; Fd(a).is_q_creator</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; Fd(i).is_q_creator</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; Fd(p).is_q_creator</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_above_fermi</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="CreateFermion.is_q_annihilator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.CreateFermion.is_q_annihilator">[docs]</a>    <span class="k">def</span> <span class="nf">is_q_annihilator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Can we destroy a quasi-particle?  (annihilate hole or annihilate particle)</span>
<span class="sd">        If so, would that be above or below the fermi surface?</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import Fd</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=1)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=1)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; Fd(a).is_q_annihilator</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; Fd(i).is_q_annihilator</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; Fd(p).is_q_annihilator</span>
<span class="sd">        -1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_below_fermi</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="CreateFermion.is_only_q_creator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.CreateFermion.is_only_q_creator">[docs]</a>    <span class="k">def</span> <span class="nf">is_only_q_creator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always create a quasi-particle?  (create hole or create particle)</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import Fd</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; Fd(a).is_only_q_creator</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Fd(i).is_only_q_creator</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Fd(p).is_only_q_creator</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_only_above_fermi</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="CreateFermion.is_only_q_annihilator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.CreateFermion.is_only_q_annihilator">[docs]</a>    <span class="k">def</span> <span class="nf">is_only_q_annihilator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Always destroy a quasi-particle?  (annihilate hole or annihilate particle)</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import Fd</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; Fd(a).is_only_q_annihilator</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Fd(i).is_only_q_annihilator</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Fd(p).is_only_q_annihilator</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_only_below_fermi</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;CreateFermion(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>

    <span class="k">def</span> <span class="nf">_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;a^</span><span class="se">\\</span><span class="s">dagger_{</span><span class="si">%s</span><span class="s">}&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">name</span>
</div>
<span class="n">Fd</span> <span class="o">=</span> <span class="n">CreateFermion</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">AnnihilateFermion</span>


<div class="viewcode-block" id="FockState"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.FockState">[docs]</a><span class="k">class</span> <span class="nc">FockState</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Many particle Fock state with a sequence of occupation numbers.</span>

<span class="sd">    Anywhere you can have a FockState, you can also have S.Zero.</span>
<span class="sd">    All code must check for this!</span>

<span class="sd">    Base class to represent FockStates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">occupations</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        occupations is a list with two possible meanings:</span>

<span class="sd">        - For bosons it is a list of occupation numbers.</span>
<span class="sd">          Element i is the number of particles in state i.</span>

<span class="sd">        - For fermions it is a list of occupied orbits.</span>
<span class="sd">          Element 0 is the state that was occupied first, element i</span>
<span class="sd">          is the i&#39;th occupied state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">occupations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">occupations</span><span class="p">))</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">occupations</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&quot;FockState(</span><span class="si">%r</span><span class="s">)&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s%r%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lbracket</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_labels</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbracket</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

</div>
<span class="k">class</span> <span class="nc">BosonState</span><span class="p">(</span><span class="n">FockState</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for FockStateBoson(Ket/Bra).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the action of a creation operator.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import BBra</span>
<span class="sd">        &gt;&gt;&gt; b = BBra([1, 2])</span>
<span class="sd">        &gt;&gt;&gt; b</span>
<span class="sd">        FockStateBosonBra((1, 2))</span>
<span class="sd">        &gt;&gt;&gt; b.up(1)</span>
<span class="sd">        FockStateBosonBra((1, 3))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">new_occs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new_occs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_occs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">new_occs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the action of an annihilation operator.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import BBra</span>
<span class="sd">        &gt;&gt;&gt; b = BBra([1, 2])</span>
<span class="sd">        &gt;&gt;&gt; b</span>
<span class="sd">        FockStateBosonBra((1, 2))</span>
<span class="sd">        &gt;&gt;&gt; b.down(1)</span>
<span class="sd">        FockStateBosonBra((1, 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">new_occs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">new_occs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_occs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_occs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">new_occs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FermionState</span><span class="p">(</span><span class="n">FockState</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for FockStateFermion(Ket/Bra).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">fermi_level</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">occupations</span><span class="p">,</span> <span class="n">fermi_level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">occupations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">occupations</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">occupations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="p">(</span><span class="n">occupations</span><span class="p">,</span> <span class="n">sign</span><span class="p">)</span> <span class="o">=</span> <span class="n">_sort_anticommuting_fermions</span><span class="p">(</span>
                    <span class="n">occupations</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">hash</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ViolationOfPauliPrinciple</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">fermi_level</span> <span class="o">=</span> <span class="n">fermi_level</span>

        <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_count_holes</span><span class="p">(</span><span class="n">occupations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">fermi_level</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">if</span> <span class="n">sign</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="o">*</span><span class="n">FockState</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">occupations</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FockState</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">occupations</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the action of a creation operator.</span>

<span class="sd">        If below fermi we try to remove a hole,</span>
<span class="sd">        if above fermi we try to create a particle.</span>

<span class="sd">        if general index p we return Kronecker(p,i)*self</span>
<span class="sd">        where i is a new symbol with restriction above or below.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import FKet</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        &gt;&gt;&gt; FKet([]).up(a)</span>
<span class="sd">        FockStateFermionKet((a,))</span>

<span class="sd">        A creator acting on vacuum below fermi vanishes</span>
<span class="sd">        &gt;&gt;&gt; FKet([]).up(i)</span>
<span class="sd">        0</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">present</span> <span class="o">=</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_above_fermi</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">present</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_below_fermi</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">present</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">present</span><span class="p">:</span>
                <span class="n">hole</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="n">below_fermi</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">hole</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_remove_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">particle</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">above_fermi</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">particle</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the action of an annihilation operator.</span>

<span class="sd">        If below fermi we try to create a hole,</span>
<span class="sd">        if above fermi we try to remove a particle.</span>

<span class="sd">        if general index p we return Kronecker(p,i)*self</span>
<span class="sd">        where i is a new symbol with restriction above or below.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import FKet</span>
<span class="sd">        &gt;&gt;&gt; a = Symbol(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = Symbol(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; p = Symbol(&#39;p&#39;)</span>

<span class="sd">        An annihilator acting on vacuum above fermi vanishes</span>
<span class="sd">        &gt;&gt;&gt; FKet([]).down(a)</span>
<span class="sd">        0</span>

<span class="sd">        Also below fermi, it vanishes, unless we specify a fermi level &gt; 0</span>
<span class="sd">        &gt;&gt;&gt; FKet([]).down(i)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; FKet([],4).down(i)</span>
<span class="sd">        FockStateFermionKet((i,))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">present</span> <span class="o">=</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_above_fermi</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">present</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_only_below_fermi</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">present</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">present</span><span class="p">:</span>
                <span class="n">hole</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="n">below_fermi</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">hole</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">particle</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">above_fermi</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">particle</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_remove_orbit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_only_below_fermi</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests if given orbit is only below fermi surface.</span>

<span class="sd">        If nothing can be concluded we return a conservative False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">cls</span><span class="o">.</span><span class="n">fermi_level</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;below_fermi&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_only_above_fermi</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tests if given orbit is only above fermi surface.</span>

<span class="sd">        If fermi level has not been set we return True.</span>
<span class="sd">        If nothing can be concluded we return a conservative False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">cls</span><span class="o">.</span><span class="n">fermi_level</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;above_fermi&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">cls</span><span class="o">.</span><span class="n">fermi_level</span>

    <span class="k">def</span> <span class="nf">_remove_orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes particle/fills hole in orbit i. No input tests performed here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_occs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">new_occs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">new_occs</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">new_occs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">new_occs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_level</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds particle/creates hole in orbit i. No input tests performed here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">((</span><span class="n">i</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_level</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_count_holes</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns number of identified hole states in list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span> <span class="k">if</span> <span class="n">cls</span><span class="o">.</span><span class="n">_only_below_fermi</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">_negate_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="o">-</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_level</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_level</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;FockStateKet(</span><span class="si">%r</span><span class="s">, fermi_level=</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;FockStateKet(</span><span class="si">%r</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>

    <span class="k">def</span> <span class="nf">_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negate_holes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<div class="viewcode-block" id="FockStateKet"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.FockStateKet">[docs]</a><span class="k">class</span> <span class="nc">FockStateKet</span><span class="p">(</span><span class="n">FockState</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a ket.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lbracket</span> <span class="o">=</span> <span class="s">&#39;|&#39;</span>
    <span class="n">rbracket</span> <span class="o">=</span> <span class="s">&#39;&gt;&#39;</span>

</div>
<div class="viewcode-block" id="FockStateBra"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.FockStateBra">[docs]</a><span class="k">class</span> <span class="nc">FockStateBra</span><span class="p">(</span><span class="n">FockState</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a bra.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lbracket</span> <span class="o">=</span> <span class="s">&#39;&lt;&#39;</span>
    <span class="n">rbracket</span> <span class="o">=</span> <span class="s">&#39;|&#39;</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">FockStateKet</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">InnerProduct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Expr</span><span class="o">.</span><span class="n">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="FockStateBosonKet"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.FockStateBosonKet">[docs]</a><span class="k">class</span> <span class="nc">FockStateBosonKet</span><span class="p">(</span><span class="n">BosonState</span><span class="p">,</span> <span class="n">FockStateKet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Many particle Fock state with a sequence of occupation numbers.</span>

<span class="sd">    Occupation numbers can be any integer &gt;= 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import BKet</span>
<span class="sd">    &gt;&gt;&gt; BKet([1, 2])</span>
<span class="sd">    FockStateBosonKet((1, 2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FockStateBosonBra</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="FockStateBosonBra"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.FockStateBosonBra">[docs]</a><span class="k">class</span> <span class="nc">FockStateBosonBra</span><span class="p">(</span><span class="n">BosonState</span><span class="p">,</span> <span class="n">FockStateBra</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Describes a collection of BosonBra particles.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import BBra</span>
<span class="sd">    &gt;&gt;&gt; BBra([1, 2])</span>
<span class="sd">    FockStateBosonBra((1, 2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FockStateBosonKet</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

</div>
<span class="k">class</span> <span class="nc">FockStateFermionKet</span><span class="p">(</span><span class="n">FermionState</span><span class="p">,</span> <span class="n">FockStateKet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Many-particle Fock state with a sequence of occupied orbits.</span>

<span class="sd">    Each state can only have one particle, so we choose to store a list of</span>
<span class="sd">    occupied orbits rather than a tuple with occupation numbers (zeros and ones).</span>

<span class="sd">    states below fermi level are holes, and are represented by negative labels</span>
<span class="sd">    in the occupation list.</span>

<span class="sd">    For symbolic state labels, the fermi_level caps the number of allowed hole-</span>
<span class="sd">    states.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import FKet</span>
<span class="sd">    &gt;&gt;&gt; FKet([1, 2]) #doctest: +SKIP</span>
<span class="sd">    FockStateFermionKet((1, 2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FockStateFermionBra</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FockStateFermionBra</span><span class="p">(</span><span class="n">FermionState</span><span class="p">,</span> <span class="n">FockStateBra</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    FockStateFermionKet</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import FBra</span>
<span class="sd">    &gt;&gt;&gt; FBra([1, 2]) #doctest: +SKIP</span>
<span class="sd">    FockStateFermionBra((1, 2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_dagger_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FockStateFermionKet</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

<span class="n">BBra</span> <span class="o">=</span> <span class="n">FockStateBosonBra</span>
<span class="n">BKet</span> <span class="o">=</span> <span class="n">FockStateBosonKet</span>
<span class="n">FBra</span> <span class="o">=</span> <span class="n">FockStateFermionBra</span>
<span class="n">FKet</span> <span class="o">=</span> <span class="n">FockStateFermionKet</span>


<span class="k">def</span> <span class="nf">_apply_Mul</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take a Mul instance with operators and apply them to states.</span>

<span class="sd">    This method applies all operators with integer state labels</span>
<span class="sd">    to the actual states.  For symbolic state labels, nothing is done.</span>
<span class="sd">    When inner products of FockStates are encountered (like &lt;a|b&gt;),</span>
<span class="sd">    they are converted to instances of InnerProduct.</span>

<span class="sd">    This does not currently work on double inner products like,</span>
<span class="sd">    &lt;a|b&gt;&lt;c|d&gt;.</span>

<span class="sd">    If the argument is not a Mul, it is simply returned as is.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">m</span>
    <span class="n">c_part</span><span class="p">,</span> <span class="n">nc_part</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
    <span class="n">n_nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nc_part</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_nc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n_nc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">next_to_last</span> <span class="o">=</span> <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">FockStateKet</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_to_last</span><span class="p">,</span> <span class="n">SqOperator</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">next_to_last</span><span class="o">.</span><span class="n">is_symbolic</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">m</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">next_to_last</span><span class="o">.</span><span class="n">apply_operator</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_apply_Mul</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">c_part</span> <span class="o">+</span> <span class="n">nc_part</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">result</span><span class="p">])))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_to_last</span><span class="p">,</span> <span class="n">Pow</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_to_last</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">SqOperator</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="n">next_to_last</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">next_to_last</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_symbolic</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">m</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">last</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">next_to_last</span><span class="o">.</span><span class="n">exp</span><span class="p">):</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="n">next_to_last</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">apply_operator</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">_apply_Mul</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">c_part</span> <span class="o">+</span> <span class="n">nc_part</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">result</span><span class="p">])))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">m</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">next_to_last</span><span class="p">,</span> <span class="n">FockStateBra</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">InnerProduct</span><span class="p">(</span><span class="n">next_to_last</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_apply_Mul</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">c_part</span> <span class="o">+</span> <span class="n">nc_part</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">result</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span>


<div class="viewcode-block" id="apply_operators"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.apply_operators">[docs]</a><span class="k">def</span> <span class="nf">apply_operators</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take a sympy expression with operators and states and apply the operators.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import apply_operators</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sympify</span>
<span class="sd">    &gt;&gt;&gt; apply_operators(sympify(3)+4)</span>
<span class="sd">    7</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
    <span class="n">muls</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span>
    <span class="n">subs_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span><span class="p">,</span> <span class="n">_apply_Mul</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">muls</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs_list</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="InnerProduct"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.InnerProduct">[docs]</a><span class="k">class</span> <span class="nc">InnerProduct</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An unevaluated inner product between a bra and ket.</span>

<span class="sd">    Currently this class just reduces things to a product of</span>
<span class="sd">    Kronecker Deltas.  In the future, we could introduce abstract</span>
<span class="sd">    states like ``|a&gt;`` and ``|b&gt;``, and leave the inner product unevaluated as</span>
<span class="sd">    ``&lt;a|b&gt;``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">ket</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bra</span><span class="p">,</span> <span class="n">FockStateBra</span><span class="p">),</span> <span class="s">&#39;must be a bra&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ket</span><span class="p">,</span> <span class="n">FockStateKet</span><span class="p">),</span> <span class="s">&#39;must be a key&#39;</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">bra</span><span class="p">,</span> <span class="n">ket</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">bra</span><span class="p">,</span> <span class="n">ket</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bra</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ket</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">result</span> <span class="o">*=</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="InnerProduct.bra"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.InnerProduct.bra">[docs]</a>    <span class="k">def</span> <span class="nf">bra</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the bra part of the state&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="InnerProduct.ket"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.InnerProduct.ket">[docs]</a>    <span class="k">def</span> <span class="nf">ket</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the ket part of the state&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sbra</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bra</span><span class="p">)</span>
        <span class="n">sket</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ket</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">|</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sbra</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sket</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="matrix_rep"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.matrix_rep">[docs]</a><span class="k">def</span> <span class="nf">matrix_rep</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the representation of an operator in a basis.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import VarBosonicBasis, B, matrix_rep</span>
<span class="sd">    &gt;&gt;&gt; b = VarBosonicBasis(5)</span>
<span class="sd">    &gt;&gt;&gt; o = B(0)</span>
<span class="sd">    &gt;&gt;&gt; matrix_rep(o, b)</span>
<span class="sd">    [0, 1,       0,       0, 0]</span>
<span class="sd">    [0, 0, sqrt(2),       0, 0]</span>
<span class="sd">    [0, 0,       0, sqrt(3), 0]</span>
<span class="sd">    [0, 0,       0,       0, 2]</span>
<span class="sd">    [0, 0,       0,       0, 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)):</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">apply_operators</span><span class="p">(</span><span class="n">Dagger</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">op</span><span class="o">*</span><span class="n">basis</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">a</span>

</div>
<div class="viewcode-block" id="BosonicBasis"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.BosonicBasis">[docs]</a><span class="k">class</span> <span class="nc">BosonicBasis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for a basis set of bosonic Fock states.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="VarBosonicBasis"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.VarBosonicBasis">[docs]</a><span class="k">class</span> <span class="nc">VarBosonicBasis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single state, variable particle number basis set.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import VarBosonicBasis</span>
<span class="sd">    &gt;&gt;&gt; b = VarBosonicBasis(5)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    [FockState((0,)), FockState((1,)), FockState((2,)),</span>
<span class="sd">     FockState((3,)), FockState((4,))]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_max</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_max</span> <span class="o">=</span> <span class="n">n_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_states</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_max</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FockStateBosonKet</span><span class="p">([</span><span class="n">i</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_basis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>

<div class="viewcode-block" id="VarBosonicBasis.index"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.VarBosonicBasis.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of state in basis.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import VarBosonicBasis</span>
<span class="sd">        &gt;&gt;&gt; b = VarBosonicBasis(3)</span>
<span class="sd">        &gt;&gt;&gt; state = b.state(1)</span>
<span class="sd">        &gt;&gt;&gt; b</span>
<span class="sd">        [FockState((0,)), FockState((1,)), FockState((2,))]</span>
<span class="sd">        &gt;&gt;&gt; state</span>
<span class="sd">        FockStateBosonKet((1,))</span>
<span class="sd">        &gt;&gt;&gt; b.index(state)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="VarBosonicBasis.state"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.VarBosonicBasis.state">[docs]</a>    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The state of a single basis.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import VarBosonicBasis</span>
<span class="sd">        &gt;&gt;&gt; b = VarBosonicBasis(5)</span>
<span class="sd">        &gt;&gt;&gt; b.state(3)</span>
<span class="sd">        FockStateBosonKet((3,))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="FixedBosonicBasis"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.FixedBosonicBasis">[docs]</a><span class="k">class</span> <span class="nc">FixedBosonicBasis</span><span class="p">(</span><span class="n">BosonicBasis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fixed particle number basis set.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import FixedBosonicBasis</span>
<span class="sd">    &gt;&gt;&gt; b = FixedBosonicBasis(2, 2)</span>
<span class="sd">    &gt;&gt;&gt; state = b.state(1)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    [FockState((2, 0)), FockState((1, 1)), FockState((0, 2))]</span>
<span class="sd">    &gt;&gt;&gt; state</span>
<span class="sd">    FockStateBosonKet((1, 1))</span>
<span class="sd">    &gt;&gt;&gt; b.index(state)</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_particles</span><span class="p">,</span> <span class="n">n_levels</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span> <span class="o">=</span> <span class="n">n_particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span> <span class="o">=</span> <span class="n">n_levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_particle_locations</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_states</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_build_particle_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;i</span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span><span class="p">)]</span>
        <span class="n">first_loop</span> <span class="o">=</span> <span class="s">&quot;for i0 in range(</span><span class="si">%i</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span>
        <span class="n">other_loops</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">cur</span><span class="p">,</span> <span class="n">prev</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">tup</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="s">&quot;for </span><span class="si">%s</span><span class="s"> in range(</span><span class="si">%s</span><span class="s"> + 1) &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span>
            <span class="n">other_loops</span> <span class="o">=</span> <span class="n">other_loops</span> <span class="o">+</span> <span class="n">temp</span>
        <span class="n">tup_string</span> <span class="o">=</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>
        <span class="n">list_comp</span> <span class="o">=</span> <span class="s">&quot;[</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tup_string</span><span class="p">,</span> <span class="n">first_loop</span><span class="p">,</span> <span class="n">other_loops</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">list_comp</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_particles</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">item</span><span class="p">,)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span> <span class="o">=</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_build_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tuple_of_indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_locations</span><span class="p">:</span>
            <span class="n">occ_numbers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_levels</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">tuple_of_indices</span><span class="p">:</span>
                <span class="n">occ_numbers</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FockStateBosonKet</span><span class="p">(</span><span class="n">occ_numbers</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_basis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>

<div class="viewcode-block" id="FixedBosonicBasis.index"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.FixedBosonicBasis.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index of state in basis.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import FixedBosonicBasis</span>
<span class="sd">        &gt;&gt;&gt; b = FixedBosonicBasis(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; b.index(b.state(3))</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FixedBosonicBasis.state"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.FixedBosonicBasis.state">[docs]</a>    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the state that lies at index i of the basis</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import FixedBosonicBasis</span>
<span class="sd">        &gt;&gt;&gt; b = FixedBosonicBasis(2, 3)</span>
<span class="sd">        &gt;&gt;&gt; b.state(3)</span>
<span class="sd">        FockStateBosonKet((1, 0, 1))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">)</span>


<span class="c"># def move(e, i, d):</span>
<span class="c">#     &quot;&quot;&quot;</span>
<span class="c">#     Takes the expression &quot;e&quot; and moves the operator at the position i by &quot;d&quot;.</span>
<span class="c">#     &quot;&quot;&quot;</span>
<span class="c">#     if e.is_Mul:</span>
<span class="c">#         if d == 1:</span>
<span class="c">#             # e = a*b*c*d</span>
<span class="c">#             a = Mul(*e.args[:i])</span>
<span class="c">#             b = e.args[i]</span>
<span class="c">#             c = e.args[i+1]</span>
<span class="c">#             d = Mul(*e.args[i+2:])</span>
<span class="c">#             if isinstance(b, Dagger) and not isinstance(c, Dagger):</span>
<span class="c">#                 i, j = b.args[0].args[0], c.args[0]</span>
<span class="c">#                 return a*c*b*d-a*KroneckerDelta(i, j)*d</span>
<span class="c">#             elif not isinstance(b, Dagger) and isinstance(c, Dagger):</span>
<span class="c">#                 i, j = b.args[0], c.args[0].args[0]</span>
<span class="c">#                 return a*c*b*d-a*KroneckerDelta(i, j)*d</span>
<span class="c">#             else:</span>
<span class="c">#                 return a*c*b*d</span>
<span class="c">#         elif d == -1:</span>
<span class="c">#             # e = a*b*c*d</span>
<span class="c">#             a = Mul(*e.args[:i-1])</span>
<span class="c">#             b = e.args[i-1]</span>
<span class="c">#             c = e.args[i]</span>
<span class="c">#             d = Mul(*e.args[i+1:])</span>
<span class="c">#             if isinstance(b, Dagger) and not isinstance(c, Dagger):</span>
<span class="c">#                 i, j = b.args[0].args[0], c.args[0]</span>
<span class="c">#                 return a*c*b*d-a*KroneckerDelta(i, j)*d</span>
<span class="c">#             elif not isinstance(b, Dagger) and isinstance(c, Dagger):</span>
<span class="c">#                 i, j = b.args[0], c.args[0].args[0]</span>
<span class="c">#                 return a*c*b*d-a*KroneckerDelta(i, j)*d</span>
<span class="c">#             else:</span>
<span class="c">#                 return a*c*b*d</span>
<span class="c">#         else:</span>
<span class="c">#             if d &gt; 1:</span>
<span class="c">#                 while d &gt;= 1:</span>
<span class="c">#                     e = move(e, i, 1)</span>
<span class="c">#                     d -= 1</span>
<span class="c">#                     i += 1</span>
<span class="c">#                 return e</span>
<span class="c">#             elif d &lt; -1:</span>
<span class="c">#                 while d &lt;= -1:</span>
<span class="c">#                     e = move(e, i, -1)</span>
<span class="c">#                     d += 1</span>
<span class="c">#                     i -= 1</span>
<span class="c">#                 return e</span>
<span class="c">#     elif isinstance(e, Add):</span>
<span class="c">#         a, b = e.as_two_terms()</span>
<span class="c">#         return move(a, i, d) + move(b, i, d)</span>
<span class="c">#     raise NotImplementedError()</span>
</div>
<div class="viewcode-block" id="Commutator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.Commutator">[docs]</a><span class="k">class</span> <span class="nc">Commutator</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The Commutator:  [A, B] = A*B - B*A</span>

<span class="sd">    The arguments are ordered according to .__cmp__()</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import Commutator</span>
<span class="sd">    &gt;&gt;&gt; A, B = symbols(&#39;A,B&#39;, commutative=False)</span>
<span class="sd">    &gt;&gt;&gt; Commutator(B, A)</span>
<span class="sd">    -Commutator(A, B)</span>

<span class="sd">    Evaluate the commutator with .doit()</span>

<span class="sd">    &gt;&gt;&gt; comm = Commutator(A,B); comm</span>
<span class="sd">    Commutator(A, B)</span>
<span class="sd">    &gt;&gt;&gt; comm.doit()</span>
<span class="sd">    A*B - B*A</span>


<span class="sd">    For two second quantization operators the commutator is evaluated</span>
<span class="sd">    immediately:</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import Fd, F</span>
<span class="sd">    &gt;&gt;&gt; a = symbols(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">    &gt;&gt;&gt; i = symbols(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">    &gt;&gt;&gt; p,q = symbols(&#39;p,q&#39;)</span>

<span class="sd">    &gt;&gt;&gt; Commutator(Fd(a),Fd(i))</span>
<span class="sd">    2*NO(CreateFermion(a)*CreateFermion(i))</span>

<span class="sd">    But for more complicated expressions, the evaluation is triggered by</span>
<span class="sd">    a call to .doit()</span>

<span class="sd">    &gt;&gt;&gt; comm = Commutator(Fd(p)*Fd(q),F(i)); comm</span>
<span class="sd">    Commutator(CreateFermion(p)*CreateFermion(q), AnnihilateFermion(i))</span>
<span class="sd">    &gt;&gt;&gt; comm.doit(wicks=True)</span>
<span class="sd">    -KroneckerDelta(p, i)*CreateFermion(q) +</span>
<span class="sd">     KroneckerDelta(q, i)*CreateFermion(p)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">nargs</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Commutator.eval"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.Commutator.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Commutator [A,B] is on canonical form if A &lt; B.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import Commutator, F, Fd</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; c1 = Commutator(F(x), Fd(x))</span>
<span class="sd">        &gt;&gt;&gt; c2 = Commutator(Fd(x), F(x))</span>
<span class="sd">        &gt;&gt;&gt; Commutator.eval(c1, c2)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c">#</span>
        <span class="c"># [A+B,C]  -&gt;  [A,C] + [B,C]</span>
        <span class="c">#</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">cls</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">cls</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="c">#</span>
        <span class="c"># [xA,yB]  -&gt;  xy*[A,B]</span>
        <span class="c">#</span>
        <span class="n">ca</span><span class="p">,</span> <span class="n">nca</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
        <span class="n">cb</span><span class="p">,</span> <span class="n">ncb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
        <span class="n">c_part</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c_part</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">c_part</span><span class="p">),</span> <span class="n">cls</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">nca</span><span class="p">),</span> <span class="n">Mul</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">ncb</span><span class="p">)))</span>

        <span class="c">#</span>
        <span class="c"># single second quantization operators</span>
        <span class="c">#</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">BosonicOperator</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">BosonicOperator</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">CreateBoson</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">AnnihilateBoson</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">CreateBoson</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">AnnihilateBoson</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="o">*</span><span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">FermionicOperator</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">FermionicOperator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">wicks</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">wicks</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>

        <span class="c">#</span>
        <span class="c"># Canonical ordering of arguments</span>
        <span class="c">#</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">sort_key</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">sort_key</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="o">*</span><span class="n">cls</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Commutator.doit"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.Commutator.doit">[docs]</a>    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enables the computation of complex expressions.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import Commutator, F, Fd</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; i, j = symbols(&#39;i,j&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; a, b = symbols(&#39;a,b&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; c = Commutator(Fd(a)*F(i),Fd(b)*F(j))</span>
<span class="sd">        &gt;&gt;&gt; c.doit(wicks=True)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;wicks&quot;</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">wicks</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">wicks</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ContractionAppliesOnlyToFermions</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">except</span> <span class="n">WicksTheoremDoesNotApply</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">hints</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Commutator(</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;[</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">left[</span><span class="si">%s</span><span class="s">,</span><span class="si">%s</span><span class="se">\\</span><span class="s">right]&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">([</span>
            <span class="n">printer</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

</div>
<div class="viewcode-block" id="NO"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.NO">[docs]</a><span class="k">class</span> <span class="nc">NO</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This Object is used to represent normal ordering brackets.</span>

<span class="sd">    i.e.  {abcd}  sometimes written  :abcd:</span>

<span class="sd">    Applying the function NO(arg) to an argument means that all operators in</span>
<span class="sd">    the argument will be assumed to anticommute, and have vanishing</span>
<span class="sd">    contractions.  This allows an immediate reordering to canonical form</span>
<span class="sd">    upon object creation.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import NO, F, Fd</span>
<span class="sd">    &gt;&gt;&gt; p,q = symbols(&#39;p,q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; NO(Fd(p)*F(q))</span>
<span class="sd">    NO(CreateFermion(p)*AnnihilateFermion(q))</span>
<span class="sd">    &gt;&gt;&gt; NO(F(q)*Fd(p))</span>
<span class="sd">    -NO(CreateFermion(p)*AnnihilateFermion(q))</span>


<span class="sd">    Note:</span>
<span class="sd">    If you want to generate a normal ordered equivalent of an expression, you</span>
<span class="sd">    should use the function wicks().  This class only indicates that all</span>
<span class="sd">    operators inside the brackets anticommute, and have vanishing contractions.</span>
<span class="sd">    Nothing more, nothing less.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nargs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use anticommutation to get canonical form of operators.</span>

<span class="sd">        Employ associativity of normal ordered product: {ab{cd}} = {abcd}</span>
<span class="sd">        but note that {ab}{cd} /= {abcd}.</span>

<span class="sd">        We also employ distributivity: {ab + cd} = {ab} + {cd}.</span>

<span class="sd">        Canonical form also implies expand() {ab(c+d)} = {abc} + {abd}.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># {ab + cd} = {ab} + {cd}</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span> <span class="n">cls</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>

            <span class="c"># take coefficient outside of normal ordering brackets</span>
            <span class="n">c_part</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">c_part</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">c_part</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">coeff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

            <span class="c"># {ab{cd}} = {abcd}</span>
            <span class="n">newseq</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">foundit</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fac</span><span class="p">,</span> <span class="n">NO</span><span class="p">):</span>
                    <span class="n">newseq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">fac</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                    <span class="n">foundit</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newseq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fac</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">foundit</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">cls</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">newseq</span><span class="p">))</span>

            <span class="c"># We assume that the user don&#39;t mix B and F operators</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BosonicOperator</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">newseq</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">_sort_anticommuting_fermions</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ViolationOfPauliPrinciple</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

            <span class="k">if</span> <span class="n">sign</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="o">*</span><span class="n">coeff</span><span class="p">)</span><span class="o">*</span><span class="n">cls</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">newseq</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">sign</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">cls</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">newseq</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c"># since sign==0, no permutations was necessary</span>

            <span class="c"># if we couldn&#39;t do anything with Mul object, we just</span>
            <span class="c"># mark it as normal ordered</span>
            <span class="k">if</span> <span class="n">coeff</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">cls</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">newseq</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">Expr</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">newseq</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">NO</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">arg</span>

        <span class="c"># if object was not Mul or Add, normal ordering does not apply</span>
        <span class="k">return</span> <span class="n">arg</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="NO.has_q_creators"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.NO.has_q_creators">[docs]</a>    <span class="k">def</span> <span class="nf">has_q_creators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return 0 if the leftmost argument of the first argument is a not a</span>
<span class="sd">        q_creator, else 1 if it is above fermi or -1 if it is below fermi.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import NO, F, Fd</span>

<span class="sd">        &gt;&gt;&gt; a = symbols(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = symbols(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; NO(Fd(a)*Fd(i)).has_q_creators</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; NO(F(i)*F(a)).has_q_creators</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; NO(Fd(i)*F(a)).has_q_creators           #doctest: +SKIP</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_q_creator</span>
</div>
    <span class="nd">@property</span>
<div class="viewcode-block" id="NO.has_q_annihilators"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.NO.has_q_annihilators">[docs]</a>    <span class="k">def</span> <span class="nf">has_q_annihilators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return 0 if the rightmost argument of the first argument is a not a</span>
<span class="sd">        q_annihilator, else 1 if it is above fermi or -1 if it is below fermi.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import NO, F, Fd</span>

<span class="sd">        &gt;&gt;&gt; a = symbols(&#39;a&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; i = symbols(&#39;i&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; NO(Fd(a)*Fd(i)).has_q_annihilators</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; NO(F(i)*F(a)).has_q_annihilators</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; NO(Fd(a)*F(i)).has_q_annihilators</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_q_annihilator</span>
</div>
<div class="viewcode-block" id="NO.doit"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.NO.doit">[docs]</a>    <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Either removes the brackets or enables complex computations</span>
<span class="sd">        in its arguments.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import NO, Fd, F</span>
<span class="sd">        &gt;&gt;&gt; from textwrap import fill</span>
<span class="sd">        &gt;&gt;&gt; from sympy import symbols, Dummy</span>
<span class="sd">        &gt;&gt;&gt; p,q = symbols(&#39;p,q&#39;, cls=Dummy)</span>
<span class="sd">        &gt;&gt;&gt; print(fill(str(NO(Fd(p)*F(q)).doit())))</span>
<span class="sd">        KroneckerDelta(_a, _p)*KroneckerDelta(_a,</span>
<span class="sd">        _q)*CreateFermion(_a)*AnnihilateFermion(_a) + KroneckerDelta(_a,</span>
<span class="sd">        _p)*KroneckerDelta(_i, _q)*CreateFermion(_a)*AnnihilateFermion(_i) -</span>
<span class="sd">        KroneckerDelta(_a, _q)*KroneckerDelta(_i,</span>
<span class="sd">        _p)*AnnihilateFermion(_a)*CreateFermion(_i) - KroneckerDelta(_i,</span>
<span class="sd">        _p)*KroneckerDelta(_i, _q)*AnnihilateFermion(_i)*CreateFermion(_i)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">kw_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;remove_brackets&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_brackets</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="o">**</span><span class="n">kw_args</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">_remove_brackets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sorted string without normal order brackets.</span>

<span class="sd">        The returned string have the property that no nonzero</span>
<span class="sd">        contractions exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># check if any creator is also an annihilator</span>
        <span class="n">subslist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_q_creators</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_q_annihilator</span><span class="p">:</span>
                <span class="n">assume</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span>

                <span class="c"># only operators with a dummy index can be split in two terms</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">):</span>

                    <span class="c"># create indices with fermi restriction</span>
                    <span class="n">assume</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;above_fermi&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="n">assume</span><span class="p">[</span><span class="s">&quot;below_fermi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">below</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">assume</span><span class="p">)</span>
                    <span class="n">assume</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&quot;below_fermi&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="n">assume</span><span class="p">[</span><span class="s">&quot;above_fermi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">above</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">assume</span><span class="p">)</span>

                    <span class="n">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">split</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">below</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">below</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
                        <span class="o">+</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">above</span><span class="p">)</span>
                        <span class="o">*</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">above</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">subslist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">split</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SubstitutionOfAmbigousOperatorFailed</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">subslist</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">NO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subslist</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">term</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_expand_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a sum of NO objects that contain no ambiguous q-operators.</span>

<span class="sd">        If an index q has range both above and below fermi, the operator F(q)</span>
<span class="sd">        is ambiguous in the sense that it can be both a q-creator and a q-annihilator.</span>
<span class="sd">        If q is dummy, it is assumed to be a summation variable and this method</span>
<span class="sd">        rewrites it into a sum of NO terms with unambiguous operators:</span>

<span class="sd">        {Fd(p)*F(q)} = {Fd(a)*F(b)} + {Fd(a)*F(i)} + {Fd(j)*F(b)} -{F(i)*Fd(j)}</span>

<span class="sd">        where a,b are above and i,j are below fermi level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_remove_brackets</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

<div class="viewcode-block" id="NO.iter_q_annihilators"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.NO.iter_q_annihilators">[docs]</a>    <span class="k">def</span> <span class="nf">iter_q_annihilators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over the annihilation operators.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; i, j = symbols(&#39;i j&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; a, b = symbols(&#39;a b&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import NO, F, Fd</span>
<span class="sd">        &gt;&gt;&gt; no = NO(Fd(a)*F(i)*F(b)*Fd(j))</span>

<span class="sd">        &gt;&gt;&gt; no.iter_q_creators()</span>
<span class="sd">        &lt;generator object... at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; list(no.iter_q_creators())</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; list(no.iter_q_annihilators())</span>
<span class="sd">        [3, 2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_q_annihilator</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
</div>
<div class="viewcode-block" id="NO.iter_q_creators"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.NO.iter_q_creators">[docs]</a>    <span class="k">def</span> <span class="nf">iter_q_creators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates over the creation operators.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; i, j = symbols(&#39;i j&#39;, below_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; a, b = symbols(&#39;a b&#39;, above_fermi=True)</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import NO, F, Fd</span>
<span class="sd">        &gt;&gt;&gt; no = NO(Fd(a)*F(i)*F(b)*Fd(j))</span>

<span class="sd">        &gt;&gt;&gt; no.iter_q_creators()</span>
<span class="sd">        &lt;generator object... at 0x...&gt;</span>
<span class="sd">        &gt;&gt;&gt; list(no.iter_q_creators())</span>
<span class="sd">        [0, 1]</span>
<span class="sd">        &gt;&gt;&gt; list(no.iter_q_annihilators())</span>
<span class="sd">        [3, 2]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_q_creator</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
</div>
<div class="viewcode-block" id="NO.get_subNO"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.NO.get_subNO">[docs]</a>    <span class="k">def</span> <span class="nf">get_subNO</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a NO() without FermionicOperator at index i.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import F, NO</span>
<span class="sd">        &gt;&gt;&gt; p,q,r = symbols(&#39;p,q,r&#39;)</span>

<span class="sd">        &gt;&gt;&gt; NO(F(p)*F(q)*F(r)).get_subNO(1)  # doctest: +SKIP</span>
<span class="sd">        NO(AnnihilateFermion(p)*AnnihilateFermion(r))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arg0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># it&#39;s a Mul by definition of how it&#39;s created</span>
        <span class="n">mul</span> <span class="o">=</span> <span class="n">arg0</span><span class="o">.</span><span class="n">_new_rawargs</span><span class="p">(</span><span class="n">arg0</span><span class="o">.</span><span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">arg0</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">NO</span><span class="p">(</span><span class="n">mul</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">left</span><span class="se">\\</span><span class="s">{</span><span class="si">%s</span><span class="se">\\</span><span class="s">right</span><span class="se">\\</span><span class="s">}&quot;</span> <span class="o">%</span> <span class="n">printer</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;NO(</span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;:</span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="c"># @cacheit</span></div>
<div class="viewcode-block" id="contraction"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.contraction">[docs]</a><span class="k">def</span> <span class="nf">contraction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates contraction of Fermionic operators a and b.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import F, Fd, contraction</span>
<span class="sd">    &gt;&gt;&gt; p, q = symbols(&#39;p,q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a, b = symbols(&#39;a,b&#39;, above_fermi=True)</span>
<span class="sd">    &gt;&gt;&gt; i, j = symbols(&#39;i,j&#39;, below_fermi=True)</span>

<span class="sd">    A contraction is non-zero only if a quasi-creator is to the right of a</span>
<span class="sd">    quasi-annihilator:</span>

<span class="sd">    &gt;&gt;&gt; contraction(F(a),Fd(b))</span>
<span class="sd">    KroneckerDelta(a, b)</span>
<span class="sd">    &gt;&gt;&gt; contraction(Fd(i),F(j))</span>
<span class="sd">    KroneckerDelta(i, j)</span>

<span class="sd">    For general indices a non-zero result restricts the indices to below/above</span>
<span class="sd">    the fermi surface:</span>

<span class="sd">    &gt;&gt;&gt; contraction(Fd(p),F(q))</span>
<span class="sd">    KroneckerDelta(p, q)*KroneckerDelta(q, _i)</span>
<span class="sd">    &gt;&gt;&gt; contraction(F(p),Fd(q))</span>
<span class="sd">    KroneckerDelta(p, q)*KroneckerDelta(q, _a)</span>

<span class="sd">    Two creators or two annihilators always vanishes:</span>

<span class="sd">    &gt;&gt;&gt; contraction(F(p),F(q))</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; contraction(Fd(p),Fd(q))</span>
<span class="sd">    0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">FermionicOperator</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">FermionicOperator</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">AnnihilateFermion</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">CreateFermion</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;below_fermi&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;below_fermi&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;above_fermi&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;above_fermi&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">)</span><span class="o">*</span>
                    <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">above_fermi</span><span class="o">=</span><span class="bp">True</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">AnnihilateFermion</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">CreateFermion</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;above_fermi&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;above_fermi&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;below_fermi&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;below_fermi&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">)</span><span class="o">*</span>
                    <span class="n">KroneckerDelta</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="n">below_fermi</span><span class="o">=</span><span class="bp">True</span><span class="p">)))</span>

        <span class="c"># vanish if 2xAnnihilator or 2xCreator</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c">#not fermion operators</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">FermionicOperator</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">raise</span> <span class="n">ContractionAppliesOnlyToFermions</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_sqkey</span><span class="p">(</span><span class="n">sq_operator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates key for canonical sorting of SQ operators.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sq_operator</span><span class="o">.</span><span class="n">_sortkey</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_sort_anticommuting_fermions</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_sqkey</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort fermionic operators to canonical order, assuming all pairs anticommute.</span>

<span class="sd">    Uses a bidirectional bubble sort.  Items in string1 are not referenced</span>
<span class="sd">    so in principle they may be any comparable objects.   The sorting depends on the</span>
<span class="sd">    operators &#39;&gt;&#39; and &#39;==&#39;.</span>

<span class="sd">    If the Pauli principle is violated, an exception is raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    tuple (sorted_str, sign)</span>

<span class="sd">    sorted_str: list containing the sorted operators</span>
<span class="sd">    sign: int telling how many times the sign should be changed</span>
<span class="sd">          (if sign==0 the string was already sorted)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">verified</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">string1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">rev</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">string1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">string1</span><span class="p">))</span>
    <span class="n">key_val</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">string1</span><span class="p">)))</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">verified</span><span class="p">:</span>
        <span class="n">verified</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rng</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ViolationOfPauliPrinciple</span><span class="p">([</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">verified</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">]</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">verified</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rev</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ViolationOfPauliPrinciple</span><span class="p">([</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">verified</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">]</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">string1</span> <span class="o">=</span> <span class="p">[</span> <span class="n">key_val</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span> <span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">sign</span><span class="p">)</span>


<div class="viewcode-block" id="evaluate_deltas"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.evaluate_deltas">[docs]</a><span class="k">def</span> <span class="nf">evaluate_deltas</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We evaluate KroneckerDelta symbols in the expression assuming Einstein summation.</span>

<span class="sd">    If one index is repeated it is summed over and in effect substituted with</span>
<span class="sd">    the other one. If both indices are repeated we substitute according to what</span>
<span class="sd">    is the preferred index.  this is determined by</span>
<span class="sd">    KroneckerDelta.preferred_index and KroneckerDelta.killable_index.</span>

<span class="sd">    In case there are no possible substitutions or if a substitution would</span>
<span class="sd">    imply a loss of information, nothing is done.</span>

<span class="sd">    In case an index appears in more than one KroneckerDelta, the resulting</span>
<span class="sd">    substitution depends on the order of the factors.  Since the ordering is platform</span>
<span class="sd">    dependent, the literal expression resulting from this function may be hard to</span>
<span class="sd">    predict.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    We assume the following:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Function, Dummy, KroneckerDelta</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import evaluate_deltas</span>
<span class="sd">    &gt;&gt;&gt; i,j = symbols(&#39;i j&#39;, below_fermi=True, cls=Dummy)</span>
<span class="sd">    &gt;&gt;&gt; a,b = symbols(&#39;a b&#39;, above_fermi=True, cls=Dummy)</span>
<span class="sd">    &gt;&gt;&gt; p,q = symbols(&#39;p q&#39;, cls=Dummy)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; t = Function(&#39;t&#39;)</span>

<span class="sd">    The order of preference for these indices according to KroneckerDelta is</span>
<span class="sd">    (a, b, i, j, p, q).</span>

<span class="sd">    Trivial cases:</span>

<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(i,j)*f(i))       # d_ij f(i) -&gt; f(j)</span>
<span class="sd">    f(_j)</span>
<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(i,j)*f(j))       # d_ij f(j) -&gt; f(i)</span>
<span class="sd">    f(_i)</span>
<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(i,p)*f(p))       # d_ip f(p) -&gt; f(i)</span>
<span class="sd">    f(_i)</span>
<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(q,p)*f(p))       # d_qp f(p) -&gt; f(q)</span>
<span class="sd">    f(_q)</span>
<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(q,p)*f(q))       # d_qp f(q) -&gt; f(p)</span>
<span class="sd">    f(_p)</span>

<span class="sd">    More interesting cases:</span>

<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(i,p)*t(a,i)*f(p,q))</span>
<span class="sd">    f(_i, _q)*t(_a, _i)</span>
<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(a,p)*t(a,i)*f(p,q))</span>
<span class="sd">    f(_a, _q)*t(_a, _i)</span>
<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(p,q)*f(p,q))</span>
<span class="sd">    f(_p, _p)</span>

<span class="sd">    Finally, here are some cases where nothing is done, because that would</span>
<span class="sd">    imply a loss of information:</span>

<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(i,p)*f(q))</span>
<span class="sd">    f(_q)*KroneckerDelta(_i, _p)</span>
<span class="sd">    &gt;&gt;&gt; evaluate_deltas(KroneckerDelta(i,p)*f(i))</span>
<span class="sd">    f(_i)*KroneckerDelta(_i, _p)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># We treat Deltas only in mul objects</span>
    <span class="c"># for general function objects we don&#39;t evaluate KroneckerDeltas in arguments,</span>
    <span class="c"># but here we hard code exceptions to this rule</span>
    <span class="n">accepted_functions</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">Add</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">accepted_functions</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">evaluate_deltas</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>
        <span class="c"># find all occurences of delta function and count each index present in</span>
        <span class="c"># expression.</span>
        <span class="n">deltas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">atoms</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">indices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indices</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># geek counting simplifies logic below</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">KroneckerDelta</span><span class="p">):</span>
                <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deltas</span><span class="p">:</span>
            <span class="c"># If we do something, and there are more deltas, we should recurse</span>
            <span class="c"># to treat the resulting expression properly</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">killable_index</span><span class="p">]:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">killable_index</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">preferred_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">evaluate_deltas</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">indices</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">preferred_index</span><span class="p">]</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">indices_contain_equal_information</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">preferred_index</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">killable_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">evaluate_deltas</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">e</span>
    <span class="c"># nothing to do, maybe we hit a Symbol or a number</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>

</div>
<div class="viewcode-block" id="substitute_dummies"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.substitute_dummies">[docs]</a><span class="k">def</span> <span class="nf">substitute_dummies</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">new_indices</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">pretty_indices</span><span class="o">=</span><span class="p">{}):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect terms by substitution of dummy variables.</span>

<span class="sd">    This routine allows simplification of Add expressions containing terms</span>
<span class="sd">    which differ only due to dummy variables.</span>

<span class="sd">    The idea is to substitute all dummy variables consistently depending on</span>
<span class="sd">    the structure of the term.  For each term, we obtain a sequence of all</span>
<span class="sd">    dummy variables, where the order is determined by the index range, what</span>
<span class="sd">    factors the index belongs to and its position in each factor.  See</span>
<span class="sd">    _get_ordered_dummies() for more inforation about the sorting of dummies.</span>
<span class="sd">    The index sequence is then substituted consistently in each term.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Function, Dummy</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import substitute_dummies</span>
<span class="sd">    &gt;&gt;&gt; a,b,c,d = symbols(&#39;a b c d&#39;, above_fermi=True, cls=Dummy)</span>
<span class="sd">    &gt;&gt;&gt; i,j = symbols(&#39;i j&#39;, below_fermi=True, cls=Dummy)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    &gt;&gt;&gt; expr = f(a,b) + f(c,d); expr</span>
<span class="sd">    f(_a, _b) + f(_c, _d)</span>

<span class="sd">    Since a, b, c and d are equivalent summation indices, the expression can be</span>
<span class="sd">    simplified to a single term (for which the dummy indices are still summed over)</span>

<span class="sd">    &gt;&gt;&gt; substitute_dummies(expr)</span>
<span class="sd">    2*f(_a, _b)</span>


<span class="sd">    Controlling output:</span>

<span class="sd">    By default the dummy symbols that are already present in the expression</span>
<span class="sd">    will be reused in a different permuation.  However, if new_indices=True,</span>
<span class="sd">    new dummies will be generated and inserted.  The keyword &#39;pretty_indices&#39;</span>
<span class="sd">    can be used to control this generation of new symbols.</span>

<span class="sd">    By default the new dummies will be generated on the form i_1, i_2, a_1,</span>
<span class="sd">    etc.  If you supply a dictionary with key:value pairs in the form:</span>

<span class="sd">        { index_group: string_of_letters }</span>

<span class="sd">    The letters will be used as labels for the new dummy symbols.  The</span>
<span class="sd">    index_groups must be one of &#39;above&#39;, &#39;below&#39; or &#39;general&#39;.</span>

<span class="sd">    &gt;&gt;&gt; expr = f(a,b,i,j)</span>
<span class="sd">    &gt;&gt;&gt; my_dummies = { &#39;above&#39;:&#39;st&#39;, &#39;below&#39;:&#39;uv&#39; }</span>
<span class="sd">    &gt;&gt;&gt; substitute_dummies(expr, new_indices=True, pretty_indices=my_dummies)</span>
<span class="sd">    f(_s, _t, _u, _v)</span>

<span class="sd">    If we run out of letters, or if there is no keyword for some index_group</span>
<span class="sd">    the default dummy generator will be used as a fallback:</span>

<span class="sd">    &gt;&gt;&gt; p,q = symbols(&#39;p q&#39;, cls=Dummy)  # general indices</span>
<span class="sd">    &gt;&gt;&gt; expr = f(p,q)</span>
<span class="sd">    &gt;&gt;&gt; substitute_dummies(expr, new_indices=True, pretty_indices=my_dummies)</span>
<span class="sd">    f(_p_0, _p_1)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># setup the replacing dummies</span>
    <span class="k">if</span> <span class="n">new_indices</span><span class="p">:</span>
        <span class="n">letters_above</span> <span class="o">=</span> <span class="n">pretty_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;above&#39;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="n">letters_below</span> <span class="o">=</span> <span class="n">pretty_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;below&#39;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="n">letters_general</span> <span class="o">=</span> <span class="n">pretty_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;general&#39;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="n">len_above</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">letters_above</span><span class="p">)</span>
        <span class="n">len_below</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">letters_below</span><span class="p">)</span>
        <span class="n">len_general</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">letters_general</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_i</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">letters_below</span><span class="p">[</span><span class="n">number</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;i_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span> <span class="o">-</span> <span class="n">len_below</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_a</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">letters_above</span><span class="p">[</span><span class="n">number</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;a_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span> <span class="o">-</span> <span class="n">len_above</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_p</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">letters_general</span><span class="p">[</span><span class="n">number</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">&#39;p_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">number</span> <span class="o">-</span> <span class="n">len_general</span><span class="p">)</span>

    <span class="n">aboves</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">belows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">generals</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">dummies</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Dummy</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">new_indices</span><span class="p">:</span>
        <span class="n">dummies</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dummies</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

    <span class="c"># generate lists with the dummies we will insert</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dummies</span><span class="p">:</span>
        <span class="n">assum</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">assumptions0</span>

        <span class="k">if</span> <span class="n">assum</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;above_fermi&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_indices</span><span class="p">:</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">_a</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">aboves</span>
        <span class="k">elif</span> <span class="n">assum</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;below_fermi&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">new_indices</span><span class="p">:</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">_i</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">belows</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_indices</span><span class="p">:</span>
                <span class="n">sym</span> <span class="o">=</span> <span class="n">_p</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">l1</span> <span class="o">=</span> <span class="n">generals</span>

        <span class="k">if</span> <span class="n">new_indices</span><span class="p">:</span>
            <span class="n">l1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Dummy</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">assum</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
    <span class="n">terms</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">new_terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">belows</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">aboves</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">generals</span><span class="p">)</span>
        <span class="n">ordered</span> <span class="o">=</span> <span class="n">_get_ordered_dummies</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="n">subsdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;below_fermi&#39;</span><span class="p">):</span>
                <span class="n">subsdict</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;above_fermi&#39;</span><span class="p">):</span>
                <span class="n">subsdict</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subsdict</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">subslist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_subs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">subsdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">subsdict</span><span class="p">:</span>
                <span class="c"># We check if the sequence of substitutions end quickly.  In</span>
                <span class="c"># that case, we can avoid temporary symbols if we ensure the</span>
                <span class="c"># correct substitution order.</span>
                <span class="k">if</span> <span class="n">subsdict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="ow">in</span> <span class="n">subsdict</span><span class="p">:</span>
                    <span class="c"># (x, y) -&gt; (y, x),  we need a temporary variable</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
                    <span class="n">subslist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
                    <span class="n">final_subs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># (x, y) -&gt; (y, a),  x-&gt;y must be done last</span>
                    <span class="c"># but before temporary variables are resolved</span>
                    <span class="n">final_subs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subslist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="n">subslist</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">final_subs</span><span class="p">)</span>
        <span class="n">new_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subslist</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">new_terms</span><span class="p">)</span>

</div>
<span class="k">class</span> <span class="nc">KeyPrinter</span><span class="p">(</span><span class="n">StrPrinter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Printer for which only equal objects are equal in print&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_print_Dummy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s">_</span><span class="si">%i</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">dummy_index</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">__kprint</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">KeyPrinter</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">doprint</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_ordered_dummies</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns all dummies in the mul sorted in canonical order</span>

<span class="sd">    The purpose of the canonical ordering is that dummies can be substituted</span>
<span class="sd">    consistently across terms with the result that equivalent terms can be</span>
<span class="sd">    simplified.</span>

<span class="sd">    It is not possible to determine if two terms are equivalent based solely on</span>
<span class="sd">    the dummy order.  However, a consistent substitution guided by the ordered</span>
<span class="sd">    dummies should lead to trivially (non-)equivalent terms, thereby revealing</span>
<span class="sd">    the equivalence.  This also means that if two terms have identical sequences of</span>
<span class="sd">    dummies, the (non-)equivalence should already be apparent.</span>

<span class="sd">    Strategy</span>
<span class="sd">    --------</span>

<span class="sd">    The canoncial order is given by an arbitrary sorting rule.  A sort key</span>
<span class="sd">    is determined for each dummy as a tuple that depends on all factors where</span>
<span class="sd">    the index is present.  The dummies are thereby sorted according to the</span>
<span class="sd">    contraction structure of the term, instead of sorting based solely on the</span>
<span class="sd">    dummy symbol itself.</span>

<span class="sd">    After all dummies in the term has been assigned a key, we check for identical</span>
<span class="sd">    keys, i.e. unorderable dummies.  If any are found, we call a specialized</span>
<span class="sd">    method, _determine_ambiguous(), that will determine a unique order based</span>
<span class="sd">    on recursive calls to _get_ordered_dummies().</span>

<span class="sd">    Key description</span>
<span class="sd">    ---------------</span>

<span class="sd">    A high level description of the sort key:</span>

<span class="sd">        1. Range of the dummy index</span>
<span class="sd">        2. Relation to external (non-dummy) indices</span>
<span class="sd">        3. Position of the index in the first factor</span>
<span class="sd">        4. Position of the index in the second factor</span>

<span class="sd">    The sort key is a tuple with the following components:</span>

<span class="sd">        1. A single character indicating the range of the dummy (above, below</span>
<span class="sd">           or general.)</span>
<span class="sd">        2. A list of strings with fully masked string representations of all</span>
<span class="sd">           factors where the dummy is present.  By masked, we mean that dummies</span>
<span class="sd">           are represented by a symbol to indicate either below fermi, above or</span>
<span class="sd">           general.  No other information is displayed about the dummies at</span>
<span class="sd">           this point.  The list is sorted stringwise.</span>
<span class="sd">        3. An integer number indicating the position of the index, in the first</span>
<span class="sd">           factor as sorted in 2.</span>
<span class="sd">        4. An integer number indicating the position of the index, in the second</span>
<span class="sd">           factor as sorted in 2.</span>

<span class="sd">    If a factor is either of type AntiSymmetricTensor or SqOperator, the index</span>
<span class="sd">    position in items 3 and 4 is indicated as &#39;upper&#39; or &#39;lower&#39; only.</span>
<span class="sd">    (Creation operators are considered upper and annihilation operators lower.)</span>

<span class="sd">    If the masked factors are identical, the two factors cannot be ordered</span>
<span class="sd">    unambiguously in item 2.  In this case, items 3, 4 are left out.  If several</span>
<span class="sd">    indices are contracted between the unorderable factors, it will be handled by</span>
<span class="sd">    _determine_ambiguous()</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># setup dicts to avoid repeated calculations in key()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">mul</span><span class="p">)</span>
    <span class="n">fac_dum</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">fac</span><span class="p">,</span> <span class="n">fac</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Dummy</span><span class="p">))</span> <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span> <span class="p">)</span>
    <span class="n">fac_repr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">fac</span><span class="p">,</span> <span class="n">__kprint</span><span class="p">(</span><span class="n">fac</span><span class="p">))</span> <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span> <span class="p">)</span>
    <span class="n">all_dums</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fac_dum</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="nb">set</span><span class="p">())</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">all_dums</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;below_fermi&#39;</span><span class="p">):</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;0&#39;</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">assumptions0</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;above_fermi&#39;</span><span class="p">):</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;1&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;2&#39;</span>
    <span class="n">dum_repr</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">__kprint</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">all_dums</span> <span class="p">])</span>

    <span class="k">def</span> <span class="nf">_key</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">dumstruct</span> <span class="o">=</span> <span class="p">[</span> <span class="n">fac</span> <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">fac_dum</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">fac_dum</span><span class="p">[</span><span class="n">fac</span><span class="p">]</span> <span class="p">]</span>
        <span class="n">other_dums</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span>
            <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="p">[</span> <span class="n">fac_dum</span><span class="p">[</span><span class="n">fac</span><span class="p">]</span> <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">dumstruct</span> <span class="p">],</span> <span class="nb">set</span><span class="p">())</span>
        <span class="n">fac</span> <span class="o">=</span> <span class="n">dumstruct</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">other_dums</span> <span class="ow">is</span> <span class="n">fac_dum</span><span class="p">[</span><span class="n">fac</span><span class="p">]:</span>
            <span class="n">other_dums</span> <span class="o">=</span> <span class="n">fac_dum</span><span class="p">[</span><span class="n">fac</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">other_dums</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">masked_facs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">fac_repr</span><span class="p">[</span><span class="n">fac</span><span class="p">]</span> <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">dumstruct</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">d2</span> <span class="ow">in</span> <span class="n">other_dums</span><span class="p">:</span>
            <span class="n">masked_facs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">fac</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">dum_repr</span><span class="p">[</span><span class="n">d2</span><span class="p">],</span> <span class="n">mask</span><span class="p">[</span><span class="n">d2</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">masked_facs</span> <span class="p">]</span>
        <span class="n">all_masked</span> <span class="o">=</span> <span class="p">[</span> <span class="n">fac</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">dum_repr</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">mask</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                       <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">masked_facs</span> <span class="p">]</span>
        <span class="n">masked_facs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dumstruct</span><span class="p">,</span> <span class="n">masked_facs</span><span class="p">)))</span>

        <span class="c"># dummies for which the ordering cannot be determined</span>
        <span class="k">if</span> <span class="n">has_dups</span><span class="p">(</span><span class="n">all_masked</span><span class="p">):</span>
            <span class="n">all_masked</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">mask</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_masked</span><span class="p">)</span>  <span class="c"># positions are ambiguous</span>

        <span class="c"># sort factors according to fully masked strings</span>
        <span class="n">keydict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dumstruct</span><span class="p">,</span> <span class="n">all_masked</span><span class="p">)))</span>
        <span class="n">dumstruct</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">keydict</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">all_masked</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">pos_val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fac</span> <span class="ow">in</span> <span class="n">dumstruct</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fac</span><span class="p">,</span> <span class="n">AntiSymmetricTensor</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">fac</span><span class="o">.</span><span class="n">upper</span><span class="p">:</span>
                    <span class="n">pos_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">fac</span><span class="o">.</span><span class="n">lower</span><span class="p">:</span>
                    <span class="n">pos_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;l&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fac</span><span class="p">,</span> <span class="n">Creator</span><span class="p">):</span>
                <span class="n">pos_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fac</span><span class="p">,</span> <span class="n">Annihilator</span><span class="p">):</span>
                <span class="n">pos_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;l&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fac</span><span class="p">,</span> <span class="n">NO</span><span class="p">):</span>
                <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span> <span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">fac</span> <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">]</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Creator</span><span class="p">):</span>
                        <span class="n">pos_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pos_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;l&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># fallback to position in string representation</span>
                <span class="n">facpos</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">facpos</span> <span class="o">=</span> <span class="n">masked_facs</span><span class="p">[</span><span class="n">fac</span><span class="p">]</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">dum_repr</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="n">facpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">facpos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">pos_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">facpos</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">d</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">all_masked</span><span class="p">),</span> <span class="n">pos_val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos_val</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">dumkey</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_dums</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_key</span><span class="p">,</span> <span class="n">all_dums</span><span class="p">)))))</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_dums</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dumkey</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">has_dups</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">dumkey</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
        <span class="c"># We have ambiguities</span>
        <span class="n">unordered</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dumkey</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">unordered</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">unordered</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unordered</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">]:</span>
            <span class="k">del</span> <span class="n">unordered</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="n">unordered</span> <span class="o">=</span> <span class="p">[</span> <span class="n">unordered</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unordered</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_determine_ambiguous</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">unordered</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_determine_ambiguous</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">ambiguous_groups</span><span class="p">):</span>
    <span class="c"># We encountered a term for which the dummy substitution is ambiguous.</span>
    <span class="c"># This happens for terms with 2 or more contractions between factors that</span>
    <span class="c"># cannot be uniquely ordered independent of summation indices.  For</span>
    <span class="c"># example:</span>
    <span class="c">#</span>
    <span class="c"># Sum(p, q) v^{p, .}_{q, .}v^{q, .}_{p, .}</span>
    <span class="c">#</span>
    <span class="c"># Assuming that the indices represented by . are dummies with the</span>
    <span class="c"># same range, the factors cannot be ordered, and there is no</span>
    <span class="c"># way to determine a consistent ordering of p and q.</span>
    <span class="c">#</span>
    <span class="c"># The strategy employed here, is to relabel all unambiguous dummies with</span>
    <span class="c"># non-dummy symbols and call _get_ordered_dummies again.  This procedure is</span>
    <span class="c"># applied to the entire term so there is a possibility that</span>
    <span class="c"># _determine_ambiguous() is called again from a deeper recursion level.</span>

    <span class="c"># break recursion if there are no ordered dummies</span>
    <span class="n">all_ambiguous</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dummies</span> <span class="ow">in</span> <span class="n">ambiguous_groups</span><span class="p">:</span>
        <span class="n">all_ambiguous</span> <span class="o">|=</span> <span class="n">dummies</span>
    <span class="n">all_ordered</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ordered</span><span class="p">)</span> <span class="o">-</span> <span class="n">all_ambiguous</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">all_ordered</span><span class="p">:</span>
        <span class="c"># FIXME: If we arrive here, there are no ordered dummies. A method to</span>
        <span class="c"># handle this needs to be implemented.  In order to return something</span>
        <span class="c"># useful nevertheless, we choose arbitrarily the first dummy and</span>
        <span class="c"># determine the rest from this one.  This method is dependent on the</span>
        <span class="c"># actual dummy labels which violates an assumption for the canonization</span>
        <span class="c"># procedure.  A better implementation is needed.</span>
        <span class="n">group</span> <span class="o">=</span> <span class="p">[</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ordered</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ambiguous_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">all_ordered</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">ambiguous_groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="n">stored_counter</span> <span class="o">=</span> <span class="n">_symbol_factory</span><span class="o">.</span><span class="n">_counter</span>
    <span class="n">subslist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">[</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ordered</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">all_ordered</span> <span class="p">]:</span>
        <span class="n">nondum</span> <span class="o">=</span> <span class="n">_symbol_factory</span><span class="o">.</span><span class="n">_next</span><span class="p">()</span>
        <span class="n">subslist</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">nondum</span><span class="p">))</span>
    <span class="n">newterm</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subslist</span><span class="p">)</span>
    <span class="n">neworder</span> <span class="o">=</span> <span class="n">_get_ordered_dummies</span><span class="p">(</span><span class="n">newterm</span><span class="p">)</span>
    <span class="n">_symbol_factory</span><span class="o">.</span><span class="n">_set_counter</span><span class="p">(</span><span class="n">stored_counter</span><span class="p">)</span>

    <span class="c"># update ordered list with new information</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">ambiguous_groups</span><span class="p">:</span>
        <span class="n">ordered_group</span> <span class="o">=</span> <span class="p">[</span> <span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">neworder</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">group</span> <span class="p">]</span>
        <span class="n">ordered_group</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ordered_group</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">ordered</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">ordered</span>


<span class="k">class</span> <span class="nc">_SymbolFactory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counterVar</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">label</span>

    <span class="k">def</span> <span class="nf">_set_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets counter to value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counterVar</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        What counter is currently at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counterVar</span>

    <span class="k">def</span> <span class="nf">_next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates the next symbols and increments counter by 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counterVar</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counterVar</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">s</span>
<span class="n">_symbol_factory</span> <span class="o">=</span> <span class="n">_SymbolFactory</span><span class="p">(</span><span class="s">&#39;_]&quot;]_&#39;</span><span class="p">)</span>  <span class="c"># most certainly a unique label</span>


<span class="nd">@cacheit</span>
<span class="k">def</span> <span class="nf">_get_contractions</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span> <span class="n">keep_only_fully_contracted</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns Add-object with contracted terms.</span>

<span class="sd">    Uses recursion to find all contractions. -- Internal helper function --</span>

<span class="sd">    Will find nonzero contractions in string1 between indices given in</span>
<span class="sd">    leftrange and rightrange.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Should we store current level of contraction?</span>
    <span class="k">if</span> <span class="n">keep_only_fully_contracted</span> <span class="ow">and</span> <span class="n">string1</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">NO</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">string1</span><span class="p">))]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">string1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">string1</span><span class="p">)):</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">contraction</span><span class="p">(</span><span class="n">string1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">string1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="c"># print &quot;found contraction&quot;,c</span>

                <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="o">*</span><span class="n">c</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coeff</span> <span class="o">=</span> <span class="n">c</span>

                <span class="c">#</span>
                <span class="c">#  Call next level of recursion</span>
                <span class="c">#  ============================</span>
                <span class="c">#</span>
                <span class="c"># We now need to find more contractions among operators</span>
                <span class="c">#</span>
                <span class="c"># oplist = string1[:i]+ string1[i+1:j] + string1[j+1:]</span>
                <span class="c">#</span>
                <span class="c"># To prevent overcounting, we don&#39;t allow contractions</span>
                <span class="c"># we have already encountered. i.e. contractions between</span>
                <span class="c">#       string1[:i] &lt;---&gt; string1[i+1:j]</span>
                <span class="c"># and   string1[:i] &lt;---&gt; string1[j+1:].</span>
                <span class="c">#</span>
                <span class="c"># This leaves the case:</span>
                <span class="n">oplist</span> <span class="o">=</span> <span class="n">string1</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">string1</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>

                <span class="k">if</span> <span class="n">oplist</span><span class="p">:</span>

                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">NO</span><span class="p">(</span>
                        <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">string1</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">_get_contractions</span><span class="p">(</span> <span class="n">oplist</span><span class="p">,</span>
                            <span class="n">keep_only_fully_contracted</span><span class="o">=</span><span class="n">keep_only_fully_contracted</span><span class="p">)))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="o">*</span><span class="n">NO</span><span class="p">(</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">string1</span><span class="p">[:</span><span class="n">i</span><span class="p">])))</span>

        <span class="k">if</span> <span class="n">keep_only_fully_contracted</span><span class="p">:</span>
            <span class="k">break</span>   <span class="c"># next iteration over i leaves leftmost operator string1[0] uncontracted</span>

    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)</span>


<span class="c"># @cacheit</span>
<div class="viewcode-block" id="wicks"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.wicks">[docs]</a><span class="k">def</span> <span class="nf">wicks</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the normal ordered equivalent of an expression using Wicks Theorem.</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Function, Dummy</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import wicks, F, Fd, NO</span>
<span class="sd">    &gt;&gt;&gt; p,q,r = symbols(&#39;p,q,r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; wicks(Fd(p)*F(q))  # doctest: +SKIP</span>
<span class="sd">    d(p, q)*d(q, _i) + NO(CreateFermion(p)*AnnihilateFermion(q))</span>

<span class="sd">    By default, the expression is expanded:</span>

<span class="sd">    &gt;&gt;&gt; wicks(F(p)*(F(q)+F(r))) # doctest: +SKIP</span>
<span class="sd">    NO(AnnihilateFermion(p)*AnnihilateFermion(q)) + NO(</span>
<span class="sd">        AnnihilateFermion(p)*AnnihilateFermion(r))</span>

<span class="sd">    With the keyword &#39;keep_only_fully_contracted=True&#39;, only fully contracted</span>
<span class="sd">    terms are returned.</span>

<span class="sd">    By request, the result can be simplified in the following order:</span>
<span class="sd">     -- KroneckerDelta functions are evaluated</span>
<span class="sd">     -- Dummy variables are substituted consistently across terms</span>

<span class="sd">    &gt;&gt;&gt; p, q, r = symbols(&#39;p q r&#39;, cls=Dummy)</span>
<span class="sd">    &gt;&gt;&gt; wicks(Fd(p)*(F(q)+F(r)), keep_only_fully_contracted=True) # doctest: +SKIP</span>
<span class="sd">    KroneckerDelta(_i, _q)*KroneckerDelta(</span>
<span class="sd">        _p, _q) + KroneckerDelta(_i, _r)*KroneckerDelta(_p, _r)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="n">opts</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;simplify_kronecker_deltas&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">&#39;expand&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
        <span class="s">&#39;simplify_dummies&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">&#39;keep_only_fully_contracted&#39;</span><span class="p">:</span> <span class="bp">False</span>
    <span class="p">}</span>
    <span class="n">opts</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kw_args</span><span class="p">)</span>

    <span class="c"># check if we are already normally ordered</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">NO</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="s">&#39;keep_only_fully_contracted&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">FermionicOperator</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="s">&#39;keep_only_fully_contracted&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">e</span>

    <span class="c"># break up any NO-objects, and evaluate commutators</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">wicks</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># make sure we have only one term to consider</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="s">&#39;simplify_dummies&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">substitute_dummies</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span> <span class="n">wicks</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span> <span class="n">wicks</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="c"># For Mul-objects we can actually do something</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Mul</span><span class="p">):</span>

        <span class="c"># we dont want to mess around with commuting part of Mul</span>
        <span class="c"># so we factorize it out before starting recursion</span>
        <span class="n">c_part</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">string1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">c_part</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">string1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">string1</span><span class="p">)</span>

        <span class="c"># catch trivial cases</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="s">&#39;keep_only_fully_contracted&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">e</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c"># non-trivial</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">string1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BosonicOperator</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>

            <span class="n">string1</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">string1</span><span class="p">)</span>

            <span class="c"># recursion over higher order contractions</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_get_contractions</span><span class="p">(</span><span class="n">string1</span><span class="p">,</span>
                <span class="n">keep_only_fully_contracted</span><span class="o">=</span><span class="n">opts</span><span class="p">[</span><span class="s">&#39;keep_only_fully_contracted&#39;</span><span class="p">]</span> <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">c_part</span><span class="p">)</span><span class="o">*</span><span class="n">result</span>

        <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="s">&#39;expand&#39;</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">opts</span><span class="p">[</span><span class="s">&#39;simplify_kronecker_deltas&#39;</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">evaluate_deltas</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="c"># there was nothing to do</span>
    <span class="k">return</span> <span class="n">e</span>

</div>
<div class="viewcode-block" id="PermutationOperator"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.PermutationOperator">[docs]</a><span class="k">class</span> <span class="nc">PermutationOperator</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents the index permutation operator P(ij).</span>

<span class="sd">    P(ij)*f(i)*g(j) = f(i)*g(j) - f(j)*g(i)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

<div class="viewcode-block" id="PermutationOperator.get_permuted"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.PermutationOperator.get_permuted">[docs]</a>    <span class="k">def</span> <span class="nf">get_permuted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns -expr with permuted indices.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols, Function</span>
<span class="sd">        &gt;&gt;&gt; from sympy.physics.secondquant import PermutationOperator</span>
<span class="sd">        &gt;&gt;&gt; p,q = symbols(&#39;p,q&#39;)</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">        &gt;&gt;&gt; PermutationOperator(p,q).get_permuted(f(p,q))</span>
<span class="sd">        -f(q, p)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="o">*</span><span class="n">expr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>
</div>
    <span class="k">def</span> <span class="nf">_latex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">printer</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;P(</span><span class="si">%s%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

</div>
<div class="viewcode-block" id="simplify_index_permutations"><a class="viewcode-back" href="../../../modules/physics/secondquant.html#sympy.physics.secondquant.simplify_index_permutations">[docs]</a><span class="k">def</span> <span class="nf">simplify_index_permutations</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">permutation_operators</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs simplification by introducing PermutationOperators where appropriate.</span>

<span class="sd">    Schematically:</span>
<span class="sd">        [abij] - [abji] - [baij] + [baji] -&gt;  P(ab)*P(ij)*[abij]</span>

<span class="sd">    permutation_operators is a list of PermutationOperators to consider.</span>

<span class="sd">    If permutation_operators=[P(ab),P(ij)] we will try to introduce the</span>
<span class="sd">    permutation operators P(ij) and P(ab) in the expression.  If there are other</span>
<span class="sd">    possible simplifications, we ignore them.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, Function</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import simplify_index_permutations</span>
<span class="sd">    &gt;&gt;&gt; from sympy.physics.secondquant import PermutationOperator</span>
<span class="sd">    &gt;&gt;&gt; p,q,r,s = symbols(&#39;p,q,r,s&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>
<span class="sd">    &gt;&gt;&gt; g = Function(&#39;g&#39;)</span>

<span class="sd">    &gt;&gt;&gt; expr = f(p)*g(q) - f(q)*g(p); expr</span>
<span class="sd">    f(p)*g(q) - f(q)*g(p)</span>
<span class="sd">    &gt;&gt;&gt; simplify_index_permutations(expr,[PermutationOperator(p,q)])</span>
<span class="sd">    f(p)*g(q)*PermutationOperator(p, q)</span>

<span class="sd">    &gt;&gt;&gt; PermutList = [PermutationOperator(p,q),PermutationOperator(r,s)]</span>
<span class="sd">    &gt;&gt;&gt; expr = f(p,r)*g(q,s) - f(q,r)*g(p,s) + f(q,s)*g(p,r) - f(p,s)*g(q,r)</span>
<span class="sd">    &gt;&gt;&gt; simplify_index_permutations(expr,PermutList)</span>
<span class="sd">    f(p, r)*g(q, s)*PermutationOperator(p, q)*PermutationOperator(r, s)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_get_indices</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects indices recursively in predictable order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_get_indices</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ind</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_choose_one_to_keep</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
        <span class="c"># we keep the one where indices in ind are in order ind[0] &lt; ind[1]</span>
        <span class="k">if</span> <span class="n">_get_indices</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_get_indices</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">P</span> <span class="ow">in</span> <span class="n">permutation_operators</span><span class="p">:</span>
            <span class="n">new_terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="n">on_hold</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">while</span> <span class="n">terms</span><span class="p">:</span>
                <span class="n">term</span> <span class="o">=</span> <span class="n">terms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">permuted</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">get_permuted</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">permuted</span> <span class="ow">in</span> <span class="n">terms</span> <span class="o">|</span> <span class="n">on_hold</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">terms</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">permuted</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">on_hold</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">permuted</span><span class="p">)</span>
                    <span class="n">keep</span> <span class="o">=</span> <span class="n">_choose_one_to_keep</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">permuted</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                    <span class="n">new_terms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="n">keep</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="c"># Some terms must get a second chance because the permuted</span>
                    <span class="c"># term may already have canonical dummy ordering.  Then</span>
                    <span class="c"># substitute_dummies() does nothing.  However, the other</span>
                    <span class="c"># term, if it exists, will be able to match with us.</span>
                    <span class="n">permuted1</span> <span class="o">=</span> <span class="n">permuted</span>
                    <span class="n">permuted</span> <span class="o">=</span> <span class="n">substitute_dummies</span><span class="p">(</span><span class="n">permuted</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">permuted1</span> <span class="o">==</span> <span class="n">permuted</span><span class="p">:</span>
                        <span class="n">on_hold</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">permuted</span> <span class="ow">in</span> <span class="n">terms</span> <span class="o">|</span> <span class="n">on_hold</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">terms</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">permuted</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="n">on_hold</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">permuted</span><span class="p">)</span>
                        <span class="n">keep</span> <span class="o">=</span> <span class="n">_choose_one_to_keep</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">permuted</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                        <span class="n">new_terms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">P</span><span class="o">*</span><span class="n">keep</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_terms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="n">new_terms</span> <span class="o">|</span> <span class="n">on_hold</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expr</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Jan 20, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>
