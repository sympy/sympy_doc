

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.core.evalf &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.core.evalf</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Adaptive numerical evaluation of SymPy expressions, using mpmath</span>
<span class="sd">for mathematical functions.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">sympy.mpmath.libmp</span> <span class="kn">as</span> <span class="nn">libmp</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="n">make_mpc</span><span class="p">,</span> <span class="n">make_mpf</span><span class="p">,</span> <span class="n">mp</span><span class="p">,</span> <span class="n">mpc</span><span class="p">,</span> <span class="n">mpf</span><span class="p">,</span> <span class="n">nsum</span><span class="p">,</span> <span class="n">quadts</span><span class="p">,</span> <span class="n">quadosc</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="n">inf</span> <span class="k">as</span> <span class="n">mpmath_inf</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath.libmp</span> <span class="kn">import</span> <span class="p">(</span><span class="n">bitcount</span><span class="p">,</span> <span class="n">from_int</span><span class="p">,</span> <span class="n">from_man_exp</span><span class="p">,</span>
        <span class="n">from_rational</span><span class="p">,</span> <span class="n">fhalf</span><span class="p">,</span> <span class="n">fnan</span><span class="p">,</span> <span class="n">fnone</span><span class="p">,</span> <span class="n">fone</span><span class="p">,</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">mpf_abs</span><span class="p">,</span> <span class="n">mpf_add</span><span class="p">,</span>
        <span class="n">mpf_atan</span><span class="p">,</span> <span class="n">mpf_atan2</span><span class="p">,</span> <span class="n">mpf_cmp</span><span class="p">,</span> <span class="n">mpf_cos</span><span class="p">,</span> <span class="n">mpf_e</span><span class="p">,</span> <span class="n">mpf_exp</span><span class="p">,</span> <span class="n">mpf_log</span><span class="p">,</span> <span class="n">mpf_lt</span><span class="p">,</span>
        <span class="n">mpf_mul</span><span class="p">,</span> <span class="n">mpf_neg</span><span class="p">,</span> <span class="n">mpf_pi</span><span class="p">,</span> <span class="n">mpf_pow</span><span class="p">,</span> <span class="n">mpf_pow_int</span><span class="p">,</span> <span class="n">mpf_shift</span><span class="p">,</span> <span class="n">mpf_sin</span><span class="p">,</span>
        <span class="n">mpf_sqrt</span><span class="p">,</span> <span class="n">normalize</span><span class="p">,</span> <span class="n">round_nearest</span><span class="p">,</span> <span class="n">to_int</span><span class="p">,</span> <span class="n">to_str</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath.libmp.backend</span> <span class="kn">import</span> <span class="n">MPZ</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath.libmp.libmpc</span> <span class="kn">import</span> <span class="n">_infs_nan</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath.libmp.libmpf</span> <span class="kn">import</span> <span class="n">dps_to_prec</span><span class="p">,</span> <span class="n">prec_to_dps</span>

<span class="kn">from</span> <span class="nn">sympy.mpmath.libmp.gammazeta</span> <span class="kn">import</span> <span class="n">mpf_bernoulli</span>

<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">.sympify</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="n">C</span>
<span class="kn">from</span> <span class="nn">.singleton</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">.containers</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="n">LG10</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">rnd</span> <span class="o">=</span> <span class="n">round_nearest</span>

<span class="c"># Used in a few places as placeholder values to denote exponents and</span>
<span class="c"># precision levels, e.g. of exact numbers. Must be careful to avoid</span>
<span class="c"># passing these to mpmath functions or returning them in final results.</span>
<span class="n">INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mpmath_inf</span><span class="p">)</span>
<span class="n">MINUS_INF</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="n">mpmath_inf</span><span class="p">)</span>

<span class="c"># ~= 100 digits. Real men set this to INF.</span>
<span class="n">DEFAULT_MAXPREC</span> <span class="o">=</span> <span class="mi">333</span>


<div class="viewcode-block" id="PrecisionExhausted"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.evalf.PrecisionExhausted">[docs]</a><span class="k">class</span> <span class="nc">PrecisionExhausted</span><span class="p">(</span><span class="ne">ArithmeticError</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="c">#----------------------------------------------------------------------------#</span>
<span class="c">#                                                                            #</span>
<span class="c">#              Helper functions for arithmetic and complex parts             #</span>
<span class="c">#                                                                            #</span>
<span class="c">#----------------------------------------------------------------------------#</span>
</div>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">An mpf value tuple is a tuple of integers (sign, man, exp, bc)</span>
<span class="sd">representing a floating-point number: [1, -1][sign]*man*2**exp where</span>
<span class="sd">sign is 0 or 1 and bc should correspond to the number of bits used to</span>
<span class="sd">represent the mantissa (man) in binary notation, e.g.</span>

<span class="sd">&gt;&gt;&gt; from sympy.core.evalf import bitcount</span>
<span class="sd">&gt;&gt;&gt; sign, man, exp, bc = 0, 5, 1, 3</span>
<span class="sd">&gt;&gt;&gt; n = [1, -1][sign]*man*2**exp</span>
<span class="sd">&gt;&gt;&gt; n, bitcount(man)</span>
<span class="sd">(10, 3)</span>

<span class="sd">A temporary result is a tuple (re, im, re_acc, im_acc) where</span>
<span class="sd">re and im are nonzero mpf value tuples representing approximate</span>
<span class="sd">numbers, or None to denote exact zeros.</span>

<span class="sd">re_acc, im_acc are integers denoting log2(e) where e is the estimated</span>
<span class="sd">relative accuracy of the respective complex part, but may be anything</span>
<span class="sd">if the corresponding complex part is None.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">fastlog</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fast approximation of log2(x) for an mpf value tuple x.</span>

<span class="sd">    Notes: Calculated as exponent + width of mantissa. This is an</span>
<span class="sd">    approximation for two reasons: 1) it gives the ceil(log2(abs(x)))</span>
<span class="sd">    value and 2) it is too high by 1 in the case that x is an exact</span>
<span class="sd">    power of 2. Although this is easy to remedy by testing to see if</span>
<span class="sd">    the odd mpf mantissa is 1 (indicating that one was dealing with</span>
<span class="sd">    an exact power of 2) that would decrease the speed and is not</span>
<span class="sd">    necessary as this is only being used as an approximation for the</span>
<span class="sd">    number of bits in x. The correct return value could be written as</span>
<span class="sd">    &quot;x[2] + (x[3] if x[1] != 1 else 0)&quot;.</span>
<span class="sd">        Since mpf tuples always have an odd mantissa, no check is done</span>
<span class="sd">    to see if the mantissa is a multiple of 2 (in which case the</span>
<span class="sd">    result would be too large by 1).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.core.evalf import fastlog, bitcount</span>
<span class="sd">    &gt;&gt;&gt; s, m, e = 0, 5, 1</span>
<span class="sd">    &gt;&gt;&gt; bc = bitcount(m)</span>
<span class="sd">    &gt;&gt;&gt; n = [1, -1][s]*m*2**e</span>
<span class="sd">    &gt;&gt;&gt; n, (log(n)/log(2)).evalf(2), fastlog((s, m, e, bc))</span>
<span class="sd">    (10, 3.3, 4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MINUS_INF</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">pure_complex</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a and b if v matches a + I*b where b is not zero and</span>
<span class="sd">    a and b are Numbers, else None.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.evalf import pure_complex</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Tuple, I</span>
<span class="sd">    &gt;&gt;&gt; a, b = Tuple(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; pure_complex(a)</span>
<span class="sd">    &gt;&gt;&gt; pure_complex(a + b*I)</span>
<span class="sd">    (2, 3)</span>
<span class="sd">    &gt;&gt;&gt; pure_complex(I)</span>
<span class="sd">    (0, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
    <span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span>


<span class="k">def</span> <span class="nf">scaled_zero</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an mpf representing a power of two with magnitude ``mag``</span>
<span class="sd">    and -1 for precision. Or, if ``mag`` is a scaled_zero tuple, then just</span>
<span class="sd">    remove the sign from within the list that it was initially wrapped</span>
<span class="sd">    in.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.core.evalf import scaled_zero</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Float</span>
<span class="sd">    &gt;&gt;&gt; z, p = scaled_zero(100)</span>
<span class="sd">    &gt;&gt;&gt; z, p</span>
<span class="sd">    (([0], 1, 100, 1), -1)</span>
<span class="sd">    &gt;&gt;&gt; ok = scaled_zero(z)</span>
<span class="sd">    &gt;&gt;&gt; ok</span>
<span class="sd">    (0, 1, 100, 1)</span>
<span class="sd">    &gt;&gt;&gt; Float(ok)</span>
<span class="sd">    1.26765060022823e+30</span>
<span class="sd">    &gt;&gt;&gt; Float(ok, p)</span>
<span class="sd">    0.e+30</span>
<span class="sd">    &gt;&gt;&gt; ok, p = scaled_zero(100, -1)</span>
<span class="sd">    &gt;&gt;&gt; Float(scaled_zero(ok), p)</span>
<span class="sd">    -0.e+30</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">iszero</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">mag</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">mag</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;sign must be +/-1&#39;</span><span class="p">)</span>
        <span class="n">rv</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mpf_shift</span><span class="p">(</span><span class="n">fone</span><span class="p">,</span> <span class="n">mag</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="p">([</span><span class="n">s</span><span class="p">],)</span> <span class="o">+</span> <span class="n">rv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">rv</span><span class="p">,</span> <span class="n">p</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;scaled zero expects int or scaled_zero tuple.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">iszero</span><span class="p">(</span><span class="n">mpf</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">scaled</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">mpf</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mpf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mpf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mpf</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">mpf</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="n">mpf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">mpf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">complex_accuracy</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns relative accuracy of a complex number with given accuracies</span>
<span class="sd">    for the real and imaginary parts. The relative accuracy is defined</span>
<span class="sd">    in the complex norm sense as ||z|+|error|| / |z| where error</span>
<span class="sd">    is equal to (real absolute error) + (imag absolute error)*i.</span>

<span class="sd">    The full expression for the (logarithmic) error can be approximated</span>
<span class="sd">    easily by using the max norm to approximate the complex norm.</span>

<span class="sd">    In the worst case (re and im equal), this is wrong by a factor</span>
<span class="sd">    sqrt(2), or by log2(sqrt(2)) = 0.5 bit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">im</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">INF</span>
        <span class="k">return</span> <span class="n">re_acc</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">im_acc</span>
    <span class="n">re_size</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="n">im_size</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">absolute_error</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">re_size</span> <span class="o">-</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_size</span> <span class="o">-</span> <span class="n">im_acc</span><span class="p">)</span>
    <span class="n">relative_error</span> <span class="o">=</span> <span class="n">absolute_error</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">re_size</span><span class="p">,</span> <span class="n">im_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">relative_error</span>


<span class="k">def</span> <span class="nf">get_abs</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span>
    <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_abs</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">),</span> <span class="n">prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">elif</span> <span class="n">re</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mpf_abs</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">get_complex_part</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;no = 0 for real part, no = 1 for imaginary part&quot;&quot;&quot;</span>
    <span class="n">workprec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">workprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">accuracy</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">no</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="c"># XXX is the last one correct? Consider re((1+I)**2).n()</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="n">accuracy</span> <span class="o">&gt;=</span> <span class="n">prec</span> <span class="ow">or</span> <span class="o">-</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">prec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">workprec</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">evalf_abs</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_abs</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">evalf_re</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_complex_part</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">evalf_im</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_complex_part</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">re</span> <span class="o">==</span> <span class="n">fzero</span> <span class="ow">and</span> <span class="n">im</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;got complex zero with unknown accuracy&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">re</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span>
    <span class="k">elif</span> <span class="n">im</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>

    <span class="n">size_re</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="n">size_im</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size_re</span> <span class="o">&gt;</span> <span class="n">size_im</span><span class="p">:</span>
        <span class="n">re_acc</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="n">im_acc</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">size_re</span> <span class="o">-</span> <span class="n">size_im</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">im_acc</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="n">re_acc</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">size_im</span> <span class="o">-</span> <span class="n">size_re</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">chop_parts</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Chop off tiny real or complex parts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">value</span>
    <span class="c"># Method 1: chop based on absolute value</span>
    <span class="k">if</span> <span class="n">re</span> <span class="ow">and</span> <span class="n">re</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_infs_nan</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">im</span> <span class="ow">and</span> <span class="n">im</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_infs_nan</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
    <span class="c"># Method 2: chop if inaccurate and relatively small</span>
    <span class="k">if</span> <span class="n">re</span> <span class="ow">and</span> <span class="n">im</span><span class="p">:</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">re_acc</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">delta</span> <span class="o">-</span> <span class="n">re_acc</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">im_acc</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span><span class="n">delta</span> <span class="o">-</span> <span class="n">im_acc</span> <span class="o">&gt;=</span> <span class="n">prec</span> <span class="o">-</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">check_target</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">complex_accuracy</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">prec</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PrecisionExhausted</span><span class="p">(</span><span class="s">&quot;Failed to distinguish the expression: </span><span class="se">\n\n</span><span class="si">%s</span><span class="se">\n\n</span><span class="s">&quot;</span>
            <span class="s">&quot;from zero. Try simplifying the input, using chop=True, or providing &quot;</span>
            <span class="s">&quot;a higher maxn for evalf&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">expr</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">get_integer_part</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">return_ints</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    With no = 1, computes ceiling(expr)</span>
<span class="sd">    With no = -1, computes floor(expr)</span>

<span class="sd">    Note: this function either gives the exact result or signals failure.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># The expression is likely less than 2^30 or so</span>
    <span class="n">assumed_size</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">ire</span><span class="p">,</span> <span class="n">iim</span><span class="p">,</span> <span class="n">ire_acc</span><span class="p">,</span> <span class="n">iim_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">assumed_size</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="c"># We now know the size, so we can calculate how much extra precision</span>
    <span class="c"># (if any) is needed to get within the nearest integer</span>
    <span class="k">if</span> <span class="n">ire</span> <span class="ow">and</span> <span class="n">iim</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fastlog</span><span class="p">(</span><span class="n">ire</span><span class="p">)</span> <span class="o">-</span> <span class="n">ire_acc</span><span class="p">,</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">iim</span><span class="p">)</span> <span class="o">-</span> <span class="n">iim_acc</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ire</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">ire</span><span class="p">)</span> <span class="o">-</span> <span class="n">ire_acc</span>
    <span class="k">elif</span> <span class="n">iim</span><span class="p">:</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">iim</span><span class="p">)</span> <span class="o">-</span> <span class="n">iim_acc</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># ... or maybe the expression was exactly zero</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="n">margin</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">if</span> <span class="n">gap</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">margin</span><span class="p">:</span>
        <span class="n">ire</span><span class="p">,</span> <span class="n">iim</span><span class="p">,</span> <span class="n">ire_acc</span><span class="p">,</span> <span class="n">iim_acc</span> <span class="o">=</span> \
            <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">margin</span> <span class="o">+</span> <span class="n">assumed_size</span> <span class="o">+</span> <span class="n">gap</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="c"># We can now easily find the nearest integer, but to find floor/ceil, we</span>
    <span class="c"># must also calculate whether the difference to the nearest integer is</span>
    <span class="c"># positive or negative (which may fail if very close).</span>
    <span class="k">def</span> <span class="nf">calc_part</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">nexpr</span><span class="p">):</span>
        <span class="n">nint</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">nexpr</span><span class="p">,</span> <span class="n">rnd</span><span class="p">))</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">-</span><span class="n">nint</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x_acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_target</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">x_acc</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">PrecisionExhausted</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">PrecisionExhausted</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">fzero</span>
        <span class="n">nint</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">no</span><span class="o">*</span><span class="p">(</span><span class="n">mpf_cmp</span><span class="p">(</span><span class="n">x</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">fzero</span><span class="p">)</span> <span class="o">==</span> <span class="n">no</span><span class="p">))</span>
        <span class="n">nint</span> <span class="o">=</span> <span class="n">from_int</span><span class="p">(</span><span class="n">nint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nint</span><span class="p">,</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">nint</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">ire</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="n">calc_part</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">ire</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iim</span><span class="p">:</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">calc_part</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">im</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">iim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_ints</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">re</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_int</span><span class="p">(</span><span class="n">im</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">evalf_ceiling</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_integer_part</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">evalf_floor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_integer_part</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

<span class="c">#----------------------------------------------------------------------------#</span>
<span class="c">#                                                                            #</span>
<span class="c">#                            Arithmetic operations                           #</span>
<span class="c">#                                                                            #</span>
<span class="c">#----------------------------------------------------------------------------#</span>


<span class="k">def</span> <span class="nf">add_terms</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper for evalf_add. Adds a list of (mpfval, accuracy) terms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    - None, None if there are no non-zero terms;</span>
<span class="sd">    - terms[0] if there is only 1 term;</span>
<span class="sd">    - scaled_zero if the sum of the terms produces a zero by cancellation</span>
<span class="sd">      e.g. mpfs representing 1 and -1 would produce a scaled zero which need</span>
<span class="sd">      special handling since they are not actually zero and they are purposely</span>
<span class="sd">      malformed to ensure that they can&#39;t be used in anything but accuracy</span>
<span class="sd">      calculations;</span>
<span class="sd">    - a tuple that is scaled to target_prec that corresponds to the</span>
<span class="sd">      sum of the terms.</span>

<span class="sd">    The returned mpf tuple will be normalized to target_prec; the input</span>
<span class="sd">    prec is used to define the working precision.</span>

<span class="sd">    XXX explain why this is needed and why one can&#39;t just loop using mpf_add</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">iszero</span><span class="p">(</span><span class="n">t</span><span class="p">)]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">terms</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">working_prec</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">prec</span>
    <span class="n">sum_man</span><span class="p">,</span> <span class="n">sum_exp</span><span class="p">,</span> <span class="n">absolute_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MINUS_INF</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">accuracy</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
        <span class="n">sign</span><span class="p">,</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bc</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">sign</span><span class="p">:</span>
            <span class="n">man</span> <span class="o">=</span> <span class="o">-</span><span class="n">man</span>
        <span class="n">absolute_error</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">absolute_error</span><span class="p">,</span> <span class="n">bc</span> <span class="o">+</span> <span class="n">exp</span> <span class="o">-</span> <span class="n">accuracy</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">exp</span> <span class="o">-</span> <span class="n">sum_exp</span>
        <span class="k">if</span> <span class="n">exp</span> <span class="o">&gt;=</span> <span class="n">sum_exp</span><span class="p">:</span>
            <span class="c"># x much larger than existing sum?</span>
            <span class="c"># first: quick test</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">delta</span> <span class="o">&gt;</span> <span class="n">working_prec</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">((</span><span class="ow">not</span> <span class="n">sum_man</span><span class="p">)</span> <span class="ow">or</span>
                 <span class="n">delta</span> <span class="o">-</span> <span class="n">bitcount</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sum_man</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">working_prec</span><span class="p">)):</span>
                <span class="n">sum_man</span> <span class="o">=</span> <span class="n">man</span>
                <span class="n">sum_exp</span> <span class="o">=</span> <span class="n">exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sum_man</span> <span class="o">+=</span> <span class="p">(</span><span class="n">man</span> <span class="o">&lt;&lt;</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span>
            <span class="c"># x much smaller than existing sum?</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">-</span> <span class="n">bc</span> <span class="o">&gt;</span> <span class="n">working_prec</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sum_man</span><span class="p">:</span>
                    <span class="n">sum_man</span><span class="p">,</span> <span class="n">sum_exp</span> <span class="o">=</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sum_man</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_man</span> <span class="o">&lt;&lt;</span> <span class="n">delta</span><span class="p">)</span> <span class="o">+</span> <span class="n">man</span>
                <span class="n">sum_exp</span> <span class="o">=</span> <span class="n">exp</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sum_man</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">absolute_error</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sum_man</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sum_sign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">sum_man</span> <span class="o">=</span> <span class="o">-</span><span class="n">sum_man</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sum_sign</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">sum_bc</span> <span class="o">=</span> <span class="n">bitcount</span><span class="p">(</span><span class="n">sum_man</span><span class="p">)</span>
    <span class="n">sum_accuracy</span> <span class="o">=</span> <span class="n">sum_exp</span> <span class="o">+</span> <span class="n">sum_bc</span> <span class="o">-</span> <span class="n">absolute_error</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">sum_sign</span><span class="p">,</span> <span class="n">sum_man</span><span class="p">,</span> <span class="n">sum_exp</span><span class="p">,</span> <span class="n">sum_bc</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span>
        <span class="n">rnd</span><span class="p">),</span> <span class="n">sum_accuracy</span>
    <span class="c">#print &quot;returning&quot;, to_str(r[0],50), r[1]</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">evalf_add</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">res</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>

    <span class="n">oldmaxprec</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;maxprec&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAXPREC</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">target_prec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">options</span><span class="p">[</span><span class="s">&#39;maxprec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">oldmaxprec</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">prec</span><span class="p">)</span>

        <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="n">add_terms</span><span class="p">(</span>
            <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">prec</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">add_terms</span><span class="p">(</span>
            <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">prec</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="n">complex_accuracy</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">acc</span> <span class="o">&gt;=</span> <span class="n">target_prec</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;verbose&#39;</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;ADD: wanted&quot;</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="s">&quot;accurate bits, got&quot;</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prec</span> <span class="o">-</span> <span class="n">target_prec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">options</span><span class="p">[</span><span class="s">&#39;maxprec&#39;</span><span class="p">]:</span>
                <span class="k">break</span>

            <span class="n">prec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">,</span> <span class="n">target_prec</span> <span class="o">-</span> <span class="n">acc</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;verbose&#39;</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;ADD: restarting with prec&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>

    <span class="n">options</span><span class="p">[</span><span class="s">&#39;maxprec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldmaxprec</span>
    <span class="k">if</span> <span class="n">iszero</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iszero</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">scaled</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="k">def</span> <span class="nf">evalf_mul</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
        <span class="c"># the only pure complex that is a mul is h*I</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">res</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">im_acc</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="c"># With guard digits, multiplication in the real case does not destroy</span>
    <span class="c"># accuracy. This is also true in the complex case when considering the</span>
    <span class="c"># total accuracy; however accuracy for the real or imaginary parts</span>
    <span class="c"># separately may be lower.</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">prec</span>

    <span class="c"># XXX: big overestimate</span>
    <span class="n">working_prec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span>

    <span class="c"># Empty product is 1</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bc</span> <span class="o">=</span> <span class="n">MPZ</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

    <span class="c"># First, we multiply all pure real or pure imaginary numbers.</span>
    <span class="c"># direction tells us that the result should be multiplied by</span>
    <span class="c"># I**direction; all other numbers get put into complex_factors</span>
    <span class="c"># to be multiplied out after the first phase.</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span>
    <span class="n">complex_factors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last</span> <span class="ow">and</span> <span class="n">pure_complex</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">last</span> <span class="ow">and</span> <span class="n">arg</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">working_prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">re</span> <span class="ow">and</span> <span class="n">im</span><span class="p">:</span>
            <span class="n">complex_factors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">re</span><span class="p">:</span>
            <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w_acc</span> <span class="o">=</span> <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span>
        <span class="k">elif</span> <span class="n">im</span><span class="p">:</span>
            <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">w_acc</span> <span class="o">=</span> <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span>
            <span class="n">direction</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">direction</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">s</span>
        <span class="n">man</span> <span class="o">*=</span> <span class="n">m</span>
        <span class="n">exp</span> <span class="o">+=</span> <span class="n">e</span>
        <span class="n">bc</span> <span class="o">+=</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">bc</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">working_prec</span><span class="p">:</span>
            <span class="n">man</span> <span class="o">&gt;&gt;=</span> <span class="n">working_prec</span>
            <span class="n">exp</span> <span class="o">+=</span> <span class="n">working_prec</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="n">w_acc</span><span class="p">)</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="p">(</span><span class="n">direction</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">complex_factors</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bitcount</span><span class="p">(</span><span class="n">man</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
        <span class="c"># multiply by i</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">acc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># initialize with the first term</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">start</span><span class="p">:</span>
            <span class="c"># there was a real part; give it an imaginary part</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="p">(</span><span class="n">sign</span><span class="p">,</span> <span class="n">man</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">bitcount</span><span class="p">(</span><span class="n">man</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MPZ</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># there is no real part to start (other than the starting 1)</span>
            <span class="n">wre</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">wre_acc</span><span class="p">,</span> <span class="n">wim_acc</span> <span class="o">=</span> <span class="n">complex_factors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span>
                      <span class="n">complex_accuracy</span><span class="p">((</span><span class="n">wre</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">wre_acc</span><span class="p">,</span> <span class="n">wim_acc</span><span class="p">)))</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">wre</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">wim</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">wre</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">wre_acc</span><span class="p">,</span> <span class="n">wim_acc</span> <span class="ow">in</span> <span class="n">complex_factors</span><span class="p">[</span><span class="n">i0</span><span class="p">:]:</span>
            <span class="c"># acc is the overall accuracy of the product; we aren&#39;t</span>
            <span class="c"># computing exact accuracies of the product.</span>
            <span class="n">acc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span>
                      <span class="n">complex_accuracy</span><span class="p">((</span><span class="n">wre</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">wre_acc</span><span class="p">,</span> <span class="n">wim_acc</span><span class="p">)))</span>

            <span class="n">use_prec</span> <span class="o">=</span> <span class="n">working_prec</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">mpf_mul</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">wre</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">mpf_mul</span><span class="p">(</span><span class="n">mpf_neg</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">wim</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">mpf_mul</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">wim</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">mpf_mul</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">wre</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">mpf_add</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">mpf_add</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">use_prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;verbose&#39;</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;MUL: wanted&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="s">&quot;accurate bits, got&quot;</span><span class="p">,</span> <span class="n">acc</span><span class="p">)</span>
        <span class="c"># multiply by I</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">mpf_neg</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">re</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">acc</span><span class="p">,</span> <span class="n">acc</span>


<span class="k">def</span> <span class="nf">evalf_pow</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>

    <span class="n">target_prec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span>

    <span class="c"># We handle x**n separately. This has two purposes: 1) it is much</span>
    <span class="c"># faster, because we avoid calling evalf on the exponent, and 2) it</span>
    <span class="c"># allows better handling of real/imaginary parts that are exactly zero</span>
    <span class="k">if</span> <span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">p</span>
        <span class="c"># Exact</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fone</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>
        <span class="c"># Exponentiation by p magnifies relative error by |p|, so the</span>
        <span class="c"># base must be evaluated with increased precision if p is large</span>
        <span class="n">prec</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="c"># Real to integer power</span>
        <span class="k">if</span> <span class="n">re</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">im</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mpf_pow_int</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="bp">None</span>
        <span class="c"># (x*I)**n = I**n * x**n</span>
        <span class="k">if</span> <span class="n">im</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">mpf_pow_int</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
            <span class="n">case</span> <span class="o">=</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">4</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">target_prec</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mpf_neg</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">case</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mpf_neg</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">target_prec</span>
        <span class="c"># Zero raised to an integer power</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="c"># General complex number to arbitrary integer power</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_pow_int</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="c"># Assumes full accuracy in input</span>
        <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>

    <span class="c"># Pure square root</span>
    <span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span><span class="p">:</span>
        <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="c"># General complex square root</span>
        <span class="k">if</span> <span class="n">xim</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_sqrt</span><span class="p">((</span><span class="n">xre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">xim</span><span class="p">),</span> <span class="n">prec</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">xre</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="c"># Square root of a negative real number</span>
        <span class="k">if</span> <span class="n">mpf_lt</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">fzero</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mpf_sqrt</span><span class="p">(</span><span class="n">mpf_neg</span><span class="p">(</span><span class="n">xre</span><span class="p">),</span> <span class="n">prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span>
        <span class="c"># Positive square root</span>
        <span class="k">return</span> <span class="n">mpf_sqrt</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>

    <span class="c"># We first evaluate the exponent to find its magnitude</span>
    <span class="c"># This determines the working precision that must be used</span>
    <span class="n">prec</span> <span class="o">+=</span> <span class="mi">10</span>
    <span class="n">yre</span><span class="p">,</span> <span class="n">yim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="c"># Special cases: x**0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">yre</span> <span class="ow">or</span> <span class="n">yim</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fone</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>

    <span class="n">ysize</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">yre</span><span class="p">)</span>
    <span class="c"># Restart if too big</span>
    <span class="c"># XXX: prec + ysize might exceed maxprec</span>
    <span class="k">if</span> <span class="n">ysize</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">prec</span> <span class="o">+=</span> <span class="n">ysize</span>
        <span class="n">yre</span><span class="p">,</span> <span class="n">yim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="c"># Pure exponential function; no need to evalf the base</span>
    <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Exp1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">yim</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_exp</span><span class="p">((</span><span class="n">yre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">yim</span><span class="p">),</span> <span class="n">prec</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mpf_exp</span><span class="p">(</span><span class="n">yre</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="bp">None</span>

    <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="c"># 0**y</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">xre</span> <span class="ow">or</span> <span class="n">xim</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="c"># (real ** complex) or (complex ** complex)</span>
    <span class="k">if</span> <span class="n">yim</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_pow</span><span class="p">(</span>
            <span class="p">(</span><span class="n">xre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">xim</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">),</span> <span class="p">(</span><span class="n">yre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">yim</span><span class="p">),</span>
            <span class="n">target_prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
    <span class="c"># complex ** real</span>
    <span class="k">if</span> <span class="n">xim</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_pow_mpf</span><span class="p">((</span><span class="n">xre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">xim</span><span class="p">),</span> <span class="n">yre</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
    <span class="c"># negative ** real</span>
    <span class="k">elif</span> <span class="n">mpf_lt</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">fzero</span><span class="p">):</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">libmp</span><span class="o">.</span><span class="n">mpc_pow_mpf</span><span class="p">((</span><span class="n">xre</span><span class="p">,</span> <span class="n">fzero</span><span class="p">),</span> <span class="n">yre</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">finalize_complex</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">)</span>
    <span class="c"># positive ** real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mpf_pow</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">yre</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">target_prec</span><span class="p">,</span> <span class="bp">None</span>


<span class="c">#----------------------------------------------------------------------------#</span>
<span class="c">#                                                                            #</span>
<span class="c">#                            Special functions                               #</span>
<span class="c">#                                                                            #</span>
<span class="c">#----------------------------------------------------------------------------#</span>
<span class="k">def</span> <span class="nf">evalf_trig</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function handles sin and cos of real arguments.</span>

<span class="sd">    TODO: should also handle tan and complex arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">cos</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">mpf_cos</span>
    <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">sin</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">mpf_sin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c"># 20 extra bits is possibly overkill. It does make the need</span>
    <span class="c"># to restart very unlikely</span>
    <span class="n">xprec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">20</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">xprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">cos</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fone</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">sin</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="c"># For trigonometric functions, we are interested in the</span>
    <span class="c"># fixed-point (absolute) accuracy of the argument.</span>
    <span class="n">xsize</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="c"># Magnitude &lt;= 1.0. OK to compute directly, because there is no</span>
    <span class="c"># danger of hitting the first root of cos (with sin, magnitude</span>
    <span class="c"># &lt;= 2.0 would actually be ok)</span>
    <span class="k">if</span> <span class="n">xsize</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>
    <span class="c"># Very large</span>
    <span class="k">if</span> <span class="n">xsize</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">xprec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="n">xsize</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">xprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="c"># Need to repeat in case the argument is very close to a</span>
    <span class="c"># multiple of pi (or pi/2), hitting close to a root</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
        <span class="n">ysize</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="o">-</span><span class="n">ysize</span>
        <span class="n">accuracy</span> <span class="o">=</span> <span class="p">(</span><span class="n">xprec</span> <span class="o">-</span> <span class="n">xsize</span><span class="p">)</span> <span class="o">-</span> <span class="n">gap</span>
        <span class="k">if</span> <span class="n">accuracy</span> <span class="o">&lt;</span> <span class="n">prec</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;verbose&#39;</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;SIN/COS&quot;</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="s">&quot;wanted&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="s">&quot;gap&quot;</span><span class="p">,</span> <span class="n">gap</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="n">to_str</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">xprec</span> <span class="o">&gt;</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;maxprec&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAXPREC</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">,</span> <span class="bp">None</span>
            <span class="n">xprec</span> <span class="o">+=</span> <span class="n">gap</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">xprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">evalf_log</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">workprec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">xacc</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">workprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">xim</span><span class="p">:</span>
        <span class="c"># XXX: use get_abs etc instead</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">evalf_log</span><span class="p">(</span>
            <span class="n">C</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">mpf_atan2</span><span class="p">(</span><span class="n">xim</span><span class="p">,</span> <span class="n">xre</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">im</span><span class="p">,</span> <span class="n">re</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">prec</span>

    <span class="n">imaginary_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpf_cmp</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">fzero</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">re</span> <span class="o">=</span> <span class="n">mpf_log</span><span class="p">(</span><span class="n">mpf_abs</span><span class="p">(</span><span class="n">xre</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prec</span> <span class="o">-</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">workprec</span><span class="p">:</span>
        <span class="c"># We actually need to compute 1+x accurately, not x</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf_add</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">prec2</span> <span class="o">=</span> <span class="n">workprec</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">xre</span><span class="p">)</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">mpf_log</span><span class="p">(</span><span class="n">mpf_add</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">fone</span><span class="p">,</span> <span class="n">prec2</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>

    <span class="n">re_acc</span> <span class="o">=</span> <span class="n">prec</span>

    <span class="k">if</span> <span class="n">imaginary_term</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">mpf_pi</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">prec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">evalf_atan</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xre</span><span class="p">,</span> <span class="n">xim</span><span class="p">,</span> <span class="n">reacc</span><span class="p">,</span> <span class="n">imacc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xre</span> <span class="ow">is</span> <span class="n">xim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,)</span><span class="o">*</span><span class="mi">4</span>
    <span class="k">if</span> <span class="n">xim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">return</span> <span class="n">mpf_atan</span><span class="p">(</span><span class="n">xre</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">evalf_subs</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">subs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Change all Float entries in `subs` to have precision prec. &quot;&quot;&quot;</span>
    <span class="n">newsubs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">subs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="n">newsubs</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">newsubs</span>


<span class="k">def</span> <span class="nf">evalf_piecewise</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="k">if</span> <span class="s">&#39;subs&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">evalf_subs</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s">&#39;subs&#39;</span><span class="p">]))</span>
        <span class="n">newopts</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">newopts</span><span class="p">[</span><span class="s">&#39;subs&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s">&#39;func&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">newopts</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">newopts</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">evalf</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integer</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">newopts</span><span class="p">)</span>

    <span class="c"># We still have undefined symbols</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">def</span> <span class="nf">evalf_bernoulli</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Bernoulli number index must be an integer&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">mpf_bernoulli</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">rnd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>

<span class="c">#----------------------------------------------------------------------------#</span>
<span class="c">#                                                                            #</span>
<span class="c">#                            High-level operations                           #</span>
<span class="c">#                                                                            #</span>
<span class="c">#----------------------------------------------------------------------------#</span>


<span class="k">def</span> <span class="nf">as_mpmath</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Zero</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Infinity</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="s">&#39;inf&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="s">&#39;-inf&#39;</span><span class="p">)</span>
    <span class="c"># XXX</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mpc</span><span class="p">(</span><span class="n">re</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">im</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">do_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">xlow</span><span class="p">,</span> <span class="n">xhigh</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">orig</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">prec</span>

    <span class="n">oldmaxprec</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;maxprec&#39;</span><span class="p">,</span> <span class="n">DEFAULT_MAXPREC</span><span class="p">)</span>
    <span class="n">options</span><span class="p">[</span><span class="s">&#39;maxprec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">oldmaxprec</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">prec</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">5</span>
        <span class="n">xlow</span> <span class="o">=</span> <span class="n">as_mpmath</span><span class="p">(</span><span class="n">xlow</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">xhigh</span> <span class="o">=</span> <span class="n">as_mpmath</span><span class="p">(</span><span class="n">xhigh</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="c"># Integration is like summation, and we can phone home from</span>
        <span class="c"># the integrand function to update accuracy summation style</span>
        <span class="c"># Note that this accuracy is inaccurate, since it fails</span>
        <span class="c"># to account for the variable quadrature weights,</span>
        <span class="c"># but it is better than nothing</span>

        <span class="n">have_part</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">]</span>
        <span class="n">max_real_term</span> <span class="o">=</span> <span class="p">[</span><span class="n">MINUS_INF</span><span class="p">]</span>
        <span class="n">max_imag_term</span> <span class="o">=</span> <span class="p">[</span><span class="n">MINUS_INF</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">mp</span><span class="o">.</span><span class="n">prec</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;subs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">t</span><span class="p">}})</span>

            <span class="n">have_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span> <span class="ow">or</span> <span class="n">have_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">have_part</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">im</span> <span class="ow">or</span> <span class="n">have_part</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">max_real_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_real_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">))</span>
            <span class="n">max_imag_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_imag_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mpc</span><span class="p">(</span><span class="n">re</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="n">im</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mpf</span><span class="p">(</span><span class="n">re</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;quad&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;osc&#39;</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Wild</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Wild</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Wild</span><span class="p">(</span><span class="s">&#39;D&#39;</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">D</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;An integrand of the form sin(A*x+B)*f(x) &quot;</span>
                  <span class="s">&quot;or cos(A*x+B)*f(x) is required for oscillatory quadrature&quot;</span><span class="p">)</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">as_mpmath</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="o">/</span><span class="n">m</span><span class="p">[</span><span class="n">A</span><span class="p">],</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">quadosc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">xlow</span><span class="p">,</span> <span class="n">xhigh</span><span class="p">],</span> <span class="n">period</span><span class="o">=</span><span class="n">period</span><span class="p">)</span>
            <span class="c"># XXX: quadosc does not do error detection yet</span>
            <span class="n">quadrature_error</span> <span class="o">=</span> <span class="n">MINUS_INF</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">quadrature_error</span> <span class="o">=</span> <span class="n">quadts</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">xlow</span><span class="p">,</span> <span class="n">xhigh</span><span class="p">],</span> <span class="n">error</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">quadrature_error</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">quadrature_error</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">)</span>

    <span class="k">finally</span><span class="p">:</span>
        <span class="n">options</span><span class="p">[</span><span class="s">&#39;maxprec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldmaxprec</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="n">orig</span>

    <span class="k">if</span> <span class="n">have_part</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">_mpf_</span>
        <span class="k">if</span> <span class="n">re</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="n">prec</span><span class="p">,</span> <span class="o">-</span><span class="n">max_real_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">quadrature_error</span><span class="p">))</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>  <span class="c"># handled ok in evalf_integral</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">re_acc</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">max_real_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">re</span><span class="p">)</span> <span class="o">-</span>
                          <span class="n">prec</span><span class="p">,</span> <span class="n">quadrature_error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">re_acc</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">have_part</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">_mpf_</span>
        <span class="k">if</span> <span class="n">im</span> <span class="o">==</span> <span class="n">fzero</span><span class="p">:</span>
            <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span>
                <span class="nb">min</span><span class="p">(</span><span class="o">-</span><span class="n">prec</span><span class="p">,</span> <span class="o">-</span><span class="n">max_imag_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">quadrature_error</span><span class="p">))</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">scaled_zero</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>  <span class="c"># handled ok in evalf_integral</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im_acc</span> <span class="o">=</span> <span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="n">max_imag_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">im</span><span class="p">)</span> <span class="o">-</span>
                          <span class="n">prec</span><span class="p">,</span> <span class="n">quadrature_error</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">im</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">evalf_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">workprec</span> <span class="o">=</span> <span class="n">prec</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxprec</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;maxprec&#39;</span><span class="p">,</span> <span class="n">INF</span><span class="p">)</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">do_integral</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">workprec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="c"># if a scaled_zero comes back accuracy will compute to -1</span>
        <span class="c"># which will cause workprec to increment by 1</span>
        <span class="n">accuracy</span> <span class="o">=</span> <span class="n">complex_accuracy</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">accuracy</span> <span class="o">&gt;=</span> <span class="n">prec</span> <span class="ow">or</span> <span class="n">workprec</span> <span class="o">&gt;=</span> <span class="n">maxprec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">workprec</span> <span class="o">+=</span> <span class="n">prec</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">,</span> <span class="n">accuracy</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">check_convergence</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns (h, g, p) where</span>
<span class="sd">    -- h is:</span>
<span class="sd">        &gt; 0 for convergence of rate 1/factorial(n)**h</span>
<span class="sd">        &lt; 0 for divergence of rate factorial(n)**(-h)</span>
<span class="sd">        = 0 for geometric or polynomial convergence or divergence</span>

<span class="sd">    -- abs(g) is:</span>
<span class="sd">        &gt; 1 for geometric convergence of rate 1/h**n</span>
<span class="sd">        &lt; 1 for geometric divergence of rate h**n</span>
<span class="sd">        = 1 for polynomial convergence or divergence</span>

<span class="sd">        (g &lt; 0 indicates an alternating series)</span>

<span class="sd">    -- p is:</span>
<span class="sd">        &gt; 1 for polynomial convergence of rate 1/n**h</span>
<span class="sd">        &lt;= 1 for polynomial divergence of rate n**(-h)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">npol</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Poly</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">dpol</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Poly</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">npol</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">dpol</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">p</span>
    <span class="k">if</span> <span class="n">rate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rate</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
    <span class="n">constant</span> <span class="o">=</span> <span class="n">dpol</span><span class="o">.</span><span class="n">LC</span><span class="p">()</span> <span class="o">/</span> <span class="n">npol</span><span class="o">.</span><span class="n">LC</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rate</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">npol</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="n">dpol</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rate</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="mi">0</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">npol</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">dpol</span><span class="o">.</span><span class="n">all_coeffs</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">rate</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="p">(</span><span class="n">qc</span> <span class="o">-</span> <span class="n">pc</span><span class="p">)</span><span class="o">/</span><span class="n">dpol</span><span class="o">.</span><span class="n">LC</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">hypsum</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum a rapidly convergent infinite hypergeometric series with</span>
<span class="sd">    given general term, e.g. e = hypsum(1/factorial(n), n). The</span>
<span class="sd">    quotient between successive terms must be a quotient of integer</span>
<span class="sd">    polynomials.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">hypersimp</span><span class="p">,</span> <span class="n">lambdify</span>

    <span class="k">if</span> <span class="n">start</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="n">hypersimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;a hypergeometric series is required&quot;</span><span class="p">)</span>
    <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>

    <span class="n">func1</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
    <span class="n">func2</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span>

    <span class="n">h</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">check_convergence</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Sum diverges like (n!)^</span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">h</span><span class="p">))</span>

    <span class="c"># Direct summation if geometric or faster</span>
    <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">term</span> <span class="o">=</span> <span class="p">(</span><span class="n">MPZ</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">prec</span><span class="p">)</span> <span class="o">//</span> <span class="n">term</span><span class="o">.</span><span class="n">q</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">term</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">*=</span> <span class="n">MPZ</span><span class="p">(</span><span class="n">func1</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">term</span> <span class="o">//=</span> <span class="n">MPZ</span><span class="p">(</span><span class="n">func2</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">term</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">from_man_exp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="n">prec</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">alt</span> <span class="o">=</span> <span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Sum diverges like (</span><span class="si">%i</span><span class="s">)^n&quot;</span> <span class="o">%</span> <span class="nb">abs</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">g</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">alt</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Sum diverges like n^</span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>
        <span class="c"># We have polynomial convergence: use Richardson extrapolation</span>
        <span class="c"># Need to use at least quad precision because a lot of cancellation</span>
        <span class="c"># might occur in the extrapolation process</span>
        <span class="n">prec2</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">prec</span>
        <span class="n">term</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">term</span> <span class="o">=</span> <span class="p">(</span><span class="n">MPZ</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">prec2</span><span class="p">)</span> <span class="o">//</span> <span class="n">term</span><span class="o">.</span><span class="n">q</span>

        <span class="k">def</span> <span class="nf">summand</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">_term</span><span class="o">=</span><span class="p">[</span><span class="n">term</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">MPZ</span><span class="p">(</span><span class="n">func1</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">_term</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//=</span> <span class="n">MPZ</span><span class="p">(</span><span class="n">func2</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="n">from_man_exp</span><span class="p">(</span><span class="n">_term</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">prec2</span><span class="p">))</span>

        <span class="n">orig</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">prec</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mp</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="n">prec</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">nsum</span><span class="p">(</span><span class="n">summand</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mpmath_inf</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;richardson&#39;</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">mp</span><span class="o">.</span><span class="n">prec</span> <span class="o">=</span> <span class="n">orig</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="n">_mpf_</span>


<span class="k">def</span> <span class="nf">evalf_sum</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">function</span>
    <span class="n">limits</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">limits</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="nb">len</span><span class="p">(</span><span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="n">prec2</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c"># Use fast hypergeometric summation if possible</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">hypsum</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">prec2</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">-</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">10</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">hypsum</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="bp">None</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="c"># Euler-Maclaurin summation for general series</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span> <span class="o">*</span> <span class="n">prec</span>
            <span class="n">s</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">euler_maclaurin</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                <span class="n">eval_integral</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">fastlog</span><span class="p">(</span><span class="n">evalf</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">err</span><span class="p">),</span> <span class="mi">20</span><span class="p">,</span> <span class="n">options</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">prec2</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c"># issue 3174</span>
            <span class="c"># when should it try subs if they are in options?</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">if</span> <span class="n">re_acc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">re_acc</span> <span class="o">=</span> <span class="o">-</span><span class="n">err</span>
        <span class="k">if</span> <span class="n">im_acc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">im_acc</span> <span class="o">=</span> <span class="o">-</span><span class="n">err</span>
        <span class="k">return</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span>


<span class="c">#----------------------------------------------------------------------------#</span>
<span class="c">#                                                                            #</span>
<span class="c">#                            Symbolic interface                              #</span>
<span class="c">#                                                                            #</span>
<span class="c">#----------------------------------------------------------------------------#</span>

<span class="k">def</span> <span class="nf">evalf_symbol</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s">&#39;subs&#39;</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">mpf</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;_cache&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">options</span><span class="p">[</span><span class="s">&#39;_cache&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s">&#39;_cache&#39;</span><span class="p">]</span>
        <span class="n">cached</span><span class="p">,</span> <span class="n">cached_prec</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">MINUS_INF</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">cached_prec</span> <span class="o">&gt;=</span> <span class="n">prec</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cached</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>

<span class="n">evalf_table</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">_create_evalf_table</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">evalf_table</span>
    <span class="n">evalf_table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">:</span> <span class="n">evalf_symbol</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">:</span> <span class="n">evalf_symbol</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Rational</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">from_rational</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Integer</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">from_int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">One</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">fone</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Half</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">fhalf</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Pi</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">mpf_pi</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Exp1</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">mpf_e</span><span class="p">(</span><span class="n">prec</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">fone</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">fnone</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
        <span class="n">C</span><span class="o">.</span><span class="n">NaN</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="p">(</span><span class="n">fnan</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>

        <span class="n">C</span><span class="o">.</span><span class="n">exp</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">evalf_pow</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Pow</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Exp1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">),</span>

        <span class="n">C</span><span class="o">.</span><span class="n">cos</span><span class="p">:</span> <span class="n">evalf_trig</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">sin</span><span class="p">:</span> <span class="n">evalf_trig</span><span class="p">,</span>

        <span class="n">C</span><span class="o">.</span><span class="n">Add</span><span class="p">:</span> <span class="n">evalf_add</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">:</span> <span class="n">evalf_mul</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Pow</span><span class="p">:</span> <span class="n">evalf_pow</span><span class="p">,</span>

        <span class="n">C</span><span class="o">.</span><span class="n">log</span><span class="p">:</span> <span class="n">evalf_log</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">atan</span><span class="p">:</span> <span class="n">evalf_atan</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Abs</span><span class="p">:</span> <span class="n">evalf_abs</span><span class="p">,</span>

        <span class="n">C</span><span class="o">.</span><span class="n">re</span><span class="p">:</span> <span class="n">evalf_re</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">im</span><span class="p">:</span> <span class="n">evalf_im</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">floor</span><span class="p">:</span> <span class="n">evalf_floor</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">ceiling</span><span class="p">:</span> <span class="n">evalf_ceiling</span><span class="p">,</span>

        <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">:</span> <span class="n">evalf_integral</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Sum</span><span class="p">:</span> <span class="n">evalf_sum</span><span class="p">,</span>
        <span class="n">C</span><span class="o">.</span><span class="n">Piecewise</span><span class="p">:</span> <span class="n">evalf_piecewise</span><span class="p">,</span>

        <span class="n">C</span><span class="o">.</span><span class="n">bernoulli</span><span class="p">:</span> <span class="n">evalf_bernoulli</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">evalf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">re</span> <span class="k">as</span> <span class="n">re_</span><span class="p">,</span> <span class="n">im</span> <span class="k">as</span> <span class="n">im_</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rf</span> <span class="o">=</span> <span class="n">evalf_table</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">func</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># Fall back to ordinary evalf if possible</span>
            <span class="k">if</span> <span class="s">&#39;subs&#39;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">evalf_subs</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s">&#39;subs&#39;</span><span class="p">]))</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">re_</span><span class="p">)</span> <span class="ow">or</span> <span class="n">im</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">im_</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="k">if</span> <span class="n">re</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">re</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">reprec</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">allow_ints</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">_mpf_</span>
                <span class="n">reprec</span> <span class="o">=</span> <span class="n">prec</span>
            <span class="k">if</span> <span class="n">im</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">imprec</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">allow_ints</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">_mpf_</span>
                <span class="n">imprec</span> <span class="o">=</span> <span class="n">prec</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">reprec</span><span class="p">,</span> <span class="n">imprec</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;verbose&quot;</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;### input&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;### output&quot;</span><span class="p">,</span> <span class="n">to_str</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">fzero</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;### raw&quot;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>  <span class="c"># r[0], r[2]</span>
        <span class="k">print</span><span class="p">()</span>
    <span class="n">chop</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;chop&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">chop</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">chop</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">chop_prec</span> <span class="o">=</span> <span class="n">prec</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># convert (approximately) from given tolerance;</span>
            <span class="c"># the formula here will will make 1e-i rounds to 0 for</span>
            <span class="c"># i in the range +/-27 while 2e-i will not be chopped</span>
            <span class="n">chop_prec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="o">-</span><span class="mf">3.321</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">chop</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">chop_prec</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">chop_prec</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">chop_parts</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">chop_prec</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;strict&quot;</span><span class="p">):</span>
        <span class="n">check_target</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">class</span> <span class="nc">EvalfMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin class adding evalf capabililty.&quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">maxn</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">chop</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">quad</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the given formula to an accuracy of n digits.</span>
<span class="sd">        Optional keyword arguments:</span>

<span class="sd">            subs=&lt;dict&gt;</span>
<span class="sd">                Substitute numerical values for symbols, e.g.</span>
<span class="sd">                subs={x:3, y:1+pi}.</span>

<span class="sd">            maxn=&lt;integer&gt;</span>
<span class="sd">                Allow a maximum temporary working precision of maxn digits</span>
<span class="sd">                (default=100)</span>

<span class="sd">            chop=&lt;bool&gt;</span>
<span class="sd">                Replace tiny real or imaginary parts in subresults</span>
<span class="sd">                by exact zeros (default=False)</span>

<span class="sd">            strict=&lt;bool&gt;</span>
<span class="sd">                Raise PrecisionExhausted if any subresult fails to evaluate</span>
<span class="sd">                to full accuracy, given the available maxprec</span>
<span class="sd">                (default=False)</span>

<span class="sd">            quad=&lt;str&gt;</span>
<span class="sd">                Choose algorithm for numerical quadrature. By default,</span>
<span class="sd">                tanh-sinh quadrature is used. For oscillatory</span>
<span class="sd">                integrals on an infinite interval, try quad=&#39;osc&#39;.</span>

<span class="sd">            verbose=&lt;bool&gt;</span>
<span class="sd">                Print debug information (default=False)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># for sake of sage that doesn&#39;t like evalf(1)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy.core.expr</span> <span class="kn">import</span> <span class="n">_mag</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">subs</span><span class="p">,</span> <span class="n">maxn</span><span class="p">,</span> <span class="n">chop</span><span class="p">,</span> <span class="n">strict</span><span class="p">,</span> <span class="n">quad</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">_mag</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">evalf_table</span><span class="p">:</span>
            <span class="n">_create_evalf_table</span><span class="p">()</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="n">dps_to_prec</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;maxprec&#39;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxn</span><span class="o">*</span><span class="n">LG10</span><span class="p">)),</span> <span class="s">&#39;chop&#39;</span><span class="p">:</span> <span class="n">chop</span><span class="p">,</span>
               <span class="s">&#39;strict&#39;</span><span class="p">:</span> <span class="n">strict</span><span class="p">,</span> <span class="s">&#39;verbose&#39;</span><span class="p">:</span> <span class="n">verbose</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">subs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">options</span><span class="p">[</span><span class="s">&#39;subs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subs</span>
        <span class="k">if</span> <span class="n">quad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">options</span><span class="p">[</span><span class="s">&#39;quad&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="c"># Fall back to the ordinary evalf</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># If the result is numerical, normalize it</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="c"># Probably contains symbols or unknown functions</span>
                <span class="k">return</span> <span class="n">v</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">,</span> <span class="n">im_acc</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">if</span> <span class="n">re</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">re_acc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c">#re = mpf_pos(re, p, rnd)</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">im_acc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c">#im = mpf_pos(im, p, rnd)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">re</span> <span class="o">+</span> <span class="n">im</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">re</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">evalf</span>

    <span class="k">def</span> <span class="nf">_evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper for evalf. Does the same thing but takes binary precision&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">_eval_evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_to_mpmath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">allow_ints</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="c"># mpmath functions accept ints as input</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="s">&quot;cannot convert to mpmath number&quot;</span>
        <span class="k">if</span> <span class="n">allow_ints</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_as_mpf_val&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_as_mpf_val</span><span class="p">(</span><span class="n">prec</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evalf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="p">:</span>
                    <span class="n">re</span> <span class="o">=</span> <span class="n">fzero</span>
                <span class="k">return</span> <span class="n">make_mpc</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">re</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="n">fzero</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">make_mpf</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">)</span>
            <span class="c"># Number + Number*I is also fine</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">allow_ints</span> <span class="ow">and</span> <span class="n">re</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="n">re</span> <span class="o">=</span> <span class="n">from_int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">_mpf_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">allow_ints</span> <span class="ow">and</span> <span class="n">im</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">from_int</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">im</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="n">im</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">_mpf_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">make_mpc</span><span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">))</span>


<div class="viewcode-block" id="N"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.evalf.N">[docs]</a><span class="k">def</span> <span class="nf">N</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calls x.evalf(n, \*\*options).</span>

<span class="sd">    Both .n() and N() are equivalent to .evalf(); use the one that you like better.</span>
<span class="sd">    See also the docstring of .evalf() for information on the options.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Sum, Symbol, oo, N</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import k</span>
<span class="sd">    &gt;&gt;&gt; Sum(1/k**k, (k, 1, oo))</span>
<span class="sd">    Sum(k**(-k), (k, 1, oo))</span>
<span class="sd">    &gt;&gt;&gt; N(_, 4)</span>
<span class="sd">    1.291</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Jan 20, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>
