

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ODE &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../index.html" />
    <link rel="up" title="SymPy Modules Reference" href="../index.html" />
    <link rel="next" title="Solvers" href="../solvers/solvers.html" />
    <link rel="prev" title="Stats" href="../stats.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../solvers/solvers.html" title="Solvers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../stats.html" title="Stats"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ode">
<span id="ode-docs"></span><h1>ODE<a class="headerlink" href="#ode" title="Permalink to this headline">¶</a></h1>
<div class="section" id="user-functions">
<h2>User Functions<a class="headerlink" href="#user-functions" title="Permalink to this headline">¶</a></h2>
<p>These are functions that are imported into the global namespace with <tt class="docutils literal"><span class="pre">from</span> <span class="pre">sympy</span> <span class="pre">import</span> <span class="pre">*</span></tt>.  They are intended for user use.</p>
<div class="section" id="dsolve">
<h3><tt class="xref py py-func docutils literal"><span class="pre">dsolve()</span></tt><a class="headerlink" href="#dsolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.dsolve">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">dsolve</tt><big>(</big><em>eq</em>, <em>func=None</em>, <em>hint='default'</em>, <em>simplify=True</em>, <em>prep=True</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#dsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.dsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves any (supported) kind of ordinary differential equation.</p>
<p><strong>Usage</strong></p>
<blockquote>
<div>dsolve(eq, f(x), hint) -&gt; Solve ordinary differential equation
eq for function f(x), using method hint.</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">eq</span></tt> can be any supported ordinary differential equation (see</dt>
<dd>the ode docstring for supported methods).  This can either
be an Equality, or an expression, which is assumed to be
equal to 0.</dd>
<dt><tt class="docutils literal"><span class="pre">f(x)</span></tt> is a function of one variable whose derivatives in that</dt>
<dd>variable make up the ordinary differential equation eq. In many
cases it is not necessary to provide this; it will be autodetected
(and an error raised if it couldn&#8217;t be detected).</dd>
<dt><tt class="docutils literal"><span class="pre">hint</span></tt> is the solving method that you want dsolve to use.  Use</dt>
<dd>classify_ode(eq, f(x)) to get all of the possible hints for
an ODE.  The default hint, &#8216;default&#8217;, will use whatever hint
is returned first by classify_ode().  See Hints below for
more options that you can use for hint.</dd>
<dt><tt class="docutils literal"><span class="pre">simplify</span></tt> enables simplification by odesimp().  See its</dt>
<dd>docstring for more information.  Turn this off, for example,
to disable solving of solutions for func or simplification
of arbitrary constants.  It will still integrate with this
hint. Note that the solution may contain more arbitrary
constants than the order of the ODE with this option
enabled.</dd>
<dt><tt class="docutils literal"><span class="pre">prep</span></tt>, when False and when <tt class="docutils literal"><span class="pre">func</span></tt> is given, will skip the</dt>
<dd>preprocessing step where the equation is cleaned up so it
is ready for solving.</dd>
</dl>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>Aside from the various solving methods, there are also some
meta-hints that you can pass to dsolve():</p>
<dl class="docutils">
<dt>&#8220;default&#8221;:</dt>
<dd>This uses whatever hint is returned first by
classify_ode(). This is the default argument to
dsolve().</dd>
<dt>&#8220;all&#8221;:</dt>
<dd><p class="first">To make dsolve apply all relevant classification hints,
use dsolve(ODE, func, hint=&#8221;all&#8221;).  This will return a
dictionary of hint:solution terms.  If a hint causes
dsolve to raise the NotImplementedError, value of that
hint&#8217;s key will be the exception object raised.  The
dictionary will also include some special keys:</p>
<ul class="last simple">
<li>order: The order of the ODE.  See also ode_order().</li>
<li>best: The simplest hint; what would be returned by
&#8220;best&#8221; below.</li>
<li>best_hint: The hint that would produce the solution
given by &#8216;best&#8217;.  If more than one hint produces the
best solution, the first one in the tuple returned by
classify_ode() is chosen.</li>
<li>default: The solution that would be returned by
default.  This is the one produced by the hint that
appears first in the tuple returned by classify_ode().</li>
</ul>
</dd>
<dt>&#8220;all_Integral&#8221;:</dt>
<dd>This is the same as &#8220;all&#8221;, except if a hint also has a
corresponding &#8220;_Integral&#8221; hint, it only returns the
&#8220;_Integral&#8221; hint.  This is useful if &#8220;all&#8221; causes
dsolve() to hang because of a difficult or impossible
integral.  This meta-hint will also be much faster than
&#8220;all&#8221;, because integrate() is an expensive routine.</dd>
<dt>&#8220;best&#8221;:</dt>
<dd>To have dsolve() try all methods and return the simplest
one.  This takes into account whether the solution is
solvable in the function, whether it contains any
Integral classes (i.e. unevaluatable integrals), and
which one is the shortest in size.</dd>
</dl>
<p>See also the classify_ode() docstring for more info on hints,
and the ode docstring for a list of all supported hints.</p>
</div></blockquote>
<dl class="docutils">
<dt><strong>Tips</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>You can declare the derivative of an unknown function this way:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span> <span class="c"># x is the independent variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="c"># f is a function of x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># f_ will be the derivative of f with respect to x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
<li><p class="first">See test_ode.py for many tests, which serves also as a set of
examples for how to use dsolve().</p>
</li>
<li><p class="first">dsolve always returns an Equality class (except for the case
when the hint is &#8220;all&#8221; or &#8220;all_Integral&#8221;).  If possible, it
solves the solution explicitly for the function being solved
for. Otherwise, it returns an implicit solution.</p>
</li>
<li><p class="first">Arbitrary constants are symbols named C1, C2, and so on.</p>
</li>
<li><p class="first">Because all solutions should be mathematically equivalent,
some hints may return the exact same result for an ODE. Often,
though, two different hints will return the same solution
formatted differently.  The two should be equivalent. Also
note that sometimes the values of the arbitrary constants in
two different solutions may not be the same, because one
constant may have &#8220;absorbed&#8221; other constants into it.</p>
</li>
<li><p class="first">Do help(ode.ode_hintname) to get help more information on a
specific hint, where hintname is the name of a hint without
&#8220;_Integral&#8221;.</p>
</li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">f(x) == C1*sin(3*x) + C2*cos(3*x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">-log(sin(f(x))**2 - 1)/2 == C1 + log(sin(x)**2 - 1)/2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">f(x) == acos(C1/cos(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;best&#39;</span><span class="p">)</span>
<span class="go">f(x) == acos(C1/cos(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Note that even though separable is the default, 1st_exact produces</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># a simpler result in this case.</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="classify-ode">
<h3><tt class="xref py py-func docutils literal"><span class="pre">classify_ode()</span></tt><a class="headerlink" href="#classify-ode" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.classify_ode">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">classify_ode</tt><big>(</big><em>eq</em>, <em>func=None</em>, <em>dict=False</em>, <em>prep=True</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#classify_ode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.classify_ode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of possible dsolve() classifications for an ODE.</p>
<p>The tuple is ordered so that first item is the classification that
dsolve() uses to solve the ODE by default.  In general,
classifications at the near the beginning of the list will produce
better solutions faster than those near the end, thought there are
always exceptions.  To make dsolve use a different classification,
use dsolve(ODE, func, hint=&lt;classification&gt;).  See also the dsolve()
docstring for different meta-hints you can use.</p>
<p>If <tt class="docutils literal"><span class="pre">dict</span></tt> is true, classify_ode() will return a dictionary of
hint:match expression terms. This is intended for internal use by
dsolve().  Note that because dictionaries are ordered arbitrarily,
this will most likely not be in the same order as the tuple.</p>
<p>If <tt class="docutils literal"><span class="pre">prep</span></tt> is False or <tt class="docutils literal"><span class="pre">func</span></tt> is None then the equation
will be preprocessed to put it in standard form for classification.</p>
<p>You can get help on different hints by doing help(ode.ode_hintname),
where hintname is the name of the hint without &#8220;_Integral&#8221;.</p>
<p>See sympy.ode.allhints or the sympy.ode docstring for a list of all
supported hints that can be returned from classify_ode.</p>
<p class="rubric">Notes</p>
<p>These are remarks on hint names.</p>
<p><em>&#8220;_Integral&#8221;</em></p>
<blockquote>
<div><p>If a classification has &#8220;_Integral&#8221; at the end, it will return
the expression with an unevaluated Integral class in it.  Note
that a hint may do this anyway if integrate() cannot do the
integral, though just using an &#8220;_Integral&#8221; will do so much
faster.  Indeed, an &#8220;_Integral&#8221; hint will always be faster than
its corresponding hint without &#8220;_Integral&#8221; because integrate()
is an expensive routine.  If dsolve() hangs, it is probably
because integrate() is hanging on a tough or impossible
integral.  Try using an &#8220;_Integral&#8221; hint or &#8220;all_Integral&#8221; to
get it return something.</p>
<p>Note that some hints do not have &#8220;_Integral&#8221; counterparts.  This
is because integrate() is not used in solving the ODE for those
method. For example, nth order linear homogeneous ODEs with
constant coefficients do not require integration to solve, so
there is no &#8220;nth_linear_homogeneous_constant_coeff_Integrate&#8221;
hint. You can easily evaluate any unevaluated Integrals in an
expression by doing expr.doit().</p>
</div></blockquote>
<p><em>Ordinals</em></p>
<blockquote>
<div>Some hints contain an ordinal such as &#8220;1st_linear&#8221;.  This is to
help differentiate them from other hints, as well as from other
methods that may not be implemented yet. If a hint has &#8220;nth&#8221; in
it, such as the &#8220;nth_linear&#8221; hints, this means that the method
used to applies to ODEs of any order.</div></blockquote>
<p><em>&#8220;indep&#8221; and &#8220;dep&#8221;</em></p>
<blockquote>
<div>Some hints contain the words &#8220;indep&#8221; or &#8220;dep&#8221;.  These reference
the independent variable and the dependent function,
respectively. For example, if an ODE is in terms of f(x), then
&#8220;indep&#8221; will refer to x and &#8220;dep&#8221; will refer to f.</div></blockquote>
<p><em>&#8220;subs&#8221;</em></p>
<blockquote>
<div>If a hints has the word &#8220;subs&#8221; in it, it means the the ODE is
solved by substituting the expression given after the word
&#8220;subs&#8221; for a single dummy variable.  This is usually in terms of
&#8220;indep&#8221; and &#8220;dep&#8221; as above.  The substituted expression will be
written only in characters allowed for names of Python objects,
meaning operators will be spelled out.  For example, indep/dep
will be written as indep_div_dep.</div></blockquote>
<p><em>&#8220;coeff&#8221;</em></p>
<blockquote>
<div>The word &#8220;coeff&#8221; in a hint refers to the coefficients of
something in the ODE, usually of the derivative terms.  See the
docstring for the individual methods for more info (help(ode)).
This is contrast to &#8220;coefficients&#8221;, as in
&#8220;undetermined_coefficients&#8221;, which refers to the common name of
a method.</div></blockquote>
<p><em>&#8220;_best&#8221;</em></p>
<blockquote>
<div>Methods that have more than one fundamental way to solve will
have a hint for each sub-method and a &#8220;_best&#8221;
meta-classification. This will evaluate all hints and return the
best, using the same considerations as the normal &#8220;best&#8221;
meta-hint.</div></blockquote>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">classify_ode</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(&#39;separable&#39;, &#39;1st_linear&#39;, &#39;1st_homogeneous_coeff_best&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_homogeneous&#39;, &#39;separable_Integral&#39;,</span>
<span class="go">&#39;1st_linear_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ode-order">
<h3><tt class="xref py py-func docutils literal"><span class="pre">ode_order()</span></tt><a class="headerlink" href="#ode-order" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_order">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_order</tt><big>(</big><em>expr</em>, <em>func</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order of a given ODE with respect to func.</p>
<p>This function is implemented recursively.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">ode_order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="checkodesol">
<h3><tt class="xref py py-func docutils literal"><span class="pre">checkodesol()</span></tt><a class="headerlink" href="#checkodesol" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.checkodesol">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">checkodesol</tt><big>(</big><em>ode</em>, <em>sol</em>, <em>func=None</em>, <em>order='auto'</em>, <em>solve_for_func=True</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#checkodesol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.checkodesol" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes sol into the ode and checks that the result is 0.</p>
<p>This only works when func is one function, like f(x).  sol can be a
single solution or a list of solutions.  Each solution may be an Equality
that the solution satisfies, e.g. Eq(f(x), C1), Eq(f(x) + C1, 0); or simply
an Expr, e.g. f(x) - C1. In most cases it will not be necessary to
explicitly identify the function, but if the function cannot be inferred
from the original equation it can be supplied through the &#8216;func&#8217; argument.</p>
<p>If a sequence of solutions is passed, the same sort of container will be used
to return the result for each solution.</p>
<p>It tries the following methods, in order, until it finds zero
equivalence:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Substitute the solution for f in the original equation.  This
only works if the ode is solved for f.  It will attempt to solve
it first unless solve_for_func == False</li>
<li>Take n derivatives of the solution, where n is the order of
ode, and check to see if that is equal to the solution.  This
only works on exact odes.</li>
<li>Take the 1st, 2nd, ..., nth derivatives of the solution, each
time solving for the derivative of f of that order (this will
always be possible because f is a linear operator).  Then back
substitute each derivative into ode in reverse order.</li>
</ol>
</div></blockquote>
<p>This function returns a tuple.  The first item in the tuple is True
if the substitution results in 0, and False otherwise. The second
item in the tuple is what the substitution results in.  It should
always be 0 if the first item is True. Note that sometimes this
function will False, but with an expression that is identically
equal to 0, instead of returning True.  This is because simplify()
cannot reduce the expression to 0.  If an expression returned by
this function vanishes identically, then sol really is a solution to
ode.</p>
<p>If this function seems to hang, it is probably because of a hard
simplification.</p>
<p>To use this function to test, test the first item of the tuple.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">checkodesol</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">(True, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(False, 2)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="homogeneous-order">
<h3><tt class="xref py py-func docutils literal"><span class="pre">homogeneous_order()</span></tt><a class="headerlink" href="#homogeneous-order" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.homogeneous_order">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">homogeneous_order</tt><big>(</big><em>eq</em>, <em>*symbols</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#homogeneous_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.homogeneous_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order n if g is homogeneous and None if it is not
homogeneous.</p>
<p>Determines if a function is homogeneous and if so of what order.
A function f(x,y,...) is homogeneous of order n if
f(t*x,t*y,t*...) == t**n*f(x,y,...).</p>
<p>If the function is of two variables, F(x, y), then f being
homogeneous of any order is equivalent to being able to rewrite
F(x, y) as G(x/y) or H(y/x).  This fact is used to solve 1st order
ordinary differential equations whose coefficients are homogeneous
of the same order (see the docstrings of
ode.ode_1st_homogeneous_coeff_subs_indep_div_dep() and
ode.ode_1st_homogeneous_coeff_subs_indep_div_dep()</p>
<p>Symbols can be functions, but every argument of the function must be
a symbol, and the arguments of the function that appear in the
expression must match those given in the list of symbols.  If a
declared function appears with different arguments than given in the
list of symbols, None is returned.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">homogeneous_order</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="hint-methods">
<h2>Hint Methods<a class="headerlink" href="#hint-methods" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use by <tt class="xref py py-func docutils literal"><span class="pre">dsolve()</span></tt> and others.  Nonetheless, they contain useful information in their docstrings on the various ODE solving methods.</p>
<div class="section" id="preprocess">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">preprocess</span></tt><a class="headerlink" href="#preprocess" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.preprocess">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">preprocess</tt><big>(</big><em>expr</em>, <em>func=None</em>, <em>hint='_Integral'</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#preprocess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepare expr for solving by making sure that differentiation
is done so that only func remains in unevaluated derivatives and
(if hint doesn&#8217;t end with _Integral) that doit is applied to all
other derivatives. If hint is None, don&#8217;t do any differentiation.
(Currently this may cause some simple differential equations to
fail.)</p>
<p>In case func is None, an attempt will be made to autodetect the
function to be solved for.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">preprocess</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="s">&#39;fg&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Apply doit to derivatives that contain more than the function
of interest:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">preprocess</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="go">(Derivative(f(x), x) + 1, f(x))</span>
</pre></div>
</div>
<p>Do others if the differentiation variable(s) intersect with those
of the function of interest or contain the function of interest:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">preprocess</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="go">(0, f(y))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preprocess</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="go">(0, f(y))</span>
</pre></div>
</div>
<p>Do others if the hint doesn&#8217;t end in &#8216;_Integral&#8217; (the default
assumes that it does):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">preprocess</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(Derivative(g(x), y), f(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preprocess</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">)</span>
<span class="go">(0, f(x))</span>
</pre></div>
</div>
<p>Don&#8217;t do any derivatives if hint is None:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">preprocess</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="go">(Derivative(f(x) + 1, x) + Derivative(f(x), y), f(x))</span>
</pre></div>
</div>
<p>If it&#8217;s not clear what the function of interest is, it must be given:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">preprocess</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(Derivative(f(x), x) + Derivative(g(x), x), g(x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span> <span class="n">preprocess</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;A ValueError was raised.&quot;</span><span class="p">)</span>
<span class="go">A ValueError was raised.</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="odesimp">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">odesimp</span></tt><a class="headerlink" href="#odesimp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.odesimp">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">odesimp</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#odesimp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.odesimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies ODEs, including trying to solve for func and running
constantsimp().</p>
<p>It may use knowledge of the type of solution that that hint returns
to apply additional simplifications.</p>
<p>It also attempts to integrate any Integrals in the expression, if
the hint is not an &#8220;_Integral&#8221; hint.</p>
<p>This function should have no effect on expressions returned by
dsolve(), as dsolve already calls odesimp(), but the individual hint
functions do not call odesimp (because the dsolve() wrapper does).
Therefore, this function is designed for mainly internal use.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">odesimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,u2,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">              x</span>
<span class="go">                 ----</span>
<span class="go">                 f(x)</span>
<span class="go">                   /</span>
<span class="go">                  |</span>
<span class="go">       /f(x)\     |  /  1         1     \</span>
<span class="go">    log|----| -   |  |- -- - -----------| d(u2) = 0</span>
<span class="go">       \ C1 /     |  |  u2     2    /1 \|</span>
<span class="go">                  |  |       u2 *sin|--||</span>
<span class="go">                  |  \              \u2//</span>
<span class="go">                  |</span>
<span class="go">                 /</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">odesimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span>
<span class="gp">... </span><span class="p">))</span> 
<span class="go">    x</span>
<span class="go">--------- = C1</span>
<span class="go">   /f(x)\</span>
<span class="go">tan|----|</span>
<span class="go">   \2*x /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constant-renumber">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">constant_renumber</span></tt><a class="headerlink" href="#constant-renumber" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.constant_renumber">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">constant_renumber</tt><big>(</big><em>expr</em>, <em>symbolname</em>, <em>startnumber</em>, <em>endnumber</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#constant_renumber"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.constant_renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Renumber arbitrary constants in expr to have numbers 1 through N
where N is <tt class="docutils literal"><span class="pre">endnumber</span></tt> - <tt class="docutils literal"><span class="pre">startnumber</span></tt> + 1 at most.</p>
<p>This is a simple function that goes through and renumbers any Symbol
with a name in the form symbolname + num where num is in the range
from startnumber to endnumber.</p>
<p>Symbols are renumbered based on <tt class="docutils literal"><span class="pre">.sort_key()</span></tt>, so they should be
numbered roughly in the order that they appear in the final, printed
expression.  Note that this ordering is based in part on hashes, so
it can produce different results on different machines.</p>
<p>The structure of this function is very similar to that of
constantsimp().</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">constant_renumber</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,C:5&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Only constants in the given range (inclusive) are renumbered;
the renumbering always starts from 1:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C4</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1 + C2 + C4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="n">C1</span> <span class="o">+</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C4</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">C0 + 2*C1 + C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">C1</span> <span class="o">+</span> <span class="n">C2</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">C1 + 3*C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">                2</span>
<span class="go">C1*x + C2 + C3*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">                2</span>
<span class="go">C1 + C2*x + C3*x</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constantsimp">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">constantsimp</span></tt><a class="headerlink" href="#constantsimp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.constantsimp">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">constantsimp</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#constantsimp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.constantsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies an expression with arbitrary constants in it.</p>
<p>This function is written specifically to work with dsolve(), and is
not intended for general use.</p>
<p>Simplification is done by &#8220;absorbing&#8221; the arbitrary constants in to
other arbitrary constants, numbers, and symbols that they are not
independent of.</p>
<p>The symbols must all have the same name with numbers after it, for
example, C1, C2, C3.  The symbolname here would be &#8216;C&#8217;, the
startnumber would be 1, and the end number would be 3.  If the
arbitrary constants are independent of the variable x, then the
independent symbol would be x.  There is no need to specify the
dependent function, such as f(x), because it already has the
independent symbol, x, in it.</p>
<p>Because terms are &#8220;absorbed&#8221; into arbitrary constants and because
constants are renumbered after simplifying, the arbitrary constants
in expr are not necessarily equal to the ones of the same name in
the returned result.</p>
<p>If two or more arbitrary constants are added, multiplied, or raised
to the power of each other, they are first absorbed together into a
single arbitrary constant.  Then the new constant is combined into
other terms if necessary.</p>
<p>Absorption is done with limited assistance: terms of Adds are collected
to try join constants and powers with exponents that are Adds are expanded
so (C1*cos(x) + C2*cos(x))*exp(x) will simplify to C1*cos(x)*exp(x) and
exp(C1 + x) will be simplified to C1*exp(x).</p>
<p>Use constant_renumber() to renumber constants after simplification or else
arbitrary numbers on constants may appear, e.g. C1 + C3*x.</p>
<p>In rare cases, a single constant can be &#8220;simplified&#8221; into two
constants.  Every differential equation solution should have as many
arbitrary constants as the order of the differential equation.  The
result here will be technically correct, but it may, for example,
have C1 and C2 in an expression, when C1 is actually equal to C2.
Use your discretion in such situations, and also take advantage of
the ability to use hints in dsolve().</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">constantsimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;C1,C2,C3,x,y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1 + x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span><span class="o">*</span><span class="n">C2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1 + C3*x</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sol-simplicity">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">sol_simplicity</span></tt><a class="headerlink" href="#sol-simplicity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_sol_simplicity">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_sol_simplicity</tt><big>(</big><em>sol</em>, <em>func</em>, <em>trysolving=True</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_sol_simplicity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_sol_simplicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an extended integer representing how simple a solution to an
ODE is.</p>
<p>The following things are considered, in order from most simple to
least:
- sol is solved for func.
- sol is not solved for func, but can be if passed to solve (e.g.,
a solution returned by dsolve(ode, func, simplify=False)
- If sol is not solved for func, then base the result on the length
of sol, as computed by len(str(sol)).
- If sol has any unevaluated Integrals, this will automatically be
considered less simple than any of the above.</p>
<p>This function returns an integer such that if solution A is simpler
than solution B by above metric, then ode_sol_simplicity(sola, func)
&lt; ode_sol_simplicity(solb, func).</p>
<p>Currently, the following are the numbers returned, but if the
heuristic is ever improved, this may change.  Only the ordering is
guaranteed.</p>
<p>sol solved for func                        -2
sol not solved for func but can be         -1
sol is not solved or solvable for func     len(str(sol))
sol contains an Integral                   oo</p>
<p>oo here means the SymPy infinity, which should compare greater than
any integer.</p>
<p>If you already know solve() cannot solve sol, you can use
trysolving=False to skip that step, which is the only potentially
slow step.  For example, dsolve with the simplify=False flag should
do this.</p>
<p>If sol is a list of solutions, if the worst solution in the list
returns oo it returns that, otherwise it returns len(str(sol)), that
is, the length of the string representation of the whole list.</p>
<p class="rubric">Examples</p>
<p>This function is designed to be passed to min as the key argument,
such as min(listofsolutions, key=lambda i: ode_sol_simplicity(i, f(x))).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">ode_sol_simplicity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x, C1, C2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">C2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">]]</span>
<span class="go">[26, 33]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">f(x)/tan(f(x)/(2*x)) == C1</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-exact">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_exact</span></tt><a class="headerlink" href="#st-exact" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_exact">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_exact</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_exact"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order exact ordinary differential equations.</p>
<p>A 1st order differential equation is called exact if it is the total
differential of a function. That is, the differential equation
P(x, y)dx + Q(x, y)dy = 0 is exact if there is some function F(x, y)
such that P(x, y) = dF/dx and Q(x, y) = dF/dy (d here refers to the
partial derivative).  It can be shown that a necessary and
sufficient condition for a first order ODE to be exact is that
dP/dy = dQ/dx.  Then, the solution will be as given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,y,t,x0,y0,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">,</span> <span class="s">&#39;F&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Integral</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">Integral</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">))),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">            x                y</span>
<span class="go">            /                /</span>
<span class="go">           |                |</span>
<span class="go">F(x, y) =  |  P(t, y) dt +  |  Q(x0, t) dt = C1</span>
<span class="go">           |                |</span>
<span class="go">          /                /</span>
<span class="go">          x0               y0</span>
</pre></div>
</div>
<p>Where the first partials of P and Q exist and are continuous in a
simply connected region.</p>
<p>A note: SymPy currently has no way to represent inert substitution on
an expression, so the hint &#8216;1st_exact_Integral&#8217; will return an integral
with dy.  This is supposed to represent the function that you are
solving for.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Exact_differential_equation">http://en.wikipedia.org/wiki/Exact_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 73</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">x*cos(f(x)) + f(x)**3/3 == C1</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-best">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_best</span></tt><a class="headerlink" href="#st-homogeneous-coeff-best" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_best">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_homogeneous_coeff_best</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_best"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the best solution to an ODE from the two hints
&#8216;1st_homogeneous_coeff_subs_dep_div_indep&#8217; and
&#8216;1st_homogeneous_coeff_subs_indep_div_dep&#8217;.</p>
<p>This is as determined by ode_sol_simplicity().</p>
<p>See the ode_1st_homogeneous_coeff_subs_indep_div_dep() and
ode_1st_homogeneous_coeff_subs_dep_div_indep() docstrings for more
information on these hints.  Note that there is no
&#8216;1st_homogeneous_coeff_best_Integral&#8217; hint.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_best&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">               /    2    \</span>
<span class="go">               | 3*x     |</span>
<span class="go">            log|----- + 1|</span>
<span class="go">               | 2       |</span>
<span class="go">   /f(x)\      \f (x)    /</span>
<span class="go">log|----| + -------------- = 0</span>
<span class="go">   \ C1 /         3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-subs-dep-div-indep">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></tt><a class="headerlink" href="#st-homogeneous-coeff-subs-dep-div-indep" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_homogeneous_coeff_subs_dep_div_indep</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_subs_dep_div_indep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution
u1 = &lt;dependent variable&gt;/&lt;independent variable&gt;.</p>
<p>This is a differential equation P(x, y) + Q(x, y)dy/dx = 0, that P
and Q are homogeneous of the same order.  A function F(x, y) is
homogeneous of order n if F(xt, yt) = t**n*F(x, y).  Equivalently,
F(x, y) can be rewritten as G(y/x) or H(x/y).  See also the
docstring of homogeneous_order().</p>
<p>If the coefficients P and Q in the differential equation above are
homogeneous functions of the same order, then it can be shown that
the substitution y = u1*x (u1 = y/x) will turn the differential
equation into an equation separable in the variables x and u.  If
h(u1) is the function that results from making the substitution
u1 = f(x)/x on P(x, f(x)) and g(u2) is the function that results
from the substitution on Q(x, f(x)) in the differential equation
P(x, f(x)) + Q(x, f(x))*diff(f(x), x) = 0, then the general solution
is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> /f(x)\    /f(x)\ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \ x  /    \ x  / dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;</span><span class="p">))</span>
<span class="go">             f(x)</span>
<span class="go">             ----</span>
<span class="go">              x</span>
<span class="go">               /</span>
<span class="go">              |</span>
<span class="go">              |       -h(u1)</span>
<span class="go">log(C1*x) -   |  ---------------- d(u1) = 0</span>
<span class="go">              |  u1*h(u1) + g(u1)</span>
<span class="go">              |</span>
<span class="go">             /</span>
</pre></div>
</div>
<p>Where u1*h(u1) + g(u1) != 0 and x != 0.</p>
<p>See also the docstrings of ode_1st_homogeneous_coeff_best() and
ode_1st_homogeneous_coeff_subs_indep_div_dep().</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">                 /          3   \</span>
<span class="go">                 |3*f(x)   f (x)|</span>
<span class="go">              log|------ + -----|</span>
<span class="go">                 |  x         3 |</span>
<span class="go">       /x \      \           x  /</span>
<span class="go">    log|--| + ------------------- = 0</span>
<span class="go">       \C1/            3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-subs-indep-div-dep">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></tt><a class="headerlink" href="#st-homogeneous-coeff-subs-indep-div-dep" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_homogeneous_coeff_subs_indep_div_dep</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_subs_indep_div_dep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution
u2 = &lt;independent variable&gt;/&lt;dependent variable&gt;.</p>
<p>This is a differential equation P(x, y) + Q(x, y)dy/dx = 0, that P
and Q are homogeneous of the same order.  A function F(x, y) is
homogeneous of order n if F(xt, yt) = t**n*F(x, y).  Equivalently,
F(x, y) can be rewritten as G(y/x) or H(x/y).  See also the
docstring of homogeneous_order().</p>
<p>If the coefficients P and Q in the differential equation above are
homogeneous functions of the same order, then it can be shown that
the substitution x = u2*y (u2 = x/y) will turn the differential
equation into an equation separable in the variables y and u2.  If
h(u2) is the function that results from making the substitution
u2 = x/f(x) on P(x, f(x)) and g(u2) is the function that results
from the substitution on Q(x, f(x)) in the differential equation
P(x, f(x)) + Q(x, f(x))*diff(f(x), x) = 0, then the general solution
is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> / x  \    / x  \ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \f(x)/    \f(x)/ dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">))</span>
<span class="go">             x</span>
<span class="go">            ----</span>
<span class="go">            f(x)</span>
<span class="go">              /</span>
<span class="go">             |</span>
<span class="go">             |        g(u2)</span>
<span class="go">             |  ----------------- d(u2)</span>
<span class="go">             |  -u2*g(u2) - h(u2)</span>
<span class="go">             |</span>
<span class="go">            /</span>

<span class="go">f(x) = C1*e</span>
</pre></div>
</div>
<p>Where u2*g(u2) + h(u2) != 0 and f(x) != 0.</p>
<p>See also the docstrings of ode_1st_homogeneous_coeff_best() and
ode_1st_homogeneous_coeff_subs_dep_div_indep().</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span><span class="p">))</span>
<span class="go">      ___________</span>
<span class="go">     /     2</span>
<span class="go">    /   3*x</span>
<span class="go">   /   ----- + 1 *f(x) = C1</span>
<span class="go">3 /     2</span>
<span class="go">\/     f (x)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-linear">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">1st_linear</span></tt><a class="headerlink" href="#st-linear" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_linear">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_1st_linear</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order linear differential equations.</p>
<p>These are differential equations of the form dy/dx _ P(x)*y = Q(x).
These kinds of differential equations can be solved in a general
way.  The integrating factor exp(Integral(P(x), x)) will turn the
equation into a separable equation.  The general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;1st_linear_Integral&#39;</span><span class="p">))</span>
<span class="go">       /       /                   \</span>
<span class="go">       |      |                    |</span>
<span class="go">       |      |         /          |     /</span>
<span class="go">       |      |        |           |    |</span>
<span class="go">       |      |        | P(x) dx   |  - | P(x) dx</span>
<span class="go">       |      |        |           |    |</span>
<span class="go">       |      |       /            |   /</span>
<span class="go">f(x) = |C1 +  | Q(x)*e           dx|*e</span>
<span class="go">       |      |                    |</span>
<span class="go">       \     /                     /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation">http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 92</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s">&#39;1st_linear&#39;</span><span class="p">))</span>
<span class="go">f(x) = x*(C1 - cos(x))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bernoulli">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">Bernoulli</span></tt><a class="headerlink" href="#bernoulli" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Bernoulli">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_Bernoulli</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Bernoulli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Bernoulli" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves Bernoulli differential equations.</p>
<p>These are equations of the form dy/dx + P(x)*y = Q(x)*y**n, n != 1.
The substitution w = 1/y**(1-n) will transform an equation of this
form into one that is linear (see the docstring of
ode_1st_linear()).  The general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d                n</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)*f (x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;Bernoulli_Integral&#39;</span><span class="p">))</span> 
<span class="go">                                                                               1</span>
<span class="go">                                                                              ----</span>
<span class="go">                                                                             1 - n</span>
<span class="go">       //                /                            \                     \</span>
<span class="go">       ||               |                             |                     |</span>
<span class="go">       ||               |                  /          |             /       |</span>
<span class="go">       ||               |                 |           |            |        |</span>
<span class="go">       ||               |        (1 - n)* | P(x) dx   |  (-1 + n)* | P(x) dx|</span>
<span class="go">       ||               |                 |           |            |        |</span>
<span class="go">       ||               |                /            |           /         |</span>
<span class="go">f(x) = ||C1 + (-1 + n)* | -Q(x)*e                   dx|*e                   |</span>
<span class="go">       ||               |                             |                     |</span>
<span class="go">       \\               /                            /                     /</span>
</pre></div>
</div>
<p>Note that when n = 1, then the equation is separable (see the
docstring of ode_separable()).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go"> f(x)</span>
<span class="go">   /</span>
<span class="go">  |                /</span>
<span class="go">  |  1            |</span>
<span class="go">  |  - dy = C1 +  | (-P(x) + Q(x)) dx</span>
<span class="go">  |  y            |</span>
<span class="go">  |              /</span>
<span class="go"> /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Bernoulli_differential_equation">http://en.wikipedia.org/wiki/Bernoulli_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 95</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;Bernoulli&#39;</span><span class="p">))</span>
<span class="go">                1</span>
<span class="go">f(x) = -------------------</span>
<span class="go">         /     log(x)   1\</span>
<span class="go">       x*|C1 + ------ + -|</span>
<span class="go">         \       x      x/</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="liouville">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">Liouville</span></tt><a class="headerlink" href="#liouville" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Liouville">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_Liouville</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Liouville"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Liouville" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 2nd order Liouville differential equations.</p>
<p>The general form of a Liouville ODE is
d^2y/dx^2 + g(y)*(dy/dx)**2 + h(x)*dy/dx.  The general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;h&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                2                    2</span>
<span class="go">        d                d          d</span>
<span class="go">g(f(x))*--(f(x))  + h(x)*--(f(x)) + ---(f(x)) = 0</span>
<span class="go">        dx               dx           2</span>
<span class="go">                                    dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;Liouville_Integral&#39;</span><span class="p">))</span>
<span class="go">                                  f(x)</span>
<span class="go">          /                     /</span>
<span class="go">         |                     |</span>
<span class="go">         |     /               |     /</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |  - | h(x) dx        |    | g(y) dy</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |   /                 |   /</span>
<span class="go">C1 + C2* | e            dx +   |  e           dy = 0</span>
<span class="go">         |                     |</span>
<span class="go">        /                     /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Goldstein and Braun, &#8220;Advanced Methods for the Solution of
Differential Equations&#8221;, pp. 98</li>
<li><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville</a></li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;Liouville&#39;</span><span class="p">))</span>
<span class="go">           ________________           ________________</span>
<span class="go">[f(x) = -\/ C1 + C2*log(x) , f(x) = \/ C1 + C2*log(x) ]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="riccati-special-minus2">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">Riccati_special_minus2</span></tt><a class="headerlink" href="#riccati-special-minus2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Riccati_special_minus2">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_Riccati_special_minus2</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Riccati_special_minus2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Riccati_special_minus2" title="Permalink to this definition">¶</a></dt>
<dd><p>The general Riccati equation has the form dy/dx = f(x)*y**2 + g(x)*y + h(x).
While it does not have a general solution [1], the &#8220;special&#8221; form,
dy/dx = a*y**2 - b*x**c, does have solutions in many cases [2]. This routine
returns a solution for a*dy/dx = b*y**2 + c*y/x + d/x**2 that is obtained by
using a suitable change of variables to reduce it to the special form and is
valid when neither a nor b are zero and either c or d is zero.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="kn">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">checkodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
<span class="go">         /                                 /        __________________      \\</span>
<span class="go">        |           __________________    |       /                2        ||</span>
<span class="go">        |          /                2     |     \/  4*b*d - (a + c)  *log(x)||</span>
<span class="go">       -|a + c - \/  4*b*d - (a + c)  *tan|C1 + ----------------------------||</span>
<span class="go">        \                                 \                 2*a             //</span>
<span class="go">f(x) = -----------------------------------------------------------------------</span>
<span class="go">                                        2*b*x</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati</a></li>
<li><a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf</a> -
<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf</a></li>
</ol>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-homogeneous">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_homogeneous</span></tt><a class="headerlink" href="#nth-linear-constant-coeff-homogeneous" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_nth_linear_constant_coeff_homogeneous</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em>, <em>returns='sol'</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_homogeneous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an nth order linear homogeneous differential equation with
constant coefficients.</p>
<p>This is an equation of the form a_n*f(x)^(n) + a_(n-1)*f(x)^(n-1) +
... + a1*f&#8217;(x) + a0*f(x) = 0</p>
<p>These equations can be solved in a general manner, by taking the
roots of the characteristic equation a_n*m**n + a_(n-1)*m**(n-1) +
... + a1*m + a0 = 0.  The solution will then be the sum of
Cn*x**i*exp(r*x) terms, for each where Cn is an arbitrary constant,
r is a root of the characteristic equation and i is is one of each
from 0 to the multiplicity of the root - 1 (for example, a root 3 of
multiplicity 2 would create the terms C1*exp(3*x) + C2*x*exp(3*x)).
The exponential is usually expanded for complex roots using Euler&#8217;s
equation exp(I*x) = cos(x) + I*sin(x).  Complex roots always come in
conjugate pars in polynomials with real coefficients, so the two
roots will be represented (after simplifying the constants) as
exp(a*x)*(C1*cos(b*x) + C2*sin(b*x)).</p>
<p>If SymPy cannot find exact roots to the characteristic equation, a
RootOf instance will be return in its stead.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">f(x) == C1*exp(x*RootOf(_x**5 + 10*_x - 2, 0)) +</span>
<span class="go">C2*exp(x*RootOf(_x**5 + 10*_x - 2, 1)) +</span>
<span class="go">C3*exp(x*RootOf(_x**5 + 10*_x - 2, 2)) +</span>
<span class="go">C4*exp(x*RootOf(_x**5 + 10*_x - 2, 3)) +</span>
<span class="go">C5*exp(x*RootOf(_x**5 + 10*_x - 2, 4))</span>
</pre></div>
</div>
<p>Note that because this method does not involve integration, there is
no &#8216;nth_linear_constant_coeff_homogeneous_Integral&#8217; hint.</p>
<p>The following is for internal use:</p>
<ul class="simple">
<li>returns = &#8216;sol&#8217; returns the solution to the ODE.</li>
<li>returns = &#8216;list&#8217; returns a list of linearly independent
solutions, for use with non homogeneous solution methods like
variation of parameters and undetermined coefficients.  Note that,
though the solutions should be linearly independent, this function
does not explicitly check that.  You can do &#8220;assert
simplify(wronskian(sollist)) != 0&#8221; to check for linear independence.
Also, &#8220;assert len(sollist) == order&#8221; will need to pass.</li>
<li>returns = &#8216;both&#8217;, return a dictionary {&#8216;sol&#8217;:solution to ODE,
&#8216;list&#8217;: list of linearly independent solutions}.</li>
</ul>
<p class="rubric">References</p>
<ul>
<li><dl class="first docutils">
<dt><a class="reference external" href="http://en.wikipedia.org/wiki/Linear_differential_equation">http://en.wikipedia.org/wiki/Linear_differential_equation</a></dt>
<dd><p class="first last">section: Nonhomogeneous_equation_with_constant_coefficients</p>
</dd>
</dl>
</li>
<li><p class="first">M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 211</p>
</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">))</span>
<span class="go">                    x                            -2*x</span>
<span class="go">f(x) = (C1 + C2*x)*e  + (C3*sin(x) + C4*cos(x))*e</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-undetermined-coefficients">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></tt><a class="headerlink" href="#nth-linear-constant-coeff-undetermined-coefficients" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_nth_linear_constant_coeff_undetermined_coefficients</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_undetermined_coefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an nth order linear differential equation with constant
coefficients using the method of undetermined coefficients.</p>
<p>This method works on differential equations of the form a_n*f(x)^(n)
+ a_(n-1)*f(x)^(n-1) + ... + a1*f&#8217;(x) + a0*f(x) = P(x), where P(x)
is a function that has a finite number of linearly independent
derivatives.</p>
<p>Functions that fit this requirement are finite sums functions of the
form a*x**i*exp(b*x)*sin(c*x + d) or a*x**i*exp(b*x)*cos(c*x + d),
where i is a non-negative integer and a, b, c, and d are constants.
For example any polynomial in x, functions like x**2*exp(2*x),
x*sin(x), and exp(x)*cos(x) can all be used.  Products of sin&#8217;s and
cos&#8217;s have a finite number of derivatives, because they can be
expanded into sin(a*x) and cos(b*x) terms.  However, SymPy currently
cannot do that expansion, so you will need to manually rewrite the
expression in terms of the above to use this method.  So, for example,
you will need to manually convert sin(x)**2 into (1 + cos(2*x))/2 to
properly apply the method of undetermined coefficients on it.</p>
<p>This method works by creating a trial function from the expression
and all of its linear independent derivatives and substituting them
into the original ODE.  The coefficients for each term will be a
system of linear equations, which are be solved for and substituted,
giving the solution.  If any of the trial functions are linearly
dependent on the solution to the homogeneous equation, they are
multiplied by sufficient x to make them linearly independent.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients">http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 221</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">4</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;</span><span class="p">))</span>
<span class="go">       /             4\</span>
<span class="go">       |            x |  -x   4*sin(2*x)   3*cos(2*x)</span>
<span class="go">f(x) = |C1 + C2*x + --|*e   - ---------- + ----------</span>
<span class="go">       \            3 /           25           25</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-variation-of-parameters">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_variation_of_parameters</span></tt><a class="headerlink" href="#nth-linear-constant-coeff-variation-of-parameters" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_nth_linear_constant_coeff_variation_of_parameters</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_variation_of_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an nth order linear differential equation with constant
coefficients using the method of variation of parameters.</p>
<p>This method works on any differential equations of the form
f(x)^(n) + a_(n-1)*f(x)^(n-1) + ... + a1*f&#8217;(x) + a0*f(x) = P(x).</p>
<p>This method works by assuming that the particular solution takes the
form Sum(c_i(x)*y_i(x), (x, 1, n)), where y_i is the ith solution to
the homogeneous equation.  The solution is then solved using
Wronskian&#8217;s and Cramer&#8217;s Rule.  The particular solution is given by
Sum(Integral(W_i(x)/W(x), x)*y_i(x), (x, 1, n)), where W(x) is the
Wronskian of the fundamental system (the system of n linearly
independent solutions to the homogeneous equation), and W_i(x) is
the Wronskian of the fundamental system with the ith column replaced
with [0, 0, ..., 0, P(x)].</p>
<p>This method is general enough to solve any nth order inhomogeneous
linear differential equation with constant coefficients, but
sometimes SymPy cannot simplify the Wronskian well enough to
integrate it.  If this method hangs, try using the
&#8216;nth_linear_constant_coeff_variation_of_parameters_Integral&#8217; hint
and simplifying the integrals manually.  Also, prefer using
&#8216;nth_linear_constant_coeff_undetermined_coefficients&#8217; when it
applies, because it doesn&#8217;t use integration, making it faster and
more reliable.</p>
<p>Warning, using simplify=False with
&#8216;nth_linear_constant_coeff_variation_of_parameters&#8217; in dsolve()
may cause it to hang, because it will not attempt to simplify
the Wronskian before integrating.  It is recommended that you only
use simplify=False with
&#8216;nth_linear_constant_coeff_variation_of_parameters_Integral&#8217; for
this method, especially if the solution to the homogeneous
equation has trigonometric functions in it.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Variation_of_parameters">http://en.wikipedia.org/wiki/Variation_of_parameters</a></li>
<li><a class="reference external" href="http://planetmath.org/encyclopedia/VariationOfParameters.html">http://planetmath.org/encyclopedia/VariationOfParameters.html</a></li>
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 233</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;</span><span class="p">))</span>
<span class="go">       /                     3                \</span>
<span class="go">       |                2   x *(6*log(x) - 11)|  x</span>
<span class="go">f(x) = |C1 + C2*x + C3*x  + ------------------|*e</span>
<span class="go">       \                            36        /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="separable">
<h3><tt class="xref py py-obj docutils literal"><span class="pre">separable</span></tt><a class="headerlink" href="#separable" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_separable">
<tt class="descclassname">sympy.solvers.ode.</tt><tt class="descname">ode_separable</tt><big>(</big><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><big>)</big><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_separable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_separable" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves separable 1st order differential equations.</p>
<p>This is any differential equation that can be written as
P(y)*dy/dx = Q(x). The solution can then just be found by
rearranging terms and integrating:
Integral(P(y), y) = Integral(Q(x), x). This hint uses separatevars()
as its back end, so if a separable equation is not caught by this
solver, it is most likely the fault of that function. separatevars()
is smart enough to do most expansion and factoring necessary to
convert a separable equation F(x, y) into the proper form P(x)*Q(y).
The general solution is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;f&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">             d</span>
<span class="go">a(x)*b(f(x))*--(f(x)) = c(x)*d(f(x))</span>
<span class="go">             dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go">     f(x)</span>
<span class="go">   /                  /</span>
<span class="go">  |                  |</span>
<span class="go">  |  b(y)            | c(x)</span>
<span class="go">  |  ---- dy = C1 +  | ---- dx</span>
<span class="go">  |  d(y)            | a(x)</span>
<span class="go">  |                  |</span>
<span class="go"> /                  /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>M. Tenenbaum &amp; H. Pollard, &#8220;Ordinary Differential Equations&#8221;,
Dover 1963, pp. 52</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s">&#39;separable&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="go">   /   2       \         2</span>
<span class="go">log\3*f (x) - 1/        x</span>
<span class="go">---------------- = C1 + --</span>
<span class="go">       6                2</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-sympy.solvers.ode">
<span id="information-on-the-ode-module"></span><h2>Information on the ode module<a class="headerlink" href="#module-sympy.solvers.ode" title="Permalink to this headline">¶</a></h2>
<p>This module contains dsolve() and different helper functions that it
uses.</p>
<p>dsolve() solves ordinary differential equations. See the docstring on
the various functions for their uses. Note that partial differential
equations support is in pde.py.  Note that ode_hint() functions have
docstrings describing their various methods, but they are intended for
internal use.  Use dsolve(ode, func, hint=hint) to solve an ode using a
specific hint.  See also the docstring on dsolve().</p>
<p><strong>Functions in this module</strong></p>
<blockquote>
<div><p>These are the user functions in this module:</p>
<ul class="simple">
<li>dsolve() - Solves ODEs.</li>
<li>classify_ode() - Classifies ODEs into possible hints for dsolve().</li>
<li>checkodesol() - Checks if an equation is the solution to an ODE.</li>
<li>ode_order() - Returns the order (degree) of an ODE.</li>
<li>homogeneous_order() - Returns the homogeneous order of an
expression.</li>
</ul>
<p>These are the non-solver helper functions that are for internal use.
The user should use the various options to dsolve() to obtain the
functionality provided by these functions:</p>
<ul class="simple">
<li>odesimp() - Does all forms of ODE simplification.</li>
<li>ode_sol_simplicity() - A key function for comparing solutions by
simplicity.</li>
<li>constantsimp() - Simplifies arbitrary constants.</li>
<li>constant_renumber() - Renumber arbitrary constants</li>
<li>_handle_Integral() - Evaluate unevaluated Integrals.</li>
<li>preprocess - prepare the equation and detect function to solve for</li>
</ul>
<p>See also the docstrings of these functions.</p>
</div></blockquote>
<p><strong>Currently implemented solver methods</strong></p>
<p>The following methods are implemented for solving ordinary differential
equations.  See the docstrings of the various ode_hint() functions for
more information on each (run help(ode)):</p>
<blockquote>
<div><ul class="simple">
<li>1st order separable differential equations</li>
<li>1st order differential equations whose coefficients or dx and dy
are functions homogeneous of the same order.</li>
<li>1st order exact differential equations.</li>
<li>1st order linear differential equations</li>
<li>1st order Bernoulli differential equations.</li>
<li>2nd order Liouville differential equations.</li>
<li>nth order linear homogeneous differential equation with constant
coefficients.</li>
<li>nth order linear inhomogeneous differential equation with constant
coefficients using the method of undetermined coefficients.</li>
<li>nth order linear inhomogeneous differential equation with constant
coefficients using the method of variation of parameters.</li>
</ul>
</div></blockquote>
<p><strong>Philosophy behind this module</strong></p>
<p>This module is designed to make it easy to add new ODE solving methods
without having to mess with the solving code for other methods.  The
idea is that there is a classify_ode() function, which takes in an ODE
and tells you what hints, if any, will solve the ODE.  It does this
without attempting to solve the ODE, so it is fast.  Each solving method
is a hint, and it has its own function, named ode_hint.  That function
takes in the ODE and any match expression gathered by classify_ode and
returns a solved result.  If this result has any integrals in it, the
ode_hint function will return an unevaluated Integral class. dsolve(),
which is the user wrapper function around all of this, will then call
odesimp() on the result, which, among other things, will attempt to
solve the equation for the dependent variable (the function we are
solving for), simplify the arbitrary constants in the expression, and
evaluate any integrals, if the hint allows it.</p>
<p><strong>How to add new solution methods</strong></p>
<p>If you have an ODE that you want dsolve() to be able to solve, try to
avoid adding special case code here.  Instead, try finding a general
method that will solve your ODE, as well as others.  This way, the ode
module will become more robust, and unhindered by special case hacks.
WolphramAlpha and Maple&#8217;s DETools[odeadvisor] function are two resources
you can use to classify a specific ODE.  It is also better for a method
to work with an nth order ODE instead of only with specific orders, if
possible.</p>
<p>To add a new method, there are a few things that you need to do.  First,
you need a hint name for your method.  Try to name your hint so that it
is unambiguous with all other methods, including ones that may not be
implemented yet.  If your method uses integrals, also include a
&#8220;hint_Integral&#8221; hint.  If there is more than one way to solve ODEs with
your method, include a hint for each one, as well as a &#8220;hint_best&#8221; hint.
Your ode_hint_best() function should choose the best using min with
ode_sol_simplicity as the key argument.  See
ode_1st_homogeneous_coeff_best(), for example. The function that uses
your method will be called ode_hint(), so the hint must only use
characters that are allowed in a Python function name (alphanumeric
characters and the underscore &#8216;_&#8217; character).  Include a function for
every hint, except for &#8220;_Integral&#8221; hints (dsolve() takes care of those
automatically).  Hint names should be all lowercase, unless a word is
commonly capitalized (such as Integral or Bernoulli). If you have a hint
that you do not want to run with &#8220;all_Integral&#8221; that doesn&#8217;t have an
&#8220;_Integral&#8221; counterpart (such as a best hint that would defeat the
purpose of &#8220;all_Integral&#8221;), you will need to remove it manually in the
dsolve() code.  See also the classify_ode() docstring for guidelines on
writing a hint name.</p>
<p>Determine <em>in general</em> how the solutions returned by your method
compare with other methods that can potentially solve the same ODEs.
Then, put your hints in the allhints tuple in the order that they should
be called.  The ordering of this tuple determines which hints are
default. Note that exceptions are ok, because it is easy for the user to
choose individual hints with dsolve().  In general, &#8220;_Integral&#8221; variants
should go at the end of the list, and &#8220;_best&#8221; variants should go before
the various hints they apply to.  For example, the
&#8220;undetermined_coefficients&#8221; hint comes before the
&#8220;variation_of_parameters&#8221; hint because, even though variation of
parameters is more general than undetermined coefficients, undetermined
coefficients generally returns cleaner results for the ODEs that it can
solve than variation of parameters does, and it does not require
integration, so it is much faster.</p>
<p>Next, you need to have a match expression or a function that matches the
type of the ODE, which you should put in classify_ode() (if the match
function is more than just a few lines, like
_undetermined_coefficients_match(), it should go outside of
classify_ode()).  It should match the ODE without solving for it as much
as possible, so that classify_ode() remains fast and is not hindered by
bugs in solving code.  Be sure to consider corner cases. For example, if
your solution method involves dividing by something, make sure you
exclude the case where that division will be 0.</p>
<p>In most cases, the matching of the ODE will also give you the various
parts that you need to solve it. You should put that in a dictionary
(.match() will do this for you), and add that as matching_hints[&#8216;hint&#8217;]
= matchdict in the relevant part of classify_ode.  classify_ode will
then send this to dsolve(), which will send it to your function as the
match argument. Your function should be named ode_hint(eq, func, order,
match). If you need to send more information, put it in the match
dictionary.  For example, if you had to substitute in a dummy variable
in classify_ode to match the ODE, you will need to pass it to your
function using the match dict to access it.  You can access the
independent variable using func.args[0], and the dependent variable (the
function you are trying to solve for) as func.func.  If, while trying to
solve the ODE, you find that you cannot, raise NotImplementedError.
dsolve() will catch this error with the &#8220;all&#8221; meta-hint, rather than
causing the whole routine to fail.</p>
<p>Add a docstring to your function that describes the method employed.
Like with anything else in SymPy, you will need to add a doctest to the
docstring, in addition to real tests in test_ode.py.  Try to maintain
consistency with the other hint functions&#8217; docstrings.  Add your method
to the list at the top of this docstring.  Also, add your method to
ode.rst in the docs/src directory, so that the Sphinx docs will pull its
docstring into the main SymPy documentation.  Be sure to make the Sphinx
documentation by running &#8220;make html&#8221; from within the doc directory to
verify that the docstring formats correctly.</p>
<p>If your solution method involves integrating, use C.Integral() instead
of integrate().  This allows the user to bypass hard/slow integration by
using the &#8220;_Integral&#8221; variant of your hint.  In most cases, calling
.doit() will integrate your solution.  If this is not the case, you will
need to write special code in _handle_Integral().  Arbitrary constants
should be symbols named C1, C2, and so on.  All solution methods should
return an equality instance.  If you need an arbitrary number of
arbitrary constants, you can use constants =
numbered_symbols(prefix=&#8217;C&#8217;, cls=Symbol, start=1).  If it is
possible to solve for the dependent function in a general way, do so.
Otherwise, do as best as you can, but do not call solve in your
ode_hint() function.  odesimp() will attempt to solve the solution for
you, so you do not need to do that. Lastly, if your ODE has a common
simplification that can be applied to your solutions, you can add a
special case in odesimp() for it.  For example, solutions returned from
the &#8220;1st_homogeneous_coeff&#8221; hints often have many log() terms, so
odesimp() calls logcombine() on them (it also helps to write the
arbitrary constant as log(C1) instead of C1 in this case).  Also
consider common ways that you can rearrange your solution to have
constantsimp() take better advantage of it.  It is better to put
simplification in odesimp() than in your method, because it can then be
turned off with the simplify flag in dsolve(). If you have any
extraneous simplification in your function, be sure to only run it using
&#8220;if match.get(&#8216;simplify&#8217;, True):&#8221;, especially if it can be slow or if it
can reduce the domain of the solution.</p>
<p>Finally, as with every contribution to SymPy, your method will need to
be tested. Add a test for each method in test_ode.py.  Follow the
conventions there, i.e., test the solver using dsolve(eq, f(x),
hint=your_hint), and also test the solution using checkodesol (you can
put these in a separate tests and skip/XFAIL if it runs too slow/doesn&#8217;t
work).  Be sure to call your hint specifically in dsolve, that way the
test won&#8217;t be broken simply by the introduction of another matching
hint. If your method works for higher order (&gt;1) ODEs, you will need to
run sol = constant_renumber(sol, &#8216;C&#8217;, 1, order), for each solution, where
order is the order of the ODE. This is because constant_renumber renumbers
the arbitrary constants by printing order, which is platform dependent.
Try to test every corner case of your solver, including a range of
orders if it is a nth order solver, but if your solver is slow, such as
if it involves hard integration, try to keep the test run time down.</p>
<p>Feel free to refactor existing hints to avoid duplicating code or
creating inconsistencies.  If you can show that your method exactly
duplicates an existing method, including in the simplicity and speed of
obtaining the solutions, then you can remove the old, less general
method. The existing code is tested extensively in test_ode.py, so if
anything is broken, one of those tests will surely fail.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ODE</a><ul>
<li><a class="reference internal" href="#user-functions">User Functions</a><ul>
<li><a class="reference internal" href="#dsolve"><tt class="docutils literal"><span class="pre">dsolve()</span></tt></a></li>
<li><a class="reference internal" href="#classify-ode"><tt class="docutils literal"><span class="pre">classify_ode()</span></tt></a></li>
<li><a class="reference internal" href="#ode-order"><tt class="docutils literal"><span class="pre">ode_order()</span></tt></a></li>
<li><a class="reference internal" href="#checkodesol"><tt class="docutils literal"><span class="pre">checkodesol()</span></tt></a></li>
<li><a class="reference internal" href="#homogeneous-order"><tt class="docutils literal"><span class="pre">homogeneous_order()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hint-methods">Hint Methods</a><ul>
<li><a class="reference internal" href="#preprocess"><tt class="docutils literal"><span class="pre">preprocess</span></tt></a></li>
<li><a class="reference internal" href="#odesimp"><tt class="docutils literal"><span class="pre">odesimp</span></tt></a></li>
<li><a class="reference internal" href="#constant-renumber"><tt class="docutils literal"><span class="pre">constant_renumber</span></tt></a></li>
<li><a class="reference internal" href="#constantsimp"><tt class="docutils literal"><span class="pre">constantsimp</span></tt></a></li>
<li><a class="reference internal" href="#sol-simplicity"><tt class="docutils literal"><span class="pre">sol_simplicity</span></tt></a></li>
<li><a class="reference internal" href="#st-exact"><tt class="docutils literal"><span class="pre">1st_exact</span></tt></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-best"><tt class="docutils literal"><span class="pre">1st_homogeneous_coeff_best</span></tt></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-subs-dep-div-indep"><tt class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></tt></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-subs-indep-div-dep"><tt class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></tt></a></li>
<li><a class="reference internal" href="#st-linear"><tt class="docutils literal"><span class="pre">1st_linear</span></tt></a></li>
<li><a class="reference internal" href="#bernoulli"><tt class="docutils literal"><span class="pre">Bernoulli</span></tt></a></li>
<li><a class="reference internal" href="#liouville"><tt class="docutils literal"><span class="pre">Liouville</span></tt></a></li>
<li><a class="reference internal" href="#riccati-special-minus2"><tt class="docutils literal"><span class="pre">Riccati_special_minus2</span></tt></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-homogeneous"><tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_homogeneous</span></tt></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-undetermined-coefficients"><tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></tt></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-variation-of-parameters"><tt class="docutils literal"><span class="pre">nth_linear_constant_coeff_variation_of_parameters</span></tt></a></li>
<li><a class="reference internal" href="#separable"><tt class="docutils literal"><span class="pre">separable</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-sympy.solvers.ode">Information on the ode module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../stats.html"
                        title="previous chapter">Stats</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../solvers/solvers.html"
                        title="next chapter">Solvers</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/modules/solvers/ode.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../solvers/solvers.html" title="Solvers"
             >next</a> |</li>
        <li class="right" >
          <a href="../stats.html" title="Stats"
             >previous</a> |</li>
        <li><a href="../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../index.html" >SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Jan 20, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>
