
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Lambdify &#8212; SymPy 1.10.dev documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/default.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/utilities/lambdify.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Memoization" href="memoization.html" />
    <link rel="prev" title="Iterables" href="iterables.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="memoization.html" title="Memoization"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="iterables.html" title="Iterables"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.10.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../reference/index.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="index.html" accesskey="U">Utilities</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Lambdify</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-sympy.utilities.lambdify">
<span id="lambdify"></span><h1>Lambdify<a class="headerlink" href="#module-sympy.utilities.lambdify" title="Permalink to this headline">¶</a></h1>
<p>This module provides convenient functions to transform SymPy expressions to
lambda functions which can be used to calculate numerical values very fast.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.utilities.lambdify.implemented_function">
<span class="sig-prename descclassname"><span class="pre">sympy.utilities.lambdify.</span></span><span class="sig-name descname"><span class="pre">implemented_function</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symfunc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">implementation</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/utilities/lambdify.py#L1346-L1398"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.utilities.lambdify.implemented_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Add numerical <code class="docutils literal notranslate"><span class="pre">implementation</span></code> to function <code class="docutils literal notranslate"><span class="pre">symfunc</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">symfunc</span></code> can be an <code class="docutils literal notranslate"><span class="pre">UndefinedFunction</span></code> instance, or a name string.
In the latter case we create an <code class="docutils literal notranslate"><span class="pre">UndefinedFunction</span></code> instance with that
name.</p>
<p>Be aware that this is a quick workaround, not a general method to create
special symbolic functions. If you want to create a symbolic function to be
used by all the machinery of SymPy you should subclass the <code class="docutils literal notranslate"><span class="pre">Function</span></code>
class.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>symfunc</strong> : <code class="docutils literal notranslate"><span class="pre">str</span></code> or <code class="docutils literal notranslate"><span class="pre">UndefinedFunction</span></code> instance</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">str</span></code>, then create new <code class="docutils literal notranslate"><span class="pre">UndefinedFunction</span></code> with this as
name.  If <code class="docutils literal notranslate"><span class="pre">symfunc</span></code> is an Undefined function, create a new function
with the same name and the implemented function attached.</p>
</div></blockquote>
<p><strong>implementation</strong> : callable</p>
<blockquote>
<div><p>numerical implementation to be called by <code class="docutils literal notranslate"><span class="pre">evalf()</span></code> or <code class="docutils literal notranslate"><span class="pre">lambdify</span></code></p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>afunc</strong> : sympy.FunctionClass instance</p>
<blockquote>
<div><p>function with attached implementation</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="kn">import</span> <span class="n">lambdify</span><span class="p">,</span> <span class="n">implemented_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">implemented_function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lam_f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lam_f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.utilities.lambdify.lambdastr">
<span class="sig-prename descclassname"><span class="pre">sympy.utilities.lambdify.</span></span><span class="sig-name descname"><span class="pre">lambdastr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">printer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dummify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/utilities/lambdify.py#L964-L1080"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.utilities.lambdify.lambdastr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string that can be evaluated to a lambda function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="kn">import</span> <span class="n">lambdastr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lambdastr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">&#39;lambda x: (x**2)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lambdastr</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">])</span>
<span class="go">&#39;lambda x,y,z: ([z, y, x])&#39;</span>
</pre></div>
</div>
<p>Although tuples may not appear as arguments to lambda in Python 3,
lambdastr will create a lambda function that will unpack the original
arguments so that nested arguments can be handled:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lambdastr</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="go">&#39;lambda _0,_1: (lambda x,y,z: (x + y))(_0,_1[0],_1[1])&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.utilities.lambdify.lambdify">
<span class="sig-prename descclassname"><span class="pre">sympy.utilities.lambdify.</span></span><span class="sig-name descname"><span class="pre">lambdify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Iterable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modules</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">printer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_imps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dummify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/dfd966437a2ac0551c2c55174187f92dd6cba278/sympy/utilities/lambdify.py#L177-L916"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.utilities.lambdify.lambdify" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a SymPy expression into a function that allows for fast
numeric evaluation.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function uses <code class="docutils literal notranslate"><span class="pre">exec</span></code>, and thus shouldn’t be used on
unsanitized input.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 1.7.0: </span>Passing a set for the <em>args</em> parameter is deprecated as sets are
unordered. Use an ordered iterable such as a list or tuple.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> : List[Symbol]</p>
<blockquote>
<div><p>A variable or a list of variables whose nesting represents the
nesting of the arguments that will be passed to the function.</p>
<p>Variables can be symbols, undefined functions, or matrix symbols.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<p>The list of variables should match the structure of how the
arguments will be passed to the function. Simply enclose the
parameters as they will be passed in a list.</p>
<p>To call a function like <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> then <code class="docutils literal notranslate"><span class="pre">[x]</span></code>
should be the first argument to <code class="docutils literal notranslate"><span class="pre">lambdify</span></code>; for this
case a single <code class="docutils literal notranslate"><span class="pre">x</span></code> can also be used:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>To call a function like <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">y)</span></code> then <code class="docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span></code> will
be the first argument of the <code class="docutils literal notranslate"><span class="pre">lambdify</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>To call a function with a single 3-element tuple like
<code class="docutils literal notranslate"><span class="pre">f((x,</span> <span class="pre">y,</span> <span class="pre">z))</span></code> then <code class="docutils literal notranslate"><span class="pre">[(x,</span> <span class="pre">y,</span> <span class="pre">z)]</span></code> will be the first
argument of the <code class="docutils literal notranslate"><span class="pre">lambdify</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)],</span> <span class="n">Eq</span><span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If two args will be passed and the first is a scalar but
the second is a tuple with two arguments then the items
in the list should match that structure:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">6</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>expr</strong> : Expr</p>
<blockquote>
<div><p>An expression, list of expressions, or matrix to be evaluated.</p>
<p>Lists may be nested.
If the expression is a list, the output will also be a list.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[1, [2, 3]]</span>
</pre></div>
</div>
<p>If it is a matrix, an array will be returned (for the NumPy module).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[[1]</span>
<span class="go">[2]]</span>
</pre></div>
</div>
<p>Note that the argument order here (variables then expression) is used
to emulate the Python <code class="docutils literal notranslate"><span class="pre">lambda</span></code> keyword. <code class="docutils literal notranslate"><span class="pre">lambdify(x,</span> <span class="pre">expr)</span></code> works
(roughly) like <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">expr</span></code>
(see <a class="reference internal" href="#lambdify-how-it-works"><span class="std std-ref">How It Works</span></a> below).</p>
</div></blockquote>
<p><strong>modules</strong> : str, optional</p>
<blockquote>
<div><p>Specifies the numeric library to use.</p>
<p>If not specified, <em>modules</em> defaults to:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">[&quot;scipy&quot;,</span> <span class="pre">&quot;numpy&quot;]</span></code> if SciPy is installed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[&quot;numpy&quot;]</span></code> if only NumPy is installed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[&quot;math&quot;,</span> <span class="pre">&quot;mpmath&quot;,</span> <span class="pre">&quot;sympy&quot;]</span></code> if neither is installed.</p></li>
</ul>
<p>That is, SymPy functions are replaced as far as possible by
either <code class="docutils literal notranslate"><span class="pre">scipy</span></code> or <code class="docutils literal notranslate"><span class="pre">numpy</span></code> functions if available, and Python’s
standard library <code class="docutils literal notranslate"><span class="pre">math</span></code>, or <code class="docutils literal notranslate"><span class="pre">mpmath</span></code> functions otherwise.</p>
<p><em>modules</em> can be one of the following types:</p>
<ul class="simple">
<li><p>The strings <code class="docutils literal notranslate"><span class="pre">&quot;math&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;mpmath&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;numpy&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;numexpr&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;scipy&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;sympy&quot;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&quot;tensorflow&quot;</span></code>. This uses the
corresponding printer and namespace mapping for that module.</p></li>
<li><p>A module (e.g., <code class="docutils literal notranslate"><span class="pre">math</span></code>). This uses the global namespace of the
module. If the module is one of the above known modules, it will
also use the corresponding printer and namespace mapping
(i.e., <code class="docutils literal notranslate"><span class="pre">modules=numpy</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">modules=&quot;numpy&quot;</span></code>).</p></li>
<li><p>A dictionary that maps names of SymPy functions to arbitrary
functions
(e.g., <code class="docutils literal notranslate"><span class="pre">{'sin':</span> <span class="pre">custom_sin}</span></code>).</p></li>
<li><p>A list that contains a mix of the arguments above, with higher
priority given to entries appearing first
(e.g., to use the NumPy module but override the <code class="docutils literal notranslate"><span class="pre">sin</span></code> function
with a custom version, you can use
<code class="docutils literal notranslate"><span class="pre">[{'sin':</span> <span class="pre">custom_sin},</span> <span class="pre">'numpy']</span></code>).</p></li>
</ul>
</div></blockquote>
<p><strong>dummify</strong> : bool, optional</p>
<blockquote>
<div><p>Whether or not the variables in the provided expression that are not
valid Python identifiers are substituted with dummy symbols.</p>
<p>This allows for undefined functions like <code class="docutils literal notranslate"><span class="pre">Function('f')(t)</span></code> to be
supplied as arguments. By default, the variables are only dummified
if they are not valid Python identifiers.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">dummify=True</span></code> to replace all arguments with dummy symbols
(if <code class="docutils literal notranslate"><span class="pre">args</span></code> is not a string) - for example, to ensure that the
arguments do not redefine any built-in names.</p>
</div></blockquote>
<p><strong>cse</strong> : bool, or callable, optional</p>
<blockquote>
<div><p>Large expressions can be computed more efficiently when
common subexpressions are identified and precomputed before
being used multiple time. Finding the subexpressions will make
creation of the ‘lambdify’ function slower, however.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">sympy.simplify.cse</span></code> is used, otherwise (the default)
the user may pass a function matching the <code class="docutils literal notranslate"><span class="pre">cse</span></code> signature.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Explanation</p>
<p>For example, to convert the SymPy expression <code class="docutils literal notranslate"><span class="pre">sin(x)</span> <span class="pre">+</span> <span class="pre">cos(x)</span></code> to an
equivalent NumPy function that numerically evaluates it:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">lambdify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">sin(x) + cos(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1.38177329 0.49315059]</span>
</pre></div>
</div>
<p>The primary purpose of this function is to provide a bridge from SymPy
expressions to numerical libraries such as NumPy, SciPy, NumExpr, mpmath,
and tensorflow. In general, SymPy functions do not work with objects from
other libraries, such as NumPy arrays, and functions from numeric
libraries like NumPy or mpmath do not work on SymPy expressions.
<code class="docutils literal notranslate"><span class="pre">lambdify</span></code> bridges the two by converting a SymPy expression to an
equivalent numeric function.</p>
<p>The basic workflow with <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> is to first create a SymPy expression
representing whatever mathematical function you wish to evaluate. This
should be done using only SymPy functions and expressions. Then, use
<code class="docutils literal notranslate"><span class="pre">lambdify</span></code> to convert this to an equivalent function for numerical
evaluation. For instance, above we created <code class="docutils literal notranslate"><span class="pre">expr</span></code> using the SymPy symbol
<code class="docutils literal notranslate"><span class="pre">x</span></code> and SymPy functions <code class="docutils literal notranslate"><span class="pre">sin</span></code> and <code class="docutils literal notranslate"><span class="pre">cos</span></code>, then converted it to an
equivalent NumPy function <code class="docutils literal notranslate"><span class="pre">f</span></code>, and called it on a NumPy array <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="kn">import</span> <span class="n">implemented_function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="p">[</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[3, 2, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Matrix</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">modules</span><span class="o">=</span><span class="s1">&#39;sympy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">row</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">Matrix([[1, 3]])</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">lambdify</span></code> can be used to translate SymPy expressions into mpmath
functions. This may be preferable to using <code class="docutils literal notranslate"><span class="pre">evalf</span></code> (which uses mpmath on
the backend) in some cases.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;mpmath&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0.8414709848078965</span>
</pre></div>
</div>
<p>Tuple arguments are handled and the lambdified function should
be called with the same type of arguments as were used to create
the function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">flatten</span></code> function can be used to always work with flattened
arguments:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">flatten</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vals</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">w</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">flatten</span><span class="p">(</span><span class="n">vals</span><span class="p">))</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Functions present in <code class="docutils literal notranslate"><span class="pre">expr</span></code> can also carry their own numerical
implementations, in a callable attached to the <code class="docutils literal notranslate"><span class="pre">_imp_</span></code> attribute. This
can be used with undefined functions using the <code class="docutils literal notranslate"><span class="pre">implemented_function</span></code>
factory:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">implemented_function</span><span class="p">(</span><span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">lambdify</span></code> always prefers <code class="docutils literal notranslate"><span class="pre">_imp_</span></code> implementations to implementations
in other namespaces, unless the <code class="docutils literal notranslate"><span class="pre">use_imps</span></code> input parameter is False.</p>
<p>Usage with Tensorflow:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Max</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">lambdify</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>After tensorflow v2, eager execution is enabled by default.
If you want to get the compatible result across tensorflow v1 and v2
as same as this tutorial, run this line.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">enable_eager_execution</span><span class="p">()</span>
</pre></div>
</div>
<p>If you have eager execution enabled, you can get the result out
immediately as you can use numpy.</p>
<p>If you pass tensorflow objects, you may get an <code class="docutils literal notranslate"><span class="pre">EagerTensor</span></code>
object instead of value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">tf.Tensor(1.0, shape=(), dtype=float32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
<span class="go">&lt;class &#39;tensorflow.python.framework.ops.EagerTensor&#39;&gt;</span>
</pre></div>
</div>
<p>You can use <code class="docutils literal notranslate"><span class="pre">.numpy()</span></code> to get the numpy value of the tensor.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="go">1.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="c1"># also works for tf.Variable and tf.Placeholder</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>And it works with any shape array.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">tensor</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
<span class="go">[[1. 2.]</span>
<span class="go"> [3. 4.]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul>
<li><p>For functions involving large array calculations, numexpr can provide a
significant speedup over numpy. Please note that the available functions
for numexpr are more limited than numpy but can be expanded with
<code class="docutils literal notranslate"><span class="pre">implemented_function</span></code> and user defined subclasses of Function. If
specified, numexpr may be the only option in modules. The official list
of numexpr functions can be found at:
<a class="reference external" href="https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions">https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions</a></p></li>
<li><p>In previous versions of SymPy, <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> replaced <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> with
<code class="docutils literal notranslate"><span class="pre">numpy.matrix</span></code> by default. As of SymPy 1.0 <code class="docutils literal notranslate"><span class="pre">numpy.array</span></code> is the
default. To get the old default behavior you must pass in
<code class="docutils literal notranslate"><span class="pre">[{'ImmutableDenseMatrix':</span>&#160; <span class="pre">numpy.matrix},</span> <span class="pre">'numpy']</span></code> to the
<code class="docutils literal notranslate"><span class="pre">modules</span></code> kwarg.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">lambdify</span><span class="p">,</span> <span class="n">Matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array2mat</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;ImmutableDenseMatrix&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matrix</span><span class="p">},</span> <span class="s1">&#39;numpy&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]),</span> <span class="n">modules</span><span class="o">=</span><span class="n">array2mat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[1]</span>
<span class="go"> [2]]</span>
</pre></div>
</div>
</li>
<li><p>In the above examples, the generated functions can accept scalar
values or numpy arrays as arguments.  However, in some cases
the generated function relies on the input being a numpy array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Piecewise</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.testing.pytest</span> <span class="kn">import</span> <span class="n">ignore_warnings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)),</span> <span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ignore_warnings</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="go">[-1.   0.   1.   0.5]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ZeroDivisionError</span>: <span class="n">division by zero</span>
</pre></div>
</div>
<p>In such cases, the input should be wrapped in a numpy array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ignore_warnings</span><span class="p">(</span><span class="ne">RuntimeWarning</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">float</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<p>Or if numpy functionality is not required another module can be used:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)),</span> <span class="s2">&quot;math&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</li>
</ul>
<p class="rubric" id="lambdify-how-it-works">How It Works</p>
<p>When using this function, it helps a great deal to have an idea of what it
is doing. At its core, lambdify is nothing more than a namespace
translation, on top of a special printer that makes some corner cases work
properly.</p>
<p>To understand lambdify, first we must properly understand how Python
namespaces work. Say we had two files. One called <code class="docutils literal notranslate"><span class="pre">sin_cos_sympy.py</span></code>,
with</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># sin_cos_sympy.py</span>

<span class="kn">from</span> <span class="nn">sympy.functions.elementary.trigonometric</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sin_cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>and one called <code class="docutils literal notranslate"><span class="pre">sin_cos_numpy.py</span></code> with</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># sin_cos_numpy.py</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>

<span class="k">def</span> <span class="nf">sin_cos</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The two files define an identical function <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code>. However, in the
first file, <code class="docutils literal notranslate"><span class="pre">sin</span></code> and <code class="docutils literal notranslate"><span class="pre">cos</span></code> are defined as the SymPy <code class="docutils literal notranslate"><span class="pre">sin</span></code> and
<code class="docutils literal notranslate"><span class="pre">cos</span></code>. In the second, they are defined as the NumPy versions.</p>
<p>If we were to import the first file and use the <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code> function, we
would get something like</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sin_cos_sympy</span> <span class="kn">import</span> <span class="n">sin_cos</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin_cos</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">cos(1) + sin(1)</span>
</pre></div>
</div>
<p>On the other hand, if we imported <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code> from the second file, we
would get</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sin_cos_numpy</span> <span class="kn">import</span> <span class="n">sin_cos</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin_cos</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">1.38177329068</span>
</pre></div>
</div>
<p>In the first case we got a symbolic output, because it used the symbolic
<code class="docutils literal notranslate"><span class="pre">sin</span></code> and <code class="docutils literal notranslate"><span class="pre">cos</span></code> functions from SymPy. In the second, we got a numeric
result, because <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code> used the numeric <code class="docutils literal notranslate"><span class="pre">sin</span></code> and <code class="docutils literal notranslate"><span class="pre">cos</span></code> functions
from NumPy. But notice that the versions of <code class="docutils literal notranslate"><span class="pre">sin</span></code> and <code class="docutils literal notranslate"><span class="pre">cos</span></code> that were
used was not inherent to the <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code> function definition. Both
<code class="docutils literal notranslate"><span class="pre">sin_cos</span></code> definitions are exactly the same. Rather, it was based on the
names defined at the module where the <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code> function was defined.</p>
<p>The key point here is that when function in Python references a name that
is not defined in the function, that name is looked up in the “global”
namespace of the module where that function is defined.</p>
<p>Now, in Python, we can emulate this behavior without actually writing a
file to disk using the <code class="docutils literal notranslate"><span class="pre">exec</span></code> function. <code class="docutils literal notranslate"><span class="pre">exec</span></code> takes a string
containing a block of Python code, and a dictionary that should contain
the global variables of the module. It then executes the code “in” that
dictionary, as if it were the module globals. The following is equivalent
to the <code class="docutils literal notranslate"><span class="pre">sin_cos</span></code> defined in <code class="docutils literal notranslate"><span class="pre">sin_cos_sympy.py</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">module_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sin&#39;</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">:</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exec</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">def sin_cos(x):</span>
<span class="gp">... </span><span class="s1">    return sin(x) + cos(x)</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">module_dictionary</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin_cos</span> <span class="o">=</span> <span class="n">module_dictionary</span><span class="p">[</span><span class="s1">&#39;sin_cos&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin_cos</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">cos(1) + sin(1)</span>
</pre></div>
</div>
<p>and similarly with <code class="docutils literal notranslate"><span class="pre">sin_cos_numpy</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">module_dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sin&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exec</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">def sin_cos(x):</span>
<span class="gp">... </span><span class="s1">    return sin(x) + cos(x)</span>
<span class="gp">... </span><span class="s1">&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">module_dictionary</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin_cos</span> <span class="o">=</span> <span class="n">module_dictionary</span><span class="p">[</span><span class="s1">&#39;sin_cos&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sin_cos</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1.38177329068</span>
</pre></div>
</div>
<p>So now we can get an idea of how <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> works. The name “lambdify”
comes from the fact that we can think of something like <code class="docutils literal notranslate"><span class="pre">lambdify(x,</span>
<span class="pre">sin(x)</span> <span class="pre">+</span> <span class="pre">cos(x),</span> <span class="pre">'numpy')</span></code> as <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">sin(x)</span> <span class="pre">+</span> <span class="pre">cos(x)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">sin</span></code> and <code class="docutils literal notranslate"><span class="pre">cos</span></code> come from the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> namespace. This is also why
the symbols argument is first in <code class="docutils literal notranslate"><span class="pre">lambdify</span></code>, as opposed to most SymPy
functions where it comes after the expression: to better mimic the
<code class="docutils literal notranslate"><span class="pre">lambda</span></code> keyword.</p>
<p><code class="docutils literal notranslate"><span class="pre">lambdify</span></code> takes the input expression (like <code class="docutils literal notranslate"><span class="pre">sin(x)</span> <span class="pre">+</span> <span class="pre">cos(x)</span></code>) and</p>
<ol class="arabic simple">
<li><p>Converts it to a string</p></li>
<li><p>Creates a module globals dictionary based on the modules that are
passed in (by default, it uses the NumPy module)</p></li>
<li><p>Creates the string <code class="docutils literal notranslate"><span class="pre">&quot;def</span> <span class="pre">func({vars}):</span> <span class="pre">return</span> <span class="pre">{expr}&quot;</span></code>, where <code class="docutils literal notranslate"><span class="pre">{vars}</span></code> is the
list of variables separated by commas, and <code class="docutils literal notranslate"><span class="pre">{expr}</span></code> is the string
created in step 1., then <code class="docutils literal notranslate"><span class="pre">exec``s</span> <span class="pre">that</span> <span class="pre">string</span> <span class="pre">with</span> <span class="pre">the</span> <span class="pre">module</span> <span class="pre">globals</span>
<span class="pre">namespace</span> <span class="pre">and</span> <span class="pre">returns</span> <span class="pre">``func</span></code>.</p></li>
</ol>
<p>In fact, functions returned by <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> support inspection. So you can
see exactly how they are defined by using <code class="docutils literal notranslate"><span class="pre">inspect.getsource</span></code>, or <code class="docutils literal notranslate"><span class="pre">??</span></code> if you
are using IPython or the Jupyter notebook.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">def _lambdifygenerated(x):</span>
<span class="go">    return sin(x) + cos(x)</span>
</pre></div>
</div>
<p>This shows us the source code of the function, but not the namespace it
was defined in. We can inspect that by looking at the <code class="docutils literal notranslate"><span class="pre">__globals__</span></code>
attribute of <code class="docutils literal notranslate"><span class="pre">f</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__globals__</span><span class="p">[</span><span class="s1">&#39;sin&#39;</span><span class="p">]</span>
<span class="go">&lt;ufunc &#39;sin&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__globals__</span><span class="p">[</span><span class="s1">&#39;cos&#39;</span><span class="p">]</span>
<span class="go">&lt;ufunc &#39;cos&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__globals__</span><span class="p">[</span><span class="s1">&#39;sin&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span>
<span class="go">True</span>
</pre></div>
</div>
<p>This shows us that <code class="docutils literal notranslate"><span class="pre">sin</span></code> and <code class="docutils literal notranslate"><span class="pre">cos</span></code> in the namespace of <code class="docutils literal notranslate"><span class="pre">f</span></code> will be
<code class="docutils literal notranslate"><span class="pre">numpy.sin</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy.cos</span></code>.</p>
<p>Note that there are some convenience layers in each of these steps, but at
the core, this is how <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> works. Step 1 is done using the
<code class="docutils literal notranslate"><span class="pre">LambdaPrinter</span></code> printers defined in the printing module (see
<a class="reference internal" href="../printing.html#module-sympy.printing.lambdarepr" title="sympy.printing.lambdarepr"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sympy.printing.lambdarepr</span></code></a>). This allows different SymPy expressions
to define how they should be converted to a string for different modules.
You can change which printer <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> uses by passing a custom printer
in to the <code class="docutils literal notranslate"><span class="pre">printer</span></code> argument.</p>
<p>Step 2 is augmented by certain translations. There are default
translations for each module, but you can provide your own by passing a
list to the <code class="docutils literal notranslate"><span class="pre">modules</span></code> argument. For instance,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mysin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;taking the sin of&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">[{</span><span class="s1">&#39;sin&#39;</span><span class="p">:</span> <span class="n">mysin</span><span class="p">},</span> <span class="s1">&#39;numpy&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">taking the sin of 1</span>
<span class="go">0.8414709848078965</span>
</pre></div>
</div>
<p>The globals dictionary is generated from the list by merging the
dictionary <code class="docutils literal notranslate"><span class="pre">{'sin':</span> <span class="pre">mysin}</span></code> and the module dictionary for NumPy. The
merging is done so that earlier items take precedence, which is why
<code class="docutils literal notranslate"><span class="pre">mysin</span></code> is used above instead of <code class="docutils literal notranslate"><span class="pre">numpy.sin</span></code>.</p>
<p>If you want to modify the way <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> works for a given function, it
is usually easiest to do so by modifying the globals dictionary as such.
In more complicated cases, it may be necessary to create and pass in a
custom printer.</p>
<p>Finally, step 3 is augmented with certain convenience operations, such as
the addition of a docstring.</p>
<p>Understanding how <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> works can make it easier to avoid certain
gotchas when using it. For instance, a common mistake is to create a
lambdified function for one module (say, NumPy), and pass it objects from
another (say, a SymPy expression).</p>
<p>For instance, say we create</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now if we pass in a NumPy array, we get that array plus 1</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[2 3]</span>
</pre></div>
</div>
<p>But what happens if you make the mistake of passing in a SymPy expression
instead of a NumPy array:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">x + 2</span>
</pre></div>
</div>
<p>This worked, but it was only by accident. Now take a different lambdified
function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This works as expected on NumPy arrays:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1.84147098 2.90929743]</span>
</pre></div>
</div>
<p>But if we try to pass in a SymPy expression, it fails</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">g</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span><span class="c1"># NumPy release after 1.17 raises TypeError instead of</span>
<span class="gp">... </span><span class="c1"># AttributeError</span>
<span class="gp">... </span><span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">()</span> 
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AttributeError</span>:
</pre></div>
</div>
<p>Now, let’s look at what happened. The reason this fails is that <code class="docutils literal notranslate"><span class="pre">g</span></code>
calls <code class="docutils literal notranslate"><span class="pre">numpy.sin</span></code> on the input expression, and <code class="docutils literal notranslate"><span class="pre">numpy.sin</span></code> does not
know how to operate on a SymPy object. <strong>As a general rule, NumPy
functions do not know how to operate on SymPy expressions, and SymPy
functions do not know how to operate on NumPy arrays. This is why lambdify
exists: to provide a bridge between SymPy and NumPy.</strong></p>
<p>However, why is it that <code class="docutils literal notranslate"><span class="pre">f</span></code> did work? That’s because <code class="docutils literal notranslate"><span class="pre">f</span></code> doesn’t call
any functions, it only adds 1. So the resulting function that is created,
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">_lambdifygenerated(x):</span> <span class="pre">return</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">1</span></code> does not depend on the globals
namespace it is defined in. Thus it works, but only by accident. A future
version of <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> may remove this behavior.</p>
<p>Be aware that certain implementation details described here may change in
future versions of SymPy. The API of passing in custom modules and
printers will not change, but the details of how a lambda function is
created may change. However, the basic idea will remain the same, and
understanding it will be helpful to understanding the behavior of
lambdify.</p>
<p><strong>In general: you should create lambdified functions for one module (say,
NumPy), and only pass it input types that are compatible with that module
(say, NumPy arrays).</strong> Remember that by default, if the <code class="docutils literal notranslate"><span class="pre">module</span></code>
argument is not provided, <code class="docutils literal notranslate"><span class="pre">lambdify</span></code> creates functions using the NumPy
and SciPy namespaces.</p>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="iterables.html"
                        title="previous chapter">Iterables</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="memoization.html"
                        title="next chapter">Memoization</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/utilities/lambdify.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="memoization.html" title="Memoization"
             >next</a> |</li>
        <li class="right" >
          <a href="iterables.html" title="Iterables"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.10.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../reference/index.html" >Reference</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="index.html" >Utilities</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Lambdify</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021 SymPy Development Team.
      Last updated on Nov 09, 2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>