

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.solvers.solvers &mdash; SymPy 0.7.3 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.3 documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.solvers.solvers</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contain solvers for all kinds of equations:</span>

<span class="sd">    - algebraic or transcendental, use solve()</span>

<span class="sd">    - recurrence, use rsolve()</span>

<span class="sd">    - differential, use dsolve()</span>

<span class="sd">    - nonlinear (numerically), use nsolve()</span>
<span class="sd">      (you will need a good starting point)</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">is_sequence</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span>
    <span class="n">default_sort_key</span><span class="p">,</span> <span class="nb">reduce</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.exceptions</span> <span class="kn">import</span> <span class="n">SymPyDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Equality</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Basic</span><span class="p">,</span>
    <span class="n">Expr</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">factor_terms</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="p">(</span><span class="n">expand_mul</span><span class="p">,</span> <span class="n">expand_multinomial</span><span class="p">,</span> <span class="n">expand_log</span><span class="p">,</span>
                          <span class="n">Derivative</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">,</span> <span class="n">UndefinedFunction</span><span class="p">,</span> <span class="n">nfloat</span><span class="p">,</span>
                          <span class="n">count_ops</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">expand_power_exp</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">ilcm</span><span class="p">,</span> <span class="n">Float</span>
<span class="kn">from</span> <span class="nn">sympy.core.relational</span> <span class="kn">import</span> <span class="n">Relational</span>
<span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span>
<span class="kn">from</span> <span class="nn">sympy.core.basic</span> <span class="kn">import</span> <span class="n">preorder_traversal</span>

<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">LambertW</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cot</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span>
                             <span class="n">sinh</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">coth</span><span class="p">,</span> <span class="n">acos</span><span class="p">,</span> <span class="n">asin</span><span class="p">,</span> <span class="n">atan</span><span class="p">,</span> <span class="n">acot</span><span class="p">,</span> <span class="n">acosh</span><span class="p">,</span>
                             <span class="n">asinh</span><span class="p">,</span> <span class="n">atanh</span><span class="p">,</span> <span class="n">acoth</span><span class="p">,</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span>
                             <span class="n">sqrt</span><span class="p">,</span> <span class="n">atan2</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.miscellaneous</span> <span class="kn">import</span> <span class="n">real_root</span>
<span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="n">collect</span><span class="p">,</span> <span class="n">powsimp</span><span class="p">,</span> <span class="n">posify</span><span class="p">,</span> <span class="n">powdenest</span><span class="p">,</span>
                            <span class="n">nsimplify</span><span class="p">,</span> <span class="n">denom</span><span class="p">,</span> <span class="n">logcombine</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.sqrtdenest</span> <span class="kn">import</span> <span class="n">sqrt_depth</span><span class="p">,</span> <span class="n">_mexpand</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.fu</span> <span class="kn">import</span> <span class="n">TR1</span><span class="p">,</span> <span class="n">hyper_as_trig</span>
<span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">zeros</span>
<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">cancel</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">together</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">,</span>
    <span class="n">degree</span><span class="p">,</span> <span class="n">PolynomialError</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.functions.elementary.piecewise</span> <span class="kn">import</span> <span class="n">piecewise_fold</span><span class="p">,</span> <span class="n">Piecewise</span>

<span class="kn">from</span> <span class="nn">sympy.utilities.lambdify</span> <span class="kn">import</span> <span class="n">lambdify</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">filldedent</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">uniq</span>

<span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="n">findroot</span>

<span class="kn">from</span> <span class="nn">sympy.solvers.polysys</span> <span class="kn">import</span> <span class="n">solve_poly_system</span>
<span class="kn">from</span> <span class="nn">sympy.solvers.inequalities</span> <span class="kn">import</span> <span class="n">reduce_inequalities</span>

<span class="kn">from</span> <span class="nn">sympy.assumptions</span> <span class="kn">import</span> <span class="n">Q</span><span class="p">,</span> <span class="n">ask</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">GeneratorType</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<span class="k">def</span> <span class="nf">_ispow</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if e is a Pow or is exp.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">denoms</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return (recursively) set of all denominators that appear in eq</span>
<span class="sd">    that contain any symbol in iterable ``symbols``; if ``symbols`` is</span>
<span class="sd">    None (default) then all denominators will be returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import denoms</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>

<span class="sd">    &gt;&gt;&gt; denoms(x/y)</span>
<span class="sd">    set([y])</span>

<span class="sd">    &gt;&gt;&gt; denoms(x/(y*z))</span>
<span class="sd">    set([y, z])</span>

<span class="sd">    &gt;&gt;&gt; denoms(3/x + y/z)</span>
<span class="sd">    set([x, z])</span>

<span class="sd">    &gt;&gt;&gt; denoms(x/2 + y/z)</span>
<span class="sd">    set([2, z])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
        <span class="n">den</span> <span class="o">=</span>  <span class="n">denom</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">den</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">den</span><span class="p">):</span>
            <span class="n">dens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dens</span>
    <span class="n">rv</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">:</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">free</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">):</span>
            <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>


<div class="viewcode-block" id="checksol"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.checksol">[docs]</a><span class="k">def</span> <span class="nf">checksol</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">sol</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks whether sol is a solution of equation f == 0.</span>

<span class="sd">    Input can be either a single symbol and corresponding value</span>
<span class="sd">    or a dictionary of symbols and values. ``f`` can be a single</span>
<span class="sd">    equation or an iterable of equations. A solution must satisfy</span>
<span class="sd">    all equations in ``f`` to be considered valid; if a solution</span>
<span class="sd">    does not satisfy any equation, False is returned; if one or</span>
<span class="sd">    more checks are inconclusive (and none are False) then None</span>
<span class="sd">    is returned.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers import checksol</span>
<span class="sd">    &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; checksol(x**4 - 1, x, 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; checksol(x**4 - 1, x, 0)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; checksol(x**2 + y**2 - 5**2, {x: 3, y: 4})</span>
<span class="sd">    True</span>

<span class="sd">    To check if an expression is zero using checksol, pass it</span>
<span class="sd">    as ``f`` and send an empty dictionary for ``symbol``:</span>

<span class="sd">    &gt;&gt;&gt; checksol(x**2 + x - x*(x + 1), {})</span>
<span class="sd">    True</span>

<span class="sd">    None is returned if checksol() could not conclude.</span>

<span class="sd">    flags:</span>
<span class="sd">        &#39;numerical=True (default)&#39;</span>
<span class="sd">           do a fast numerical check if ``f`` has only one symbol.</span>
<span class="sd">        &#39;minimal=True (default is False)&#39;</span>
<span class="sd">           a very fast, minimal testing.</span>
<span class="sd">        &#39;warn=True (default is False)&#39;</span>
<span class="sd">           show a warning if checksol() could not conclude.</span>
<span class="sd">        &#39;simplify=True (default)&#39;</span>
<span class="sd">           simplify solution before substituting into function and</span>
<span class="sd">           simplify the function before trying specific simplifications</span>
<span class="sd">        &#39;force=True (default is False)&#39;</span>
<span class="sd">           make positive all symbols without assumptions regarding sign.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">sol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">sol</span><span class="p">}</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">sol</span> <span class="o">=</span> <span class="n">symbol</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;Expecting sym, val or {sym: val}, None but got </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;no functions to check&#39;</span><span class="p">)</span>
        <span class="n">rv</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">checksol</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">check</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># don&#39;t return, wait to see if there&#39;s a False</span>
        <span class="k">return</span> <span class="n">rv</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Poly</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">rhs</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">sol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
        <span class="c"># if f(y) == 0, x=3 does not set f(y) to zero...nor does it not</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">illegal</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span>
               <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">,</span>
               <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span>
               <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">illegal</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="n">was</span> <span class="o">=</span> <span class="n">f</span>
    <span class="n">attempt</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">numerical</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">attempt</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">illegal</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="o">.</span><span class="n">is_constant</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="c"># there are free symbols -- simple expansion might work</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expand_multinomial</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;minimal&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
                    <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="c"># start over without the failed expanded form, possibly</span>
            <span class="c"># with a simplified solution</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="n">val</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="c"># expansion may work now, so try again and check</span>
                <span class="n">exval</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expand_multinomial</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">exval</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">exval</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="c"># we can decide now</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">exval</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">together</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attempt</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># if there are no radicals and no functions then this can&#39;t be</span>
            <span class="c"># zero anymore -- can it?</span>
            <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
                    <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">UndefinedFunction</span><span class="p">):</span>
                    <span class="n">saw_pow_func</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">saw_pow_func</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">saw_pow_func</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="c"># don&#39;t do a zero check with the positive assumptions in place</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
            <span class="n">nz</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">is_nonzero</span>
            <span class="k">if</span> <span class="n">nz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># issue 2574: nz may be True even when False</span>
                <span class="c"># so these are just hacks to keep a false positive</span>
                <span class="c"># from being returned</span>

                <span class="c"># HACK 1: LambertW (issue 2574)</span>
                <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">LambertW</span><span class="p">):</span>
                    <span class="c"># don&#39;t eval this to verify solution since if we got here,</span>
                    <span class="c"># numerical must be False</span>
                    <span class="k">return</span> <span class="bp">None</span>

                <span class="c"># add other HACKs here if necessary, otherwise we assume</span>
                <span class="c"># the nz value is correct</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="n">nz</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">numerical</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">val</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">chop</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-9</span>
        <span class="n">was</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;warn&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\t</span><span class="s">Warning: could not verify solution </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="n">sol</span><span class="p">)</span>
    <span class="c"># returns None if it can&#39;t conclude</span>
    <span class="c"># TODO: improve solution testing</span>

</div>
<div class="viewcode-block" id="check_assumptions"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.check_assumptions">[docs]</a><span class="k">def</span> <span class="nf">check_assumptions</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Checks whether expression `expr` satisfies all assumptions.</span>

<span class="sd">    `assumptions` is a dict of assumptions: {&#39;assumption&#39;: True|False, ...}.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">       &gt;&gt;&gt; from sympy import Symbol, pi, I, exp</span>
<span class="sd">       &gt;&gt;&gt; from sympy.solvers.solvers import check_assumptions</span>

<span class="sd">       &gt;&gt;&gt; check_assumptions(-5, integer=True)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(pi, real=True, integer=False)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(pi, real=True, negative=True)</span>
<span class="sd">       False</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(exp(I*pi/7), real=False)</span>
<span class="sd">       True</span>

<span class="sd">       &gt;&gt;&gt; x = Symbol(&#39;x&#39;, real=True, positive=True)</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(2*x + 1, real=True, positive=True)</span>
<span class="sd">       True</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(-2*x - 5, real=True, positive=True)</span>
<span class="sd">       False</span>

<span class="sd">       `None` is returned if check_assumptions() could not conclude.</span>

<span class="sd">       &gt;&gt;&gt; check_assumptions(2*x - 1, real=True, positive=True)</span>
<span class="sd">       &gt;&gt;&gt; z = Symbol(&#39;z&#39;)</span>
<span class="sd">       &gt;&gt;&gt; check_assumptions(z, real=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">expected</span> <span class="ow">in</span> <span class="n">assumptions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">expected</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">test</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s">&#39;is_&#39;</span> <span class="o">+</span> <span class="n">key</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="n">expected</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">test</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># Can&#39;t conclude, unless an other test fails.</span>
    <span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Algebraically solves equations and systems of equations.</span>

<span class="sd">    Currently supported are:</span>
<span class="sd">        - univariate polynomial,</span>
<span class="sd">        - transcendental</span>
<span class="sd">        - piecewise combinations of the above</span>
<span class="sd">        - systems of linear and polynomial equations</span>
<span class="sd">        - sytems containing relational expressions.</span>

<span class="sd">    Input is formed as:</span>

<span class="sd">    * f</span>
<span class="sd">        - a single Expr or Poly that must be zero,</span>
<span class="sd">        - an Equality</span>
<span class="sd">        - a Relational expression or boolean</span>
<span class="sd">        - iterable of one or more of the above</span>

<span class="sd">    * symbols (object(s) to solve for) specified as</span>
<span class="sd">        - none given (other non-numeric objects will be used)</span>
<span class="sd">        - single symbol</span>
<span class="sd">        - denested list of symbols</span>
<span class="sd">          e.g. solve(f, x, y)</span>
<span class="sd">        - ordered iterable of symbols</span>
<span class="sd">          e.g. solve(f, [x, y])</span>

<span class="sd">    * flags</span>
<span class="sd">        &#39;dict&#39;=True (default is False)</span>
<span class="sd">            return list (perhaps empty) of solution mappings</span>
<span class="sd">        &#39;set&#39;=True (default is False)</span>
<span class="sd">            return list of symbols and set of tuple(s) of solution(s)</span>
<span class="sd">        &#39;exclude=[] (default)&#39;</span>
<span class="sd">            don&#39;t try to solve for any of the free symbols in exclude;</span>
<span class="sd">            if expressions are given, the free symbols in them will</span>
<span class="sd">            be extracted automatically.</span>
<span class="sd">        &#39;check=True (default)&#39;</span>
<span class="sd">            If False, don&#39;t do any testing of solutions. This can be</span>
<span class="sd">            useful if one wants to include solutions that make any</span>
<span class="sd">            denominator zero.</span>
<span class="sd">        &#39;numerical=True (default)&#39;</span>
<span class="sd">            do a fast numerical check if ``f`` has only one symbol.</span>
<span class="sd">        &#39;minimal=True (default is False)&#39;</span>
<span class="sd">            a very fast, minimal testing.</span>
<span class="sd">        &#39;warning=True (default is False)&#39;</span>
<span class="sd">            show a warning if checksol() could not conclude.</span>
<span class="sd">        &#39;simplify=True (default)&#39;</span>
<span class="sd">            simplify all but cubic and quartic solutions before</span>
<span class="sd">            returning them and (if check is not False) use the</span>
<span class="sd">            general simplify function on the solutions and the</span>
<span class="sd">            expression obtained when they are substituted into the</span>
<span class="sd">            function which should be zero</span>
<span class="sd">        &#39;force=True (default is False)&#39;</span>
<span class="sd">            make positive all symbols without assumptions regarding sign.</span>
<span class="sd">        &#39;rational=True (default)&#39;</span>
<span class="sd">            recast Floats as Rational; if this option is not used, the</span>
<span class="sd">            system containing floats may fail to solve because of issues</span>
<span class="sd">            with polys. If rational=None, Floats will be recast as</span>
<span class="sd">            rationals but the answer will be recast as Floats. If the</span>
<span class="sd">            flag is False then nothing will be done to the Floats.</span>
<span class="sd">        &#39;manual=True (default is False)&#39;</span>
<span class="sd">            do not use the polys/matrix method to solve a system of</span>
<span class="sd">            equations, solve them one at a time as you might &quot;manually&quot;.</span>
<span class="sd">        &#39;implicit=True (default is False)&#39;</span>
<span class="sd">            allows solve to return a solution for a pattern in terms of</span>
<span class="sd">            other functions that contain that pattern; this is only</span>
<span class="sd">            needed if the pattern is inside of some invertible function</span>
<span class="sd">            like cos, exp, ....</span>
<span class="sd">        &#39;minimal=True (default is False)&#39;</span>
<span class="sd">            instructs solve to try to find a particular solution to a linear</span>
<span class="sd">            system with as many zeros as possible; this is very expensive</span>
<span class="sd">        &#39;quick=True (default is False)&#39;</span>
<span class="sd">            when using minimal=True, use a fast heuristic instead to find a</span>
<span class="sd">            solution with many zeros (instead of using the very slow method</span>
<span class="sd">            guaranteed to find the largest number of zeros possible)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    The output varies according to the input and can be seen by example::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import solve, Poly, Eq, Function, exp</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z, a, b</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;)</span>

<span class="sd">    * boolean or univariate Relational</span>

<span class="sd">        &gt;&gt;&gt; solve(x &lt; 3)</span>
<span class="sd">        And(im(x) == 0, re(x) &lt; 3)</span>

<span class="sd">    * to always get a list of solution mappings, use flag dict=True</span>

<span class="sd">        &gt;&gt;&gt; solve(x - 3, dict=True)</span>
<span class="sd">        [{x: 3}]</span>
<span class="sd">        &gt;&gt;&gt; solve([x - 3, y - 1], dict=True)</span>
<span class="sd">        [{x: 3, y: 1}]</span>

<span class="sd">    * to get a list of symbols and set of solution(s) use flag set=True</span>

<span class="sd">        &gt;&gt;&gt; solve([x**2 - 3, y - 1], set=True)</span>
<span class="sd">        ([x, y], set([(-sqrt(3), 1), (sqrt(3), 1)]))</span>

<span class="sd">    * single expression and single symbol that is in the expression</span>

<span class="sd">        &gt;&gt;&gt; solve(x - y, x)</span>
<span class="sd">        [y]</span>
<span class="sd">        &gt;&gt;&gt; solve(x - 3, x)</span>
<span class="sd">        [3]</span>
<span class="sd">        &gt;&gt;&gt; solve(Eq(x, 3), x)</span>
<span class="sd">        [3]</span>
<span class="sd">        &gt;&gt;&gt; solve(Poly(x - 3), x)</span>
<span class="sd">        [3]</span>
<span class="sd">        &gt;&gt;&gt; solve(x**2 - y**2, x, set=True)</span>
<span class="sd">        ([x], set([(-y,), (y,)]))</span>
<span class="sd">        &gt;&gt;&gt; solve(x**4 - 1, x, set=True)</span>
<span class="sd">        ([x], set([(-1,), (1,), (-I,), (I,)]))</span>

<span class="sd">    * single expression with no symbol that is in the expression</span>

<span class="sd">        &gt;&gt;&gt; solve(3, x)</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; solve(x - 3, y)</span>
<span class="sd">        []</span>

<span class="sd">    * single expression with no symbol given</span>

<span class="sd">          In this case, all free symbols will be selected as potential</span>
<span class="sd">          symbols to solve for. If the equation is univariate then a list</span>
<span class="sd">          of solutions is returned; otherwise -- as is the case when symbols are</span>
<span class="sd">          given as an iterable of length &gt; 1 -- a list of mappings will be returned.</span>

<span class="sd">            &gt;&gt;&gt; solve(x - 3)</span>
<span class="sd">            [3]</span>
<span class="sd">            &gt;&gt;&gt; solve(x**2 - y**2)</span>
<span class="sd">            [{x: -y}, {x: y}]</span>
<span class="sd">            &gt;&gt;&gt; solve(z**2*x**2 - z**2*y**2)</span>
<span class="sd">            [{x: -y}, {x: y}, {z: 0}]</span>
<span class="sd">            &gt;&gt;&gt; solve(z**2*x - z**2*y**2)</span>
<span class="sd">            [{x: y**2}, {z: 0}]</span>

<span class="sd">    * when an object other than a Symbol is given as a symbol, it is</span>
<span class="sd">      isolated algebraically and an implicit solution may be obtained.</span>
<span class="sd">      This is mostly provided as a convenience to save one from replacing</span>
<span class="sd">      the object with a Symbol and solving for that Symbol. It will only</span>
<span class="sd">      work if the specified object can be replaced with a Symbol using the</span>
<span class="sd">      subs method.</span>

<span class="sd">          &gt;&gt;&gt; solve(f(x) - x, f(x))</span>
<span class="sd">          [x]</span>
<span class="sd">          &gt;&gt;&gt; solve(f(x).diff(x) - f(x) - x, f(x).diff(x))</span>
<span class="sd">          [x + f(x)]</span>
<span class="sd">          &gt;&gt;&gt; solve(f(x).diff(x) - f(x) - x, f(x))</span>
<span class="sd">          [-x + Derivative(f(x), x)]</span>
<span class="sd">          &gt;&gt;&gt; solve(x + exp(x)**2, exp(x), set=True)</span>
<span class="sd">          ([exp(x)], set([(-sqrt(-x),), (sqrt(-x),)]))</span>

<span class="sd">          &gt;&gt;&gt; from sympy import Indexed, IndexedBase, Tuple, sqrt</span>
<span class="sd">          &gt;&gt;&gt; A = IndexedBase(&#39;A&#39;)</span>
<span class="sd">          &gt;&gt;&gt; eqs = Tuple(A[1] + A[2] - 3, A[1] - A[2] + 1)</span>
<span class="sd">          &gt;&gt;&gt; solve(eqs, eqs.atoms(Indexed))</span>
<span class="sd">          {A[1]: 1, A[2]: 2}</span>

<span class="sd">        * To solve for a *symbol* implicitly, use &#39;implicit=True&#39;:</span>

<span class="sd">            &gt;&gt;&gt; solve(x + exp(x), x)</span>
<span class="sd">            [-LambertW(1)]</span>
<span class="sd">            &gt;&gt;&gt; solve(x + exp(x), x, implicit=True)</span>
<span class="sd">            [-exp(x)]</span>

<span class="sd">        * It is possible to solve for anything that can be targeted with</span>
<span class="sd">          subs:</span>

<span class="sd">            &gt;&gt;&gt; solve(x + 2 + sqrt(3), x + 2)</span>
<span class="sd">            [-sqrt(3)]</span>
<span class="sd">            &gt;&gt;&gt; solve((x + 2 + sqrt(3), x + 4 + y), y, x + 2)</span>
<span class="sd">            {y: -2 + sqrt(3), x + 2: -sqrt(3)}</span>

<span class="sd">        * Nothing heroic is done in this implicit solving so you may end up</span>
<span class="sd">          with a symbol still in the solution:</span>

<span class="sd">            &gt;&gt;&gt; eqs = (x*y + 3*y + sqrt(3), x + 4 + y)</span>
<span class="sd">            &gt;&gt;&gt; solve(eqs, y, x + 2)</span>
<span class="sd">            {y: -sqrt(3)/(x + 3), x + 2: (-2*x - 6 + sqrt(3))/(x + 3)}</span>
<span class="sd">            &gt;&gt;&gt; solve(eqs, y*x, x)</span>
<span class="sd">            {x: -y - 4, x*y: -3*y - sqrt(3)}</span>

<span class="sd">        * if you attempt to solve for a number remember that the number</span>
<span class="sd">          you have obtained does not necessarily mean that the value is</span>
<span class="sd">          equivalent to the expression obtained:</span>

<span class="sd">            &gt;&gt;&gt; solve(sqrt(2) - 1, 1)</span>
<span class="sd">            [sqrt(2)]</span>
<span class="sd">            &gt;&gt;&gt; solve(x - y + 1, 1)  # /!\ -1 is targeted, too</span>
<span class="sd">            [x/(y - 1)]</span>
<span class="sd">            &gt;&gt;&gt; [_.subs(z, -1) for _ in solve((x - y + 1).subs(-1, z), 1)]</span>
<span class="sd">            [-x + y]</span>

<span class="sd">        * To solve for a function within a derivative, use dsolve.</span>

<span class="sd">    * single expression and more than 1 symbol</span>

<span class="sd">        * when there is a linear solution</span>

<span class="sd">            &gt;&gt;&gt; solve(x - y**2, x, y)</span>
<span class="sd">            [{x: y**2}]</span>
<span class="sd">            &gt;&gt;&gt; solve(x**2 - y, x, y)</span>
<span class="sd">            [{y: x**2}]</span>

<span class="sd">        * when undetermined coefficients are identified</span>

<span class="sd">            * that are linear</span>

<span class="sd">                &gt;&gt;&gt; solve((a + b)*x - b + 2, a, b)</span>
<span class="sd">                {a: -2, b: 2}</span>

<span class="sd">            * that are nonlinear</span>

<span class="sd">                &gt;&gt;&gt; solve((a + b)*x - b**2 + 2, a, b, set=True)</span>
<span class="sd">                ([a, b], set([(-sqrt(2), sqrt(2)), (sqrt(2), -sqrt(2))]))</span>

<span class="sd">        * if there is no linear solution then the first successful</span>
<span class="sd">          attempt for a nonlinear solution will be returned</span>

<span class="sd">            &gt;&gt;&gt; solve(x**2 - y**2, x, y)</span>
<span class="sd">            [{x: -y}, {x: y}]</span>
<span class="sd">            &gt;&gt;&gt; solve(x**2 - y**2/exp(x), x, y)</span>
<span class="sd">            [{x: 2*LambertW(y/2)}]</span>
<span class="sd">            &gt;&gt;&gt; solve(x**2 - y**2/exp(x), y, x)</span>
<span class="sd">            [{y: -x*exp(x/2)}, {y: x*exp(x/2)}]</span>

<span class="sd">    * iterable of one or more of the above</span>

<span class="sd">        * involving relationals or bools</span>

<span class="sd">            &gt;&gt;&gt; solve([x &lt; 3, x - 2])</span>
<span class="sd">            And(im(x) == 0, re(x) == 2)</span>
<span class="sd">            &gt;&gt;&gt; solve([x &gt; 3, x - 2])</span>
<span class="sd">            False</span>

<span class="sd">        * when the system is linear</span>

<span class="sd">            * with a solution</span>

<span class="sd">                &gt;&gt;&gt; solve([x - 3], x)</span>
<span class="sd">                {x: 3}</span>
<span class="sd">                &gt;&gt;&gt; solve((x + 5*y - 2, -3*x + 6*y - 15), x, y)</span>
<span class="sd">                {x: -3, y: 1}</span>
<span class="sd">                &gt;&gt;&gt; solve((x + 5*y - 2, -3*x + 6*y - 15), x, y, z)</span>
<span class="sd">                {x: -3, y: 1}</span>
<span class="sd">                &gt;&gt;&gt; solve((x + 5*y - 2, -3*x + 6*y - z), z, x, y)</span>
<span class="sd">                {x: -5*y + 2, z: 21*y - 6}</span>

<span class="sd">            * without a solution</span>

<span class="sd">                &gt;&gt;&gt; solve([x + 3, x - 3])</span>
<span class="sd">                []</span>

<span class="sd">        * when the system is not linear</span>

<span class="sd">            &gt;&gt;&gt; solve([x**2 + y -2, y**2 - 4], x, y, set=True)</span>
<span class="sd">            ([x, y], set([(-2, -2), (0, 2), (2, -2)]))</span>

<span class="sd">        * if no symbols are given, all free symbols will be selected and a list</span>
<span class="sd">          of mappings returned</span>

<span class="sd">            &gt;&gt;&gt; solve([x - 2, x**2 + y])</span>
<span class="sd">            [{x: 2, y: -4}]</span>
<span class="sd">            &gt;&gt;&gt; solve([x - 2, x**2 + f(x)], set([f(x), x]))</span>
<span class="sd">            [{x: 2, f(x): -4}]</span>

<span class="sd">        * if any equation doesn&#39;t depend on the symbol(s) given it will be</span>
<span class="sd">          eliminated from the equation set and an answer may be given</span>
<span class="sd">          implicitly in terms of variables that were not of interest</span>

<span class="sd">            &gt;&gt;&gt; solve([x - y, y - 3], x)</span>
<span class="sd">            {x: y}</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    assumptions aren&#39;t checked when `solve()` input involves</span>
<span class="sd">    relationals or bools.</span>

<span class="sd">    When the solutions are checked, those that make any denominator zero</span>
<span class="sd">    are automatically excluded. If you do not want to exclude such solutions</span>
<span class="sd">    then use the check=False option:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, limit</span>
<span class="sd">        &gt;&gt;&gt; solve(sin(x)/x)  # 0 is excluded</span>
<span class="sd">        [pi]</span>

<span class="sd">    If check=False then a solution to the numerator being zero is found: x = 0.</span>
<span class="sd">    In this case, this is a spurious solution since sin(x)/x has the well known</span>
<span class="sd">    limit (without dicontinuity) of 1 at x = 0:</span>

<span class="sd">        &gt;&gt;&gt; solve(sin(x)/x, check=False)</span>
<span class="sd">        [0, pi]</span>

<span class="sd">    In the following case, however, the limit exists and is equal to the the</span>
<span class="sd">    value of x = 0 that is excluded when check=True:</span>

<span class="sd">        &gt;&gt;&gt; eq = x**2*(1/x - z**2/x)</span>
<span class="sd">        &gt;&gt;&gt; solve(eq, x)</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; solve(eq, x, check=False)</span>
<span class="sd">        [0]</span>
<span class="sd">        &gt;&gt;&gt; limit(eq, x, 0, &#39;-&#39;)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; limit(eq, x, 0, &#39;+&#39;)</span>
<span class="sd">        0</span>


<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">        - rsolve() for solving recurrence relationships</span>
<span class="sd">        - dsolve() for solving differential equations</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># make f and symbols into lists of sympified quantities</span>
    <span class="c"># keeping track of how f was passed since if it is a list</span>
    <span class="c"># a dictionary of results will be returned.</span>
    <span class="c">###########################################################################</span>

    <span class="k">def</span> <span class="nf">_sympified_list</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">w</span> <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">w</span><span class="p">]))</span>
    <span class="n">bare_f</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">ordered_symbols</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbols</span> <span class="ow">and</span>
                       <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span>
                       <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">is_sequence</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">include</span><span class="o">=</span><span class="n">GeneratorType</span><span class="p">)</span>
                       <span class="p">)</span>
                      <span class="p">)</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">symbols</span> <span class="o">=</span> <span class="p">(</span><span class="n">_sympified_list</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">])</span>

    <span class="n">implicit</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;implicit&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="c"># preprocess equation(s)</span>
    <span class="c">###########################################################################</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">fi</span><span class="o">.</span><span class="n">rhs</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">Poly</span><span class="p">):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">fi</span><span class="o">.</span><span class="n">is_Relational</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">reduce_inequalities</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">assume</span><span class="o">=</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;assume&#39;</span><span class="p">),</span>
                                       <span class="n">symbols</span><span class="o">=</span><span class="n">symbols</span><span class="p">)</span>

        <span class="c"># Any embedded piecewise functions need to be brought out to the</span>
        <span class="c"># top level so that the appropriate strategy gets selected.</span>
        <span class="c"># However, this is necessary only if one of the piecewise</span>
        <span class="c"># functions depends on one of the symbols we are solving for.</span>
        <span class="k">def</span> <span class="nf">_has_piecewise</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Piecewise</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">_has_piecewise</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">_has_piecewise</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">piecewise_fold</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c"># if we have a Matrix, we need to iterate over its elements again</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_Matrix</span><span class="p">:</span>
            <span class="n">bare_f</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">f</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c"># if we can split it into real and imaginary parts then do so</span>
        <span class="n">freei</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="n">freei</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">is_imaginary</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">freei</span><span class="p">):</span>
            <span class="n">fr</span><span class="p">,</span> <span class="n">fi</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">fr</span> <span class="ow">and</span> <span class="n">fi</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="n">fi</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">bare_f</span><span class="p">:</span>
                    <span class="n">bare_f</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fr</span><span class="p">,</span> <span class="n">fi</span><span class="p">]</span>

    <span class="c"># preprocess symbol(s)</span>
    <span class="c">###########################################################################</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="c"># get symbols from equations</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">free_symbols</span>
                                     <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">],</span> <span class="nb">set</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">)</span> <span class="ow">or</span> \
                            <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">AppliedUndef</span><span class="p">):</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;dict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c"># better show symbols</span>
                        <span class="n">symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>  <span class="c"># don&#39;t go any deeper</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="c"># supply dummy symbols so solve(3) behaves like solve(3, x)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)):</span>
            <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Dummy</span><span class="p">())</span>

        <span class="n">ordered_symbols</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">iterable</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># remove symbols the user is not interested in</span>
    <span class="n">exclude</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;exclude&#39;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude</span><span class="p">]</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sympify</span><span class="p">(</span><span class="n">exclude</span><span class="p">)])</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>

    <span class="c"># real/imag handling</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">_abs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Abs</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)]</span>
        <span class="n">fi</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">_abs</span><span class="p">,</span>
            <span class="p">[</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_abs</span><span class="p">]))))</span>
        <span class="n">_arg</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)]</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">_arg</span><span class="p">,</span>
            <span class="p">[</span><span class="n">atan</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">re</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_arg</span><span class="p">]))))</span>
    <span class="c"># see if re(s) or im(s) appear</span>
    <span class="n">irf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="c"># if s is real or complex then re(s) or im(s) will not appear in the equation;</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_real</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">is_complex</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c"># if re(s) or im(s) appear, the auxiliary equation must be present</span>
        <span class="n">irs</span> <span class="o">=</span> <span class="n">re</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">im</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">_f</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">_f</span> <span class="ow">in</span> <span class="n">f</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">irs</span><span class="p">):</span>
            <span class="n">symbols</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">irs</span><span class="p">)</span>
            <span class="n">irf</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">re</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="o">*</span><span class="n">im</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">irf</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">irf</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">rhs</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">bare_f</span><span class="p">:</span>
            <span class="n">bare_f</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;dict&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">f</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="n">rhs</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">irf</span><span class="p">)</span>
    <span class="c"># end of real/imag handling</span>

    <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ordered_symbols</span><span class="p">:</span>
        <span class="c"># we do this to make the results returned canonical in case f</span>
        <span class="c"># contains a system of nonlinear equations; all other cases should</span>
        <span class="c"># be unambiguous</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

    <span class="c"># we can solve for non-symbol entities by replacing them with Dummy symbols</span>
    <span class="n">symbols_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">symbol_swapped</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="n">s_new</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">symbol_swapped</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">s_new</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;X</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">symbols_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_new</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">symbol_swapped</span><span class="p">:</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">symbols_new</span><span class="p">))</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols_new</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">swap_sym</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">swap_sym</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c"># this is needed in the next two events</span>
    <span class="n">symset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>

    <span class="c"># get rid of equations that have no symbols of interest; we don&#39;t</span>
    <span class="c"># try to solve them because the user didn&#39;t ask and they might be</span>
    <span class="c"># hard to solve; this means that solutions may be given in terms</span>
    <span class="c"># of the eliminated equations e.g. solve((x-y, y-3), x) -&gt; {x: y}</span>
    <span class="n">newf</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="c"># let the solver handle equations that..</span>
        <span class="c"># - have no symbols but are expressions</span>
        <span class="c"># - have symbols of interest</span>
        <span class="c"># - have no symbols of interest but are constant</span>
        <span class="c"># but when an expression is not constant and has no symbols of</span>
        <span class="c"># interest, it can&#39;t change what we obtain for a solution from</span>
        <span class="c"># the remaining equations so we don&#39;t include it; and if it&#39;s</span>
        <span class="c"># zero it can be removed and if it&#39;s not zero, there is no</span>
        <span class="c"># solution for the equation set as a whole</span>
        <span class="c">#</span>
        <span class="c"># The reason for doing this filtering is to allow an answer</span>
        <span class="c"># to be obtained to queries like solve((x - y, y), x); without</span>
        <span class="c"># this mod the return value is []</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">symset</span><span class="p">):</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">free</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">free</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">return</span> <span class="p">[]</span>
                <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">is_constant</span><span class="p">():</span>
                    <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">ok</span><span class="p">:</span>
            <span class="n">newf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">newf</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">newf</span>
    <span class="k">del</span> <span class="n">newf</span>

    <span class="c"># mask off any Object that we aren&#39;t going to invert: Derivative,</span>
    <span class="c"># Integral, etc... so that solving for anything that they contain will</span>
    <span class="c"># give an implicit solution</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">non_inverts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pot</span> <span class="o">=</span> <span class="n">preorder_traversal</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pot</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Piecewise</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span>
                    <span class="n">p</span> <span class="ow">in</span> <span class="n">symset</span> <span class="ow">or</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">implicit</span> <span class="ow">or</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">implicit</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">symset</span><span class="p">:</span>
                    <span class="n">non_inverts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">pot</span><span class="o">.</span><span class="n">skip</span><span class="p">()</span>
    <span class="k">del</span> <span class="n">seen</span>
    <span class="n">non_inverts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">,</span> <span class="p">[</span><span class="n">Dummy</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">non_inverts</span><span class="p">])))</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">)</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>

    <span class="n">non_inverts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">non_inverts</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

    <span class="c"># rationalize Floats</span>
    <span class="n">floats</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;rational&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">Float</span><span class="p">):</span>
                <span class="n">floats</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c">#</span>
    <span class="c"># try to get a solution</span>
    <span class="c">###########################################################################</span>
    <span class="k">if</span> <span class="n">bare_f</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">_solve_system</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

    <span class="c">#</span>
    <span class="c"># postprocessing</span>
    <span class="c">###########################################################################</span>
    <span class="c"># Restore masked-off objects</span>
    <span class="k">if</span> <span class="n">non_inverts</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">_do_dict</span><span class="p">(</span><span class="n">solution</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                         <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">solution</span> <span class="o">=</span> <span class="n">_do_dict</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">solution</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">_do_dict</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span>
                                <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">non_inverts</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">                            no handling of </span><span class="si">%s</span><span class="s"> was implemented&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">solution</span><span class="p">))</span>

    <span class="c"># Restore original &quot;symbols&quot; if a dictionary is returned.</span>
    <span class="c"># This is not necessary for</span>
    <span class="c">#   - the single univariate equation case</span>
    <span class="c">#     since the symbol will have been removed from the solution;</span>
    <span class="c">#   - the nonlinear poly_system since that only supports zero-dimensional</span>
    <span class="c">#     systems and those results come back as a list</span>
    <span class="c">#</span>
    <span class="c"># ** unless there were Derivatives with the symbols, but those were handled</span>
    <span class="c">#    above.</span>
    <span class="k">if</span> <span class="n">symbol_swapped</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="n">swap_sym</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">swap_sym</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">))</span>
                             <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">elif</span> <span class="n">solution</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sol</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">solution</span><span class="p">):</span>
                <span class="n">solution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">swap_sym</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">swap_sym</span><span class="p">))</span>
                              <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="c"># undo the dictionary solutions returned when the system was only partially</span>
    <span class="c"># solved with poly-system if all symbols are present</span>
    <span class="k">if</span> <span class="p">(</span>
            <span class="n">solution</span> <span class="ow">and</span>
            <span class="n">ordered_symbols</span> <span class="ow">and</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span> <span class="ow">and</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span> <span class="ow">and</span>
            <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>

    <span class="c"># Get assumptions about symbols, to filter solutions.</span>
    <span class="c"># Note that if assumptions about a solution can&#39;t be verified, it is still</span>
    <span class="c"># returned.</span>
    <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;check&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="c"># restore floats</span>
    <span class="k">if</span> <span class="n">floats</span> <span class="ow">and</span> <span class="n">solution</span> <span class="ow">and</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;rational&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">nfloat</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="n">solution</span><span class="p">:</span>

        <span class="n">warning</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;warn&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">got_None</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># solutions for which one or more symbols gave None</span>
        <span class="n">no_False</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># solutions for which no symbols gave False</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
                        <span class="n">test</span> <span class="o">=</span> <span class="n">check_assumptions</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">symb</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">got_None</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">no_False</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">:</span>
                    <span class="n">a_None</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">test</span> <span class="o">=</span> <span class="n">check_assumptions</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">symb</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">a_None</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">no_False</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">a_None</span><span class="p">:</span>
                            <span class="n">got_None</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># list of expressions</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">:</span>
                    <span class="n">test</span> <span class="o">=</span> <span class="n">check_assumptions</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="o">**</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">no_False</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">got_None</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">a_None</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">symb</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">test</span> <span class="o">=</span> <span class="n">check_assumptions</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="o">**</span><span class="n">symb</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">test</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="n">no_False</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">break</span>
                <span class="n">a_None</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">no_False</span> <span class="o">=</span> <span class="n">solution</span>
                <span class="k">if</span> <span class="n">a_None</span><span class="p">:</span>
                    <span class="n">got_None</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="p">(</span><span class="n">Relational</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">)):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">warning</span> <span class="ow">and</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">assumptions0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                    </span><span class="se">\t</span><span class="s">Warning: assumptions about variable &#39;</span><span class="si">%s</span><span class="s">&#39; are</span>
<span class="s">                    not handled currently.&quot;&quot;&quot;</span> <span class="o">%</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="c"># TODO: check also variable assumptions for inequalities</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Unrecognized solution&#39;</span><span class="p">)</span>  <span class="c"># improve the checker</span>

        <span class="n">solution</span> <span class="o">=</span> <span class="n">no_False</span>
        <span class="k">if</span> <span class="n">warning</span> <span class="ow">and</span> <span class="n">got_None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                </span><span class="se">\t</span><span class="s">Warning: assumptions concerning following solution(s)</span>
<span class="s">                can&#39;t be checked:&quot;&quot;&quot;</span> <span class="o">+</span> <span class="s">&#39;</span><span class="se">\n\t</span><span class="s">&#39;</span> <span class="o">+</span>
                <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">got_None</span><span class="p">)))</span>

    <span class="c">#</span>
    <span class="c"># done</span>
    <span class="c">###########################################################################</span>

    <span class="n">as_dict</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;dict&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">as_set</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;set&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">as_set</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="c"># Make sure that a list of solutions is ordered in a canonical way.</span>
        <span class="n">solution</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">as_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">as_set</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solution</span> <span class="ow">or</span> <span class="p">[]</span>

    <span class="c"># return a list of mappings or []</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="n">solution</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">iterable</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">s</span><span class="p">)))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="p">[{</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">s</span><span class="p">}</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">solution</span>
    <span class="k">assert</span> <span class="n">as_set</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="o">.</span><span class="n">sort_key</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="nb">set</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="n">ki</span><span class="p">]</span> <span class="k">for</span> <span class="n">ki</span> <span class="ow">in</span> <span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solution</span><span class="p">])</span>

</div>
<span class="k">def</span> <span class="nf">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a checked solution for f in terms of one or more of the</span>
<span class="sd">    symbols.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">soln</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">ex</span> <span class="o">=</span> <span class="n">free</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ind</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">dep</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># may come back as dict or list (if non-linear)</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">solve_undetermined_coeffs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">ex</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">soln</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">soln</span>
        <span class="c"># find first successful solution</span>
        <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">got_s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">solve_linear</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                <span class="c"># no need to check but we should simplify if desired</span>
                <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">]):</span>
                    <span class="c"># sol depends on previously solved symbols: discard it</span>
                    <span class="k">continue</span>
                <span class="n">got_s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">d</span><span class="p">})</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">d</span><span class="p">:</span>  <span class="c"># otherwise there was no solution for s</span>
                <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">failed</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">failed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">]):</span>
                        <span class="c"># sol depends on previously solved symbols: discard it</span>
                        <span class="k">continue</span>
                    <span class="n">got_s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">s</span><span class="p">:</span> <span class="n">sol</span><span class="p">})</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">if</span> <span class="n">got_s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;No algorithms are implemented to solve equation </span><span class="si">%s</span><span class="s">&quot;</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">symbol</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;check&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="c"># build up solutions if f is a Mul</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">denoms</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">soln</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span>
                <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">checksol</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">s</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">den</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">)]</span>
        <span class="c"># set flags for quick exit at end</span>
        <span class="n">check</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">elif</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Piecewise</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">or</span> <span class="n">cond</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="c"># Only include solutions that do not match the condition</span>
                    <span class="c"># of any previous pieces.</span>
                    <span class="n">matches_other_piece</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">for</span> <span class="n">other_n</span><span class="p">,</span> <span class="p">(</span><span class="n">other_expr</span><span class="p">,</span> <span class="n">other_cond</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">other_n</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="k">if</span> <span class="n">other_cond</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">other_cond</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                            <span class="n">matches_other_piece</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">matches_other_piece</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Piecewise</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">or</span> <span class="n">cond</span><span class="o">.</span><span class="n">doit</span><span class="p">()),</span>
                            <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
                        <span class="p">))</span>
        <span class="n">check</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># first see if it really depends on symbol and whether there</span>
        <span class="c"># is a linear solution</span>
        <span class="n">f_num</span><span class="p">,</span> <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_linear</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">f_num</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">f_num</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
            <span class="c"># no need to check but simplify if desired</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
                <span class="n">sol</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">sol</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># no solution was obtained</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>  <span class="c"># there is no failure message</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">denoms</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>  <span class="c"># store these for checking later</span>

        <span class="c"># Poly is generally robust enough to convert anything to</span>
        <span class="c"># a polynomial and tell us the different generators that it</span>
        <span class="c"># contains, so we will inspect the generators identified by</span>
        <span class="c"># polys to figure out what to do.</span>

        <span class="c"># but first remove radicals as this will help Polys</span>
        <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;unrad&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># try remove all...</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c"># ...else hope for the best while letting some remain</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># hope for best with original equation</span>
            <span class="k">if</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">flags</span><span class="p">[</span><span class="s">&#39;unrad&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># don&#39;t unrad next time</span>
                <span class="n">eq</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">dens2</span> <span class="o">=</span> <span class="n">u</span>
                <span class="n">dens</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dens2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cov</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Not sure how to handle this.&#39;</span><span class="p">)</span>
                    <span class="n">isym</span><span class="p">,</span> <span class="n">ieq</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c"># since cov is written in terms of positive symbols, set</span>
                    <span class="c"># check to False or else 0 would be excluded; the solution</span>
                    <span class="c"># will be checked below</span>
                    <span class="n">absent</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
                    <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;check&#39;</span><span class="p">,</span> <span class="n">absent</span><span class="p">)</span>
                    <span class="n">flags</span><span class="p">[</span><span class="s">&#39;check&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">sol</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">isym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="n">inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ieq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">isym</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">check</span> <span class="o">==</span> <span class="n">absent</span><span class="p">:</span>
                        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;check&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;check&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">check</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="c"># rewrite hyperbolics in terms of exp</span>
            <span class="n">f_num</span> <span class="o">=</span> <span class="n">f_num</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">),</span>
                <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>

            <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">poly</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;could not convert </span><span class="si">%s</span><span class="s"> to Poly&#39;</span> <span class="o">%</span> <span class="n">f_num</span><span class="p">)</span>
            <span class="n">gens</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">gens</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">)]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># If there is more than one generator, it could be that the</span>
                <span class="c"># generators have the same base but different powers, e.g.</span>
                <span class="c">#   &gt;&gt;&gt; Poly(exp(x)+1/exp(x))</span>
                <span class="c">#   Poly(exp(-x) + exp(x), exp(-x), exp(x), domain=&#39;ZZ&#39;)</span>
                <span class="c">#   &gt;&gt;&gt; Poly(sqrt(x)+sqrt(sqrt(x)))</span>
                <span class="c">#   Poly(sqrt(x) + x**(1/4), sqrt(x), x**(1/4), domain=&#39;ZZ&#39;)</span>
                <span class="c"># If the exponents are Rational then a change of variables</span>
                <span class="c"># will make this a polynomial equation in a single base.</span>

                <span class="k">def</span> <span class="nf">_as_base_q</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;Return (b**e, q) for x = b**(p*e/q) where p/q is the leading</span>
<span class="sd">                    Rational of the exponent of x, e.g. exp(-2*x/3) -&gt; (exp(x), 3)</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">q</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">ee</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>  <span class="c"># c could be a Float</span>
                        <span class="k">return</span> <span class="n">b</span><span class="o">**</span><span class="n">ee</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">q</span>
                    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span>

                <span class="n">bases</span><span class="p">,</span> <span class="n">qs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_as_base_q</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gens</span><span class="p">]))</span>
                <span class="n">bases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">funcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Function</span><span class="p">)</span>

                    <span class="n">trig</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="k">if</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">)])</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">funcs</span> <span class="o">-</span> <span class="n">trig</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">trig</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">newf</span> <span class="o">=</span> <span class="n">TR1</span><span class="p">(</span><span class="n">f_num</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">tan</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">newf</span> <span class="o">!=</span> <span class="n">f_num</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">newf</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

                    <span class="c"># just a simple case - see if replacement of single function</span>
                    <span class="c"># clears all symbol-dependent functions, e.g.</span>
                    <span class="c"># log(x) - log(log(x) - 1) - 3 can be solved even though it has</span>
                    <span class="c"># two generators.</span>

                    <span class="k">if</span> <span class="n">funcs</span><span class="p">:</span>
                        <span class="n">funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">funcs</span><span class="p">))</span>  <span class="c"># put shallowest function first</span>
                        <span class="n">f1</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
                        <span class="c"># perform the substitution</span>
                        <span class="n">ftry</span> <span class="o">=</span> <span class="n">f_num</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

                        <span class="c"># if no Functions left, we can proceed with usual solve</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">ftry</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
                            <span class="n">cv_sols</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ftry</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                            <span class="n">cv_inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">f1</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">sols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">cv_sols</span><span class="p">:</span>
                                <span class="n">sols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv_inv</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span>
                            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">sols</span><span class="p">))</span>

                    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;multiple generators </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">gens</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c"># len(bases) == 1 and all(q == 1 for q in qs):</span>
                    <span class="c"># e.g. case where gens are exp(x), exp(-x)</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
                    <span class="n">inv</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">Pow</span><span class="p">,</span> <span class="n">exp</span><span class="p">)):</span>
                        <span class="c"># this will be resolved by factor in _tsolve but we might</span>
                        <span class="c"># as well try a simple expansion here to get things in</span>
                        <span class="c"># order so something like the following will work now without</span>
                        <span class="c"># having to factor:</span>
                        <span class="c"># &gt;&gt;&gt; eq = (exp(I*(-x-2))+exp(I*(x+2)))</span>
                        <span class="c"># &gt;&gt;&gt; eq.subs(exp(x),y)  # fails</span>
                        <span class="c"># exp(I*(-x - 2)) + exp(I*(x + 2))</span>
                        <span class="c"># &gt;&gt;&gt; eq.expand().subs(exp(x),y)  # works</span>
                        <span class="c"># y**I*exp(2*I) + y**(-I)*exp(-2*I)</span>
                        <span class="k">def</span> <span class="nf">_expand</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                            <span class="n">e</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                            <span class="k">return</span> <span class="n">expand_power_exp</span><span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
                        <span class="n">ftry</span> <span class="o">=</span> <span class="n">f_num</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                            <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">exp</span><span class="p">),</span>
                            <span class="n">_expand</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">ftry</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">symbol</span><span class="p">):</span>
                            <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">ftry</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                            <span class="n">sols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
                                    <span class="n">sols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sol</span><span class="p">))</span>
                            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">sols</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

                <span class="c"># There is only one generator that we are interested in, but there</span>
                <span class="c"># may have been more than one generator identified by polys (e.g.</span>
                <span class="c"># for symbols other than the one we are interested in) so recast</span>
                <span class="c"># the poly in terms of our generator of interest.</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c"># if we aren&#39;t on the tsolve-pass, use roots</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;tsolve&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                    <span class="n">flags</span><span class="p">[</span><span class="s">&#39;tsolve&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">poly</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span>
                            <span class="n">poly</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span>
                            <span class="ow">not</span> <span class="n">poly</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">):</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># for cubics and quartics, if the flag wasn&#39;t set, DON&#39;T do it</span>
                        <span class="c"># by default since the results are quite long. Perhaps one</span>
                        <span class="c"># could base this decision on a certain critical length of the</span>
                        <span class="c"># roots.</span>
                        <span class="n">deg</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">deg</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">flags</span><span class="p">[</span><span class="s">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

                        <span class="c"># TODO: Just pass composite=True to roots()</span>
                        <span class="n">poly</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">as_expr</span><span class="p">(),</span> <span class="n">poly</span><span class="o">.</span><span class="n">gen</span><span class="p">,</span> <span class="n">composite</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                        <span class="n">soln</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">roots</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">cubics</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">quartics</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                                             <span class="n">quintics</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">deg</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="c"># get all_roots if possible</span>
                                <span class="n">soln</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">all_roots</span><span class="p">())))</span>
                            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                                <span class="k">pass</span>
                        <span class="n">gen</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">gen</span>
                        <span class="k">if</span> <span class="n">gen</span> <span class="o">!=</span> <span class="n">symbol</span><span class="p">:</span>
                            <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
                            <span class="n">inversion</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">gen</span> <span class="o">-</span> <span class="n">u</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                            <span class="n">soln</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                        <span class="n">inversion</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">])))</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">soln</span>


    <span class="c"># fallback if above fails</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>

        <span class="c"># allow tsolve to be used on next pass if needed</span>
        <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;tsolve&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">PolynomialError</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span>
        <span class="s">&quot;</span><span class="se">\n</span><span class="s">No algorithms are implemented to solve equation </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">simplify</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
        <span class="c"># we just simplified the solution so we now set the flag to</span>
        <span class="c"># False so the simplification doesn&#39;t happen again in checksol()</span>
        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
        <span class="c"># reject any result that makes any denom. affirmatively 0;</span>
        <span class="c"># if in doubt, keep it</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">)</span> <span class="ow">or</span>
                  <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="n">checksol</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">s</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">den</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">)]</span>
        <span class="c"># keep only results if the check is not False</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">RootOf</span><span class="p">)</span> <span class="ow">or</span>
                  <span class="n">checksol</span><span class="p">(</span><span class="n">f_num</span><span class="p">,</span> <span class="p">{</span><span class="n">symbol</span><span class="p">:</span> <span class="n">r</span><span class="p">},</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">False</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_solve_system</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="n">check</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;check&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exprs</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">manual</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;manual&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exprs</span><span class="p">):</span>
        <span class="n">dens</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">denoms</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">symbols</span><span class="p">))</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">i</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">exprs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">manual</span><span class="p">:</span>
            <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="n">poly</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">poly</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">polys</span><span class="p">:</span>
        <span class="n">solved_syms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">is_linear</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">):</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">terms</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">monom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>

            <span class="c"># returns a dictionary ({symbols: values}) or None</span>
            <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;minimal&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">minsolve_linear_system</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                <span class="c"># it doesn&#39;t need to be checked but we need to see</span>
                <span class="c"># that it didn&#39;t set any denominators to 0</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">subsets</span>

                <span class="n">free</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">])</span>
                <span class="n">free</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">free</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
                <span class="n">free</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
                <span class="n">got_s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">syms</span> <span class="ow">in</span> <span class="n">subsets</span><span class="p">(</span><span class="n">free</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c"># returns [] or list of tuples of solutions for syms</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">solve_poly_system</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                                <span class="n">skip</span> <span class="o">=</span> <span class="bp">False</span>
                                <span class="k">for</span> <span class="n">r1</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">r1</span><span class="o">.</span><span class="n">free_symbols</span>
                                           <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">]):</span>
                                        <span class="c"># sol depends on previously</span>
                                        <span class="c"># solved symbols: discard it</span>
                                        <span class="n">skip</span> <span class="o">=</span> <span class="bp">True</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">skip</span><span class="p">:</span>
                                    <span class="n">got_s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>
                                    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">r</span><span class="p">)))])</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">if</span> <span class="n">got_s</span><span class="p">:</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">got_s</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;no valid subset found&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">solve_poly_system</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="n">symbols</span>
                <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                    <span class="n">failed</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">g</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">])</span>
                    <span class="n">solved_syms</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
                    <span class="c"># we don&#39;t know here if the symbols provided were given</span>
                    <span class="c"># or not, so let solve resolve that. A list of dictionaries</span>
                    <span class="c"># is going to always be returned from here.</span>
                    <span class="c">#</span>
                    <span class="c"># We do not check the solution obtained from polys, either.</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">solved_syms</span><span class="p">,</span> <span class="n">r</span><span class="p">)))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
        <span class="c"># For each failed equation, see if we can solve for one of the</span>
        <span class="c"># remaining symbols from that equation. If so, we update the</span>
        <span class="c"># solution set and continue with the next failed equation,</span>
        <span class="c"># repeating until we are done or we get an equation that can&#39;t</span>
        <span class="c"># be solved.</span>
        <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[{}]</span>

        <span class="k">def</span> <span class="nf">_ok_syms</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">-</span> <span class="n">solved_syms</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">legal</span>
            <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
                <span class="n">rv</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rv</span>

        <span class="n">solved_syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">solved_syms</span><span class="p">)</span>  <span class="c"># set of symbols we have solved for</span>
        <span class="n">legal</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>  <span class="c"># what we are interested in</span>
        <span class="n">simplify_flag</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">do_simplify</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="c"># sort so equation with the fewest potential symbols is first</span>
        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">ordered</span><span class="p">(</span><span class="n">failed</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">_ok_syms</span><span class="p">(</span><span class="n">_</span><span class="p">))):</span>
            <span class="n">newresult</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bad_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">got_s</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="c"># update eq with everything that is known so far</span>
                <span class="n">eq2</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="c"># if check is True then we see if it satisfies this</span>
                <span class="c"># equation, otherwise we just accept it</span>
                <span class="k">if</span> <span class="n">check</span> <span class="ow">and</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">checksol</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">eq2</span><span class="p">,</span> <span class="n">minimal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="c"># this solution is sufficient to know whether</span>
                        <span class="c"># it is valid or not so we either accept or</span>
                        <span class="c"># reject it, then continue</span>
                        <span class="k">if</span> <span class="n">b</span><span class="p">:</span>
                            <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bad_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="c"># search for a symbol amongst those available that</span>
                <span class="c"># can be solved for</span>
                <span class="n">ok_syms</span> <span class="o">=</span> <span class="n">_ok_syms</span><span class="p">(</span><span class="n">eq2</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ok_syms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                    <span class="k">break</span>  <span class="c"># skip as it&#39;s independent of desired symbols</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ok_syms</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">eq2</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c"># put each solution in r and append the now-expanded</span>
                    <span class="c"># result in the new result list; use copy since the</span>
                    <span class="c"># solution for s in being added in-place</span>
                    <span class="k">if</span> <span class="n">do_simplify</span><span class="p">:</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># for checksol&#39;s sake</span>
                    <span class="k">for</span> <span class="n">sol</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">got_s</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">([</span><span class="n">ss</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">free_symbols</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">got_s</span><span class="p">]):</span>
                            <span class="c"># sol depends on previously solved symbols: discard it</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
                            <span class="c"># check that it satisfies *other* equations</span>
                            <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">checksol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                                    <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="c"># check that it doesn&#39;t set any denominator to 0</span>
                            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">):</span>
                                <span class="k">continue</span>
                        <span class="c"># update existing solutions with this new one</span>
                        <span class="n">rnew</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="n">rnew</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sol</span><span class="p">)</span>
                        <span class="c"># and add this new solution</span>
                        <span class="n">rnew</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span>
                        <span class="n">newresult</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rnew</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">simplify_flag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;simplify&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">simplify_flag</span>
                    <span class="n">got_s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">got_s</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;could not solve </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">eq2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">got_s</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">newresult</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bad_results</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c"># if there is only one result should we return just the dictionary?</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="solve_linear"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear">[docs]</a><span class="k">def</span> <span class="nf">solve_linear</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[],</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[]):</span>
    <span class="sd">r&quot;&quot;&quot; Return a tuple derived from f = lhs - rhs that is either:</span>

<span class="sd">        (numerator, denominator) of ``f``</span>
<span class="sd">            If this comes back as (0, 1) it means</span>
<span class="sd">            that ``f`` is independent of the symbols in ``symbols``, e.g::</span>

<span class="sd">                y*cos(x)**2 + y*sin(x)**2 - y = y*(0) = 0</span>
<span class="sd">                cos(x)**2 + sin(x)**2 = 1</span>

<span class="sd">            If it comes back as (0, 0) there is no solution to the equation</span>
<span class="sd">            amongst the symbols given.</span>

<span class="sd">            If the numerator is not zero then the function is guaranteed</span>
<span class="sd">            to be dependent on a symbol in ``symbols``.</span>

<span class="sd">        or</span>

<span class="sd">        (symbol, solution) where symbol appears linearly in the numerator of</span>
<span class="sd">        ``f``, is in ``symbols`` (if given) and is not in ``exclude`` (if given).</span>

<span class="sd">        No simplification is done to ``f`` other than and mul=True expansion,</span>
<span class="sd">        so the solution will correspond strictly to a unique solution.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import solve_linear</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">    These are linear in x and 1/x:</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x + y**2)</span>
<span class="sd">    (x, -y**2)</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(1/x - y**2)</span>
<span class="sd">    (x, y**(-2))</span>

<span class="sd">    When not linear in x or y then the numerator and denominator are returned.</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x**2/y**2 - 3)</span>
<span class="sd">    (x**2 - 3*y**2, y**2)</span>

<span class="sd">    If the numerator is a symbol then (0, 0) is returned if the solution for</span>
<span class="sd">    that symbol would have set any denominator to 0:</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(1/(1/x - 2))</span>
<span class="sd">    (0, 0)</span>
<span class="sd">    &gt;&gt;&gt; 1/(1/x) # to SymPy, this looks like x ...</span>
<span class="sd">    x</span>
<span class="sd">    &gt;&gt;&gt; solve_linear(1/(1/x)) # so a solution is given</span>
<span class="sd">    (x, 0)</span>

<span class="sd">    If x is allowed to cancel, then this appears linear, but this sort of</span>
<span class="sd">    cancellation is not done so the solution will always satisfy the original</span>
<span class="sd">    expression without causing a division by zero error.</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x**2*(1/x - z**2/x))</span>
<span class="sd">    (x**2*(-z**2 + 1), x)</span>

<span class="sd">    You can give a list of what you prefer for x candidates:</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x + y + z, symbols=[y])</span>
<span class="sd">    (y, -x - z)</span>

<span class="sd">    You can also indicate what variables you don&#39;t want to consider:</span>

<span class="sd">    &gt;&gt;&gt; solve_linear(x + y + z, exclude=[x, z])</span>
<span class="sd">    (y, -x - z)</span>

<span class="sd">    If only x was excluded then a solution for y or z might be obtained.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Equality</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">            If lhs is an Equality, rhs must be 0 but was </span><span class="si">%s</span><span class="s">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">rhs</span><span class="p">))</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">rhs</span>
        <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">lhs</span>
    <span class="n">dens</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="n">free</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">free_symbols</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">free</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bad</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bad</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bad</span> <span class="o">=</span> <span class="n">bad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">eg</span> <span class="o">=</span> <span class="s">&#39;solve(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eg</span> <span class="o">=</span> <span class="s">&#39;solve(</span><span class="si">%s</span><span class="s">, *</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">                solve_linear only handles symbols, not </span><span class="si">%s</span><span class="s">. To isolate</span>
<span class="s">                non-symbols use solve, e.g. &gt;&gt;&gt; </span><span class="si">%s</span><span class="s"> &lt;&lt;&lt;.</span>
<span class="s">                             &#39;&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bad</span><span class="p">,</span> <span class="n">eg</span><span class="p">)))</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">free</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
    <span class="n">dfree</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span>

    <span class="c"># derivatives are easy to do but tricky to analyze to see if they are going</span>
    <span class="c"># to disallow a linear solution, so for simplicity we just evaluate the</span>
    <span class="c"># ones that have the symbols of interest</span>
    <span class="n">derivs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">der</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Derivative</span><span class="p">):</span>
        <span class="n">csym</span> <span class="o">=</span> <span class="n">der</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="n">symbols</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">csym</span><span class="p">:</span>
            <span class="n">derivs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">der</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">all_zero</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="c"># if there are derivatives in this var, calculate them now</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">derivs</span><span class="p">[</span><span class="n">xi</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="n">derivs</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">der</span><span class="p">,</span> <span class="n">der</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span> <span class="k">for</span> <span class="n">der</span> <span class="ow">in</span> <span class="n">derivs</span><span class="p">[</span><span class="n">xi</span><span class="p">]])</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">derivs</span><span class="p">[</span><span class="n">xi</span><span class="p">])</span>
            <span class="n">dn</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dn</span><span class="p">:</span>
                <span class="n">all_zero</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">dn</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="n">vi</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="n">dn</span>
                    <span class="k">if</span> <span class="n">dens</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">dens</span> <span class="o">=</span> <span class="n">denoms</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">checksol</span><span class="p">(</span><span class="n">di</span><span class="p">,</span> <span class="p">{</span><span class="n">xi</span><span class="p">:</span> <span class="n">vi</span><span class="p">},</span> <span class="n">minimal</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">True</span>
                              <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">dens</span><span class="p">):</span>
                        <span class="c"># simplify any trivial integral</span>
                        <span class="n">irep</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">doit</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">)</span> <span class="k">if</span>
                                <span class="n">i</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">is_number</span><span class="p">]</span>
                        <span class="c"># do a slight bit of simplification</span>
                        <span class="n">vi</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">vi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">irep</span><span class="p">))</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">xi</span><span class="p">):</span>
                            <span class="k">return</span> <span class="n">xi</span><span class="p">,</span> <span class="n">vi</span>

        <span class="k">if</span> <span class="n">all_zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>  <span class="c"># there was no valid solution</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">d</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span>  <span class="c"># should we cancel now?</span>

</div>
<span class="k">def</span> <span class="nf">minsolve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Find a particular solution to a linear system.</span>

<span class="sd">    In particular, try to find a solution with the minimal possible number</span>
<span class="sd">    of non-zero variables. This is a very computationally hard prolem.</span>
<span class="sd">    If ``quick=True``, a heuristic is used. Otherwise a naive algorithm with</span>
<span class="sd">    exponential complexity is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quick</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;quick&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="c"># Check if there are any non-zero solutions at all</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s0</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s0</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">s0</span>
    <span class="k">if</span> <span class="n">quick</span><span class="p">:</span>
        <span class="c"># We just solve the system and try to heuristically find a nice</span>
        <span class="c"># solution.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">solution</span><span class="p">):</span>
            <span class="n">delete</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">solution</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">determined</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="n">delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">delete</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">solution</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">determined</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
            <span class="c"># NOTE sort by default_sort_key to get deterministic result</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">),</span> <span class="n">default_sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">determined</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">update</span><span class="p">(</span><span class="n">determined</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">determined</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># We try to select n variables which we want to be non-zero.</span>
        <span class="c"># All others will be assumed zero. We try to solve the modified system.</span>
        <span class="c"># If there is a non-trivial solution, just set the free variables to</span>
        <span class="c"># one. If we do this for increasing n, trying all combinations of</span>
        <span class="c"># variables, we will find an optimal solution.</span>
        <span class="c"># We speed up slightly by starting at one less than the number of</span>
        <span class="c"># variables the quick method manages.</span>
        <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.misc</span> <span class="kn">import</span> <span class="n">debug</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">bestsol</span> <span class="o">=</span> <span class="n">minsolve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="n">quick</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bestsol</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">debug</span><span class="p">(</span><span class="s">&#39;minsolve: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">thissol</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">nonzeros</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)),</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">subm</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="n">system</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">system</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">solve_linear_system</span><span class="p">(</span><span class="n">subm</span><span class="p">,</span> <span class="o">*</span><span class="p">[</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">subs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">symbols</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">symbols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nonzeros</span><span class="p">:</span>
                                <span class="n">s</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">s</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">thissol</span> <span class="o">=</span> <span class="n">s</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">thissol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">bestsol</span> <span class="o">=</span> <span class="n">thissol</span>
        <span class="k">return</span> <span class="n">bestsol</span>


<div class="viewcode-block" id="solve_linear_system"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear_system">[docs]</a><span class="k">def</span> <span class="nf">solve_linear_system</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solve system of N linear equations with M variables, which means</span>
<span class="sd">    both under- and overdetermined systems are supported. The possible</span>
<span class="sd">    number of solutions is zero, one or infinite. Respectively, this</span>
<span class="sd">    procedure will return None or a dictionary with solutions. In the</span>
<span class="sd">    case of underdetermined systems, all arbitrary parameters are skipped.</span>
<span class="sd">    This may cause a situation in which an empty dictionary is returned.</span>
<span class="sd">    In that case, all symbols can be assigned arbitrary values.</span>

<span class="sd">    Input to this functions is a Nx(M+1) matrix, which means it has</span>
<span class="sd">    to be in augmented form. If you prefer to enter N equations and M</span>
<span class="sd">    unknowns then use `solve(Neqs, *Msymbols)` instead. Note: a local</span>
<span class="sd">    copy of the matrix is made by this routine so the matrix that is</span>
<span class="sd">    passed will not be modified.</span>

<span class="sd">    The algorithm used here is fraction-free Gaussian elimination,</span>
<span class="sd">    which results, after elimination, in an upper-triangular matrix.</span>
<span class="sd">    Then solutions are found using back-substitution. This approach</span>
<span class="sd">    is more efficient and compact than the Gauss-Jordan method.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix, solve_linear_system</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">    Solve the following system::</span>

<span class="sd">           x + 4 y ==  2</span>
<span class="sd">        -2 x +   y == 14</span>

<span class="sd">    &gt;&gt;&gt; system = Matrix(( (1, 4, 2), (-2, 1, 14)))</span>
<span class="sd">    &gt;&gt;&gt; solve_linear_system(system, x, y)</span>
<span class="sd">    {x: -6, y: 2}</span>

<span class="sd">    A degenerate system returns an empty dictionary.</span>

<span class="sd">    &gt;&gt;&gt; system = Matrix(( (0,0,0), (0,0,0) ))</span>
<span class="sd">    &gt;&gt;&gt; solve_linear_system(system, x, y)</span>
<span class="sd">    {}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix</span> <span class="o">=</span> <span class="n">system</span><span class="p">[:,</span> <span class="p">:]</span>
    <span class="n">syms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>

    <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># don&#39;t count augmentation</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
            <span class="c"># an overdetermined system</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="n">m</span><span class="p">]):</span>
                <span class="k">return</span> <span class="bp">None</span>   <span class="c"># no solutions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># remove trailing rows</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
            <span class="c"># there is no pivot in current column</span>
            <span class="c"># so try to find one in other columns</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">]:</span>
                    <span class="c"># we need to know if this is always zero or not. We</span>
                    <span class="c"># assume that if there are free symbols that it is not</span>
                    <span class="c"># identically zero (or that there is more than one way</span>
                    <span class="c"># to make this zero. Otherwise, if there are none, this</span>
                    <span class="c"># is a constant and we assume that it does not simplify</span>
                    <span class="c"># to zero XXX are there better ways to test this?</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">None</span>  <span class="c"># no solution</span>

                    <span class="c"># zero row with non-zero rhs can only be accepted</span>
                    <span class="c"># if there is another equivalent row, so look for</span>
                    <span class="c"># them and delete them</span>
                    <span class="n">nrows</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span>
                    <span class="n">rowi</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ip</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                        <span class="c"># do we need to see if the rhs of j</span>
                        <span class="c"># is a constant multiple of i&#39;s rhs?</span>
                        <span class="n">rowj</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">row</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">rowj</span> <span class="o">==</span> <span class="n">rowi</span><span class="p">:</span>
                            <span class="n">matrix</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">rowj</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">rowi</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">ip</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="n">_</span><span class="p">,</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">rowi</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
                            <span class="n">_</span><span class="p">,</span> <span class="n">jp</span> <span class="o">=</span> <span class="n">rowj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">jp</span> <span class="o">-</span> <span class="n">ip</span><span class="p">)</span> <span class="ow">or</span> <span class="n">simplify</span><span class="p">(</span><span class="n">jp</span> <span class="o">+</span> <span class="n">ip</span><span class="p">)):</span>
                                <span class="n">matrix</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="k">if</span> <span class="n">nrows</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
                        <span class="c"># no solution</span>
                        <span class="k">return</span> <span class="bp">None</span>
                <span class="c"># zero row or was a linear combination of</span>
                <span class="c"># other rows or was a row with a symbolic</span>
                <span class="c"># expression that matched other rows, e.g. [0, 0, x - y]</span>
                <span class="c"># so now we can safely skip it</span>
                <span class="n">matrix</span><span class="o">.</span><span class="n">row_del</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">:</span>
                    <span class="c"># every choice of variable values is a solution</span>
                    <span class="c"># so we return an empty dict instead of None</span>
                    <span class="k">return</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="c"># we want to change the order of colums so</span>
            <span class="c"># the order of variables must also change</span>
            <span class="n">syms</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">syms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">matrix</span><span class="o">.</span><span class="n">col_swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">pivot_inv</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="o">/</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="c"># divide all elements in the current row by the pivot</span>
        <span class="n">matrix</span><span class="o">.</span><span class="n">row_op</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pivot_inv</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

                <span class="c"># subtract from the current row the row containing</span>
                <span class="c"># pivot and multiplied by extracted coefficient</span>
                <span class="n">matrix</span><span class="o">.</span><span class="n">row_op</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">simplify</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">coeff</span><span class="p">))</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c"># if there weren&#39;t any problems, augmented matrix is now</span>
    <span class="c"># in row-echelon form so we can check how many solutions</span>
    <span class="c"># there are and extract them using back substitution</span>

    <span class="n">do_simplify</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;simplify&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
        <span class="c"># this system is Cramer equivalent so there is</span>
        <span class="c"># exactly one solution to this system of equations</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">solutions</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{}</span>

        <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>

            <span class="c"># run back-substitution for variables</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="n">content</span> <span class="o">-=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">do_simplify</span><span class="p">:</span>
                <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">content</span>

            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">solutions</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">:</span>
        <span class="c"># this system will have infinite number of solutions</span>
        <span class="c"># dependent on exactly len(syms) - i parameters</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">solutions</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{}</span>

        <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>

            <span class="c"># run back-substitution for variables</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">content</span> <span class="o">-=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>

            <span class="c"># run back-substitution for parameters</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
                <span class="n">content</span> <span class="o">-=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">syms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">do_simplify</span><span class="p">:</span>
                <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">simplify</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="n">content</span>

            <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">solutions</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>   <span class="c"># no solutions</span>

</div>
<div class="viewcode-block" id="solve_undetermined_coeffs"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve_undetermined_coeffs">[docs]</a><span class="k">def</span> <span class="nf">solve_undetermined_coeffs</span><span class="p">(</span><span class="n">equ</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Solve equation of a type p(x; a_1, ..., a_k) == q(x) where both</span>
<span class="sd">       p, q are univariate polynomials and f depends on k parameters.</span>
<span class="sd">       The result of this functions is a dictionary with symbolic</span>
<span class="sd">       values of those parameters with respect to coefficients in q.</span>

<span class="sd">       This functions accepts both Equations class instances and ordinary</span>
<span class="sd">       SymPy expressions. Specification of parameters and variable is</span>
<span class="sd">       obligatory for efficiency and simplicity reason.</span>

<span class="sd">       &gt;&gt;&gt; from sympy import Eq</span>
<span class="sd">       &gt;&gt;&gt; from sympy.abc import a, b, c, x</span>
<span class="sd">       &gt;&gt;&gt; from sympy.solvers import solve_undetermined_coeffs</span>

<span class="sd">       &gt;&gt;&gt; solve_undetermined_coeffs(Eq(2*a*x + a+b, x), [a, b], x)</span>
<span class="sd">       {a: 1/2, b: -1/2}</span>

<span class="sd">       &gt;&gt;&gt; solve_undetermined_coeffs(Eq(a*c*x + a+b, x), [a, b], x)</span>
<span class="sd">       {a: 1/c, b: -1/c}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">equ</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="c"># got equation, so move all the</span>
        <span class="c"># terms to the left hand side</span>
        <span class="n">equ</span> <span class="o">=</span> <span class="n">equ</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">equ</span><span class="o">.</span><span class="n">rhs</span>

    <span class="n">equ</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">equ</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">system</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="n">equ</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">sym</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">equ</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">equ</span> <span class="ow">in</span> <span class="n">system</span><span class="p">):</span>
        <span class="c"># consecutive powers in the input expressions have</span>
        <span class="c"># been successfully collected, so solve remaining</span>
        <span class="c"># system using Gaussian elimination algorithm</span>
        <span class="k">return</span> <span class="n">solve</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="o">*</span><span class="n">coeffs</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>  <span class="c"># no solutions</span>

</div>
<div class="viewcode-block" id="solve_linear_system_LU"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.solve_linear_system_LU">[docs]</a><span class="k">def</span> <span class="nf">solve_linear_system_LU</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the augmented matrix system using LUsolve and returns a dictionary</span>
<span class="sd">    in which solutions are keyed to the symbols of syms *as ordered*.</span>

<span class="sd">    The matrix must be invertible.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import solve_linear_system_LU</span>

<span class="sd">    &gt;&gt;&gt; solve_linear_system_LU(Matrix([</span>
<span class="sd">    ... [1, 2, 0, 1],</span>
<span class="sd">    ... [3, 2, 2, 1],</span>
<span class="sd">    ... [2, 0, 0, 1]]), [x, y, z])</span>
<span class="sd">    {x: 1/2, y: 1/4, z: -1/2}</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.matrices.LUsolve</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">matrix</span><span class="o">.</span><span class="n">rows</span> <span class="o">==</span> <span class="n">matrix</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:</span><span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="p">:</span><span class="n">matrix</span><span class="o">.</span><span class="n">rows</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">soln</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">LUsolve</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">solutions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">soln</span><span class="o">.</span><span class="n">rows</span><span class="p">):</span>
        <span class="n">solutions</span><span class="p">[</span><span class="n">syms</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">soln</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">solutions</span>
</div>
<div class="viewcode-block" id="tsolve"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.tsolve">[docs]</a><span class="k">def</span> <span class="nf">tsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">):</span>
    <span class="n">SymPyDeprecationWarning</span><span class="p">(</span>
        <span class="n">feature</span><span class="o">=</span><span class="s">&quot;tsolve()&quot;</span><span class="p">,</span>
        <span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;solve()&quot;</span><span class="p">,</span>
        <span class="n">issue</span><span class="o">=</span><span class="mi">3385</span><span class="p">,</span>
        <span class="n">deprecated_since_version</span><span class="o">=</span><span class="s">&quot;0.7.2&quot;</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>


<span class="c"># these are functions that have multiple inverse values per period</span></div>
<span class="n">multi_inverses</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">sin</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">asin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Pi</span> <span class="o">-</span> <span class="n">asin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
    <span class="n">cos</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span> <span class="o">-</span> <span class="n">acos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_tsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper for _solve that solves a transcendental equation with respect</span>
<span class="sd">    to the given symbol. Various equations containing powers and logarithms,</span>
<span class="sd">    can be solved.</span>

<span class="sd">    There is currently no guarantee that all solutions will be returned or</span>
<span class="sd">    that a real solution will be favored over a complex one.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import _tsolve as tsolve</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">    &gt;&gt;&gt; tsolve(3**(2*x + 5) - 4, x)</span>
<span class="sd">    [-5/2 + log(2)/log(3), log(-2*sqrt(3)/27)/log(3)]</span>

<span class="sd">    &gt;&gt;&gt; tsolve(log(x) + 2*x, x)</span>
<span class="sd">    [LambertW(2)/2]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s">&#39;tsolve_saw&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">:</span>
        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;tsolve_saw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">[</span><span class="s">&#39;tsolve_saw&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;tsolve_saw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">rhs</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="c"># it&#39;s time to try factoring; powdenest is used</span>
            <span class="c"># to try get powers in standard form for better factoring</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rhs</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">log</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">log</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span> <span class="o">!=</span> <span class="n">eq</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span> <span class="o">-</span> <span class="n">rhs</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                <span class="c"># f(x)**g(x) only has solutions where f(x) == 0 and g(x) != 0 at</span>
                <span class="c"># the same place</span>
                <span class="n">sol_base</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sol_base</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sol_base</span>  <span class="c"># no solutions to remove so return now</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sol_base</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">rhs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span> <span class="ow">and</span>
                        <span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span>
                        <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_real</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="p">)</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="n">rhs</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
            <span class="n">llhs</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">llhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">llhs</span> <span class="o">-</span> <span class="n">log</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">nargs</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">func</span> <span class="ow">in</span> <span class="n">multi_inverses</span><span class="p">:</span>
            <span class="c"># sin(x) = 1/3 -&gt; x - asin(1/3) &amp; x - (pi - asin(1/3))</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multi_inverses</span><span class="p">[</span><span class="n">lhs</span><span class="o">.</span><span class="n">func</span><span class="p">](</span><span class="n">rhs</span><span class="p">):</span>
                <span class="n">soln</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_solve</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">soln</span><span class="p">))</span>

        <span class="n">rewrite</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rewrite</span> <span class="o">!=</span> <span class="n">lhs</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_solve</span><span class="p">(</span><span class="n">rewrite</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c"># maybe it is a lambert pattern</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;bivariate&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="c"># lambert forms may need some help being recognized, e.g. changing</span>
        <span class="c"># 2**(3*x) + x**3*log(2)**3 + 3*x**2*log(2)**2 + 3*x*log(2) + 1</span>
        <span class="c"># to 2**(3*x) + (x*log(2) + 1)**3</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">_filtered_gens</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">as_poly</span><span class="p">(),</span> <span class="n">sym</span><span class="p">)</span>
        <span class="n">up_or_log</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gi</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gi</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span> <span class="ow">or</span> <span class="n">gi</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>
                <span class="n">up_or_log</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">gi</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="n">gisimp</span> <span class="o">=</span> <span class="n">powdenest</span><span class="p">(</span><span class="n">expand_power_exp</span><span class="p">(</span><span class="n">gi</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">gisimp</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">gisimp</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
                    <span class="n">up_or_log</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gi</span><span class="p">)</span>
        <span class="n">down</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">up_or_log</span><span class="p">)</span>
        <span class="n">eq_down</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">expand_power_exp</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">up_or_log</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">up_or_log</span><span class="p">)))))</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">expand_power_exp</span><span class="p">(</span><span class="n">factor</span><span class="p">(</span><span class="n">eq_down</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eq</span> <span class="o">-</span> <span class="n">eq_down</span><span class="p">))</span>
        <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">as_poly</span><span class="p">()</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">_filtered_gens</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_solve_lambert</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="c"># maybe it&#39;s a convoluted function</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">gpu</span> <span class="o">=</span> <span class="n">bivariate_type</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">gpu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                        <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">gpu</span>
                        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;bivariate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">inversion</span> <span class="o">=</span> <span class="n">_tsolve</span><span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="n">u</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">inversion</span><span class="p">:</span>
                            <span class="n">sol</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inversion</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="p">]))</span>
                    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">flags</span><span class="p">[</span><span class="s">&#39;force&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">sym</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">_solve</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">soln</span><span class="p">]))</span>


<span class="c"># TODO: option for calculating J numerically</span>


<div class="viewcode-block" id="nsolve"><a class="viewcode-back" href="../../../modules/solvers/solvers.html#sympy.solvers.solvers.nsolve">[docs]</a><span class="k">def</span> <span class="nf">nsolve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Solve a nonlinear equation system numerically::</span>

<span class="sd">        nsolve(f, [args,] x0, modules=[&#39;mpmath&#39;], **kwargs)</span>

<span class="sd">    f is a vector function of symbolic expressions representing the system.</span>
<span class="sd">    args are the variables. If there is only one variable, this argument can</span>
<span class="sd">    be omitted.</span>
<span class="sd">    x0 is a starting vector close to a solution.</span>

<span class="sd">    Use the modules keyword to specify which modules should be used to</span>
<span class="sd">    evaluate the function and the Jacobian matrix. Make sure to use a module</span>
<span class="sd">    that supports matrices. For more information on the syntax, please see the</span>
<span class="sd">    docstring of lambdify.</span>

<span class="sd">    Overdetermined systems are supported.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, nsolve</span>
<span class="sd">    &gt;&gt;&gt; import sympy</span>
<span class="sd">    &gt;&gt;&gt; sympy.mpmath.mp.dps = 15</span>
<span class="sd">    &gt;&gt;&gt; x1 = Symbol(&#39;x1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x2 = Symbol(&#39;x2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f1 = 3 * x1**2 - 2 * x2**2 - 1</span>
<span class="sd">    &gt;&gt;&gt; f2 = x1**2 - 2 * x1 + x2**2 + 2 * x2 - 8</span>
<span class="sd">    &gt;&gt;&gt; print(nsolve((f1, f2), (x1, x2), (-1, 1)))</span>
<span class="sd">    [-1.19287309935246]</span>
<span class="sd">    [ 1.27844411169911]</span>

<span class="sd">    For one-dimensional functions the syntax is simplified:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sin, nsolve</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; nsolve(sin(x), x, 2)</span>
<span class="sd">    3.14159265358979</span>
<span class="sd">    &gt;&gt;&gt; nsolve(sin(x), 2)</span>
<span class="sd">    3.14159265358979</span>

<span class="sd">    mpmath.findroot is used, you can find there more extensive documentation,</span>
<span class="sd">    especially concerning keyword parameters and available solvers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># interpret arguments</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fargs</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;nsolve expected at least 2 arguments, got </span><span class="si">%i</span><span class="s">&#39;</span>
                        <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;nsolve expected at most 3 arguments, got </span><span class="si">%i</span><span class="s">&#39;</span>
                        <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
    <span class="n">modules</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;modules&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;mpmath&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
        <span class="c"># assume it&#39;s a sympy expression</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">rhs</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="n">fargs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fargs</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fargs</span> <span class="ow">in</span> <span class="n">syms</span> <span class="ow">or</span> <span class="n">fargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">                expected a one-dimensional and numerical function&#39;&#39;&#39;</span><span class="p">))</span>

        <span class="c"># the function is much better behaved if there is no denominator</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">fargs</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">modules</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">findroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">filldedent</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">            need at least as many equations as variables&#39;&#39;&#39;</span><span class="p">))</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;verbose&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;f(x):&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="c"># derive Jacobian</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">fargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;J(x):&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="c"># create functions</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">fargs</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">modules</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">(</span><span class="n">fargs</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">modules</span><span class="p">)</span>
    <span class="c"># solve the system numerically</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">findroot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

</div>
<span class="k">def</span> <span class="nf">_invert</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return tuple (i, d) where ``i`` is independent of ``symbols`` and ``d``</span>
<span class="sd">    contains symbols. ``i`` and ``d`` are obtained after recursively using</span>
<span class="sd">    algebraic inversion until an uninvertible ``d`` remains. If there are no</span>
<span class="sd">    free symbols then ``d`` will be zero. Some (but not necessarily all)</span>
<span class="sd">    solutions to the expression ``i - d`` will be related to the solutions of</span>
<span class="sd">    the original expression.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.solvers.solvers import _invert as invert</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt, cos</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; invert(x - 3)</span>
<span class="sd">    (3, x)</span>
<span class="sd">    &gt;&gt;&gt; invert(3)</span>
<span class="sd">    (3, 0)</span>
<span class="sd">    &gt;&gt;&gt; invert(2*cos(x) - 1)</span>
<span class="sd">    (1/2, cos(x))</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x) - 3)</span>
<span class="sd">    (3, sqrt(x))</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x) + y, x)</span>
<span class="sd">    (-y, sqrt(x))</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x) + y, y)</span>
<span class="sd">    (-sqrt(x), y)</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x) + y, x, y)</span>
<span class="sd">    (0, sqrt(x) + y)</span>

<span class="sd">    If there is more than one symbol in a power&#39;s base and the exponent</span>
<span class="sd">    is not an Integer, then the principal root will be used for the</span>
<span class="sd">    inversion:</span>

<span class="sd">    &gt;&gt;&gt; invert(sqrt(x + y) - 2)</span>
<span class="sd">    (4, x + y)</span>
<span class="sd">    &gt;&gt;&gt; invert(sqrt(x + y) - 2)</span>
<span class="sd">    (4, x + y)</span>

<span class="sd">    If the exponent is an integer, setting ``integer_power`` to True</span>
<span class="sd">    will force the principal root to be selected:</span>

<span class="sd">    &gt;&gt;&gt; invert(x**2 - 4, integer_power=True)</span>
<span class="sd">    (2, x)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">free</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">free</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">free</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="n">dointpow</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;integer_power&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

    <span class="n">lhs</span> <span class="o">=</span> <span class="n">eq</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">was</span> <span class="o">=</span> <span class="n">lhs</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">indep</span><span class="p">,</span> <span class="n">dep</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>

            <span class="c"># dep + indep == rhs</span>
            <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c"># this indicates we have done it all</span>
                <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">lhs</span> <span class="o">=</span> <span class="n">dep</span>
                <span class="n">rhs</span> <span class="o">-=</span> <span class="n">indep</span>

            <span class="c"># dep * indep == rhs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># this indicates we have done it all</span>
                <span class="k">if</span> <span class="n">indep</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">lhs</span> <span class="o">=</span> <span class="n">dep</span>
                <span class="n">rhs</span> <span class="o">/=</span> <span class="n">indep</span>

        <span class="c"># collect like-terms in symbols</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
                <span class="n">terms</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">)</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c"># if it&#39;s a two-term Add with rhs = 0 and two powers we can get the</span>
        <span class="c"># dependent terms together, e.g. 3*f(x) + 2*g(x) -&gt; f(x)/g(x) = -2/3</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_polynomial</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ordered</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="n">ai</span><span class="p">,</span> <span class="n">ad</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="n">bi</span><span class="p">,</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="o">*</span><span class="n">symbols</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">_ispow</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">bd</span><span class="p">)):</span>
                <span class="n">a_base</span><span class="p">,</span> <span class="n">a_exp</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="n">b_base</span><span class="p">,</span> <span class="n">b_exp</span> <span class="o">=</span> <span class="n">bd</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">a_base</span> <span class="o">==</span> <span class="n">b_base</span><span class="p">:</span>
                    <span class="c"># a = -b</span>
                    <span class="n">lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">ad</span><span class="o">/</span><span class="n">bd</span><span class="p">))</span>
                    <span class="n">rhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">bi</span><span class="o">/</span><span class="n">ai</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rat</span> <span class="o">=</span> <span class="n">ad</span><span class="o">/</span><span class="n">bd</span>
                    <span class="n">_lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">ad</span><span class="o">/</span><span class="n">bd</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">_lhs</span> <span class="o">!=</span> <span class="n">rat</span><span class="p">:</span>
                        <span class="n">lhs</span> <span class="o">=</span> <span class="n">_lhs</span>
                        <span class="n">rhs</span> <span class="o">=</span> <span class="o">-</span><span class="n">bi</span><span class="o">/</span><span class="n">ai</span>
            <span class="k">if</span> <span class="n">ai</span><span class="o">*</span><span class="n">bi</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Function</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ad</span><span class="p">,</span> <span class="n">bd</span><span class="p">))</span> <span class="ow">and</span> \
                        <span class="n">ad</span><span class="o">.</span><span class="n">func</span> <span class="o">==</span> <span class="n">bd</span><span class="o">.</span><span class="n">func</span> <span class="ow">and</span> <span class="n">ad</span><span class="o">.</span><span class="n">nargs</span> <span class="o">==</span> <span class="n">bd</span><span class="o">.</span><span class="n">nargs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ad</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">lhs</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># should be able to solve</span>
                        <span class="c"># f(x, y) == f(2, 3) -&gt; x == 2</span>
                        <span class="c"># f(x, x + y) == f(2, 3) -&gt; x == 2 or x == 3 - y</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;equal function with more than 1 argument&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">_ispow</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">lhs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="s">&#39;inverse&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c">#                    -1</span>
                <span class="c"># f(x) = g  -&gt;  x = f  (g)</span>
                <span class="c">#</span>
                <span class="c"># /!\ inverse should not be defined if there are multiple values</span>
                <span class="c"># for the function -- these are handled in _tsolve</span>
                <span class="c">#</span>
                <span class="n">rhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">inverse</span><span class="p">()(</span><span class="n">rhs</span><span class="p">)</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">lhs</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">atan2</span><span class="p">:</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">args</span>
                <span class="n">lhs</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">rhs</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">lhs</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">rhs</span>

        <span class="c"># base**a = b -&gt; base = b**(1/a) if</span>
        <span class="c">#    a is an Integer and dointpow=True (this gives real branch of root)</span>
        <span class="c">#    a is not an Integer and the equation is multivariate and the</span>
        <span class="c">#      base has more than 1 symbol in it</span>
        <span class="c"># The rationale for this is that right now the multi-system solvers</span>
        <span class="c"># doesn&#39;t try to resolve generators to see, for example, if the whole</span>
        <span class="c"># system is written in terms of sqrt(x + y) so it will just fail, so we</span>
        <span class="c"># do that step here.</span>
        <span class="k">if</span> <span class="n">lhs</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">dointpow</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">free_symbols</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">lhs</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">base</span>

        <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">was</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span>


<span class="k">def</span> <span class="nf">unrad</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Remove radicals with symbolic arguments and return (eq, cov, dens),</span>
<span class="sd">    None or raise an error:</span>

<span class="sd">    None is returned if there are no radicals to remove.</span>

<span class="sd">    ValueError is raised if there are radicals and they cannot be removed.</span>

<span class="sd">    Otherwise the tuple, ``(eq, cov, dens)``, is returned where::</span>

<span class="sd">        ``eq``, ``cov``</span>
<span class="sd">            equation without radicals, perhaps written in terms of</span>
<span class="sd">            change variables; the relationship to the original variables</span>
<span class="sd">            is given by the expressions in list (``cov``) whose tuples,</span>
<span class="sd">            (``v``, ``expr``) give the change variable introduced (``v``)</span>
<span class="sd">            and the expression (``expr``) which equates the base of the radical</span>
<span class="sd">            to the power of the change variable needed to clear the radical.</span>
<span class="sd">            For example, for sqrt(2 - x) the tuple (_p, -_p**2 - x + 2), would</span>
<span class="sd">            be obtained.</span>
<span class="sd">        ``dens``</span>
<span class="sd">            A set containing all denominators encountered while removing</span>
<span class="sd">            radicals. This may be of interest since any solution obtained in</span>
<span class="sd">            the modified expression should not set any denominator to zero.</span>
<span class="sd">        ``syms``</span>
<span class="sd">            an iterable of symbols which, if provided, will limit the focus of</span>
<span class="sd">            radical removal: only radicals with one or more of the symbols of</span>
<span class="sd">            interest will be cleared.</span>

<span class="sd">    ``flags`` are used internally for communication during recursive calls.</span>
<span class="sd">    Two options are also recognized::</span>

<span class="sd">        ``take``, when defined, is interpreted as a single-argument function</span>
<span class="sd">        that returns True if a given Pow should be handled.</span>
<span class="sd">        ``all``, when True, will signify that an attempt should be made to</span>
<span class="sd">        remove all radicals. ``take``, if present, has priority over ``all``.</span>

<span class="sd">    Radicals can be removed from an expression if::</span>

<span class="sd">        *   all bases of the radicals are the same; a change of variables is</span>
<span class="sd">            done in this case.</span>
<span class="sd">        *   if all radicals appear in one term of the expression</span>
<span class="sd">        *   there are only 4 terms with sqrt() factors or there are less than</span>
<span class="sd">            four terms having sqrt() factors</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.solvers.solvers import unrad</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, Rational</span>
<span class="sd">        &gt;&gt;&gt; unrad(sqrt(x)*x**Rational(1, 3) + 2)</span>
<span class="sd">        (x**5 - 64, [], [])</span>
<span class="sd">        &gt;&gt;&gt; unrad(sqrt(x) + (x + 1)**Rational(1, 3))</span>
<span class="sd">        (x**3 - x**2 - 2*x - 1, [], [])</span>
<span class="sd">        &gt;&gt;&gt; unrad(sqrt(x) + x**Rational(1, 3) + 2)</span>
<span class="sd">        (_p**3 + _p**2 + 2, [(_p, -_p**6 + x)], [])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_canonical</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="c"># remove constants since these don&#39;t change the location of the root</span>
        <span class="c"># and expand the expression</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">is_number</span><span class="p">])</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

        <span class="c"># make sign canonical</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">free</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">**</span><span class="n">degree</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">eq</span> <span class="o">=</span> <span class="o">-</span><span class="n">eq</span>
        <span class="k">elif</span> <span class="n">eq</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">():</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="o">-</span><span class="n">eq</span>

        <span class="k">return</span> <span class="n">eq</span>

    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">cov</span><span class="p">,</span> <span class="n">dens</span><span class="p">,</span> <span class="n">nwas</span><span class="p">,</span> <span class="n">rpt</span> <span class="o">=</span> <span class="p">[</span><span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
        <span class="nb">sorted</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">dens</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rpt</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>

    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;take&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">_take</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;take&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">flags</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">_rad</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">w</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">w</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_rad</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">_rad</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Pow</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">()</span>
            <span class="n">flags</span><span class="p">[</span><span class="s">&#39;take&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_take</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">i</span><span class="p">)}),</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">}</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="p">(</span><span class="n">_canonical</span><span class="p">(</span><span class="n">rv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rep</span><span class="p">)),</span>
                      <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">j</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rv</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                      <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rv</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
                <span class="k">return</span> <span class="n">rv</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">msg</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">msg</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="c"># see if this is a term that has symbols of interest</span>
            <span class="c"># and merits further processing</span>
            <span class="n">free</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">free_symbols</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">free</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">syms</span> <span class="ow">or</span> <span class="n">free</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dens</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="n">powdenest</span><span class="p">(</span><span class="n">factor_terms</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">radical</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
    <span class="n">eq</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_take</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">dens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">dens</span><span class="p">)</span>

    <span class="n">poly</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_poly</span><span class="p">()</span>

    <span class="c"># if all the bases are the same or all the radicals are in one</span>
    <span class="c"># term, `lcm` will be the lcm of the radical&#39;s exponent</span>
    <span class="c"># denominators</span>
    <span class="n">lcm</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">gens</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_take</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">g</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">ecoeff</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># a Rational</span>
        <span class="k">if</span> <span class="n">ecoeff</span><span class="o">.</span><span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rads</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="n">lcm</span> <span class="o">=</span> <span class="n">ilcm</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="n">ecoeff</span><span class="o">.</span><span class="n">q</span><span class="p">)</span>
            <span class="n">bases</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">rads</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">depth</span> <span class="o">=</span> <span class="n">sqrt_depth</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>

    <span class="c"># get terms together that have common generators</span>
    <span class="n">drad</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rads</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rads</span><span class="p">))))))</span>
    <span class="n">rterms</span> <span class="o">=</span> <span class="p">{():</span> <span class="p">[]}</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_take</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">common</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">as_poly</span><span class="p">()</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">rads</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">drad</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">common</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">rterms</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">rterms</span><span class="o">.</span><span class="n">pop</span><span class="p">(()))</span>
    <span class="n">rterms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">rterms</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">rterms</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
    <span class="c"># the output will depend on the order terms are processed, so</span>
    <span class="c"># make it canonical quickly</span>
    <span class="n">rterms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ordered</span><span class="p">(</span><span class="n">rterms</span><span class="p">))))</span>

    <span class="c"># continue handling</span>
    <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">lcm</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="n">args</span><span class="p">)</span><span class="o">**</span><span class="n">lcm</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">lcm</span> <span class="o">-</span> <span class="n">rterms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="n">lcm</span>

    <span class="k">elif</span> <span class="n">log</span><span class="p">(</span><span class="n">lcm</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">args</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">_norm2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">b</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c"># (r0+r1)**2 - (r2+r3)**2</span>
            <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">rterms</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span> <span class="o">-</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c"># (r1+r2)**2 - (r0+args)**2</span>
            <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">rterms</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="o">-</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c"># r0**2 - (r1+args)**2</span>
            <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">rterms</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">r0</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">_norm2</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># change of variables may work</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">covwas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">bexpr</span> <span class="ow">in</span> <span class="n">cov</span><span class="p">:</span>
            <span class="nb">pow</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">bexpr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">pow</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="n">pb</span><span class="p">,</span> <span class="n">pe</span> <span class="o">=</span> <span class="nb">pow</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">pe</span> <span class="o">==</span> <span class="n">lcm</span> <span class="ow">and</span> <span class="n">pb</span> <span class="o">==</span> <span class="n">p</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">pb</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">cov</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">p</span><span class="o">**</span><span class="n">lcm</span><span class="p">))</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="o">**</span><span class="n">lcm</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">eq</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">):</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">covwas</span><span class="p">:</span>
                <span class="n">cov</span> <span class="o">=</span> <span class="n">cov</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">new_depth</span> <span class="o">=</span> <span class="n">sqrt_depth</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="n">rpt</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># XXX how many repeats with others unchanging is enough?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">nwas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">)</span> <span class="o">==</span> <span class="n">nwas</span> <span class="ow">and</span>
                <span class="n">new_depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">new_depth</span> <span class="o">==</span> <span class="n">depth</span> <span class="ow">and</span>
                <span class="n">rpt</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">):</span>
        <span class="c"># XXX: XFAIL tests indicate other cases that should be handled.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Cannot remove all radicals from </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">eq</span><span class="p">)</span>

    <span class="n">neq</span> <span class="o">=</span> <span class="n">unrad</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span> <span class="n">dens</span><span class="o">=</span><span class="n">dens</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">rterms</span><span class="p">),</span> <span class="n">rpt</span><span class="o">=</span><span class="n">rpt</span><span class="p">,</span> <span class="n">take</span><span class="o">=</span><span class="n">_take</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">neq</span><span class="p">:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">neq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">_canonical</span><span class="p">(</span><span class="n">eq</span><span class="p">),</span> <span class="n">cov</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">dens</span><span class="p">))</span>


<span class="kn">from</span> <span class="nn">sympy.solvers.bivariate</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">bivariate_type</span><span class="p">,</span> <span class="n">_solve_lambert</span><span class="p">,</span> <span class="n">_filtered_gens</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.3 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Aug 04, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>