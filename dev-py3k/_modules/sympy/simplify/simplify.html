

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.simplify.simplify &mdash; SymPy 0.7.2-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.2-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/SymPy-Favicon.ico"/>
    <link rel="top" title="SymPy 0.7.2-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.simplify.simplify</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">SYMPY_DEBUG</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Basic</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">Pow</span><span class="p">,</span> <span class="n">Rational</span><span class="p">,</span> <span class="n">Integer</span><span class="p">,</span>
    <span class="n">Derivative</span><span class="p">,</span> <span class="n">Wild</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">expand</span><span class="p">,</span> <span class="n">expand_mul</span><span class="p">,</span> <span class="n">expand_func</span><span class="p">,</span>
    <span class="n">Function</span><span class="p">,</span> <span class="n">Equality</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">factor_terms</span><span class="p">,</span>
    <span class="n">expand_multinomial</span><span class="p">,</span> <span class="n">expand_power_base</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">iterable</span><span class="p">,</span> <span class="nb">reduce</span><span class="p">,</span> <span class="n">default_sort_key</span>
<span class="kn">from</span> <span class="nn">sympy.core.numbers</span> <span class="kn">import</span> <span class="n">Float</span>
<span class="kn">from</span> <span class="nn">sympy.core.function</span> <span class="kn">import</span> <span class="n">expand_log</span><span class="p">,</span> <span class="n">count_ops</span>
<span class="kn">from</span> <span class="nn">sympy.core.mul</span> <span class="kn">import</span> <span class="n">_keep_coeff</span><span class="p">,</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">sympy.core.rules</span> <span class="kn">import</span> <span class="n">Transform</span>

<span class="kn">from</span> <span class="nn">sympy.functions</span> <span class="kn">import</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">exp_polar</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">has_variety</span>

<span class="kn">from</span> <span class="nn">sympy.simplify.cse_main</span> <span class="kn">import</span> <span class="n">cse</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.cse_opts</span> <span class="kn">import</span> <span class="n">sub_pre</span><span class="p">,</span> <span class="n">sub_post</span>
<span class="kn">from</span> <span class="nn">sympy.simplify.sqrtdenest</span> <span class="kn">import</span> <span class="n">sqrtdenest</span>

<span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Poly</span><span class="p">,</span> <span class="n">together</span><span class="p">,</span> <span class="n">reduced</span><span class="p">,</span> <span class="n">cancel</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span>
    <span class="n">ComputationFailed</span><span class="p">,</span> <span class="n">lcm</span><span class="p">,</span> <span class="n">gcd</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">sympy.mpmath</span> <span class="kn">as</span> <span class="nn">mpmath</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>


<span class="k">def</span> <span class="nf">_mexpand</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expand_multinomial</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>


<div class="viewcode-block" id="fraction"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.fraction">[docs]</a><span class="k">def</span> <span class="nf">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a pair with expression&#39;s numerator and denominator.</span>
<span class="sd">       If the given expression is not a fraction then this function</span>
<span class="sd">       will return the tuple (expr, 1).</span>

<span class="sd">       This function will not make any attempt to simplify nested</span>
<span class="sd">       fractions or to do any term rewriting at all.</span>

<span class="sd">       If only one of the numerator/denominator pair is needed then</span>
<span class="sd">       use numer(expr) or denom(expr) functions respectively.</span>

<span class="sd">       &gt;&gt;&gt; from sympy import fraction, Rational, Symbol</span>
<span class="sd">       &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">       &gt;&gt;&gt; fraction(x/y)</span>
<span class="sd">       (x, y)</span>
<span class="sd">       &gt;&gt;&gt; fraction(x)</span>
<span class="sd">       (x, 1)</span>

<span class="sd">       &gt;&gt;&gt; fraction(1/y**2)</span>
<span class="sd">       (1, y**2)</span>

<span class="sd">       &gt;&gt;&gt; fraction(x*y/2)</span>
<span class="sd">       (x*y, 2)</span>
<span class="sd">       &gt;&gt;&gt; fraction(Rational(1, 2))</span>
<span class="sd">       (1, 2)</span>

<span class="sd">       This function will also work fine with assumptions:</span>

<span class="sd">       &gt;&gt;&gt; k = Symbol(&#39;k&#39;, negative=True)</span>
<span class="sd">       &gt;&gt;&gt; fraction(x * y**k)</span>
<span class="sd">       (x, y**(-k))</span>

<span class="sd">       If we know nothing about sign of some exponent and &#39;exact&#39;</span>
<span class="sd">       flag is unset, then structure this exponent&#39;s structure will</span>
<span class="sd">       be analyzed and pretty fraction will be returned:</span>

<span class="sd">       &gt;&gt;&gt; from sympy import exp</span>
<span class="sd">       &gt;&gt;&gt; fraction(2*x**(-y))</span>
<span class="sd">       (2, x**y)</span>

<span class="sd">       &gt;&gt;&gt; fraction(exp(-x))</span>
<span class="sd">       (1, exp(x))</span>

<span class="sd">       &gt;&gt;&gt; fraction(exp(-x), exact=True)</span>
<span class="sd">       (exp(-x), 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">term</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">):</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ex</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">ex</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">exact</span> <span class="ow">and</span> <span class="n">ex</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">numer</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">denom</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">numer</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">denom</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">fraction_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">numer_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">numer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">denom_expand</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">denom</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>

<span class="n">expand_numer</span> <span class="o">=</span> <span class="n">numer_expand</span>
<span class="n">expand_denom</span> <span class="o">=</span> <span class="n">denom_expand</span>
<span class="n">expand_fraction</span> <span class="o">=</span> <span class="n">fraction_expand</span>


<div class="viewcode-block" id="separate"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.separate">[docs]</a><span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deprecated wrapper around ``expand_power_base()``.  Use that function instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.utilities.exceptions</span> <span class="kn">import</span> <span class="n">SymPyDeprecationWarning</span>
    <span class="n">SymPyDeprecationWarning</span><span class="p">(</span>
        <span class="n">feature</span><span class="o">=</span><span class="s">&quot;separate()&quot;</span><span class="p">,</span> <span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;expand_power_base()&quot;</span><span class="p">,</span> <span class="n">issue</span><span class="o">=</span><span class="mi">3383</span><span class="p">,</span>
        <span class="n">deprecated_since_version</span><span class="o">=</span><span class="s">&quot;0.7.2&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;Note: in separate() deep &quot;</span>
        <span class="s">&quot;defaults to False, whereas in expand_power_base(), deep defaults to True.&quot;</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">warn</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="collect"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.collect">[docs]</a><span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect additive terms of an expression.</span>

<span class="sd">    This function collects additive terms of an expression with respect</span>
<span class="sd">    to a list of expression up to powers with rational exponents. By the</span>
<span class="sd">    term symbol here are meant arbitrary expressions, which can contain</span>
<span class="sd">    powers, products, sums etc. In other words symbol is a pattern which</span>
<span class="sd">    will be searched for in the expression&#39;s terms.</span>

<span class="sd">    The input expression is not expanded by :func:`collect`, so user is</span>
<span class="sd">    expected to provide an expression is an appropriate form. This makes</span>
<span class="sd">    :func:`collect` more predictable as there is no magic happening behind the</span>
<span class="sd">    scenes. However, it is important to note, that powers of products are</span>
<span class="sd">    converted to products of powers using the :func:`expand_power_base`</span>
<span class="sd">    function.</span>

<span class="sd">    There are two possible types of output. First, if ``evaluate`` flag is</span>
<span class="sd">    set, this function will return an expression with collected terms or</span>
<span class="sd">    else it will return a dictionary with expressions up to rational powers</span>
<span class="sd">    as keys and collected coefficients as values.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import S, collect, expand, factor, Wild</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, c, x, y, z</span>

<span class="sd">    This function can collect symbolic coefficients in polynomials or</span>
<span class="sd">    rational expressions. It will manage to find all integer or rational</span>
<span class="sd">    powers of collection variable::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**2 + b*x**2 + a*x - b*x + c, x)</span>
<span class="sd">        c + x**2*(a + b) + x*(a - b)</span>

<span class="sd">    The same result can be achieved in dictionary form::</span>

<span class="sd">        &gt;&gt;&gt; d = collect(a*x**2 + b*x**2 + a*x - b*x + c, x, evaluate=False)</span>
<span class="sd">        &gt;&gt;&gt; d[x**2]</span>
<span class="sd">        a + b</span>
<span class="sd">        &gt;&gt;&gt; d[x]</span>
<span class="sd">        a - b</span>
<span class="sd">        &gt;&gt;&gt; d[S.One]</span>
<span class="sd">        c</span>

<span class="sd">    You can also work with multivariate polynomials. However, remember that</span>
<span class="sd">    this function is greedy so it will care only about a single symbol at time,</span>
<span class="sd">    in specification order::</span>

<span class="sd">        &gt;&gt;&gt; collect(x**2 + y*x**2 + x*y + y + a*y, [x, y])</span>
<span class="sd">        x**2*(y + 1) + x*y + y*(a + 1)</span>

<span class="sd">    Also more complicated expressions can be used as patterns::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, log</span>
<span class="sd">        &gt;&gt;&gt; collect(a*sin(2*x) + b*sin(2*x), sin(2*x))</span>
<span class="sd">        (a + b)*sin(2*x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x*log(x) + b*(x*log(x)), x*log(x))</span>
<span class="sd">        x*(a + b)*log(x)</span>

<span class="sd">    You can use wildcards in the pattern::</span>

<span class="sd">        &gt;&gt;&gt; w = Wild(&#39;w1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**y - b*x**y, w**y)</span>
<span class="sd">        x**y*(a - b)</span>

<span class="sd">    It is also possible to work with symbolic powers, although it has more</span>
<span class="sd">    complicated behavior, because in this case power&#39;s base and symbolic part</span>
<span class="sd">    of the exponent are treated as a single symbol::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**c + b*x**c, x)</span>
<span class="sd">        a*x**c + b*x**c</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**c + b*x**c, x**c)</span>
<span class="sd">        x**c*(a + b)</span>

<span class="sd">    However if you incorporate rationals to the exponents, then you will get</span>
<span class="sd">    well known behavior::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**(2*c) + b*x**(2*c), x**c)</span>
<span class="sd">        x**(2*c)*(a + b)</span>

<span class="sd">    Note also that all previously stated facts about :func:`collect` function</span>
<span class="sd">    apply to the exponential function, so you can get::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import exp</span>
<span class="sd">        &gt;&gt;&gt; collect(a*exp(2*x) + b*exp(2*x), exp(x))</span>
<span class="sd">        (a + b)*exp(2*x)</span>

<span class="sd">    If you are interested only in collecting specific powers of some symbols</span>
<span class="sd">    then set ``exact`` flag in arguments::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*x**7 + b*x**7, x, exact=True)</span>
<span class="sd">        a*x**7 + b*x**7</span>
<span class="sd">        &gt;&gt;&gt; collect(a*x**7 + b*x**7, x**7, exact=True)</span>
<span class="sd">        x**7*(a + b)</span>

<span class="sd">    You can also apply this function to differential equations, where derivatives</span>
<span class="sd">    of arbitrary order can be collected. Note that if you collect with respect</span>
<span class="sd">    to a function or a derivative of a function, all derivatives of that function</span>
<span class="sd">    will also be collected. Use ``exact=True`` to prevent this from happening::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Derivative as D, collect, Function</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;) (x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(f,x) + b*D(f,x), D(f,x))</span>
<span class="sd">        (a + b)*Derivative(f(x), x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x) + b*D(D(f,x),x), f)</span>
<span class="sd">        (a + b)*Derivative(f(x), x, x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x) + b*D(D(f,x),x), D(f,x), exact=True)</span>
<span class="sd">        a*Derivative(f(x), x, x) + b*Derivative(f(x), x, x)</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(f,x) + b*D(f,x) + a*f + b*f, f)</span>
<span class="sd">        (a + b)*f(x) + (a + b)*Derivative(f(x), x)</span>

<span class="sd">    Or you can even match both derivative order and exponent at the same time::</span>

<span class="sd">        &gt;&gt;&gt; collect(a*D(D(f,x),x)**2 + b*D(D(f,x),x)**2, D(f,x))</span>
<span class="sd">        (a + b)*Derivative(f(x), x, x)**2</span>

<span class="sd">    Finally, you can apply a function to each of the collected coefficients.</span>
<span class="sd">    For example you can factorize symbolic coefficients of polynomial::</span>

<span class="sd">        &gt;&gt;&gt; f = expand((x + a + 1)**3)</span>

<span class="sd">        &gt;&gt;&gt; collect(f, x, factor)</span>
<span class="sd">        x**3 + 3*x**2*(a + 1) + 3*x*(a + 1)**2 + (a + 1)**3</span>

<span class="sd">    .. note:: Arguments are expected to be in expanded form, so you might have</span>
<span class="sd">              to call :func:`expand` prior to calling this function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">make_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="n">product</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">deriv</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">deriv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">var</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">deriv</span>

                <span class="k">while</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">term</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">var</span><span class="p">),</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rat</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">product</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Pow</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">rat</span><span class="o">*</span><span class="n">sym</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">product</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_derivative</span><span class="p">(</span><span class="n">deriv</span><span class="p">):</span>
        <span class="c"># scan derivatives tower in the input expression and return</span>
        <span class="c"># underlying function and maximal differentiation order</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">deriv</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">deriv</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">deriv</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s">&#39;Improve MV Derivative support in collect&#39;</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
            <span class="n">s0</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">s0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s">&#39;Improve MV Derivative support in collect&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">s0</span> <span class="o">==</span> <span class="n">sym</span><span class="p">:</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="n">Rational</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">parse_term</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parses expression expr and outputs tuple (sexpr, rat_expo,</span>
<span class="sd">        sym_expo, deriv)</span>
<span class="sd">        where:</span>
<span class="sd">         - sexpr is the base expression</span>
<span class="sd">         - rat_expo is the rational exponent that sexpr is raised to</span>
<span class="sd">         - sym_expo is the symbolic exponent that sexpr is raised to</span>
<span class="sd">         - deriv contains the derivatives the the expression</span>

<span class="sd">         for example, the output of x would be (x, 1, None, None)</span>
<span class="sd">         the output of 2**x would be (2, 1, x, None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">None</span>
        <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">parse_derivative</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sexpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">base</span>

            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">coeff</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
                    <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sym_expo</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">exp</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Exp1</span><span class="p">,</span> <span class="n">arg</span>
            <span class="k">elif</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">tail</span><span class="p">),</span> <span class="n">coeff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">):</span>
            <span class="n">sexpr</span><span class="p">,</span> <span class="n">deriv</span> <span class="o">=</span> <span class="n">parse_derivative</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sexpr</span><span class="p">,</span> <span class="n">rat_expo</span><span class="p">,</span> <span class="n">sym_expo</span><span class="p">,</span> <span class="n">deriv</span>

    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse terms searching for a pattern.</span>
<span class="sd">        terms is a list of tuples as returned by parse_terms;</span>
<span class="sd">        pattern is an expression treated as a product of factors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
            <span class="c"># pattern is longer than matched product</span>
            <span class="c"># so no chance for positive parsing result</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_term</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">pattern</span><span class="p">]</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[:]</span>  <span class="c"># need a copy</span>
            <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span> <span class="o">=</span> <span class="p">[],</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">False</span>

            <span class="k">for</span> <span class="n">elem</span><span class="p">,</span> <span class="n">e_rat</span><span class="p">,</span> <span class="n">e_sym</span><span class="p">,</span> <span class="n">e_ord</span> <span class="ow">in</span> <span class="n">pattern</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span> <span class="n">e_rat</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">e_sym</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c"># a constant is a match for everything</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">term</span><span class="p">,</span> <span class="n">t_rat</span><span class="p">,</span> <span class="n">t_sym</span><span class="p">,</span> <span class="n">t_ord</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                    <span class="c"># keeping track of whether one of the terms had</span>
                    <span class="c"># a derivative or not as this will require rebuilding</span>
                    <span class="c"># the expression later</span>
                    <span class="k">if</span> <span class="n">t_ord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">has_deriv</span> <span class="o">=</span> <span class="bp">True</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">t_sym</span> <span class="o">==</span> <span class="n">e_sym</span> <span class="ow">or</span> <span class="n">t_sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="n">e_sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                            <span class="n">t_sym</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e_sym</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">exact</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                            <span class="c"># we don&#39;t have to be exact so find common exponent</span>
                            <span class="c"># for both expression&#39;s term and pattern&#39;s element</span>
                            <span class="n">expo</span> <span class="o">=</span> <span class="n">t_rat</span> <span class="o">/</span> <span class="n">e_rat</span>

                            <span class="k">if</span> <span class="n">common_expo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="c"># first time</span>
                                <span class="n">common_expo</span> <span class="o">=</span> <span class="n">expo</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c"># common exponent was negotiated before so</span>
                                <span class="c"># there is no chance for a pattern match unless</span>
                                <span class="c"># common and current exponents are equal</span>
                                <span class="k">if</span> <span class="n">common_expo</span> <span class="o">!=</span> <span class="n">expo</span><span class="p">:</span>
                                    <span class="n">common_expo</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c"># we ought to be exact so all fields of</span>
                            <span class="c"># interest must match in every details</span>
                            <span class="k">if</span> <span class="n">e_rat</span> <span class="o">!=</span> <span class="n">t_rat</span> <span class="ow">or</span> <span class="n">e_ord</span> <span class="o">!=</span> <span class="n">t_ord</span><span class="p">:</span>
                                <span class="k">continue</span>

                        <span class="c"># found common term so remove it from the expression</span>
                        <span class="c"># and try to match next element in the pattern</span>
                        <span class="n">elems</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

                        <span class="k">break</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># pattern element not found</span>
                    <span class="k">return</span> <span class="bp">None</span>

            <span class="k">return</span> <span class="p">[</span><span class="n">_f</span> <span class="k">for</span> <span class="n">_f</span> <span class="ow">in</span> <span class="n">terms</span> <span class="k">if</span> <span class="n">_f</span><span class="p">],</span> <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span>

    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span> <span class="n">collect</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span> <span class="p">])</span>
        <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="p">,</span> <span class="n">distribute_order_term</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">syms</span><span class="p">):</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span><span class="n">expand_power_base</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="p">[</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">syms</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="p">]</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="n">order_term</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">distribute_order_term</span><span class="p">:</span>
        <span class="n">order_term</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">order_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order_term</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">syms</span><span class="p">):</span>
                <span class="n">order_term</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>

    <span class="n">summa</span> <span class="o">=</span> <span class="p">[</span><span class="n">expand_power_base</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">)]</span>

    <span class="n">collected</span><span class="p">,</span> <span class="n">disliked</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
    <span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">summa</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">parse_term</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">product</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">SYMPY_DEBUG</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;DEBUG: parsing of expression </span><span class="si">%s</span><span class="s"> with symbol </span><span class="si">%s</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">terms</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">symbol</span><span class="p">)))</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">parse_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">SYMPY_DEBUG</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;DEBUG: returned </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">terms</span><span class="p">,</span> <span class="n">elems</span><span class="p">,</span> <span class="n">common_expo</span><span class="p">,</span> <span class="n">has_deriv</span> <span class="o">=</span> <span class="n">result</span>

                <span class="c"># when there was derivative in current pattern we</span>
                <span class="c"># will need to rebuild its expression from scratch</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">has_deriv</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="n">e</span> <span class="o">*=</span> <span class="n">elem</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">index</span> <span class="o">*=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">make_expression</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span>
                <span class="n">terms</span> <span class="o">=</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">make_expression</span><span class="p">(</span><span class="n">terms</span><span class="p">),</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">expand_power_base</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="n">collected</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># none of the patterns matched</span>
            <span class="n">disliked</span> <span class="o">+=</span> <span class="n">product</span>
    <span class="c"># add terms now for each key</span>
    <span class="n">collected</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="k">if</span> <span class="n">disliked</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
        <span class="n">collected</span><span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]</span> <span class="o">=</span> <span class="n">disliked</span>

    <span class="k">if</span> <span class="n">order_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">collected</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">order_term</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">collected</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">])</span>

    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">key</span><span class="o">*</span><span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">collected</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">collected</span>

</div>
<div class="viewcode-block" id="rcollect"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.rcollect">[docs]</a><span class="k">def</span> <span class="nf">rcollect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively collect sums in an expression.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify import rcollect</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">    &gt;&gt;&gt; expr = (x**2*y + x*y + x + y)/(x + y)</span>

<span class="sd">    &gt;&gt;&gt; rcollect(expr, y)</span>
<span class="sd">    (x + y*(x**2 + x + 1))/(x + y)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="nb">vars</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="o">*</span><span class="p">[</span> <span class="n">rcollect</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span> <span class="p">])</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

</div>
<div class="viewcode-block" id="separatevars"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.separatevars">[docs]</a><span class="k">def</span> <span class="nf">separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="p">[],</span> <span class="nb">dict</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separates variables in an expression, if possible.  By</span>
<span class="sd">    default, it separates with respect to all symbols in an</span>
<span class="sd">    expression and collects constant coefficients that are</span>
<span class="sd">    independent of symbols.</span>

<span class="sd">    If dict=True then the separated terms will be returned</span>
<span class="sd">    in a dictionary keyed to their corresponding symbols.</span>
<span class="sd">    By default, all symbols in the expression will appear as</span>
<span class="sd">    keys; if symbols are provided, then all those symbols will</span>
<span class="sd">    be used as keys, and any terms in the expression containing</span>
<span class="sd">    other symbols or non-symbols will be returned keyed to the</span>
<span class="sd">    string &#39;coeff&#39;. (Passing None for symbols will return the</span>
<span class="sd">    expression in a dictionary keyed to &#39;coeff&#39;.)</span>

<span class="sd">    If force=True, then bases of powers will be separated regardless</span>
<span class="sd">    of assumptions on the symbols involved.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>
<span class="sd">    The order of the factors is determined by Mul, so that the</span>
<span class="sd">    separated expressions may not necessarily be grouped together.</span>

<span class="sd">    Although factoring is necessary to separate variables in some</span>
<span class="sd">    expressions, it is not necessary in all cases, so one should not</span>
<span class="sd">    count on the returned factors being factored.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z, alpha</span>
<span class="sd">    &gt;&gt;&gt; from sympy import separatevars, sin</span>
<span class="sd">    &gt;&gt;&gt; separatevars((x*y)**y)</span>
<span class="sd">    (x*y)**y</span>
<span class="sd">    &gt;&gt;&gt; separatevars((x*y)**y, force=True)</span>
<span class="sd">    x**y*y**y</span>

<span class="sd">    &gt;&gt;&gt; e = 2*x**2*z*sin(y)+2*z*x**2</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e)</span>
<span class="sd">    2*x**2*z*(sin(y) + 1)</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e, symbols=(x, y), dict=True)</span>
<span class="sd">    {&#39;coeff&#39;: 2*z, x: x**2, y: sin(y) + 1}</span>
<span class="sd">    &gt;&gt;&gt; separatevars(e, [x, y, alpha], dict=True)</span>
<span class="sd">    {&#39;coeff&#39;: 2*z, alpha: 1, x: x**2, y: sin(y) + 1}</span>

<span class="sd">    If the expression is not really separable, or is only partially</span>
<span class="sd">    separable, separatevars will do the best it can to separate it</span>
<span class="sd">    by using factoring.</span>

<span class="sd">    &gt;&gt;&gt; separatevars(x + x*y - 3*x**2)</span>
<span class="sd">    -x*(3*x - y - 1)</span>

<span class="sd">    If the expression is not separable then expr is returned unchanged</span>
<span class="sd">    or (if dict=True) then None is returned.</span>

<span class="sd">    &gt;&gt;&gt; eq = 2*x + y*sin(x)</span>
<span class="sd">    &gt;&gt;&gt; separatevars(eq) == eq</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; separatevars(2*x + y*sin(x), symbols=(x, y), dict=True) == None</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_separatevars_dict</span><span class="p">(</span><span class="n">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">),</span> <span class="n">symbols</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_separatevars</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="c"># don&#39;t destroy a Mul since much of the work may already be done</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">separatevars</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="n">changed</span> <span class="ow">or</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span>
        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># get a Pow ready for expansion</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">separatevars</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

    <span class="c"># First try other expansion methods</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">mul</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">)</span>

    <span class="n">_expr</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>  <span class="c"># factor fails for nc</span>
        <span class="n">_expr</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">force</span> <span class="k">else</span> <span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">factor</span><span class="p">(</span><span class="n">_expr</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># Find any common coefficients to pull out</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">commonc</span> <span class="o">&amp;=</span> <span class="n">i</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">commonc</span><span class="p">)</span>
    <span class="n">commonc</span> <span class="o">=</span> <span class="n">commonc</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># ignore constants</span>
    <span class="n">commonc_set</span> <span class="o">=</span> <span class="n">commonc</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># remove them</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">commonc_set</span>
        <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nc</span><span class="p">)</span>
    <span class="n">nonsepar</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonsepar</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_expr</span> <span class="o">=</span> <span class="n">nonsepar</span>
        <span class="n">_expr</span><span class="p">,</span> <span class="n">reps</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">_expr</span><span class="p">)</span> <span class="k">if</span> <span class="n">force</span> <span class="k">else</span> <span class="p">(</span><span class="n">_expr</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">_expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span><span class="p">(</span><span class="n">_expr</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">nonsepar</span> <span class="o">=</span> <span class="n">_expr</span>

    <span class="k">return</span> <span class="n">commonc</span><span class="o">*</span><span class="n">nonsepar</span>


<span class="k">def</span> <span class="nf">_separatevars_dict</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbols</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">((</span><span class="n">t</span><span class="o">.</span><span class="n">is_Atom</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)),</span> <span class="s">&quot;symbols must be Atoms.&quot;</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">symbols</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;coeff&#39;</span><span class="p">:</span> <span class="n">expr</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(((</span><span class="n">i</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">symbols</span> <span class="o">+</span> <span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="n">expsym</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">free_symbols</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">expsym</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># There are no symbols, so it is part of the coefficient</span>
            <span class="n">ret</span><span class="p">[</span><span class="s">&#39;coeff&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">intersection</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c"># rebuild</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ret</span>


<div class="viewcode-block" id="ratsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.ratsimp">[docs]</a><span class="k">def</span> <span class="nf">ratsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Put an expression over a common denominator, cancel and reduce.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import ratsimp</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; ratsimp(1/x + 1/y)</span>
<span class="sd">    (x + y)/(x*y)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">Q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">g</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">ComputationFailed</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f</span><span class="o">/</span><span class="n">g</span>

    <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span> <span class="o">+</span> <span class="n">cancel</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">ratsimpmodprime</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies a rational expression ``expr`` modulo the prime ideal</span>
<span class="sd">    generated by ``G``.  ``G`` should be a Groebner basis of the</span>
<span class="sd">    ideal.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import ratsimpmodprime</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; ratsimpmodprime((x + y**5 + y)/(x - y), [x*y**5 - x - y], x, y, order=&#39;lex&#39;)</span>
<span class="sd">    (x**2 + x*y + x + y)/(x**2 - x*y)</span>

<span class="sd">    The algorithm computes a rational simplification which minimizes</span>
<span class="sd">    the sum of the total degrees of the numerator and the denominator.</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial</span>
<span class="sd">    Ideal,</span>
<span class="sd">    http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.163.6984</span>
<span class="sd">    (specifically, the second algorithm)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">parallel_poly_from_expr</span>
    <span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="kn">import</span> <span class="n">PolificationFailed</span><span class="p">,</span> <span class="n">DomainError</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solve</span><span class="p">,</span> <span class="n">Monomial</span>
    <span class="kn">from</span> <span class="nn">sympy.polys.monomialtools</span> <span class="kn">import</span> <span class="n">monomial_div</span>
    <span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">product</span>

    <span class="c"># usual preparation of polynomials:</span>

    <span class="n">num</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">polys</span><span class="p">,</span> <span class="n">opt</span> <span class="o">=</span> <span class="n">parallel_poly_from_expr</span><span class="p">([</span><span class="n">num</span><span class="p">,</span> <span class="n">denom</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">PolificationFailed</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">domain</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">domain</span>

    <span class="k">if</span> <span class="n">domain</span><span class="o">.</span><span class="n">has_assoc_Field</span><span class="p">:</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">get_field</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">DomainError</span><span class="p">(</span>
            <span class="s">&quot;can&#39;t compute rational simplification over </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">domain</span><span class="p">)</span>

    <span class="c"># compute only once</span>
    <span class="n">leading_monomials</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">LM</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>

    <span class="k">def</span> <span class="nf">staircase</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute all monomials with degree less than ``n`` that are</span>
<span class="sd">        not divisible by any element of ``leading_monomials``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">))):</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">monomial_div</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">lmg</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">lmg</span> <span class="ow">in</span> <span class="n">leading_monomials</span><span class="p">]):</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">Monomial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">(</span><span class="o">*</span><span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">S</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_ratsimpmodprime</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a rational simplification of ``a/b`` which minimizes</span>
<span class="sd">        the sum of the total degrees of the numerator and the denominator.</span>

<span class="sd">        The algorithm proceeds by looking at ``a * d - b * c`` modulo</span>
<span class="sd">        the ideal generated by ``G`` for some ``c`` and ``d`` with degree</span>
<span class="sd">        less than ``a`` and ``b`` respectively.</span>
<span class="sd">        The coefficients of ``c`` and ``d`` are indeterminates and thus</span>
<span class="sd">        the coefficients of the normalform of ``a * d - b * c`` are</span>
<span class="sd">        linear polynomials in these indeterminates.</span>
<span class="sd">        If these linear polynomials, considered as system of</span>
<span class="sd">        equations, have a nontrivial solution, then `\frac{a}{b}</span>
<span class="sd">        \equiv \frac{c}{d}` modulo the ideal generated by ``G``. So,</span>
<span class="sd">        by construction, the degree of ``c`` and ``d`` is less than</span>
<span class="sd">        the degree of ``a`` and ``b``, so a simpler representation</span>
<span class="sd">        has been found.</span>
<span class="sd">        After a simpler representation has been found, the algorithm</span>
<span class="sd">        tries to reduce the degree of the numerator and denominator</span>
<span class="sd">        and returns the result afterwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">N</span> <span class="o">+</span> <span class="n">D</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">total_degree</span><span class="p">()</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">total_degree</span><span class="p">():</span>
            <span class="n">M1</span> <span class="o">=</span> <span class="n">staircase</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">M2</span> <span class="o">=</span> <span class="n">staircase</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

            <span class="n">Cs</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&quot;c:</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">M1</span><span class="p">))</span>
            <span class="n">Ds</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&quot;d:</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">M2</span><span class="p">))</span>

            <span class="n">c_hat</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">([</span><span class="n">Cs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M1</span><span class="p">))]),</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
            <span class="n">d_hat</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">([</span><span class="n">Ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">M2</span><span class="p">))]),</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">d_hat</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c_hat</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">,</span>
                        <span class="n">order</span><span class="o">=</span><span class="n">opt</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">polys</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">S</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">coeffs</span><span class="p">()</span>
            <span class="n">sol</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span><span class="p">)</span>

            <span class="c"># If nontrivial solutions exist, solve will give them</span>
            <span class="c"># parametrized, i.e. the values of some keys will be</span>
            <span class="c"># exprs. Set these to any value different from 0 to obtain</span>
            <span class="c"># one nontrivial solution:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">sol</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span><span class="p">,</span>
                                         <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Cs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ds</span><span class="p">))))))</span>

            <span class="k">if</span> <span class="n">sol</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sol</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c_hat</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d_hat</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>

                <span class="c"># The &quot;free&quot; variables occuring before as parameters</span>
                <span class="c"># might still be in the substituted c, d, so set them</span>
                <span class="c"># to the value chosen before:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Cs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ds</span><span class="p">))))))</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">Cs</span> <span class="o">+</span> <span class="n">Ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Cs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ds</span><span class="p">))))))</span>

                <span class="n">c</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">Poly</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">)</span>

                <span class="k">break</span>

            <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">D</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">steps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">_ratsimpmodprime</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">-</span> <span class="n">steps</span><span class="p">)</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">_ratsimpmodprime</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="n">steps</span><span class="p">,</span> <span class="n">D</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>

    <span class="c"># preprocessing. this improves performance a bit when deg(num)</span>
    <span class="c"># and deg(denom) are large:</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">opt</span><span class="o">.</span><span class="n">order</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="n">reduced</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">opt</span><span class="o">.</span><span class="n">order</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">_ratsimpmodprime</span><span class="p">(</span><span class="n">Poly</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">),</span> <span class="n">Poly</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">opt</span><span class="o">.</span><span class="n">gens</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">domain</span><span class="o">.</span><span class="n">has_Field</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">clear_denoms</span><span class="p">(</span><span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">clear_denoms</span><span class="p">(</span><span class="n">convert</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">c</span><span class="o">/</span><span class="n">d</span>


<div class="viewcode-block" id="trigsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.trigsimp">[docs]</a><span class="k">def</span> <span class="nf">trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reduces expression by using known trig identities</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    deep:</span>
<span class="sd">    - Apply trigsimp inside all objects with arguments</span>

<span class="sd">    recursive:</span>
<span class="sd">    - Use common subexpression elimination (cse()) and apply</span>
<span class="sd">    trigsimp recursively (this is quite expensive if the</span>
<span class="sd">    expression is large)</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import trigsimp, sin, cos, log, cosh, sinh</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; e = 2*sin(x)**2 + 2*cos(x)**2</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(e)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(log(e))</span>
<span class="sd">    log(2*sin(x)**2 + 2*cos(x)**2)</span>
<span class="sd">    &gt;&gt;&gt; trigsimp(log(e), deep=True)</span>
<span class="sd">    log(2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">cse</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">_trigsimp</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deep</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sub</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">_trigsimp</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">g</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>

</div>
<span class="k">def</span> <span class="nf">_trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;recursive helper for trigsimp&quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a b c&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">=</span><span class="n">Wild</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cot</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">tan</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">cot</span>
    <span class="n">sinh</span><span class="p">,</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">coth</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">sinh</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">cosh</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">tanh</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">coth</span>
    <span class="c"># for the simplifications like sinh/cosh -&gt; tanh:</span>
    <span class="n">matchers_division</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span>

        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span>

        <span class="c"># same as above but with noncommutative prefactor</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="p">),</span>

        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="c"># for cos(x)**2 + sin(x)**2 -&gt; 1</span>
    <span class="n">matchers_identity</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">((</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">c</span><span class="p">)))),</span>

        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sinh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">c</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="p">((</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">tanh</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">c</span><span class="p">)))),</span>

        <span class="c"># same as above but with noncommutative prefactor</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">((</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">c</span><span class="p">)))),</span>

        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sinh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">c</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">((</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">tanh</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">c</span><span class="p">)))),</span>
    <span class="p">)</span>

    <span class="c"># Reduce any lingering artefacts, such as sin(x)**2 changing</span>
    <span class="c"># to 1-cos(x)**2 when sin(x)**2 was &quot;simpler&quot;</span>
    <span class="n">artifacts</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">),</span>

        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cosh</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cosh</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">sinh</span><span class="p">),</span>

        <span class="c"># same as above but with noncommutative prefactor</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cos</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cot</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">sin</span><span class="p">),</span>

        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cosh</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cosh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">cosh</span><span class="p">),</span>
        <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">sinh</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">coth</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">sinh</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="c"># do some simplifications like sin/cos -&gt; tan:</span>
        <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">simp</span> <span class="ow">in</span> <span class="n">matchers_division</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">and</span> <span class="n">res</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c"># if &quot;a&quot; contains any of sin(&quot;b&quot;), cos(&quot;b&quot;), tan(&quot;b&quot;), cot(&quot;b&quot;),</span>
                <span class="c"># sinh(&quot;b&quot;), cosh(&quot;b&quot;), tanh(&quot;b&quot;) or coth(&quot;b),</span>
                <span class="c"># skip the simplification:</span>
                <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c"># simplify and finish:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">simp</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="k">break</span>  <span class="c"># process below</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="c"># The types of hyper functions we are looking for</span>
        <span class="c"># Scan for the terms we need</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="n">_trigsimp</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">matchers_identity</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">term</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span> <span class="o">!=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">expand</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">count_ops</span><span class="p">)</span>

        <span class="c"># Reduce any lingering artifacts, such as sin(x)**2 changing</span>
        <span class="c"># to 1 - cos(x)**2 when sin(x)**2 was &quot;simpler&quot;</span>
        <span class="k">for</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">artifacts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c"># Substitute a new wild that excludes some function(s)</span>
            <span class="c"># to help influence a better match. This is because</span>
            <span class="c"># sometimes, for example, &#39;a&#39; would match sec(x)**2</span>
            <span class="n">a_t</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[</span><span class="n">ex</span><span class="p">])</span>
            <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_t</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_t</span><span class="p">)</span>

            <span class="n">m</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">a_t</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="o">-</span><span class="n">m</span><span class="p">[</span><span class="n">a_t</span><span class="p">]</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span> <span class="n">m</span><span class="p">[</span><span class="n">a_t</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="n">a_t</span><span class="p">]</span><span class="o">*</span><span class="n">m</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">deep</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_trigsimp</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">expr</span>


<div class="viewcode-block" id="collect_sqrt"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.collect_sqrt">[docs]</a><span class="k">def</span> <span class="nf">collect_sqrt</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return expr with terms having common square roots collected together.</span>
<span class="sd">    If ``evaluate`` is False a count indicating the number of sqrt-containing</span>
<span class="sd">    terms will be returned and the returned expression will be an unevaluated</span>
<span class="sd">    Add with args ordered by default_sort_key.</span>

<span class="sd">    Note: since I = sqrt(-1), it is collected, too.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import collect_sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b</span>

<span class="sd">    &gt;&gt;&gt; r2, r3, r5 = [sqrt(i) for i in [2, 3, 5]]</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2)</span>
<span class="sd">    sqrt(2)*(a + b)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r3)</span>
<span class="sd">    sqrt(2)*(a + b) + sqrt(3)*(a + b)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5)</span>
<span class="sd">    sqrt(3)*a + sqrt(5)*b + sqrt(2)*(a + b)</span>

<span class="sd">    If evaluate is False then the arguments will be sorted and</span>
<span class="sd">    returned as a list and a count of the number of sqrt-containing</span>
<span class="sd">    terms will be returned:</span>

<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*r2 + b*r2 + a*r3 + b*r5, evaluate=False)</span>
<span class="sd">    ((sqrt(2)*(a + b), sqrt(3)*a, sqrt(5)*b), 3)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a*sqrt(2) + b, evaluate=False)</span>
<span class="sd">    ((b, sqrt(2)*a), 1)</span>
<span class="sd">    &gt;&gt;&gt; collect_sqrt(a + b, evaluate=False)</span>
<span class="sd">    ((a + b,), 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span>
                                <span class="n">m</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">):</span>
                <span class="nb">vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="nb">vars</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
        <span class="nb">vars</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>  <span class="c"># since it will be reversed below</span>
    <span class="nb">vars</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">count_ops</span><span class="p">)</span>
    <span class="nb">vars</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">collect_const</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
    <span class="n">hit</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">!=</span> <span class="n">d</span>
    <span class="n">d</span> <span class="o">*=</span> <span class="n">coeff</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="n">nrad</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ci</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">ci</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">ci</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> \
                        <span class="n">ci</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
                    <span class="n">nrad</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">hit</span> <span class="ow">or</span> <span class="n">nrad</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)]</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">nrad</span>

    <span class="k">return</span> <span class="n">d</span>

</div>
<div class="viewcode-block" id="collect_const"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.collect_const">[docs]</a><span class="k">def</span> <span class="nf">collect_const</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="n">first</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A non-greedy collection of terms with similar number coefficients in</span>
<span class="sd">    an Add expr. If ``vars`` is given then only those constants will be</span>
<span class="sd">    targeted.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, s</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import collect_const</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3) + sqrt(3)*(1 + sqrt(2)))</span>
<span class="sd">    sqrt(3)*(sqrt(2) + 2)</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(7)*s + sqrt(3) + sqrt(7))</span>
<span class="sd">    (sqrt(3) + sqrt(7))*(s + 1)</span>
<span class="sd">    &gt;&gt;&gt; s = sqrt(2) + 2</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7))</span>
<span class="sd">    (sqrt(2) + 3)*(sqrt(3) + sqrt(7))</span>
<span class="sd">    &gt;&gt;&gt; collect_const(sqrt(3)*s + sqrt(3) + sqrt(7)*s + sqrt(7), sqrt(3))</span>
<span class="sd">    sqrt(7) + sqrt(3)*(sqrt(2) + 3) + sqrt(7)*(sqrt(2) + 2)</span>

<span class="sd">    If no constants are provided then a leading Rational might be returned:</span>

<span class="sd">    &gt;&gt;&gt; collect_const(2*sqrt(3) + 4*a*sqrt(5))</span>
<span class="sd">    2*(2*sqrt(5)*a + sqrt(3))</span>
<span class="sd">    &gt;&gt;&gt; collect_const(2*sqrt(3) + 4*a*sqrt(5), sqrt(3))</span>
<span class="sd">    4*sqrt(5)*a + 2*sqrt(3)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">first</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;first&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">expr</span>
    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_keep_coeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">collect_const</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="bp">False</span><span class="p">)))</span>
        <span class="c"># else don&#39;t leave the Rational on the outside</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">*</span><span class="n">collect_const</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="n">recurse</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">recurse</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                    <span class="nb">vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">vars</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">count_ops</span><span class="p">)</span>
    <span class="c"># Rationals get autodistributed on Add so don&#39;t bother with them</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">ai</span><span class="p">,</span> <span class="n">ad</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">]]</span>
            <span class="n">terms</span><span class="p">[</span><span class="n">ad</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">recurse</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
                    <span class="nb">vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">expr</span>

</div>
<span class="k">def</span> <span class="nf">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    split the list of integers `a` into a list of integers a1 having</span>
<span class="sd">    g = gcd(a1) and a list a2 whose elements are not divisible by g</span>
<span class="sd">    Returns g, a1, a2</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import _split_gcd</span>
<span class="sd">    &gt;&gt;&gt; _split_gcd(55,35,22,14,77,10)</span>
<span class="sd">    (5, [55, 35, 10], [22, 14, 77])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">]</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">g1</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g1</span>
            <span class="n">b1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span>


<span class="k">def</span> <span class="nf">split_surds</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    split an expression with terms whose squares are rationals</span>
<span class="sd">    into a sum of terms whose surds squared have gcd equal to g</span>
<span class="sd">    and a sum of terms with surds squared prime with g</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import split_surds</span>
<span class="sd">    &gt;&gt;&gt; split_surds(3*sqrt(3) + sqrt(5)/7 + sqrt(6) + sqrt(10) + sqrt(15))</span>
<span class="sd">    (3, sqrt(2) + sqrt(5) + 3, sqrt(5)/7 + sqrt(10))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
    <span class="n">coeff_muls</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">surds</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coeff_muls</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">]</span>
    <span class="n">surds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">surds</span><span class="p">)</span>
    <span class="n">g2</span> <span class="o">=</span> <span class="n">g</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">b2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">b1n</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">/</span><span class="n">g</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">]</span>
        <span class="n">b1n</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b1n</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c"># only a common factor has been factored; split again</span>
        <span class="n">g1</span><span class="p">,</span> <span class="n">b1n</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">_split_gcd</span><span class="p">(</span><span class="o">*</span><span class="n">b1n</span><span class="p">)</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">g</span><span class="o">*</span><span class="n">g1</span>
    <span class="n">a1v</span><span class="p">,</span> <span class="n">a2v</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">coeff_muls</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">exp</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">Half</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">base</span>
            <span class="k">if</span> <span class="n">s1</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">:</span>
                <span class="n">a1v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s1</span><span class="o">/</span><span class="n">g2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a2v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a2v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">a1v</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">a2v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g2</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>


<span class="k">def</span> <span class="nf">rad_rationalize</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rationalize num/den by removing square roots in the denominator;</span>
<span class="sd">    num and den are sum of terms whose squares are rationals</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">    &gt;&gt;&gt; from sympy.simplify.simplify import rad_rationalize</span>
<span class="sd">    &gt;&gt;&gt; rad_rationalize(sqrt(3), 1 + sqrt(2)/3)</span>
<span class="sd">    (-sqrt(3) + sqrt(6)/3, -7/9)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">den</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span><span class="p">,</span> <span class="n">den</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">split_surds</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">num</span><span class="p">)</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rad_rationalize</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">)</span>


<div class="viewcode-block" id="radsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.radsimp">[docs]</a><span class="k">def</span> <span class="nf">radsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">max_terms</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rationalize the denominator by removing square roots.</span>

<span class="sd">    Note: the expression returned from radsimp must be used with caution</span>
<span class="sd">    since if the denominator contains symbols, it will be possible to make</span>
<span class="sd">    substitutions that violate the assumptions of the simplification process:</span>
<span class="sd">    that for a denominator matching a + b*sqrt(c), a != +/-b*sqrt(c). (If</span>
<span class="sd">    there are no symbols, this assumptions is made valid by collecting terms</span>
<span class="sd">    of sqrt(c) so the match variable ``a`` does not contain ``sqrt(c)``.) If</span>
<span class="sd">    you do not want the simplification to occur for symbolic denominators, set</span>
<span class="sd">    ``symbolic`` to False.</span>

<span class="sd">    If there are more than ``max_terms`` radical terms do not simplify.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import radsimp, sqrt, Symbol, denom, pprint, I</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, c</span>

<span class="sd">    &gt;&gt;&gt; radsimp(1/(I + 1))</span>
<span class="sd">    (1 - I)/2</span>
<span class="sd">    &gt;&gt;&gt; radsimp(1/(2 + sqrt(2)))</span>
<span class="sd">    (-sqrt(2) + 2)/2</span>
<span class="sd">    &gt;&gt;&gt; x,y = list(map(Symbol, &#39;xy&#39;))</span>
<span class="sd">    &gt;&gt;&gt; e = ((2 + 2*sqrt(2))*x + (2 + sqrt(8))*y)/(2 + sqrt(2))</span>
<span class="sd">    &gt;&gt;&gt; radsimp(e)</span>
<span class="sd">    sqrt(2)*(x + y)</span>

<span class="sd">    Terms are collected automatically:</span>

<span class="sd">    &gt;&gt;&gt; r2 = sqrt(2)</span>
<span class="sd">    &gt;&gt;&gt; r5 = sqrt(5)</span>
<span class="sd">    &gt;&gt;&gt; pprint(radsimp(1/(y*r2 + x*r2 + a*r5 + b*r5)))</span>
<span class="sd">             ___              ___</span>
<span class="sd">           \/ 5 *(-a - b) + \/ 2 *(x + y)</span>
<span class="sd">    --------------------------------------------</span>
<span class="sd">         2               2      2              2</span>
<span class="sd">    - 5*a  - 10*a*b - 5*b  + 2*x  + 4*x*y + 2*y</span>

<span class="sd">    If radicals in the denominator cannot be removed, the original expression</span>
<span class="sd">    will be returned. If the denominator was 1 then any square roots will also</span>
<span class="sd">    be collected:</span>

<span class="sd">    &gt;&gt;&gt; radsimp(sqrt(2)*x + sqrt(2))</span>
<span class="sd">    sqrt(2)*(x + 1)</span>

<span class="sd">    Results with symbols will not always be valid for all substitutions:</span>

<span class="sd">    &gt;&gt;&gt; eq = 1/(a + b*sqrt(c))</span>
<span class="sd">    &gt;&gt;&gt; eq.subs(a, b*sqrt(c))</span>
<span class="sd">    1/(2*b*sqrt(c))</span>
<span class="sd">    &gt;&gt;&gt; radsimp(eq).subs(a, b*sqrt(c))</span>
<span class="sd">    nan</span>

<span class="sd">    If symbolic=False, symbolic denominators will not be transformed (but</span>
<span class="sd">    numeric denominators will still be processed):</span>

<span class="sd">    &gt;&gt;&gt; radsimp(eq, symbolic=False)</span>
<span class="sd">    1/(a + b*sqrt(c))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">symbolic</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="n">nexpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">handle</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">nexpr</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">nargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">ni</span><span class="p">,</span> <span class="n">di</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">handle</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">di</span><span class="p">))</span>
                <span class="n">nargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ni</span><span class="p">)</span>
                <span class="n">dargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">di</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nargs</span><span class="p">)</span><span class="o">/</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">dargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">radsimp</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">q</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">sqrtdenest</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">base</span><span class="p">))</span><span class="o">**</span><span class="n">d</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">p</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># collect similar terms</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">nterms</span> <span class="o">=</span> <span class="n">collect_sqrt</span><span class="p">(</span><span class="n">_mexpand</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nterms</span> <span class="o">&gt;</span> <span class="n">max_terms</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c"># check to see if we are done:</span>
            <span class="c"># - no radical terms</span>
            <span class="c"># - if there are more than 3 radical terms, or</span>
            <span class="c">#   there 3 radical terms and a constant, use rad_rationalize</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nterms</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">nterms</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">nterms</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">is_Integer</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">args</span><span class="p">]):</span>
                    <span class="n">nd</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">rad_rationalize</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">_mexpand</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">nd</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="c"># now match for a radical</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">D</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
                <span class="n">nmul</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">D</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">c</span><span class="o">*</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">E</span><span class="o">*</span><span class="n">D</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">D</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">E</span><span class="p">))</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>
                <span class="k">if</span> <span class="n">denom</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n1</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="n">nmul</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span> <span class="ow">or</span> <span class="n">r</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
                <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vc</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

                <span class="n">dold</span> <span class="o">=</span> <span class="n">d</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">va</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">vc</span><span class="o">*</span><span class="n">vb</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">nmul</span> <span class="o">=</span> <span class="n">va</span> <span class="o">-</span> <span class="n">vb</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vc</span><span class="p">)</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>
                <span class="k">if</span> <span class="n">denom</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                    <span class="n">n1</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">n1</span><span class="o">*</span><span class="n">nmul</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d1</span> <span class="o">!=</span> <span class="n">dold</span><span class="p">:</span>
                    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">n1</span><span class="p">,</span> <span class="n">d1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">*=</span> <span class="n">nmul</span>

        <span class="n">nexpr</span> <span class="o">=</span> <span class="n">collect_sqrt</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">(</span><span class="n">n</span><span class="p">))</span><span class="o">/</span><span class="n">d</span>
        <span class="k">if</span> <span class="n">changed</span> <span class="ow">or</span> <span class="n">nexpr</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">nexpr</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">G</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Wild</span><span class="p">,</span> <span class="s">&#39;abcDEFG&#39;</span><span class="p">))</span>
    <span class="c"># do this at the start in case no other change is made since</span>
    <span class="c"># it is done if a change is made</span>
    <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>

    <span class="n">newe</span> <span class="o">=</span> <span class="n">handle</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">newe</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
        <span class="n">co</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">newe</span><span class="o">.</span><span class="n">as_content_primitive</span><span class="p">()</span>
        <span class="n">coeff</span> <span class="o">*=</span> <span class="n">co</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nexpr</span><span class="p">,</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">collect_sqrt</span><span class="p">(</span><span class="n">expand_mul</span><span class="p">(</span><span class="n">expr</span><span class="p">),</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">nexpr</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">_from_args</span><span class="p">(</span><span class="n">nexpr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hit</span> <span class="ow">and</span> <span class="n">expr</span><span class="o">.</span><span class="n">count_ops</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">nexpr</span><span class="o">.</span><span class="n">count_ops</span><span class="p">():</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">nexpr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_keep_coeff</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="posify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.posify">[docs]</a><span class="k">def</span> <span class="nf">posify</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return eq (with generic symbols made positive) and a restore</span>
<span class="sd">    dictionary.</span>

<span class="sd">    Any symbol that has positive=None will be replaced with a positive dummy</span>
<span class="sd">    symbol having the same name. This replacement will allow more symbolic</span>
<span class="sd">    processing of expressions, especially those involving powers and</span>
<span class="sd">    logarithms.</span>

<span class="sd">    A dictionary that can be sent to subs to restore eq to its original</span>
<span class="sd">    symbols is also returned.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import posify, Symbol, log</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">    &gt;&gt;&gt; posify(x + Symbol(&#39;p&#39;, positive=True) + Symbol(&#39;n&#39;, negative=True))</span>
<span class="sd">    (_x + n + p, {_x: x})</span>

<span class="sd">    &gt;&gt; log(1/x).expand() # should be log(1/x) but it comes back as -log(x)</span>
<span class="sd">    log(1/x)</span>

<span class="sd">    &gt;&gt;&gt; log(posify(1/x)[0]).expand() # take [0] and ignore replacements</span>
<span class="sd">    -log(_x)</span>
<span class="sd">    &gt;&gt;&gt; eq, rep = posify(1/x)</span>
<span class="sd">    &gt;&gt;&gt; log(eq).expand().subs(rep)</span>
<span class="sd">    -log(x)</span>
<span class="sd">    &gt;&gt;&gt; posify([x, 1 + x])</span>
<span class="sd">    ([_x, _x + 1], {_x: x})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eq</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">))</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">reps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">posify</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
            <span class="n">eq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">eq</span><span class="p">),</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">])</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

</div>
<span class="k">def</span> <span class="nf">_polarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">polar_lift</span><span class="p">,</span> <span class="n">Integral</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_polar</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span>
    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_number</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pause</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">polar_lift</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pause</span> <span class="ow">and</span> <span class="n">lift</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">polar_lift</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span>
    <span class="k">elif</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_polarify</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">lift</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">polar_lift</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">elif</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_polarify</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
        <span class="c"># Don&#39;t lift the integration variable</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">_polarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">function</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="n">pause</span><span class="p">)</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">limit</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">_polarify</span><span class="p">(</span><span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lift</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="n">pause</span><span class="p">)</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="n">_polarify</span><span class="p">(</span><span class="n">limit</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">lift</span><span class="o">=</span><span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="n">pause</span><span class="p">)</span>
            <span class="n">limits</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">var</span><span class="p">,)</span> <span class="o">+</span> <span class="n">rest</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Integral</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">func</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">limits</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_polarify</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">lift</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="n">pause</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">polarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">lift</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turn all numbers in eq into their polar equivalents (under the standard</span>
<span class="sd">    choice of argument).</span>

<span class="sd">    Note that no attempt is made to guess a formal convention of adding</span>
<span class="sd">    polar numbers, expressions like 1 + x will generally not be altered.</span>

<span class="sd">    Note also that this function does not promote exp(x) to exp_polar(x).</span>

<span class="sd">    If ``subs`` is True, all symbols which are not already polar will be</span>
<span class="sd">    substituted for polar dummies; in this case the function behaves much</span>
<span class="sd">    like posify.</span>

<span class="sd">    If ``lift`` is True, both addition statements and non-polar symbols are</span>
<span class="sd">    changed to their polar_lift()ed versions.</span>
<span class="sd">    Note that lift=True implies subs=False.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import polarify, sin, I</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; expr = (-x)**y</span>
<span class="sd">    &gt;&gt;&gt; expr.expand()</span>
<span class="sd">    (-x)**y</span>
<span class="sd">    &gt;&gt;&gt; polarify(expr)</span>
<span class="sd">    ((_x*exp_polar(I*pi))**_y, {_x: x, _y: y})</span>
<span class="sd">    &gt;&gt;&gt; polarify(expr)[0].expand()</span>
<span class="sd">    _x**_y*exp_polar(_y*I*pi)</span>
<span class="sd">    &gt;&gt;&gt; polarify(x, lift=True)</span>
<span class="sd">    polar_lift(x)</span>
<span class="sd">    &gt;&gt;&gt; polarify(x*(1+y), lift=True)</span>
<span class="sd">    polar_lift(x)*polar_lift(y + 1)</span>

<span class="sd">    Adds are treated carefully:</span>

<span class="sd">    &gt;&gt;&gt; polarify(1 + sin((1 + I)*x))</span>
<span class="sd">    (sin(_x*polar_lift(1 + I)) + 1, {_x: x})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lift</span><span class="p">:</span>
        <span class="n">subs</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">_polarify</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">),</span> <span class="n">lift</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">subs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">s</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)])</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">reps</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>


<span class="k">def</span> <span class="nf">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">polar_lift</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">principal_branch</span><span class="p">,</span> <span class="n">pi</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">pause</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp_polar</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">principal_branch</span> <span class="ow">and</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exponents_only</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Boolean</span> <span class="ow">or</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">is_Relational</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">rel_op</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;==&#39;</span><span class="p">,</span> <span class="s">&#39;!=&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span> <span class="ow">or</span>
                <span class="n">eq</span><span class="o">.</span><span class="n">rel_op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;==&#39;</span><span class="p">,</span> <span class="s">&#39;!=&#39;</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_unpolarify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">polar_lift</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">exponents_only</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="n">expo</span> <span class="o">=</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span>
            <span class="ow">not</span> <span class="p">(</span><span class="n">expo</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pause</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">**</span><span class="n">expo</span>

    <span class="k">if</span> <span class="n">eq</span><span class="o">.</span><span class="n">is_Function</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="s">&#39;unbranched&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_unpolarify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">eq</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_unpolarify</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">eq</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">subs</span><span class="o">=</span><span class="p">{},</span> <span class="n">exponents_only</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If p denotes the projection from the Riemann surface of the logarithm to</span>
<span class="sd">    the complex line, return a simplified version eq&#39; of `eq` such that</span>
<span class="sd">    p(eq&#39;) == p(eq).</span>
<span class="sd">    Also apply the substitution subs in the end. (This is a convenience, since</span>
<span class="sd">    ``unpolarify``, in a certain sense, undoes polarify.)</span>

<span class="sd">    &gt;&gt;&gt; from sympy import unpolarify, polar_lift, sin, I</span>
<span class="sd">    &gt;&gt;&gt; unpolarify(polar_lift(I + 2))</span>
<span class="sd">    2 + I</span>
<span class="sd">    &gt;&gt;&gt; unpolarify(sin(polar_lift(I + 7)))</span>
<span class="sd">    sin(7 + I)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp_polar</span><span class="p">,</span> <span class="n">polar_lift</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subs</span> <span class="o">!=</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="n">unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">subs</span><span class="p">))</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">pause</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">exponents_only</span><span class="p">:</span>
        <span class="n">pause</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">_unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">exponents_only</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="o">!=</span> <span class="n">eq</span><span class="p">:</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">res</span>
    <span class="c"># Finally, replacing Exp(0) by 1 is always correct.</span>
    <span class="c"># So is polar_lift(0) -&gt; 0.</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="n">polar_lift</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="mi">0</span><span class="p">})</span>


<span class="k">def</span> <span class="nf">_denest_pow</span><span class="p">(</span><span class="n">eq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Denest powers.</span>

<span class="sd">    This is a helper function for powdenest that performs the actual</span>
<span class="sd">    transformation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>

    <span class="c"># denest exp with log terms in exponent</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Exp1</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ai</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">log</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">ei</span><span class="p">)):</span>
                <span class="n">logs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
        <span class="n">logs</span> <span class="o">=</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">logs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logs</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">))</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">be</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">be</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">or</span>
                            <span class="n">b</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span>
                            <span class="n">b</span><span class="o">.</span><span class="n">is_positive</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="c"># denest eq which is either pos**e or Pow**e or Mul**e or Mul(b1**e1, b2**e2)</span>

    <span class="c"># handle polar numbers specially</span>
    <span class="n">polars</span><span class="p">,</span> <span class="n">nonpolars</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">bb</span><span class="o">.</span><span class="n">is_polar</span><span class="p">:</span>
            <span class="n">polars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bb</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nonpolars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">polars</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">polars</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">polars</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">e</span><span class="p">)</span><span class="o">*</span><span class="n">powdenest</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nonpolars</span><span class="p">)</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">polars</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">powdenest</span><span class="p">(</span><span class="n">bb</span><span class="o">**</span><span class="p">(</span><span class="n">ee</span><span class="o">*</span><span class="n">e</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">ee</span><span class="p">)</span> <span class="ow">in</span> <span class="n">polars</span><span class="p">])</span> \
            <span class="o">*</span><span class="n">powdenest</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nonpolars</span><span class="p">)</span><span class="o">**</span><span class="n">e</span><span class="p">)</span>

    <span class="c"># see if there is a positive, non-Mul base at the very bottom</span>
    <span class="n">exponents</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">eq</span>
    <span class="k">while</span> <span class="n">kernel</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="n">kernel</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
        <span class="n">exponents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">exponents</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">kernel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="c"># use log to see if there is a power here</span>
                <span class="n">logkernel</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">logkernel</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">logk</span> <span class="o">=</span> <span class="n">logkernel</span><span class="o">.</span><span class="n">args</span>
                    <span class="n">e</span> <span class="o">*=</span> <span class="n">c</span>
                    <span class="n">kernel</span> <span class="o">=</span> <span class="n">logk</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

    <span class="c"># if any factor is an atom then there is nothing to be done</span>
    <span class="c"># but the kernel check may have created a new exponent</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_Atom</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">exponents</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">**</span><span class="n">e</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="c"># let log handle the case of the base of the argument being a mul, e.g.</span>
    <span class="c"># sqrt(x**(2*i)*y**(6*i)) -&gt; x**i*y**(3**i) if x and y are positive; we</span>
    <span class="c"># will take the log, expand it, and then factor out the common powers that</span>
    <span class="c"># now appear as coefficient. We do this manually since terms_gcd pulls out</span>
    <span class="c"># fractions, terms_gcd(x+x*y/2) -&gt; x*(y + 2)/2 and we don&#39;t want the 1/2;</span>
    <span class="c"># gcd won&#39;t pull out numerators from a fraction: gcd(3*x, 9*x/2) -&gt; x but</span>
    <span class="c"># we want 3*x. Neither work with noncommutatives.</span>
    <span class="k">def</span> <span class="nf">nc_gcd</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">aa</span><span class="p">,</span> <span class="n">bb</span><span class="p">]]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">(</span><span class="n">cset</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">_keep_coeff</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="n">glogb</span> <span class="o">=</span> <span class="n">expand_log</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">glogb</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">glogb</span><span class="o">.</span><span class="n">args</span>
        <span class="n">g</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">nc_gcd</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cg</span><span class="p">,</span> <span class="n">rg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
            <span class="n">glogb</span> <span class="o">=</span> <span class="n">_keep_coeff</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">rg</span><span class="o">*</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">a</span><span class="o">/</span><span class="n">g</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]))</span>

    <span class="c"># now put the log back together again</span>
    <span class="k">if</span> <span class="n">glogb</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">C</span><span class="o">.</span><span class="n">log</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">glogb</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">glogb</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">glogb</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">:</span>
            <span class="n">glogb</span> <span class="o">=</span> <span class="n">_denest_pow</span><span class="p">(</span><span class="n">glogb</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">glogb</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">glogb</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">glogb</span><span class="o">.</span><span class="n">exp</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eq</span>

    <span class="c"># the log(b) was a Mul so join any adds with logcombine</span>
    <span class="n">add</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">other</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">glogb</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">logcombine</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">add</span><span class="p">))),</span> <span class="n">e</span><span class="o">*</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">))</span>


<div class="viewcode-block" id="powdenest"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.powdenest">[docs]</a><span class="k">def</span> <span class="nf">powdenest</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">polar</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Collect exponents on powers as assumptions allow.</span>

<span class="sd">    Given ``(bb**be)**e``, this can be simplified as follows:</span>
<span class="sd">        * if ``bb`` is positive, or</span>
<span class="sd">        * ``e`` is an integer, or</span>
<span class="sd">        * ``|be| &lt; 1`` then this simplifies to ``bb**(be*e)``</span>

<span class="sd">    Given a product of powers raised to a power, ``(bb1**be1 *</span>
<span class="sd">    bb2**be2...)**e``, simplification can be done as follows:</span>

<span class="sd">    - if e is positive, the gcd of all bei can be joined with e;</span>
<span class="sd">    - all non-negative bb can be separated from those that are negative</span>
<span class="sd">      and their gcd can be joined with e; autosimplification already</span>
<span class="sd">      handles this separation.</span>
<span class="sd">    - integer factors from powers that have integers in the denominator</span>
<span class="sd">      of the exponent can be removed from any term and the gcd of such</span>
<span class="sd">      integers can be joined with e</span>

<span class="sd">    Setting ``force`` to True will make symbols that are not explicitly</span>
<span class="sd">    negative behave as though they are positive, resulting in more</span>
<span class="sd">    denesting.</span>

<span class="sd">    Setting ``polar`` to True will do simplifications on the riemann surface of</span>
<span class="sd">    the logarithm, also resulting in more denestings.</span>

<span class="sd">    When there are sums of logs in exp() then a product of powers may be</span>
<span class="sd">    obtained e.g. ``exp(3*(log(a) + 2*log(b)))`` - &gt; ``a**3*b**6``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, b, x, y, z</span>
<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, exp, log, sqrt, symbols, powdenest</span>

<span class="sd">    &gt;&gt;&gt; powdenest((x**(2*a/3))**(3*x))</span>
<span class="sd">    (x**(2*a/3))**(3*x)</span>
<span class="sd">    &gt;&gt;&gt; powdenest(exp(3*x*log(2)))</span>
<span class="sd">    2**(3*x)</span>

<span class="sd">    Assumptions may prevent expansion:</span>

<span class="sd">    &gt;&gt;&gt; powdenest(sqrt(x**2))</span>
<span class="sd">    sqrt(x**2)</span>

<span class="sd">    &gt;&gt;&gt; p = symbols(&#39;p&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; powdenest(sqrt(p**2))</span>
<span class="sd">    p</span>

<span class="sd">    No other expansion is done.</span>

<span class="sd">    &gt;&gt;&gt; i, j = symbols(&#39;i,j&#39;, integer=True)</span>
<span class="sd">    &gt;&gt;&gt; powdenest((x**x)**(i + j)) # -X-&gt; (x**x)**i*(x**x)**j</span>
<span class="sd">    x**(x*(i + j))</span>

<span class="sd">    But exp() will be denested by moving all non-log terms outside of</span>
<span class="sd">    the function; this may result in the collapsing of the exp to a power</span>
<span class="sd">    with a different base:</span>

<span class="sd">    &gt;&gt;&gt; powdenest(exp(3*y*log(x)))</span>
<span class="sd">    x**(3*y)</span>
<span class="sd">    &gt;&gt;&gt; powdenest(exp(y*(log(a) + log(b))))</span>
<span class="sd">    (a*b)**y</span>
<span class="sd">    &gt;&gt;&gt; powdenest(exp(3*(log(a) + log(b))))</span>
<span class="sd">    a**3*b**3</span>

<span class="sd">    If assumptions allow, symbols can also be moved to the outermost exponent:</span>

<span class="sd">    &gt;&gt;&gt; i = Symbol(&#39;i&#39;, integer=True)</span>
<span class="sd">    &gt;&gt;&gt; p = Symbol(&#39;p&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; powdenest(((x**(2*i))**(3*y))**x)</span>
<span class="sd">    ((x**(2*i))**(3*y))**x</span>
<span class="sd">    &gt;&gt;&gt; powdenest(((x**(2*i))**(3*y))**x, force=True)</span>
<span class="sd">    x**(6*i*x*y)</span>

<span class="sd">    &gt;&gt;&gt; powdenest(((p**(2*a))**(3*y))**x)</span>
<span class="sd">    p**(6*a*x*y)</span>

<span class="sd">    &gt;&gt;&gt; powdenest(((x**(2*a/3))**(3*y/i))**x)</span>
<span class="sd">    ((x**(2*a/3))**(3*y/i))**x</span>
<span class="sd">    &gt;&gt;&gt; powdenest((x**(2*i)*y**(4*i))**z, force=True)</span>
<span class="sd">    (x*y**2)**(2*i*z)</span>

<span class="sd">    &gt;&gt;&gt; n = Symbol(&#39;n&#39;, negative=True)</span>

<span class="sd">    &gt;&gt;&gt; powdenest((x**i)**y, force=True)</span>
<span class="sd">    x**(i*y)</span>
<span class="sd">    &gt;&gt;&gt; powdenest((n**i)**x, force=True)</span>
<span class="sd">    (n**i)**x</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">force</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">posify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">powdenest</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">polar</span><span class="p">:</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">polarify</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unpolarify</span><span class="p">(</span><span class="n">powdenest</span><span class="p">(</span><span class="n">unpolarify</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">exponents_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)),</span> <span class="n">rep</span><span class="p">)</span>

    <span class="n">new</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">sympify</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">new</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">Transform</span><span class="p">(</span><span class="n">_denest_pow</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">m</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">))</span>
</div>
<span class="n">_y</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="powsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.powsimp">[docs]</a><span class="k">def</span> <span class="nf">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">count_ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reduces expression by combining powers with similar bases and exponents.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    If deep is True then powsimp() will also simplify arguments of</span>
<span class="sd">    functions. By default deep is set to False.</span>

<span class="sd">    If force is True then bases will be combined without checking for</span>
<span class="sd">    assumptions, e.g. sqrt(x)*sqrt(y) -&gt; sqrt(x*y) which is not true</span>
<span class="sd">    if x and y are both negative.</span>

<span class="sd">    You can make powsimp() only combine bases or only combine exponents by</span>
<span class="sd">    changing combine=&#39;base&#39; or combine=&#39;exp&#39;.  By default, combine=&#39;all&#39;,</span>
<span class="sd">    which does both.  combine=&#39;base&#39; will only combine::</span>

<span class="sd">         a   a          a                          2x      x</span>
<span class="sd">        x * y  =&gt;  (x*y)   as well as things like 2   =&gt;  4</span>

<span class="sd">    and combine=&#39;exp&#39; will only combine</span>
<span class="sd">    ::</span>

<span class="sd">         a   b      (a + b)</span>
<span class="sd">        x * x  =&gt;  x</span>

<span class="sd">    combine=&#39;exp&#39; will strictly only combine exponents in the way that used</span>
<span class="sd">    to be automatic.  Also use deep=True if you need the old behavior.</span>

<span class="sd">    When combine=&#39;all&#39;, &#39;exp&#39; is evaluated first.  Consider the first</span>
<span class="sd">    example below for when there could be an ambiguity relating to this.</span>
<span class="sd">    This is done so things like the second example can be completely</span>
<span class="sd">    combined.  If you want &#39;base&#39; combined first, do something like</span>
<span class="sd">    powsimp(powsimp(expr, combine=&#39;base&#39;), combine=&#39;exp&#39;).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import powsimp, exp, log, symbols</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y, z, n</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**y*x**z*y**z, combine=&#39;all&#39;)</span>
<span class="sd">    x**(y + z)*y**z</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**y*x**z*y**z, combine=&#39;exp&#39;)</span>
<span class="sd">    x**(y + z)*y**z</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**y*x**z*y**z, combine=&#39;base&#39;, force=True)</span>
<span class="sd">    x**y*(x*y)**z</span>

<span class="sd">    &gt;&gt;&gt; powsimp(x**z*x**y*n**z*n**y, combine=&#39;all&#39;, force=True)</span>
<span class="sd">    (n*x)**(y + z)</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**z*x**y*n**z*n**y, combine=&#39;exp&#39;)</span>
<span class="sd">    n**(y + z)*x**(y + z)</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x**z*x**y*n**z*n**y, combine=&#39;base&#39;, force=True)</span>
<span class="sd">    (n*x)**y*(n*x)**z</span>

<span class="sd">    &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; powsimp(log(exp(x)*exp(y)))</span>
<span class="sd">    log(exp(x)*exp(y))</span>
<span class="sd">    &gt;&gt;&gt; powsimp(log(exp(x)*exp(y)), deep=True)</span>
<span class="sd">    x + y</span>

<span class="sd">    Radicals with Mul bases will be combined if combine=&#39;exp&#39;</span>

<span class="sd">    &gt;&gt;&gt; from sympy import sqrt, Mul</span>
<span class="sd">    &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;)</span>

<span class="sd">    Two radicals are automatically joined through Mul:</span>
<span class="sd">    &gt;&gt;&gt; a=sqrt(x*sqrt(y))</span>
<span class="sd">    &gt;&gt;&gt; a*a**3 == a**4</span>
<span class="sd">    True</span>

<span class="sd">    But if an integer power of that radical has been</span>
<span class="sd">    autoexpanded then Mul does not join the resulting factors:</span>
<span class="sd">    &gt;&gt;&gt; a**4 # auto expands to a Mul, no longer a Pow</span>
<span class="sd">    x**2*y</span>
<span class="sd">    &gt;&gt;&gt; _*a # so Mul doesn&#39;t combine them</span>
<span class="sd">    x**2*y*sqrt(x*sqrt(y))</span>
<span class="sd">    &gt;&gt;&gt; powsimp(_) # but powsimp will</span>
<span class="sd">    (x*sqrt(y))**(5/2)</span>
<span class="sd">    &gt;&gt;&gt; powsimp(x*y*a) # but won&#39;t when doing so would violate assumptions</span>
<span class="sd">    x*y*sqrt(x*sqrt(y))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_deep</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;deep&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
        <span class="n">_combine</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;combine&#39;</span><span class="p">,</span> <span class="n">combine</span><span class="p">)</span>
        <span class="n">_force</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
        <span class="n">_measure</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;measure&#39;</span><span class="p">,</span> <span class="n">measure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_deep</span><span class="p">,</span> <span class="n">_combine</span><span class="p">,</span> <span class="n">_force</span><span class="p">,</span> <span class="n">_measure</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">)</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="ow">or</span> <span class="n">expr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">exp_polar</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">exp_polar</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">if</span> <span class="n">deep</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="n">_y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">recurse</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">recurse</span><span class="p">(</span><span class="n">expr</span><span class="o">*</span><span class="n">_y</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">/</span><span class="n">_y</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># handle the Mul</span>

    <span class="k">if</span> <span class="n">combine</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;exp&#39;</span><span class="p">,</span> <span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="c"># Collect base/exp data, while maintaining order in the</span>
        <span class="c"># non-commutative parts of the product</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">nc_part</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                    <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="p">[</span><span class="n">recurse</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">]]</span>
                <span class="n">c_powers</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># This is the logic that combines exponents for equal,</span>
                <span class="c"># but non-commutative bases: A**x*A**y == A**(x+y).</span>
                <span class="k">if</span> <span class="n">nc_part</span><span class="p">:</span>
                    <span class="n">b1</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="n">b2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span> <span class="ow">and</span>
                            <span class="n">e1</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">and</span> <span class="n">e2</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">):</span>
                        <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">Add</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
                        <span class="k">continue</span>
                <span class="n">nc_part</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

        <span class="c"># add up exponents of common bases</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">c_powers</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">)</span>

        <span class="c"># check for base and inverted base pairs</span>
        <span class="n">be</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c"># skip if we already saw them</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">be</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">skip</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">bpos</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_polar</span>
            <span class="k">if</span> <span class="n">bpos</span><span class="p">:</span>
                <span class="n">binv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">b</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">binv</span> <span class="ow">and</span> <span class="n">binv</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                        <span class="n">c_powers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                        <span class="n">c_powers</span><span class="p">[</span><span class="n">binv</span><span class="p">]</span> <span class="o">-=</span> <span class="n">e</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">skip</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">binv</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">binv</span><span class="p">)</span>
                        <span class="n">c_powers</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-=</span> <span class="n">e</span>

        <span class="c"># filter c_powers and convert to a list</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span><span class="p">]</span>

        <span class="c"># ==============================================================</span>
        <span class="c"># check for Mul bases of Rational powers that can be combined with</span>
        <span class="c"># separated bases, e.g. x*sqrt(x*y)*sqrt(x*sqrt(x*y)) -&gt; (x*sqrt(x*y))**(3/2)</span>
        <span class="c"># ---------------- helper functions</span>
        <span class="k">def</span> <span class="nf">ratq</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;Return Rational part of x&#39;s exponent as it appears in the bkey.</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">return</span> <span class="n">bkey</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">bkey</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;Return (b**s, c.q), c.p where e -&gt; c*s. If e is not given then</span>
<span class="sd">            it will be taken by using as_base_exp() on the input b.</span>
<span class="sd">            e.g.</span>
<span class="sd">                x**3/2 -&gt; (x, 2), 3</span>
<span class="sd">                x**y -&gt; (x**y, 1), 1</span>
<span class="sd">                x**(2*y/3) -&gt; (x**y, 3), 2</span>
<span class="sd">                exp(x/2) -&gt; (exp(a), 2), 1</span>

<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># coming from c_powers or from below</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span> <span class="n">e</span>
                <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Integer</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">q</span><span class="p">)),</span> <span class="n">Integer</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="n">m</span><span class="p">,</span> <span class="n">Integer</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">q</span><span class="p">)),</span> <span class="n">Integer</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="o">**</span><span class="n">e</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">bkey</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;Decide what to do with base, b. If its exponent is now an</span>
<span class="sd">            integer multiple of the Rational denominator, then remove it</span>
<span class="sd">            and put the factors of its base in the common_b dictionary or</span>
<span class="sd">            update the existing bases if necessary. If it has been zeroed</span>
<span class="sd">            out, simply remove the base.</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">newe</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">common_b</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">common_b</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newe</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">newe</span><span class="p">):</span>
                        <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">bkey</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_b</span><span class="p">:</span>
                            <span class="n">common_b</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">common_b</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="n">e</span>
                        <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c"># ---------------- end of helper functions</span>

        <span class="c"># assemble a dictionary of the factors having a Rational power</span>
        <span class="n">common_b</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">done</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">bkey</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="n">common_b</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">bases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">bases</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>  <span class="c"># this makes tie-breaking canonical</span>
        <span class="n">bases</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">measure</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c"># handle longest first</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">base</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_b</span><span class="p">:</span>  <span class="c"># it may have been removed already</span>
                <span class="k">continue</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">exponent</span> <span class="o">=</span> <span class="n">base</span>
            <span class="n">last</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># True when no factor of base is a radical</span>
            <span class="n">qlcm</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c"># the lcm of the radical denominators</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">bstart</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">qstart</span> <span class="o">=</span> <span class="n">qlcm</span>

                <span class="n">bb</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># list of factors</span>
                <span class="n">ee</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># (factor&#39;s exponent, current value of that exponent in common_b)</span>
                <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="n">bib</span><span class="p">,</span> <span class="n">bie</span> <span class="o">=</span> <span class="n">bkey</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bib</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_b</span> <span class="ow">or</span> <span class="n">common_b</span><span class="p">[</span><span class="n">bib</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bie</span><span class="p">:</span>
                        <span class="n">ee</span> <span class="o">=</span> <span class="n">bb</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># failed</span>
                        <span class="k">break</span>
                    <span class="n">ee</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bie</span><span class="p">,</span> <span class="n">common_b</span><span class="p">[</span><span class="n">bib</span><span class="p">]])</span>
                    <span class="n">bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bib</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ee</span><span class="p">:</span>
                    <span class="c"># find the number of extractions possible</span>
                    <span class="c"># e.g. [(1, 2), (2, 2)] -&gt; min(2/1, 2/2) -&gt; 1</span>
                    <span class="n">min1</span> <span class="o">=</span> <span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">ee</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ee</span><span class="p">)):</span>
                        <span class="n">rat</span> <span class="o">=</span> <span class="n">ee</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">ee</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">rat</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">break</span>
                        <span class="n">min1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min1</span><span class="p">,</span> <span class="n">rat</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># update base factor counts</span>
                        <span class="c"># e.g. if ee = [(2, 5), (3, 6)] then min1 = 2</span>
                        <span class="c"># and the new base counts will be 5-2*2 and 6-2*3</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bb</span><span class="p">)):</span>
                            <span class="n">common_b</span><span class="p">[</span><span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">min1</span><span class="o">*</span><span class="n">ee</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">update</span><span class="p">(</span><span class="n">bb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="c"># update the count of the base</span>
                        <span class="c"># e.g. x**2*y*sqrt(x*sqrt(y)) the count of x*sqrt(y)</span>
                        <span class="c"># will increase by 4 to give bkey (x*sqrt(y), 2, 5)</span>
                        <span class="n">common_b</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">+=</span> <span class="n">min1</span><span class="o">*</span><span class="n">qstart</span><span class="o">*</span><span class="n">exponent</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">last</span>  <span class="c"># no more radicals in base</span>
                    <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c"># nothing left to join with</span>
                    <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">common_b</span><span class="p">)</span>  <span class="c"># no radicals left in common_b</span>
                        <span class="p">):</span>
                    <span class="k">break</span>
                <span class="c"># see what we can exponentiate base by to remove any radicals</span>
                <span class="c"># so we know what to search for</span>
                <span class="c"># e.g. if base were x**(1/2)*y**(1/3) then we should exponentiate</span>
                <span class="c"># by 6 and look for powers of x and y in the ratio of 2 to 3</span>
                <span class="n">qlcm</span> <span class="o">=</span> <span class="n">lcm</span><span class="p">([</span><span class="n">ratq</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span> <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">bstart</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">qlcm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>  <span class="c"># we are done</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">bstart</span><span class="o">**</span><span class="n">qlcm</span>
                <span class="n">qlcm</span> <span class="o">*=</span> <span class="n">qstart</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">ratq</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
                    <span class="n">last</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c"># we are going to be done after this next pass</span>
            <span class="c"># this base no longer can find anything to join with and</span>
            <span class="c"># since it was longer than any other we are done with it</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">base</span>
            <span class="n">done</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">common_b</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">*</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="p">)))</span>

        <span class="c"># update c_powers and get ready to continue with powsimp</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="n">done</span>
        <span class="c"># there may be terms still in common_b that were bases that were</span>
        <span class="c"># identified as needing processing, so remove those, too</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">common_b</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">exp</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">be</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">**</span><span class="p">(</span><span class="n">be</span><span class="o">/</span><span class="n">q</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">c_powers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
        <span class="n">check</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)</span> <span class="o">==</span> <span class="n">check</span>  <span class="c"># there should have been no duplicates</span>
        <span class="c"># ==============================================================</span>

        <span class="c"># rebuild the expression</span>
        <span class="n">newexpr</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span>
            <span class="o">*</span><span class="p">(</span><span class="n">newexpr</span> <span class="o">+</span> <span class="p">[</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">()]))</span>
        <span class="k">if</span> <span class="n">combine</span> <span class="o">==</span> <span class="s">&#39;exp&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">newexpr</span><span class="p">,</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nc_part</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">recurse</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">nc_part</span><span class="p">),</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;base&#39;</span><span class="p">)</span> <span class="o">*</span> \
                <span class="n">recurse</span><span class="p">(</span><span class="n">newexpr</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;base&#39;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">combine</span> <span class="o">==</span> <span class="s">&#39;base&#39;</span><span class="p">:</span>

        <span class="c"># Build c_powers and nc_part.  These must both be lists not</span>
        <span class="c"># dicts because exp&#39;s are not combined.</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nc_part</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">term</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">c_powers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># This is the logic that combines bases that are</span>
                <span class="c"># different and non-commutative, but with equal and</span>
                <span class="c"># commutative exponents: A**x*B**x == (A*B)**x.</span>
                <span class="k">if</span> <span class="n">nc_part</span><span class="p">:</span>
                    <span class="n">b1</span><span class="p">,</span> <span class="n">e1</span> <span class="o">=</span> <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="n">b2</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span> <span class="ow">and</span> <span class="n">e2</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">):</span>
                        <span class="n">nc_part</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">),</span> <span class="n">e1</span><span class="p">)</span>
                        <span class="k">continue</span>
                <span class="n">nc_part</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>

        <span class="c"># Pull out numerical coefficients from exponent if assumptions allow</span>
        <span class="c"># e.g., 2**(2*x) =&gt; 4**x</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c_powers</span><span class="p">)):</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">c_powers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">or</span> <span class="n">force</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_polar</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">exp_c</span><span class="p">,</span> <span class="n">exp_t</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">(</span><span class="n">rational</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exp_c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="ow">and</span> <span class="n">exp_t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="n">c_powers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">exp_c</span><span class="p">),</span> <span class="n">exp_t</span><span class="p">]</span>

        <span class="c"># Combine bases whenever they have the same exponent and</span>
        <span class="c"># assumptions allow</span>
        <span class="c"># first gather the potential bases under the common exponent</span>
        <span class="n">c_exp</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">deep</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">recurse</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">c_exp</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">c_powers</span>

        <span class="c"># Merge back in the results of the above to form a new product</span>
        <span class="n">c_powers</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_exp</span><span class="p">:</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">c_exp</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>

            <span class="c"># calculate the new base for e</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_base</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">e</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
                <span class="n">new_base</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">bases</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># see which ones can be joined</span>
                <span class="n">unk</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">nonneg</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">bi</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bi</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                        <span class="n">neg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bi</span><span class="o">.</span><span class="n">is_nonnegative</span><span class="p">:</span>
                        <span class="n">nonneg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">bi</span><span class="o">.</span><span class="n">is_polar</span><span class="p">:</span>
                        <span class="n">nonneg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">bi</span><span class="p">)</span>  <span class="c"># polar can be treated like non-negative</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">unk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bi</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">neg</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">unk</span><span class="p">:</span>
                    <span class="c"># a single neg or a single unk can join the rest</span>
                    <span class="n">nonneg</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">unk</span> <span class="o">+</span> <span class="n">neg</span><span class="p">)</span>
                    <span class="n">unk</span> <span class="o">=</span> <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">elif</span> <span class="n">neg</span><span class="p">:</span>
                    <span class="c"># their negative signs cancel in groups of 2*q if we know</span>
                    <span class="c"># that e = p/q else we have to treat them as unknown</span>
                    <span class="n">israt</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                        <span class="n">israt</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_integer</span> <span class="ow">and</span> <span class="n">d</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
                            <span class="n">israt</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">israt</span><span class="p">:</span>
                        <span class="n">neg</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">neg</span><span class="p">]</span>
                        <span class="n">unk</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">neg</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">unk</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neg</span><span class="p">)</span>
                        <span class="n">neg</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">del</span> <span class="n">israt</span>

                <span class="c"># these shouldn&#39;t be joined</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">unk</span><span class="p">:</span>
                    <span class="n">c_powers</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="c"># here is a new joined base</span>
                <span class="n">new_base</span> <span class="o">=</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">nonneg</span> <span class="o">+</span> <span class="n">neg</span><span class="p">))</span>
                <span class="c"># if there are positive parts they will just get separated again</span>
                <span class="c"># unless some change is made</span>

                <span class="k">def</span> <span class="nf">_terms</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="c"># return the number of terms of this expression</span>
                    <span class="c"># when multiplied out -- assuming no joining of terms</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">_terms</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">prod</span><span class="p">([</span><span class="n">_terms</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span> <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
                    <span class="k">return</span> <span class="mi">1</span>
                <span class="n">xnew_base</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">new_base</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">xnew_base</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">_terms</span><span class="p">(</span><span class="n">new_base</span><span class="p">):</span>
                    <span class="n">new_base</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">xnew_base</span><span class="p">)</span>

            <span class="n">c_powers</span><span class="p">[</span><span class="n">new_base</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="c"># break out the powers from c_powers now</span>
        <span class="n">c_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">Pow</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ei</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c_powers</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">ei</span> <span class="ow">in</span> <span class="n">e</span><span class="p">]</span>

        <span class="c"># we&#39;re done</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">c_part</span> <span class="o">+</span> <span class="n">nc_part</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;combine must be one of (&#39;all&#39;, &#39;exp&#39;, &#39;base&#39;).&quot;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="hypersimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.hypersimp">[docs]</a><span class="k">def</span> <span class="nf">hypersimp</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given combinatorial term f(k) simplify its consecutive term ratio</span>
<span class="sd">       i.e. f(k+1)/f(k).  The input term can be composed of functions and</span>
<span class="sd">       integer sequences which have equivalent representation in terms</span>
<span class="sd">       of gamma special function.</span>

<span class="sd">       The algorithm performs three basic steps:</span>

<span class="sd">       1. Rewrite all functions in terms of gamma, if possible.</span>

<span class="sd">       2. Rewrite all occurrences of gamma in terms of products</span>
<span class="sd">          of gamma and rising factorial with integer,  absolute</span>
<span class="sd">          constant exponent.</span>

<span class="sd">       3. Perform simplification of nested fractions, powers</span>
<span class="sd">          and if the resulting expression is a quotient of</span>
<span class="sd">          polynomials, reduce their total degree.</span>

<span class="sd">       If f(k) is hypergeometric then as result we arrive with a</span>
<span class="sd">       quotient of polynomials of minimal degree. Otherwise None</span>
<span class="sd">       is returned.</span>

<span class="sd">       For more information on the implemented algorithm refer to:</span>

<span class="sd">       1. W. Koepf, Algorithms for m-fold Hypergeometric Summation,</span>
<span class="sd">          Journal of Symbolic Computation (1995) 20, 399-417</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">f</span>

    <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">expand_func</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<div class="viewcode-block" id="hypersimilar"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.hypersimilar">[docs]</a><span class="k">def</span> <span class="nf">hypersimilar</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if &#39;f&#39; and &#39;g&#39; are hyper-similar.</span>

<span class="sd">       Similarity in hypergeometric sense means that a quotient of</span>
<span class="sd">       f(k) and g(k) is a rational function in k.  This procedure</span>
<span class="sd">       is useful in solving recurrence relations.</span>

<span class="sd">       For more information see hypersimp().</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)))</span>

    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">/</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">is_rational_function</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</div>
<span class="kn">from</span> <span class="nn">sympy.utilities.timeutils</span> <span class="kn">import</span> <span class="n">timethis</span>


<span class="nd">@timethis</span><span class="p">(</span><span class="s">&#39;combsimp&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="combsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.combsimp">[docs]</a><span class="k">def</span> <span class="nf">combsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Simplify combinatorial expressions.</span>

<span class="sd">    This function takes as input an expression containing factorials,</span>
<span class="sd">    binomials, Pochhammer symbol and other &quot;combinatorial&quot; functions,</span>
<span class="sd">    and tries to minimize the number of those functions and reduce</span>
<span class="sd">    the size of their arguments. The result is be given in terms of</span>
<span class="sd">    binomials and factorials.</span>

<span class="sd">    The algorithm works by rewriting all combinatorial functions as</span>
<span class="sd">    expressions involving rising factorials (Pochhammer symbols) and</span>
<span class="sd">    applies recurrence relations and other transformations applicable</span>
<span class="sd">    to rising factorials, to reduce their arguments, possibly letting</span>
<span class="sd">    the resulting rising factorial to cancel. Rising factorials with</span>
<span class="sd">    the second argument being an integer are expanded into polynomial</span>
<span class="sd">    forms and finally all other rising factorial are rewritten in terms</span>
<span class="sd">    more familiar functions. If the initial expression contained any</span>
<span class="sd">    combinatorial functions, the result is expressed using binomial</span>
<span class="sd">    coefficients and gamma functions. If the initial expression consisted</span>
<span class="sd">    of gamma functions alone, the result is expressed in terms of gamma</span>
<span class="sd">    functions.</span>

<span class="sd">    If the result is expressed using gamma functions, the following three</span>
<span class="sd">    additional steps are performed:</span>

<span class="sd">    1. Reduce the number of gammas by applying the reflection theorem</span>
<span class="sd">       gamma(x)*gamma(1-x) == pi/sin(pi*x).</span>
<span class="sd">    2. Reduce the number of gammas by applying the multiplication theorem</span>
<span class="sd">       gamma(x)*gamma(x+1/n)*...*gamma(x+(n-1)/n) == C*gamma(n*x).</span>
<span class="sd">    3. Reduce the number of prefactors by absorbing them into gammas, where</span>
<span class="sd">       possible.</span>

<span class="sd">    All transformation rules can be found (or was derived from) here:</span>

<span class="sd">    1. http://functions.wolfram.com/GammaBetaErf/Pochhammer/17/01/02/</span>
<span class="sd">    2. http://functions.wolfram.com/GammaBetaErf/Pochhammer/27/01/0005/</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.simplify import combsimp</span>
<span class="sd">    &gt;&gt;&gt; from sympy import factorial, binomial</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import n, k</span>

<span class="sd">    &gt;&gt;&gt; combsimp(factorial(n)/factorial(n - 3))</span>
<span class="sd">    n*(n - 2)*(n - 1)</span>
<span class="sd">    &gt;&gt;&gt; combsimp(binomial(n+1, k+1)/binomial(n, k))</span>
<span class="sd">    (n + 1)/(k + 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">factorial</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">factorial</span>
    <span class="n">binomial</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">binomial</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">gamma</span>

    <span class="c"># as a rule of thumb, if the expression contained gammas initially, it</span>
    <span class="c"># probably makes sense to retain them</span>
    <span class="n">as_gamma</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span> <span class="n">binomial</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">rf</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">b</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

                <span class="n">n</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">*=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">i</span>

                    <span class="k">return</span> <span class="n">result</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">*=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">i</span>

                    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="n">result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">_b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">rf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">*</span><span class="n">rf</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">_b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">rf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_b</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">_b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">_a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">rf</span><span class="p">(</span><span class="n">_a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">_a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">binomial</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">rf</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">k</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">factorial</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span>
        <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">rf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()))</span>

    <span class="k">if</span> <span class="n">as_gamma</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">gamma</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="n">gamma</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">binomial</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">rule</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">coeff</span><span class="p">,</span> <span class="n">rewrite</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">False</span>

        <span class="n">cn</span><span class="p">,</span> <span class="n">_n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">_n</span> <span class="ow">and</span> <span class="n">cn</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">cn</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">*=</span> <span class="n">rf</span><span class="p">(</span><span class="n">_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cn</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">_n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cn</span><span class="p">)</span>
            <span class="n">rewrite</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">_n</span>

        <span class="c"># this sort of binomial has already been removed by</span>
        <span class="c"># rising factorials but is left here in case the order</span>
        <span class="c"># of rule application is changed</span>
        <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">ck</span><span class="p">,</span> <span class="n">_k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">_k</span> <span class="ow">and</span> <span class="n">ck</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">ck</span><span class="p">:</span>
                <span class="n">coeff</span> <span class="o">*=</span> <span class="n">rf</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">ck</span> <span class="o">-</span> <span class="n">_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ck</span><span class="p">)</span><span class="o">/</span><span class="n">rf</span><span class="p">(</span><span class="n">_k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ck</span><span class="p">)</span>
                <span class="n">rewrite</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">_k</span>

        <span class="k">if</span> <span class="n">rewrite</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coeff</span><span class="o">*</span><span class="n">binomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">binomial</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rule_gamma</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simplify products of gamma functions further. &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">rule_gamma</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="n">numer_gammas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">denom_gammas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">denom_others</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">newargs</span><span class="p">,</span> <span class="n">numer_others</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>

        <span class="c"># order newargs canonically</span>
        <span class="n">cexpr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span>
        <span class="n">newargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cexpr</span><span class="o">.</span><span class="n">_sorted_args</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">cexpr</span><span class="o">.</span><span class="n">is_Atom</span> <span class="k">else</span> <span class="p">[</span><span class="n">cexpr</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">cexpr</span>

        <span class="k">while</span> <span class="n">newargs</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">newargs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
                    <span class="n">barg</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">numer_gammas</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">barg</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">denom_gammas</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">barg</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">numer_others</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">denom_others</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">b</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numer_others</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="c"># Try to reduce the number of gamma factors by applying the</span>
        <span class="c"># reflection formula gamma(x)*gamma(1-x) = pi/sin(pi*x)</span>
        <span class="k">for</span> <span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span>
            <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">gammas</span><span class="p">:</span>
                <span class="n">g1</span> <span class="o">=</span> <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">g1</span><span class="o">.</span><span class="n">is_integer</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gammas</span><span class="p">):</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">g2</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">)</span>
                    <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="o">*</span><span class="n">g1</span><span class="p">))</span>
                    <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">g1</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">):</span>
                            <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">g1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g1</span><span class="p">)</span>
            <span class="c"># /!\ updating IN PLACE</span>
            <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new</span>

        <span class="c"># Try to reduce the number of gamma factors by applying the</span>
        <span class="c"># multiplication theorem.</span>

        <span class="k">def</span> <span class="nf">_run</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
            <span class="c"># find runs in coeffs such that the difference in terms (mod 1)</span>
            <span class="c"># of t1, t2, ..., tn is 1/n</span>
            <span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">uniq</span>
            <span class="n">u</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
                <span class="n">dj</span> <span class="o">=</span> <span class="p">([((</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))])</span>
                <span class="k">for</span> <span class="n">one</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dj</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">one</span><span class="o">.</span><span class="n">p</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span>
                        <span class="n">got</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">get</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dj</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">d</span>
                            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">get</span><span class="p">:</span>
                                <span class="n">get</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                                <span class="n">got</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">get</span><span class="p">:</span>
                                    <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">got</span><span class="p">):</span>
                            <span class="n">c</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                            <span class="n">coeffs</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                            <span class="n">got</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                        <span class="k">return</span> <span class="n">one</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">got</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">got</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">def</span> <span class="nf">_mult_thm</span><span class="p">(</span><span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">):</span>
            <span class="c"># pull off and analyze the leading coefficient from each gamma arg</span>
            <span class="c"># looking for runs in those Rationals</span>

            <span class="c"># expr -&gt; coeff + resid -&gt; rats[resid] = coeff</span>
            <span class="n">rats</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gammas</span><span class="p">:</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">resid</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">as_coeff_Add</span><span class="p">()</span>
                <span class="n">rats</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="c"># look for runs in Rationals for each resid</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rats</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">resid</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">coeffs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]))</span>
                <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">run</span> <span class="o">=</span> <span class="n">_run</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">run</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="c"># process the sequence that was found:</span>
                    <span class="c"># 1) convert all the gamma functions to have the right</span>
                    <span class="c">#    argument (could be off by an integer)</span>
                    <span class="c"># 2) append the factors corresponding to the theorem</span>
                    <span class="c"># 3) append the new gamma function</span>

                    <span class="n">n</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">run</span>

                    <span class="c"># (1)</span>
                    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                        <span class="n">con</span> <span class="o">=</span> <span class="n">resid</span> <span class="o">+</span> <span class="n">u</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">ui</span><span class="p">)):</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>

                    <span class="n">con</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">resid</span> <span class="o">+</span> <span class="n">ui</span><span class="p">)</span>  <span class="c"># for (2) and (3)</span>

                    <span class="c"># (2)</span>
                    <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span>
                                 <span class="n">n</span><span class="o">**</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">con</span><span class="p">))</span>
                    <span class="c"># (3)</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">con</span><span class="p">)</span>

                <span class="c"># restore resid to coeffs</span>
                <span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">resid</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">]</span> <span class="o">+</span> <span class="n">new</span>

            <span class="c"># rebuild the gamma arguments</span>
            <span class="n">g</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">resid</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">+=</span> <span class="n">rats</span><span class="p">[</span><span class="n">resid</span><span class="p">]</span>
            <span class="c"># /!\ updating IN PLACE</span>
            <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">g</span>

        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                                <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
            <span class="n">_mult_thm</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span><span class="p">)</span>

        <span class="c"># Try to reduce the number of gammas by using the duplication</span>
        <span class="c"># theorem to cancel an upper and lower.</span>
        <span class="c"># e.g. gamma(2*s)/gamma(s) = gamma(s)*gamma(s+1/2)*C/gamma(s)</span>
        <span class="c"># (in principle this can also be done with with factors other than two,</span>
        <span class="c">#  but two is special in that we need only matching numer and denom, not</span>
        <span class="c">#  several in numer).</span>
        <span class="k">for</span> <span class="n">ng</span><span class="p">,</span> <span class="n">dg</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">do</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">numer_gammas</span><span class="p">,</span> <span class="n">denom_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span>
                                <span class="n">denom_others</span><span class="p">),</span>
                               <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span>
                                <span class="n">numer_others</span><span class="p">)]:</span>

            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ng</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dg</span><span class="p">:</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">ng</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">dg</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">):</span>
                        <span class="n">do</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
                <span class="n">ng</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">no</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">do</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Pi</span><span class="p">))</span>

        <span class="c"># Try to absorb factors into the gammas.</span>
        <span class="c"># This code (in particular repeated calls to find_fuzzy) can be very</span>
        <span class="c"># slow.</span>
        <span class="k">def</span> <span class="nf">find_fuzzy</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
            <span class="n">S1</span><span class="p">,</span> <span class="n">T1</span> <span class="o">=</span> <span class="n">compute_ST</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">S2</span><span class="p">,</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">inv</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">T1</span> <span class="o">!=</span> <span class="n">T2</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">S1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span> <span class="ow">and</span>
                                <span class="p">(</span><span class="n">S1</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S2</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">())):</span>
                    <span class="k">continue</span>
                <span class="c"># XXX we want some simplification (e.g. cancel or</span>
                <span class="c"># simplify) but no matter what it&#39;s slow.</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cancel</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
                <span class="c"># TODO is there a better heuristic?</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">y</span>

        <span class="c"># We thus try to avoid expensive calls by building the following</span>
        <span class="c"># &quot;invariants&quot;: For every factor or gamma function argument</span>
        <span class="c">#   - the set of free symbols S</span>
        <span class="c">#   - the set of functional components T</span>
        <span class="c"># We will only try to absorb if T1==T2 and (S1 intersect S2 != emptyset</span>
        <span class="c"># or S1 == S2 == emptyset)</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">compute_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Pow</span>
            <span class="k">if</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">inv</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">inv</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Function</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                    <span class="nb">set</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">exp</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Pow</span><span class="p">))))</span>

        <span class="k">def</span> <span class="nf">update_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="n">inv</span><span class="p">[</span><span class="n">expr</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">numer_gammas</span> <span class="o">+</span> <span class="n">denom_gammas</span> <span class="o">+</span> <span class="n">numer_others</span> <span class="o">+</span> <span class="n">denom_others</span><span class="p">:</span>
            <span class="n">update_ST</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">gammas</span><span class="p">,</span> <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="ow">in</span> <span class="p">[(</span>
            <span class="n">numer_gammas</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">),</span>
                <span class="p">(</span><span class="n">denom_gammas</span><span class="p">,</span> <span class="n">denom_others</span><span class="p">,</span> <span class="n">numer_others</span><span class="p">)]:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">gammas</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">gammas</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">while</span> <span class="n">cont</span><span class="p">:</span>
                    <span class="n">cont</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">find_fuzzy</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">numer</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">g</span><span class="p">:</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
                            <span class="n">update_ST</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
                        <span class="n">g</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">find_fuzzy</span><span class="p">(</span><span class="n">numer</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">numer</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
                            <span class="n">update_ST</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
                        <span class="n">g</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">find_fuzzy</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">g</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">denom</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">/</span><span class="n">g</span><span class="p">:</span>
                            <span class="n">denom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">g</span><span class="p">)</span>
                            <span class="n">update_ST</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">g</span><span class="p">)</span>
                        <span class="n">g</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">find_fuzzy</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">denom</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">numer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
                            <span class="n">update_ST</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>
                        <span class="n">g</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">cont</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
            <span class="c"># /!\ updating IN PLACE</span>
            <span class="n">gammas</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new</span>

        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">gamma</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">numer_gammas</span><span class="p">])</span> \
            <span class="o">/</span> <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">gamma</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">denom_gammas</span><span class="p">])</span> \
            <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">numer_others</span><span class="p">)</span> <span class="o">/</span> <span class="n">C</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">denom_others</span><span class="p">)</span>

    <span class="c"># (for some reason we cannot use Basic.replace in this case)</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">rule_gamma</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">factor</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">signsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make all Add sub-expressions canonical wrt sign.</span>

<span class="sd">    If an Add subexpression, ``a``, can have a sign extracted,</span>
<span class="sd">    as determined by could_extract_minus_sign, it is replaced</span>
<span class="sd">    with Mul(-1, a, evaluate=False). This allows signs to be</span>
<span class="sd">    extracted from powers and products.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import signsimp, exp</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; n = -1 + 1/x</span>
<span class="sd">    &gt;&gt;&gt; n/x/(-n)**2 - 1/n/x</span>
<span class="sd">    (-1 + 1/x)/(x*(1 - 1/x)**2) - 1/(x*(-1 + 1/x))</span>
<span class="sd">    &gt;&gt;&gt; signsimp(_)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; x*n + x*-n</span>
<span class="sd">    x*(-1 + 1/x) + x*(1 - 1/x)</span>
<span class="sd">    &gt;&gt;&gt; signsimp(_)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; n**3</span>
<span class="sd">    (-1 + 1/x)**3</span>
<span class="sd">    &gt;&gt;&gt; signsimp(_)</span>
<span class="sd">    -(1 - 1/x)**3</span>

<span class="sd">    By default, signsimp doesn&#39;t leave behind any hollow simplification:</span>
<span class="sd">    if making an Add canonical wrt sign didn&#39;t change the expression, the</span>
<span class="sd">    original Add is restored. If this is not desired then the keyword</span>
<span class="sd">    ``evaluate`` can be set to False:</span>

<span class="sd">    &gt;&gt;&gt; e = exp(y - x)</span>
<span class="sd">    &gt;&gt;&gt; signsimp(e) == e</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; signsimp(e, evaluate=False)</span>
<span class="sd">    exp(-(x - y))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">sub_post</span><span class="p">(</span><span class="n">sub_pre</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">Expr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>
    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">signsimp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="nb">dict</span><span class="p">([(</span><span class="n">m</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Mul</span><span class="p">)</span> <span class="k">if</span> <span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">e</span>


<div class="viewcode-block" id="simplify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.simplify">[docs]</a><span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mf">1.7</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">count_ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplifies the given expression.</span>

<span class="sd">    Simplification is not a well defined term and the exact strategies</span>
<span class="sd">    this function tries can change in the future versions of SymPy. If</span>
<span class="sd">    your algorithm relies on &quot;simplification&quot; (whatever it is), try to</span>
<span class="sd">    determine what you need exactly  -  is it powsimp()?, radsimp()?,</span>
<span class="sd">    together()?, logcombine()?, or something else? And use this particular</span>
<span class="sd">    function directly, because those are well defined and thus your algorithm</span>
<span class="sd">    will be robust.</span>

<span class="sd">    Nonetheless, especially for interactive use, or when you don&#39;t know</span>
<span class="sd">    anything about the structure of the expression, simplify() tries to apply</span>
<span class="sd">    intelligent heuristics to make the input expression &quot;simpler&quot;.  For</span>
<span class="sd">    example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import simplify, cos, sin</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">    &gt;&gt;&gt; a = (x + x**2)/(x*sin(y)**2 + x*cos(y)**2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    (x**2 + x)/(x*sin(y)**2 + x*cos(y)**2)</span>
<span class="sd">    &gt;&gt;&gt; simplify(a)</span>
<span class="sd">    x + 1</span>

<span class="sd">    Note that we could have obtained the same result by using specific</span>
<span class="sd">    simplification functions:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import trigsimp, cancel</span>
<span class="sd">    &gt;&gt;&gt; b = trigsimp(a)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    (x**2 + x)/x</span>
<span class="sd">    &gt;&gt;&gt; c = cancel(b)</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    x + 1</span>

<span class="sd">    In some cases, applying :func:`simplify` may actually result in some more</span>
<span class="sd">    complicated expression. The default ``ratio=1.7`` prevents more extreme</span>
<span class="sd">    cases: if (result length)/(input length) &gt; ratio, then input is returned</span>
<span class="sd">    unmodified.  The ``measure`` parameter lets you specify the function used</span>
<span class="sd">    to determine how complex an expression is.  The function should take a</span>
<span class="sd">    single argument as an expression and return a number such that if</span>
<span class="sd">    expression ``a`` is more complex than expression ``b``, then</span>
<span class="sd">    ``measure(a) &gt; measure(b)``.  The default measure function is</span>
<span class="sd">    :func:`count_ops`, which returns the total number of operations in the</span>
<span class="sd">    expression.</span>

<span class="sd">    For example, if ``ratio=1``, ``simplify`` output can&#39;t be longer</span>
<span class="sd">    than input.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, simplify, count_ops, oo</span>
<span class="sd">        &gt;&gt;&gt; root = 1/(sqrt(2)+3)</span>

<span class="sd">    Since ``simplify(root)`` would result in a slightly longer expression,</span>
<span class="sd">    root is returned unchanged instead::</span>

<span class="sd">       &gt;&gt;&gt; simplify(root, ratio=1) == root</span>
<span class="sd">       True</span>

<span class="sd">    If ``ratio=oo``, simplify will be applied anyway::</span>

<span class="sd">        &gt;&gt;&gt; count_ops(simplify(root, ratio=oo)) &gt; count_ops(root)</span>
<span class="sd">        True</span>

<span class="sd">    Note that the shortest expression is not necessary the simplest, so</span>
<span class="sd">    setting ``ratio`` to 1 may not be a good idea.</span>
<span class="sd">    Heuristically, the default value ``ratio=1.7`` seems like a reasonable</span>
<span class="sd">    choice.</span>

<span class="sd">    You can easily define your own measure function based on what you feel</span>
<span class="sd">    should represent the &quot;size&quot; or &quot;complexity&quot; of the input expression.  Note</span>
<span class="sd">    that some choices, such as ``lambda expr: len(str(expr))`` may appear to be</span>
<span class="sd">    good metrics, but have other problems (in this case, the measure function</span>
<span class="sd">    may slow down simplify too much for very large expressions).  If you don&#39;t</span>
<span class="sd">    know what a good metric would be, the default, ``count_ops``, is a good one.</span>

<span class="sd">    For example:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols, log</span>
<span class="sd">    &gt;&gt;&gt; a, b = symbols(&#39;a b&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; g = log(a) + log(b) + log(a)*log(1/b)</span>
<span class="sd">    &gt;&gt;&gt; h = simplify(g)</span>
<span class="sd">    &gt;&gt;&gt; h</span>
<span class="sd">    log(a*b**(log(1/a) + 1))</span>
<span class="sd">    &gt;&gt;&gt; count_ops(g)</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; count_ops(h)</span>
<span class="sd">    6</span>

<span class="sd">    So you can see that ``h`` is simpler than ``g`` using the count_ops metric.</span>
<span class="sd">    However, we may not like how ``simplify`` (in this case, using</span>
<span class="sd">    ``logcombine``) has created the ``b**(log(1/a) + 1)`` term.  A simple way to</span>
<span class="sd">    reduce this would be to give more weight to powers as operations in</span>
<span class="sd">    ``count_ops``.  We can do this by using the ``visual=True`` option:</span>

<span class="sd">    &gt;&gt;&gt; print(count_ops(g, visual=True))</span>
<span class="sd">    2*ADD + DIV + 4*LOG + MUL</span>
<span class="sd">    &gt;&gt;&gt; print(count_ops(h, visual=True))</span>
<span class="sd">    ADD + DIV + 2*LOG + MUL + POW</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, S</span>
<span class="sd">    &gt;&gt;&gt; def my_measure(expr):</span>
<span class="sd">    ...     POW = Symbol(&#39;POW&#39;)</span>
<span class="sd">    ...     # Discourage powers by giving POW a weight of 10</span>
<span class="sd">    ...     count = count_ops(expr, visual=True).subs(POW, 10)</span>
<span class="sd">    ...     # Every other operation gets a weight of 1 (the default)</span>
<span class="sd">    ...     count = count.replace(Symbol, type(S.One))</span>
<span class="sd">    ...     return count</span>
<span class="sd">    &gt;&gt;&gt; my_measure(g)</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; my_measure(h)</span>
<span class="sd">    15</span>
<span class="sd">    &gt;&gt;&gt; 15./8 &gt; 1.7 # 1.7 is the default ratio</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; simplify(g, measure=my_measure)</span>
<span class="sd">    -log(a)*log(b) + log(a) + log(b)</span>

<span class="sd">    Note that because ``simplify()`` internally tries many different</span>
<span class="sd">    simplification strategies and then compares them using the measure</span>
<span class="sd">    function, we get a completely different result that is still different</span>
<span class="sd">    from the input expression by doing this.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">original_expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">_eval_simplify</span><span class="p">(</span><span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="n">measure</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="kn">from</span> <span class="nn">sympy.simplify.hyperexpand</span> <span class="kn">import</span> <span class="n">hyperexpand</span>
    <span class="kn">from</span> <span class="nn">sympy.functions.special.bessel</span> <span class="kn">import</span> <span class="n">BesselBase</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">signsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>  <span class="c"># XXX: temporary hack</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># TODO: Apply different strategies, considering expression pattern:</span>
    <span class="c"># is it a purely rational function? Is there any trigonometric function?...</span>
    <span class="c"># See also https://github.com/sympy/sympy/pull/185.</span>

    <span class="k">def</span> <span class="nf">shorter</span><span class="p">(</span><span class="o">*</span><span class="n">choices</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return the choice that has the fewest ops. In case of a tie,</span>
<span class="sd">        the expression listed first is selected.&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_variety</span><span class="p">(</span><span class="n">choices</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">measure</span><span class="p">)</span>

    <span class="n">expr0</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">expr1</span> <span class="o">=</span> <span class="n">together</span><span class="p">(</span><span class="n">expr0</span><span class="p">)</span>
        <span class="n">expr2</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">expr1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr1</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr0</span><span class="p">)</span>
        <span class="n">expr2</span> <span class="o">=</span> <span class="n">together</span><span class="p">(</span><span class="n">expr1</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># sometimes factors in the denominators need to be allowed to join</span>
    <span class="c"># factors in numerators (see issue 3270)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="n">expr0b</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">powsimp</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr0b</span> <span class="o">!=</span> <span class="n">expr0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_commutative</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="n">expr1b</span> <span class="o">=</span> <span class="n">together</span><span class="p">(</span><span class="n">expr0b</span><span class="p">)</span>
                <span class="n">expr2b</span> <span class="o">=</span> <span class="n">factor_terms</span><span class="p">(</span><span class="n">expr1b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr1b</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">expr0b</span><span class="p">)</span>
                <span class="n">expr2b</span> <span class="o">=</span> <span class="n">together</span><span class="p">(</span><span class="n">expr1b</span><span class="o">.</span><span class="n">expand</span><span class="p">(),</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shorter</span><span class="p">(</span><span class="n">expr2b</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="n">expr2b</span><span class="p">:</span>
                <span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span> <span class="o">=</span> <span class="n">expr1b</span><span class="p">,</span> <span class="n">expr2b</span>

    <span class="k">if</span> <span class="n">ratio</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">expr2</span><span class="p">,</span> <span class="n">expr1</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>  <span class="c"># XXX: temporary hack</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c"># hyperexpand automatically only works on hypergeometric terms</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">hyperexpand</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">BesselBase</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">besselsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">TrigonometricFunction</span><span class="p">)</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">HyperbolicFunction</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">trigsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">log</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">expand_log</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">logcombine</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">CombinatorialFunction</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">combsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">short</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">factor_terms</span><span class="p">(</span><span class="n">expr</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">short</span> <span class="o">!=</span> <span class="n">expr</span><span class="p">:</span>
        <span class="c"># get rid of hollow 2-arg Mul factorization</span>
        <span class="kn">from</span> <span class="nn">sympy.core.rules</span> <span class="kn">import</span> <span class="n">Transform</span>
        <span class="n">hollow_mul</span> <span class="o">=</span> <span class="n">Transform</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
            <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">and</span>
            <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_Add</span> <span class="ow">and</span>
            <span class="n">x</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">shorter</span><span class="p">(</span><span class="n">short</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">hollow_mul</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
    <span class="n">numer</span><span class="p">,</span> <span class="n">denom</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">denom</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">fraction</span><span class="p">(</span><span class="n">radsimp</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">denom</span><span class="p">,</span> <span class="n">symbolic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">max_terms</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">numer</span><span class="o">*</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span><span class="o">/</span><span class="n">d</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">():</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="o">-</span><span class="n">n</span><span class="o">/</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">measure</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ratio</span><span class="o">*</span><span class="n">measure</span><span class="p">(</span><span class="n">original_expr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">original_expr</span>

    <span class="k">return</span> <span class="n">expr</span>

</div>
<span class="k">def</span> <span class="nf">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace all reals in expr with rationals.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import nsimplify</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import x</span>

<span class="sd">    &gt;&gt;&gt; nsimplify(.76 + .1*x**.5, rational=True)</span>
<span class="sd">    sqrt(x)/10 + 19/25</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">expr</span>
    <span class="n">reps</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="p">):</span>
        <span class="n">newr</span> <span class="o">=</span> <span class="n">nsimplify</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">newr</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">or</span> <span class="n">r</span><span class="o">.</span><span class="n">is_finite</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">newr</span><span class="o">.</span><span class="n">is_finite</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">newr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">newr</span> <span class="o">=</span> <span class="o">-</span><span class="n">r</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">newr</span><span class="p">)</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>
                <span class="n">newr</span> <span class="o">=</span> <span class="o">-</span><span class="n">Rational</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">newr</span><span class="o">/</span><span class="n">d</span><span class="p">))</span><span class="o">*</span><span class="n">d</span>
            <span class="k">elif</span> <span class="n">newr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">Pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">mpmath</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))))</span>
                <span class="n">newr</span> <span class="o">=</span> <span class="n">Rational</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">/</span><span class="n">d</span><span class="p">))</span><span class="o">*</span><span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newr</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">reps</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">newr</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">simultaneous</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<div class="viewcode-block" id="nsimplify"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.nsimplify">[docs]</a><span class="k">def</span> <span class="nf">nsimplify</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="p">[],</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">rational</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a simple representation for a number or, if there are free symbols or</span>
<span class="sd">    if rational=True, then replace Floats with their Rational equivalents. If</span>
<span class="sd">    no change is made and rational is not False then Floats will at least be</span>
<span class="sd">    converted to Rationals.</span>

<span class="sd">    For numerical expressions, a simple formula that numerically matches the</span>
<span class="sd">    given numerical expression is sought (and the input should be possible</span>
<span class="sd">    to evalf to a precision of at least 30 digits).</span>

<span class="sd">    Optionally, a list of (rationally independent) constants to</span>
<span class="sd">    include in the formula may be given.</span>

<span class="sd">    A lower tolerance may be set to find less exact matches. If no tolerance</span>
<span class="sd">    is given then the least precise value will set the tolerance (e.g. Floats</span>
<span class="sd">    default to 15 digits of precision, so would be tolerance=10**-15).</span>

<span class="sd">    With full=True, a more extensive search is performed</span>
<span class="sd">    (this is useful to find simpler numbers when the tolerance</span>
<span class="sd">    is set low).</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import nsimplify, sqrt, GoldenRatio, exp, I, exp, pi</span>
<span class="sd">        &gt;&gt;&gt; nsimplify(4/(1+sqrt(5)), [GoldenRatio])</span>
<span class="sd">        -2 + 2*GoldenRatio</span>
<span class="sd">        &gt;&gt;&gt; nsimplify((1/(exp(3*pi*I/5)+1)))</span>
<span class="sd">        1/2 - I*sqrt(sqrt(5)/10 + 1/4)</span>
<span class="sd">        &gt;&gt;&gt; nsimplify(I**I, [pi])</span>
<span class="sd">        exp(-pi/2)</span>
<span class="sd">        &gt;&gt;&gt; nsimplify(pi, tolerance=0.01)</span>
<span class="sd">        22/7</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    sympy.core.function.nfloat</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rational</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="c"># sympy&#39;s default tolarance for Rationals is 15; other numbers may have</span>
    <span class="c"># lower tolerances set, so use them to pick the largest tolerance if none</span>
    <span class="c"># was given</span>
    <span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="ow">or</span> <span class="mi">10</span><span class="o">**-</span><span class="nb">min</span><span class="p">([</span><span class="mi">15</span><span class="p">]</span> <span class="o">+</span>
                                     <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">libmp</span><span class="o">.</span><span class="n">libmpf</span><span class="o">.</span><span class="n">prec_to_dps</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">_prec</span><span class="p">)</span>
                                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Float</span><span class="p">)])</span>

    <span class="n">prec</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">bprec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">prec</span><span class="o">*</span><span class="mf">3.33</span><span class="p">)</span>

    <span class="n">constants_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">constant</span> <span class="ow">in</span> <span class="n">constants</span><span class="p">:</span>
        <span class="n">constant</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">constant</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;constants must be real-valued&quot;</span><span class="p">)</span>
        <span class="n">constants_dict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">constant</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">bprec</span><span class="p">)</span>

    <span class="n">exprval</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="n">chop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">exprval</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>

    <span class="c"># Must be numerical</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">re</span><span class="o">.</span><span class="n">is_Float</span> <span class="ow">or</span> <span class="n">re</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">is_Float</span> <span class="ow">or</span> <span class="n">im</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">def</span> <span class="nf">nsimplify_real</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span>
        <span class="n">xv</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_to_mpmath</span><span class="p">(</span><span class="n">bprec</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c"># We&#39;ll be happy with low precision if a simple fraction</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tolerance</span> <span class="ow">or</span> <span class="n">full</span><span class="p">):</span>
                <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">15</span>
                <span class="n">rat</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">findpoly</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Rational</span><span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">rat</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">rat</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">prec</span>
            <span class="n">newexpr</span> <span class="o">=</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="n">constants_dict</span><span class="p">,</span>
                <span class="n">tol</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">full</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">newexpr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
                <span class="n">newexpr</span> <span class="o">=</span> <span class="n">newexpr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">newexpr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_finite</span> <span class="ow">is</span> <span class="bp">False</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">xv</span> <span class="ow">in</span> <span class="p">[</span><span class="n">mpmath</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">mpmath</span><span class="o">.</span><span class="n">ninf</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># even though there are returns above, this is executed</span>
            <span class="c"># before leaving</span>
            <span class="n">mpmath</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="n">orig</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">re</span><span class="p">:</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">nsimplify_real</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">im</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">nsimplify_real</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rational</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="n">rv</span> <span class="o">=</span> <span class="n">re</span> <span class="o">+</span> <span class="n">im</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span>
    <span class="c"># if there was a change or rational is explicitly not wanted</span>
    <span class="c"># return the value, else return the Rational representation</span>
    <span class="k">if</span> <span class="n">rv</span> <span class="o">!=</span> <span class="n">expr</span> <span class="ow">or</span> <span class="n">rational</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rv</span>
    <span class="k">return</span> <span class="n">_real_to_rational</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="logcombine"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.logcombine">[docs]</a><span class="k">def</span> <span class="nf">logcombine</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes logarithms and combines them using the following rules:</span>

<span class="sd">    - log(x)+log(y) == log(x*y)</span>
<span class="sd">    - a*log(x) == log(x**a)</span>

<span class="sd">    These identities are only valid if x and y are positive and if a is real,</span>
<span class="sd">    so the function will not combine the terms unless the arguments have the</span>
<span class="sd">    proper assumptions on them.  Use logcombine(func, force=True) to</span>
<span class="sd">    automatically assume that the arguments of logs are positive and that</span>
<span class="sd">    coefficients are real.  Note that this will not change any assumptions</span>
<span class="sd">    already in place, so if the coefficient is imaginary or the argument</span>
<span class="sd">    negative, combine will still not combine the equations.  Change the</span>
<span class="sd">    assumptions on the variables to make them combine.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Symbol, symbols, log, logcombine</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import a, x, y, z</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x)+log(y)-log(z))</span>
<span class="sd">    a*log(x) + log(y) - log(z)</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x)+log(y)-log(z), force=True)</span>
<span class="sd">    log(x**a*y/z)</span>
<span class="sd">    &gt;&gt;&gt; x,y,z = symbols(&#39;x,y,z&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; a = Symbol(&#39;a&#39;, real=True)</span>
<span class="sd">    &gt;&gt;&gt; logcombine(a*log(x)+log(y)-log(z))</span>
<span class="sd">    log(x**a*y/z)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Try to make (a+bi)*log(x) == a*log(x)+bi*log(x).  This needs to be a</span>
    <span class="c"># separate function call to avoid infinite recursion.</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_logcombine</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">_logcombine</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Does the main work for logcombine, it&#39;s a separate function to avoid an</span>
<span class="sd">    infinite recursion. See the docstrings of logcombine() for help.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_getlogargs</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the arguments of the logarithm in an expression.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        _getlogargs(a*log(x*y))</span>
<span class="sd">        x*y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_getlogargs</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">flatten</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span> <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_NumberSymbol</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="n">C</span><span class="o">.</span><span class="n">Integral</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Equality</span><span class="p">):</span>
        <span class="n">retval</span> <span class="o">=</span> <span class="n">Equality</span><span class="p">(</span><span class="n">_logcombine</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span> <span class="o">-</span> <span class="n">expr</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="n">force</span><span class="p">),</span>
        <span class="n">Integer</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="c"># If logcombine couldn&#39;t do much with the equality, try to make it like</span>
        <span class="c"># it was.  Hopefully extract_additively won&#39;t become smart enough to</span>
        <span class="c"># take logs apart :)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">retval</span><span class="o">.</span><span class="n">lhs</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Equality</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">_logcombine</span><span class="p">(</span><span class="o">-</span><span class="n">right</span><span class="p">,</span> <span class="n">force</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">retval</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
        <span class="n">argslist</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">notlogs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">coeflogs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">func</span> <span class="ow">is</span> <span class="n">log</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">or</span> <span class="p">(</span><span class="n">force</span> <span class="ow">and</span> <span class="ow">not</span>
                <span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_nonpositive</span><span class="p">)):</span>
                    <span class="n">argslist</span> <span class="o">*=</span> <span class="n">_logcombine</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">force</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">notlogs</span> <span class="o">+=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">&#39;func&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="o">==</span> <span class="n">log</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">]):</span>
                <span class="n">largs</span> <span class="o">=</span> <span class="n">_getlogargs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">largs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="n">loglargs</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">largs</span><span class="p">:</span>
                    <span class="n">loglargs</span> <span class="o">*=</span> <span class="n">log</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">&#39;is_positive&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">largs</span><span class="p">)</span> \
                    <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">loglargs</span><span class="p">),</span> <span class="s">&#39;is_real&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> \
                    <span class="ow">or</span> <span class="p">(</span><span class="n">force</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s">&#39;is_nonpositive&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">largs</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">loglargs</span><span class="p">),</span>
                        <span class="s">&#39;is_real&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">):</span>

                    <span class="n">coeflogs</span> <span class="o">+=</span> <span class="n">_logcombine</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">notlogs</span> <span class="o">+=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="n">i</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">log</span><span class="p">):</span>
                <span class="n">notlogs</span> <span class="o">+=</span> <span class="n">_logcombine</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">notlogs</span> <span class="o">+=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">notlogs</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="n">argslist</span><span class="p">)</span> <span class="o">+</span> <span class="n">coeflogs</span> <span class="o">==</span> <span class="n">expr</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alllogs</span> <span class="o">=</span> <span class="n">_logcombine</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">argslist</span><span class="p">)</span> <span class="o">+</span> <span class="n">coeflogs</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">notlogs</span> <span class="o">+</span> <span class="n">alllogs</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">coef</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">coef</span> \
            <span class="ow">and</span> <span class="p">(</span><span class="n">coef</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">is_real</span>
                <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Number</span>
                <span class="ow">or</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_NumberSymbol</span>
                <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">coef</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">force</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">coef</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">is_imaginary</span><span class="p">))</span> \
            <span class="ow">and</span> <span class="p">(</span><span class="n">coef</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">func</span> <span class="o">!=</span> <span class="n">log</span>
                <span class="ow">or</span> <span class="n">force</span>
                <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">coef</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="s">&#39;is_real&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">False</span>
                    <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&#39;is_positive&#39;</span><span class="p">))):</span>

            <span class="k">return</span> <span class="n">log</span><span class="p">(</span><span class="n">coef</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">**</span><span class="n">coef</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_logcombine</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">force</span><span class="p">)</span><span class="o">*</span><span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span>
             <span class="n">_logcombine</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span><span class="o">*</span><span class="n">_logcombine</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">force</span><span class="p">),</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Function</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">_logcombine</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_logcombine</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">force</span><span class="p">)</span> <span class="o">**</span> \
            <span class="n">_logcombine</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">force</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span>


<div class="viewcode-block" id="besselsimp"><a class="viewcode-back" href="../../../modules/simplify/simplify.html#sympy.simplify.simplify.besselsimp">[docs]</a><span class="k">def</span> <span class="nf">besselsimp</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplify bessel-type functions.</span>

<span class="sd">    This routine tries to simplify bessel-type functions. Currently it only</span>
<span class="sd">    works on the Bessel J and I functions, however. It works by looking at all</span>
<span class="sd">    such functions in turn, and eliminating factors of &quot;I&quot; and &quot;-1&quot; (actually</span>
<span class="sd">    their polar equivalents) in front of the argument. After that, functions of</span>
<span class="sd">    half-integer order are rewritten using trigonometric functions.</span>

<span class="sd">    &gt;&gt;&gt; from sympy import besselj, besseli, besselsimp, polar_lift, I, S</span>
<span class="sd">    &gt;&gt;&gt; from sympy.abc import z, nu</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besselj(nu, z*polar_lift(-1)))</span>
<span class="sd">    exp(I*pi*nu)*besselj(nu, z)</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besseli(nu, z*polar_lift(-I)))</span>
<span class="sd">    exp(-I*pi*nu/2)*besselj(nu, z)</span>
<span class="sd">    &gt;&gt;&gt; besselsimp(besseli(S(-1)/2, z))</span>
<span class="sd">    sqrt(2)*cosh(z)/(sqrt(pi)*sqrt(z))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">besselj</span><span class="p">,</span> <span class="n">besseli</span><span class="p">,</span> <span class="n">jn</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">Dummy</span>
    <span class="c"># TODO</span>
    <span class="c"># - extension to more types of functions</span>
    <span class="c">#   (at least rewriting functions of half integer order should be straight</span>
    <span class="c">#    forward also for Y and K)</span>
    <span class="c"># - better algorithm?</span>
    <span class="c"># - simplify (cos(pi*b)*besselj(b,z) - besselj(-b,z))/sin(pi*b) ...</span>
    <span class="c"># - use contiguity relations?</span>

    <span class="k">def</span> <span class="nf">replacer</span><span class="p">(</span><span class="n">fro</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">factors</span><span class="p">):</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">factors</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">factors</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">z</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">to</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">repl</span>

    <span class="k">def</span> <span class="nf">torewrite</span><span class="p">(</span><span class="n">fro</span><span class="p">,</span> <span class="n">to</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">tofunc</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tofunc</span>

    <span class="k">def</span> <span class="nf">tominus</span><span class="p">(</span><span class="n">fro</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">tofunc</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">nu</span><span class="p">)</span><span class="o">*</span><span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tofunc</span>

    <span class="n">ifactors</span> <span class="o">=</span> <span class="p">[</span><span class="n">I</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">exp_polar</span><span class="p">(</span><span class="o">-</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span>
                                          <span class="n">torewrite</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">besseli</span><span class="p">),</span> <span class="n">ifactors</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span>
                                          <span class="n">torewrite</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">besselj</span><span class="p">),</span> <span class="n">ifactors</span><span class="p">))</span>

    <span class="n">minusfactors</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">exp_polar</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="n">pi</span><span class="p">)]</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besselj</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">tominus</span><span class="p">(</span><span class="n">besselj</span><span class="p">),</span> <span class="n">minusfactors</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">besseli</span><span class="p">,</span> <span class="n">replacer</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">tominus</span><span class="p">(</span><span class="n">besseli</span><span class="p">),</span> <span class="n">minusfactors</span><span class="p">))</span>

    <span class="n">z0</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expander</span><span class="p">(</span><span class="n">fro</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nu</span> <span class="o">%</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">unpolarify</span><span class="p">(</span><span class="n">fro</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">z0</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">besselj</span><span class="p">)</span><span class="o">.</span><span class="n">rewrite</span><span class="p">(</span><span class="n">jn</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">repl</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besselj</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">besselj</span><span class="p">))</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">besseli</span><span class="p">,</span> <span class="n">expander</span><span class="p">(</span><span class="n">besseli</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">expr</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.2-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 SymPy Development Team.
      Last updated on Jan 20, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>
