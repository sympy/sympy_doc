<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.physics.hep.gamma_matrices &mdash; SymPy 0.7.5-git documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '0.7.5-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.5-git documentation" href="../../../../index.html" />
    <link rel="up" title="sympy" href="../../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">SymPy 0.7.5-git documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.physics.hep.gamma_matrices</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">sympy.tensor.tensor</span> <span class="kn">import</span> <span class="n">TensorIndexType</span><span class="p">,</span> <span class="n">TensorIndex</span><span class="p">,</span>\
    <span class="n">TensMul</span><span class="p">,</span> <span class="n">TensorHead</span><span class="p">,</span> <span class="n">tensorsymmetry</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">,</span>\
    <span class="n">TensAdd</span><span class="p">,</span> <span class="n">tensor_mul</span><span class="p">,</span> <span class="n">get_lines</span>
<span class="kn">from</span> <span class="nn">sympy.core.containers</span> <span class="kn">import</span> <span class="n">Tuple</span>


<span class="n">DiracSpinorIndex</span> <span class="o">=</span> <span class="n">TensorIndexType</span><span class="p">(</span><span class="s">&#39;DiracSpinorIndex&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dummy_fmt</span><span class="o">=</span><span class="s">&quot;S&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="_LorentzContainer"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices._LorentzContainer">[docs]</a><span class="k">class</span> <span class="nc">_LorentzContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper to collect LorentzIndex indices in various dimensions.</span>

<span class="sd">    It collects LorentzIndex TensorIndexType that have been implemented in the code,</span>
<span class="sd">    and stores them in a dict()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lorentz_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">eps_dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dummy_fmt</span><span class="o">=</span><span class="s">&quot;L&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_LorentzContainer</span><span class="o">.</span><span class="n">lorentz_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_LorentzContainer</span><span class="o">.</span><span class="n">lorentz_types</span><span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="p">)]</span>

        <span class="n">new_L</span> <span class="o">=</span> <span class="n">TensorIndexType</span><span class="p">(</span><span class="s">&quot;LorentzIndex&quot;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="o">=</span><span class="n">eps_dim</span><span class="p">,</span> <span class="n">dummy_fmt</span><span class="o">=</span><span class="n">dummy_fmt</span><span class="p">)</span>
        <span class="n">_LorentzContainer</span><span class="o">.</span><span class="n">lorentz_types</span><span class="p">[(</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_L</span>
        <span class="k">return</span> <span class="n">new_L</span>

</div>
<div class="viewcode-block" id="GammaMatrixHead"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead">[docs]</a><span class="k">class</span> <span class="nc">GammaMatrixHead</span><span class="p">(</span><span class="n">TensorHead</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Class to wrap a ``TensorHead`` for gamma matrices.</span>

<span class="sd">    ``dim``       dimension of the gamma matrix.</span>
<span class="sd">    ``eps_dim``   correction for dimensional regularization, use None if not needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrixHead</span>
<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices</span>
<span class="sd">    &gt;&gt;&gt; G = GammaMatrixHead()</span>
<span class="sd">    &gt;&gt;&gt; i = tensor_indices(&#39;i&#39;, G.LorentzIndex)</span>
<span class="sd">    &gt;&gt;&gt; G(i)</span>
<span class="sd">    gamma(i, auto_left, -auto_right)</span>

<span class="sd">    Note that there is already an instance of GammaMatrixHead in four dimensions:</span>
<span class="sd">    GammaMatrix, which is simply declare as</span>

<span class="sd">    ``GammaMatrix = GammaMatrixHead()``</span>

<span class="sd">    &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix</span>
<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices</span>
<span class="sd">    &gt;&gt;&gt; i = tensor_indices(&#39;i&#39;, GammaMatrix.LorentzIndex)</span>
<span class="sd">    &gt;&gt;&gt; GammaMatrix(i)</span>
<span class="sd">    gamma(i, auto_left, -auto_right)</span>

<span class="sd">    To access the metric tensor</span>

<span class="sd">    &gt;&gt;&gt; GammaMatrix.LorentzIndex.metric</span>
<span class="sd">    metric(LorentzIndex,LorentzIndex)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_gmhd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">eps_dim</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">eps_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_gmhd</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_gmhd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">lorentz</span> <span class="o">=</span> <span class="n">_LorentzContainer</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>

        <span class="n">gmh</span> <span class="o">=</span> <span class="n">TensorHead</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="n">TensorType</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="n">lorentz</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="p">),</span> <span class="n">tensorsymmetry</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">comm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">matrix_behavior</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_gmhd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">gmh</span>
        <span class="n">gmh</span><span class="o">.</span><span class="n">LorentzIndex</span> <span class="o">=</span> <span class="n">lorentz</span>
        <span class="k">return</span> <span class="n">gmh</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="GammaMatrixHead.extract_type_tens"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead.extract_type_tens">[docs]</a>    <span class="k">def</span> <span class="nf">extract_type_tens</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract from a ``TensExpr`` all elements of this type.</span>

<span class="sd">        Returns two tensor expressions:</span>

<span class="sd">        * the first contains all ``TensorHead`` of this type.</span>
<span class="sd">        * the second contains all remaining.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="c"># Collect all gamma matrices of the same dimension</span>
        <span class="n">new_expr</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="n">residual_expr</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">):</span>
                <span class="n">new_expr</span> <span class="o">*=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">residual_expr</span> <span class="o">*=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">new_expr</span><span class="p">,</span> <span class="n">residual_expr</span>
</div>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">simplify_this_type</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="n">extracted_expr</span><span class="p">,</span> <span class="n">residual_expr</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">extract_type_tens</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="n">res_expr</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_simplify_single_line</span><span class="p">(</span><span class="n">extracted_expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_expr</span> <span class="o">*</span> <span class="n">residual_expr</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="GammaMatrixHead.simplify_gpgp"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead.simplify_gpgp">[docs]</a>    <span class="k">def</span> <span class="nf">simplify_gpgp</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        simplify products ``G(i)*p(-i)*G(j)*p(-j) -&gt; p(i)*p(-i)``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p, q&#39;, [G.LorentzIndex], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4,i5 = tensor_indices(&#39;i0:6&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; ps = p(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; qs = q(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; G.simplify_gpgp(ps*qs*qs)</span>
<span class="sd">        gamma(-L_0, auto_left, -auto_right)*p(L_0)*q(L_1)*q(-L_1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_simplify_gpgp</span><span class="p">(</span><span class="n">ex</span><span class="p">):</span>
            <span class="n">tids</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">_tids</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">components</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">dum</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">dum</span>
                <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="n">dum</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">p_pos1</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">dx</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                        <span class="n">p_pos1</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">comp1</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">p_pos1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">comp1</span><span class="o">.</span><span class="n">comm</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">comp1</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">p_pos1</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ex</span>
            <span class="n">elim</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">tv</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="n">ta</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">while</span> <span class="n">hit</span><span class="p">:</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">components</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">components</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]:</span>
                        <span class="k">continue</span>
                    <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ta</span><span class="p">:</span>
                        <span class="n">ta</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                        <span class="n">mu</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="n">GammaMatrix</span><span class="o">.</span><span class="n">LorentzIndex</span><span class="p">)</span>
                    <span class="n">ind1</span> <span class="o">=</span> <span class="n">ta</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">ind2</span> <span class="o">=</span> <span class="n">ta</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">coeff</span>
                    <span class="n">tx</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">components</span><span class="p">[</span><span class="n">ai</span><span class="p">[</span><span class="mi">1</span><span class="p">]](</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span>
                    <span class="n">tv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tx</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">))</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">tv</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ta</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">]</span>
                <span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">coeff</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ex</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">sorted_components</span><span class="p">()</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_simplify_gpgp</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">ex</span><span class="p">:</span>
                <span class="n">ex</span> <span class="o">=</span> <span class="n">t</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">t</span>
</div>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="GammaMatrixHead.simplify_lines"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead.simplify_lines">[docs]</a>    <span class="k">def</span> <span class="nf">simplify_lines</span><span class="p">(</span><span class="n">ex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        simplify a product of gamma matrices</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix, DiracSpinorIndex</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4,i5 = tensor_indices(&#39;i0:6&#39;, GammaMatrix.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; s0,s1,s2,s3,s4,s5,s6,s7 = tensor_indices(&#39;s0:8&#39;, DiracSpinorIndex)</span>
<span class="sd">        &gt;&gt;&gt; G = GammaMatrix</span>
<span class="sd">        &gt;&gt;&gt; t = G(i1,s1,-s2)*G(i4,s7,-s6)*G(i2,s2,-s3)*G(i3,s4,-s5)*G(i5,s6,-s7)</span>
<span class="sd">        &gt;&gt;&gt; G.simplify_lines(t)</span>
<span class="sd">        4*gamma(i3, s4, -s5)*gamma(i1, s1, -S_0)*gamma(i2, S_0, -s3)*metric(i4, i5)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span><span class="p">,</span> <span class="n">traces</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">get_lines</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">trest</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rest</span><span class="p">])</span>
        <span class="n">tlines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">first</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">first</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">last</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">tx</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span>  <span class="ow">in</span> <span class="n">line</span><span class="p">])</span>
            <span class="n">tx1</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_simplify_single_line</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>
            <span class="n">tlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tx1</span><span class="p">)</span>
        <span class="n">traces</span> <span class="o">=</span> <span class="p">[</span><span class="n">GammaMatrix</span><span class="o">.</span><span class="n">_trace_single_line</span><span class="p">(</span><span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span>  <span class="ow">in</span> <span class="n">line</span><span class="p">]))</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">traces</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">trest</span><span class="p">]</span> <span class="o">+</span> <span class="n">tlines</span> <span class="o">+</span> <span class="n">traces</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
<div class="viewcode-block" id="GammaMatrixHead.gamma_trace"><a class="viewcode-back" href="../../../../modules/physics/hep/gamma_matrices.html#sympy.physics.hep.gamma_matrices.GammaMatrixHead.gamma_trace">[docs]</a>    <span class="k">def</span> <span class="nf">gamma_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        trace of a single line of gamma matrices</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p, q&#39;, [G.LorentzIndex], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4,i5 = tensor_indices(&#39;i0:6&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; ps = p(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; qs = q(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; G.gamma_trace(G(i0)*G(i1))</span>
<span class="sd">        4*metric(i0, i1)</span>
<span class="sd">        &gt;&gt;&gt; G.gamma_trace(ps*ps) - 4*p(i0)*p(-i0)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; G.gamma_trace(ps*qs + ps*ps) - 4*p(i0)*p(-i0) - 4*p(i0)*q(-i0)</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#assert any(x == DiracSpinorIndex.auto_right for x, p, c, in t._tids.free)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_trace_single_line</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simplify_single_line</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_single_line</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_simplify_single_line</span><span class="p">(</span><span class="n">expression</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simplify single-line product of gamma matrices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G, DiracSpinorIndex as DS</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; p = tensorhead(&#39;p&#39;, [G.LorentzIndex], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; i0,i1 = tensor_indices(&#39;i0:2&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; G._simplify_single_line(G(i0)*G(i1)*p(-i1)*G(-i0)) + 2*G(i0)*p(-i0)</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">extract_type_tens</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t1</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">_kahane_simplify</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="n">t1</span><span class="o">.</span><span class="n">_tids</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">t1</span><span class="o">*</span><span class="n">t2</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_trace_single_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the trace of a single gamma matrix line inside a ``TensExpr``.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        If there are ``DiracSpinorIndex.auto_left`` and ``DiracSpinorIndex.auto_right``</span>
<span class="sd">        indices trace over them; otherwise traces are not implied (explain)</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; p = tensorhead(&#39;p&#39;, [G.LorentzIndex], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4,i5 = tensor_indices(&#39;i0:6&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; G._trace_single_line(G(i0)*G(i1))</span>
<span class="sd">        4*metric(i0, i1)</span>
<span class="sd">        &gt;&gt;&gt; G._trace_single_line(G(i0)*p(-i0)*G(i1)*p(-i1)) - 4*p(i0)*p(-i0)</span>
<span class="sd">        0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_trace_single_line1</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">sorted_components</span><span class="p">()</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">components</span>
            <span class="n">ncomps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LorentzIndex</span><span class="o">.</span><span class="n">metric</span>
            <span class="n">sg</span> <span class="o">=</span> <span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span>
            <span class="c"># gamma matirices are in a[i:j]</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncomps</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">):</span>
                    <span class="n">hit</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">break</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">hit</span><span class="p">,</span> <span class="n">ncomps</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">components</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">ncomps</span>
            <span class="n">numG</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">numG</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">spinor_free</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tensortype</span> <span class="ow">is</span> <span class="n">DiracSpinorIndex</span><span class="p">]</span>
                <span class="n">tcoeff</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">coeff</span>
                <span class="k">if</span> <span class="n">spinor_free</span> <span class="o">==</span> <span class="p">[</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">]:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">)</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">t</span><span class="o">/</span><span class="n">tcoeff</span> <span class="k">if</span> <span class="n">tcoeff</span> <span class="k">else</span> <span class="n">t</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">t</span><span class="o">/</span><span class="n">tcoeff</span> <span class="k">if</span> <span class="n">tcoeff</span> <span class="k">else</span> <span class="n">t</span>
            <span class="k">if</span> <span class="n">numG</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[])</span>
            <span class="k">elif</span> <span class="n">numG</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">,</span> <span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_index</span><span class="p">),</span> <span class="p">(</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_index</span><span class="p">))</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">ind1</span><span class="p">,</span> <span class="n">lind1</span><span class="p">,</span> <span class="n">rind1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ind2</span><span class="p">,</span> <span class="n">lind2</span><span class="p">,</span> <span class="n">rind2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">aa</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:]</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span><span class="o">*</span><span class="n">sg</span><span class="p">(</span><span class="n">lind1</span><span class="p">,</span> <span class="n">rind1</span><span class="p">)</span><span class="o">*</span><span class="n">sg</span><span class="p">(</span><span class="n">lind2</span><span class="p">,</span> <span class="n">rind2</span><span class="p">)</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">t1</span><span class="p">]</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                    <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>
                    <span class="n">ind2</span><span class="p">,</span> <span class="n">lind2</span><span class="p">,</span> <span class="n">rind2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">aa</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="n">sign</span><span class="o">*</span><span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">aa</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span><span class="o">*</span><span class="n">sg</span><span class="p">(</span><span class="n">lind1</span><span class="p">,</span> <span class="n">rind1</span><span class="p">)</span><span class="o">*</span><span class="n">sg</span><span class="p">(</span><span class="n">lind2</span><span class="p">,</span> <span class="n">rind2</span><span class="p">)</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                    <span class="n">t2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>

                    <span class="n">t2</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="o">.</span><span class="n">simplify_gpgp</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

                <span class="c">#aa = _tensorlist_contract_metric(aa, g(ind1, ind2))</span>
                <span class="c">#t3 = t3.canon_bp()</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trace_single_line</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">t3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">:</span>
                        <span class="k">return</span> <span class="mi">4</span>  <span class="c"># FIXME only for D=4</span>
                <span class="n">t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gamma_trace1</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
                <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span>
                <span class="n">t2</span> <span class="o">=</span> <span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">a2</span><span class="p">)</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="n">t1</span><span class="o">*</span><span class="n">t2</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">t3</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">t3</span>
                <span class="n">t3</span> <span class="o">=</span> <span class="n">t3</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">t3</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">coeff</span><span class="o">*</span><span class="n">_trace_single_line1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">coeff</span><span class="o">*</span><span class="n">_trace_single_line1</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_gamma_trace1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">):</span>
        <span class="n">gctr</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c"># FIXME specific for d=4</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LorentzIndex</span><span class="o">.</span><span class="n">metric</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gctr</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c">#return TensMul.from_data(S.Zero, [], [], [])</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ind0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">gctr</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">ind0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ind3</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">gctr</span><span class="o">*</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind2</span><span class="p">,</span> <span class="n">ind3</span><span class="p">)</span> <span class="o">-</span> \
               <span class="n">g</span><span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind3</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">ind0</span><span class="p">,</span> <span class="n">ind3</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_kahane_simplify</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        This function cancels contracted elements in a product of four</span>
<span class="sd">        dimensional gamma matrices, resulting in an expression equal to the given</span>
<span class="sd">        one, without the contracted gamma matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        `coeff`     the coefficient of the tensor expression.</span>
<span class="sd">        `tids`      TIDS object representing the gamma matrix expression to simplify.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        If spinor indices are given, the matrices must be given in</span>
<span class="sd">        the order given in the product.</span>

<span class="sd">        Algorithm</span>
<span class="sd">        =========</span>

<span class="sd">        The idea behind the algorithm is to use some well-known identities,</span>
<span class="sd">        i.e., for contractions enclosing an even number of `\gamma` matrices</span>

<span class="sd">        `\gamma^\mu \gamma_{a_1} \cdots \gamma_{a_{2N}} \gamma_\mu = 2 (\gamma_{a_{2N}} \gamma_{a_1} \cdots \gamma_{a_{2N-1}} + \gamma_{a_{2N-1}} \cdots \gamma_{a_1} \gamma_{a_{2N}} )`</span>

<span class="sd">        for an odd number of `\gamma` matrices</span>

<span class="sd">        `\gamma^\mu \gamma_{a_1} \cdots \gamma_{a_{2N+1}} \gamma_\mu = -2 \gamma_{a_{2N+1}} \gamma_{a_{2N}} \cdots \gamma_{a_{1}}`</span>

<span class="sd">        Instead of repeatedly applying these identities to cancel out all contracted indices,</span>
<span class="sd">        it is possible to recognize the links that would result from such an operation,</span>
<span class="sd">        the problem is thus reduced to a simple rearrangement of free gamma matrices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        When using, always remember that the original expression coefficient</span>
<span class="sd">        has to be handled separately</span>

<span class="sd">        &gt;&gt;&gt; from sympy.physics.hep.gamma_matrices import GammaMatrix as G, DiracSpinorIndex as DS</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead, TensMul, TensAdd</span>
<span class="sd">        &gt;&gt;&gt; i0, i1, i2 = tensor_indices(&#39;i0:3&#39;, G.LorentzIndex)</span>
<span class="sd">        &gt;&gt;&gt; s0,s1,s2,s3,s4,s5 = tensor_indices(&#39;s0:6&#39;, DS)</span>
<span class="sd">        &gt;&gt;&gt; ta = G(i0)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(ta.coeff, ta._tids) - 4*DS.delta(DS.auto_left, -DS.auto_right)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; tb = G(i0)*G(i1)*G(-i0)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(tb.coeff, tb._tids)</span>
<span class="sd">        -2*gamma(i1, auto_left, -auto_right)</span>
<span class="sd">        &gt;&gt;&gt; t = G(i0, s0, -s1)*G(-i0,s1,-s2)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(t.coeff, t._tids) - 4*DS.delta(s0, -s2)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; t = G(i0, s0, -s1)*G(-i0,s1,-s0)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(t.coeff, t._tids)</span>
<span class="sd">        16</span>

<span class="sd">        If there are no contractions, the same expression is returned</span>

<span class="sd">        &gt;&gt;&gt; tc = 3*G(i0)*G(i1)</span>
<span class="sd">        &gt;&gt;&gt; G._kahane_simplify(tc.coeff, tc._tids)</span>
<span class="sd">        3*gamma(i0, auto_left, -S_0)*gamma(i1, S_0, -auto_right)</span>

<span class="sd">        References</span>
<span class="sd">        ==========</span>

<span class="sd">        [1] Algorithm for Reducing Contracted Products of gamma Matrices, Joseph Kahane, Journal of Mathematical Physics, Vol. 9, No. 10, October 1968.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tids</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">GammaMatrixHead</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;use only gamma matrices&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tids</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">dum</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">dc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">c0</span> <span class="o">-</span> <span class="n">c1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;wrong gamma matrix ordering&#39;</span><span class="p">)</span>
        <span class="n">free</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">spinor_free</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spinor_free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">spinor_free</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">spinor_free</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">assert</span> <span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">spinor_free</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;spinor indices do not match&#39;</span><span class="p">)</span>

        <span class="n">dum</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">dum</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># or GammaMatrixHead:</span>
            <span class="c"># no contractions in `expression`, just return it.</span>
            <span class="k">return</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids</span><span class="p">)</span>

        <span class="c"># find the `first_dum_pos`, i.e. the position of the first contracted</span>
        <span class="c"># gamma matrix, Kahane&#39;s algorithm as described in his paper requires the</span>
        <span class="c"># gamma matrix expression to start with a contracted gamma matrix, this is</span>
        <span class="c"># a workaround which ignores possible initial free indices, and re-adds</span>
        <span class="c"># them later.</span>
        <span class="n">dum_zip</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">dum</span><span class="p">))[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">first_dum_pos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dum_zip</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">dum_zip</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">total_number</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">free</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">number_of_contractions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum</span><span class="p">)</span>

        <span class="n">free_pos</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">total_number</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">free</span><span class="p">:</span>
            <span class="n">free_pos</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># `index_is_free` is a list of booleans, to identify index position</span>
        <span class="c"># and whether that index is free or dummy.</span>
        <span class="n">index_is_free</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span><span class="o">*</span><span class="n">total_number</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">free</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">indx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;indx[1] should be equal to 0&quot;</span><span class="p">)</span>
            <span class="n">index_is_free</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># `links` is a dictionary containing the graph described in Kahane&#39;s paper,</span>
        <span class="c"># to every key correspond one or two values, representing the linked indices.</span>
        <span class="c"># All values in `links` are integers, negative numbers are used in the case</span>
        <span class="c"># where it is necessary to insert gamma matrices between free indices, in</span>
        <span class="c"># order to make Kahane&#39;s algorithm work (see paper).</span>
        <span class="n">links</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_dum_pos</span><span class="p">,</span> <span class="n">total_number</span><span class="p">):</span>
            <span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># `cum_sign` is a step variable to mark the sign of every index, see paper.</span>
        <span class="n">cum_sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c"># `cum_sign_list` keeps storage for all `cum_sign` (every index).</span>
        <span class="n">cum_sign_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">total_number</span>
        <span class="n">block_free_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># multiply `resulting_coeff` by the coefficient parameter, the rest</span>
        <span class="c"># of the algorithm ignores a scalar coefficient.</span>
        <span class="n">resulting_coeff</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="o">*</span> <span class="n">coeff</span>

        <span class="c"># initialize a lisf of lists of indices. The outer list will contain all</span>
        <span class="c"># additive tensor expressions, while the inner list will contain the</span>
        <span class="c"># free indices (rearranged according to the algorithm).</span>
        <span class="n">resulting_indices</span> <span class="o">=</span> <span class="p">[[]]</span>

        <span class="c"># start to count the `connected_components`, which together with the number</span>
        <span class="c"># of contractions, determines a -1 or +1 factor to be multiplied.</span>
        <span class="n">connected_components</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c"># First loop: here we fill `cum_sign_list`, and draw the links</span>
        <span class="c"># among consecutive indices (they are stored in `links`). Links among</span>
        <span class="c"># non-consecutive indices will be drawn later.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">is_free</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index_is_free</span><span class="p">):</span>
            <span class="c"># if `expression` starts with free indices, they are ignored here;</span>
            <span class="c"># they are later added as they are to the beginning of all</span>
            <span class="c"># `resulting_indices` list of lists of indices.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">is_free</span><span class="p">:</span>
                <span class="n">block_free_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c"># if previous index was free as well, draw an arch in `links`.</span>
                <span class="k">if</span> <span class="n">block_free_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">links</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Change the sign of the index (`cum_sign`) if the number of free</span>
                <span class="c"># indices preceding it is even.</span>
                <span class="n">cum_sign</span> <span class="o">*=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_free_count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">block_free_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                    <span class="c"># check if there are two consecutive dummy indices:</span>
                    <span class="c"># in this case create virtual indices with negative position,</span>
                    <span class="c"># these &quot;virtual&quot; indices represent the insertion of two</span>
                    <span class="c"># gamma^0 matrices to separate consecutive dummy indices, as</span>
                    <span class="c"># Kahane&#39;s algorithm requires dummy indices to be separated by</span>
                    <span class="c"># free indices. The product of two gamma^0 matrices is unity,</span>
                    <span class="c"># so the new expression being examined is the same as the</span>
                    <span class="c"># original one.</span>
                    <span class="k">if</span> <span class="n">cum_sign</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">links</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">links</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span><span class="p">)</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                        <span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">block_free_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_is_free</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">index_is_free</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span><span class="p">]:</span>
                                <span class="n">links</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">cum_sign</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">block_free_count</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">cum_sign_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cum_sign</span>

        <span class="c"># The previous loop has only created links between consecutive free indices,</span>
        <span class="c"># it is necessary to properly create links among dummy (contracted) indices,</span>
        <span class="c"># according to the rules described in Kahane&#39;s paper. There is only one exception</span>
        <span class="c"># to Kahane&#39;s rules: the negative indices, which handle the case of some</span>
        <span class="c"># consecutive free indices (Kahane&#39;s paper just describes dummy indices</span>
        <span class="c"># separated by free indices, hinting that free indices can be added without</span>
        <span class="c"># altering the expression result).</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dum</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;i[0] should be 0&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;i[1] should be 0&quot;</span><span class="p">)</span>
            <span class="c"># get the positions of the two contracted indices:</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

            <span class="c"># create Kahane&#39;s upper links, i.e. the upper arcs between dummy</span>
            <span class="c"># (i.e. contracted) indices:</span>
            <span class="n">links</span><span class="p">[</span><span class="n">pos1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos2</span><span class="p">)</span>
            <span class="n">links</span><span class="p">[</span><span class="n">pos2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos1</span><span class="p">)</span>

            <span class="c"># create Kahane&#39;s lower links, this corresponds to the arcs below</span>
            <span class="c"># the line described in the paper:</span>

            <span class="c"># first we move `pos1` and `pos2` according to the sign of the indices:</span>
            <span class="n">linkpos1</span> <span class="o">=</span> <span class="n">pos1</span> <span class="o">+</span> <span class="n">cum_sign_list</span><span class="p">[</span><span class="n">pos1</span><span class="p">]</span>
            <span class="n">linkpos2</span> <span class="o">=</span> <span class="n">pos2</span> <span class="o">+</span> <span class="n">cum_sign_list</span><span class="p">[</span><span class="n">pos2</span><span class="p">]</span>

            <span class="c"># otherwise, perform some checks before creating the lower arcs:</span>

            <span class="c"># make sure we are not exceeding the total number of indices:</span>
            <span class="k">if</span> <span class="n">linkpos1</span> <span class="o">&gt;=</span> <span class="n">total_number</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">linkpos2</span> <span class="o">&gt;=</span> <span class="n">total_number</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c"># make sure we are not below the first dummy index in `expression`:</span>
            <span class="k">if</span> <span class="n">linkpos1</span> <span class="o">&lt;</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">linkpos2</span> <span class="o">&lt;</span> <span class="n">first_dum_pos</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c"># check if the previous loop created &quot;virtual&quot; indices between dummy</span>
            <span class="c"># indices, in such a case relink `linkpos1` and `linkpos2`:</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">linkpos1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="n">linkpos1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">linkpos1</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">linkpos2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="n">linkpos2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">linkpos2</span>

            <span class="c"># move only if not next to free index:</span>
            <span class="k">if</span> <span class="n">linkpos1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index_is_free</span><span class="p">[</span><span class="n">linkpos1</span><span class="p">]:</span>
                <span class="n">linkpos1</span> <span class="o">=</span> <span class="n">pos1</span>

            <span class="k">if</span> <span class="n">linkpos2</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index_is_free</span><span class="p">[</span><span class="n">linkpos2</span><span class="p">]:</span>
                <span class="n">linkpos2</span> <span class="o">=</span> <span class="n">pos2</span>

            <span class="c"># create the lower arcs:</span>
            <span class="k">if</span> <span class="n">linkpos2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">links</span><span class="p">[</span><span class="n">linkpos1</span><span class="p">]:</span>
                <span class="n">links</span><span class="p">[</span><span class="n">linkpos1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkpos2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">linkpos1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">links</span><span class="p">[</span><span class="n">linkpos2</span><span class="p">]:</span>
                <span class="n">links</span><span class="p">[</span><span class="n">linkpos2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linkpos1</span><span class="p">)</span>

        <span class="c"># This loop starts from the `first_dum_pos` index (first dummy index)</span>
        <span class="c"># walks through the graph deleting the visited indices from `links`,</span>
        <span class="c"># it adds a gamma matrix for every free index in encounters, while it</span>
        <span class="c"># completely ignores dummy indices and virtual indices.</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">first_dum_pos</span>
        <span class="n">previous_pointer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pointer</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                <span class="n">next_ones</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">previous_pointer</span> <span class="ow">in</span> <span class="n">next_ones</span><span class="p">:</span>
                <span class="n">next_ones</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">previous_pointer</span><span class="p">)</span>

            <span class="n">previous_pointer</span> <span class="o">=</span> <span class="n">pointer</span>

            <span class="k">if</span> <span class="n">next_ones</span><span class="p">:</span>
                <span class="n">pointer</span> <span class="o">=</span> <span class="n">next_ones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">pointer</span> <span class="o">==</span> <span class="n">previous_pointer</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">pointer</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">free_pos</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">resulting_indices</span><span class="p">:</span>
                    <span class="n">ri</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">free_pos</span><span class="p">[</span><span class="n">pointer</span><span class="p">])</span>

        <span class="c"># The following loop removes the remaining connected components in `links`.</span>
        <span class="c"># If there are free indices inside a connected component, it gives a</span>
        <span class="c"># contribution to the resulting expression given by the factor</span>
        <span class="c"># `gamma_a gamma_b ... gamma_z + gamma_z ... gamma_b gamma_a`, in Kahanes&#39;s</span>
        <span class="c"># paper represented as  {gamma_a, gamma_b, ... , gamma_z},</span>
        <span class="c"># virtual indices are ignored. The variable `connected_components` is</span>
        <span class="c"># increased by one for every connected component this loop encounters.</span>

        <span class="c"># If the connected component has virtual and dummy indices only</span>
        <span class="c"># (no free indices), it contributes to `resulting_indices` by a factor of two.</span>
        <span class="c"># The multiplication by two is a result of the</span>
        <span class="c"># factor {gamma^0, gamma^0} = 2 I, as it appears in Kahane&#39;s paper.</span>
        <span class="c"># Note: curly brackets are meant as in the paper, as a generalized</span>
        <span class="c"># multi-element anticommutator!</span>

        <span class="k">while</span> <span class="n">links</span><span class="p">:</span>
            <span class="n">connected_components</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">links</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">previous_pointer</span> <span class="o">=</span> <span class="n">pointer</span>
            <span class="c"># the inner loop erases the visited indices from `links`, and it adds</span>
            <span class="c"># all free indices to `prepend_indices` list, virtual indices are</span>
            <span class="c"># ignored.</span>
            <span class="n">prepend_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pointer</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
                    <span class="n">next_ones</span> <span class="o">=</span> <span class="n">links</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="n">previous_pointer</span> <span class="ow">in</span> <span class="n">next_ones</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_ones</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">next_ones</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">previous_pointer</span><span class="p">)</span>

                <span class="n">previous_pointer</span> <span class="o">=</span> <span class="n">pointer</span>

                <span class="k">if</span> <span class="n">next_ones</span><span class="p">:</span>
                    <span class="n">pointer</span> <span class="o">=</span> <span class="n">next_ones</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">pointer</span> <span class="o">&gt;=</span> <span class="n">first_dum_pos</span> <span class="ow">and</span> <span class="n">free_pos</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">prepend_indices</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">free_pos</span><span class="p">[</span><span class="n">pointer</span><span class="p">])</span>
            <span class="c"># if `prepend_indices` is void, it means there are no free indices</span>
            <span class="c"># in the loop (and it can be shown that there must be a virtual index),</span>
            <span class="c"># loops of virtual indices only contribute by a factor of two:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prepend_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">resulting_coeff</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="c"># otherwise, add the free indices in `prepend_indices` to</span>
            <span class="c"># the `resulting_indices`:</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expr1</span> <span class="o">=</span> <span class="n">prepend_indices</span>
                <span class="n">expr2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">prepend_indices</span><span class="p">))</span>
                <span class="n">resulting_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">expri</span> <span class="o">+</span> <span class="n">ri</span> <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">resulting_indices</span> <span class="k">for</span> <span class="n">expri</span> <span class="ow">in</span> <span class="p">(</span><span class="n">expr1</span><span class="p">,</span> <span class="n">expr2</span><span class="p">)]</span>

        <span class="c"># sign correction, as described in Kahane&#39;s paper:</span>
        <span class="n">resulting_coeff</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">number_of_contractions</span> <span class="o">-</span> <span class="n">connected_components</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="c"># power of two factor, as described in Kahane&#39;s paper:</span>
        <span class="n">resulting_coeff</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">number_of_contractions</span><span class="p">)</span>

        <span class="c"># If `first_dum_pos` is not zero, it means that there are trailing free gamma</span>
        <span class="c"># matrices in front of `expression`, so multiply by them:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">first_dum_pos</span><span class="p">):</span>
            <span class="p">[</span><span class="n">ri</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">free_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">resulting_indices</span><span class="p">]</span>

        <span class="n">resulting_expr</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">resulting_indices</span><span class="p">:</span>
            <span class="n">temp_expr</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">temp_expr</span> <span class="o">*=</span> <span class="n">GammaMatrix</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">resulting_expr</span> <span class="o">+=</span> <span class="n">temp_expr</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">resulting_coeff</span> <span class="o">*</span> <span class="n">resulting_expr</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">):</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">t</span>
        <span class="k">if</span> <span class="n">t1</span><span class="p">:</span>
            <span class="n">spinor_free1</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">t1</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">spinor_free1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spinor_free</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">,</span> <span class="n">spinor_free</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># FIXME trace</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_right</span><span class="p">,</span> <span class="o">-</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">auto_left</span><span class="p">)</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">GammaMatrix</span><span class="o">.</span><span class="n">simplify_lines</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">spinor_free</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">spinor_free</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="mi">4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spinor_free</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">DiracSpinorIndex</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">spinor_free</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">spinor_free</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="mi">4</span>
        <span class="k">return</span> <span class="n">t</span>
</div>
<span class="n">GammaMatrix</span> <span class="o">=</span> <span class="n">GammaMatrixHead</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../index.html">
              <img class="logo" src="../../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../../index.html">SymPy 0.7.5-git documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014 SymPy Development Team.
      Last updated on Jun 24, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>