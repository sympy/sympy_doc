

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.core.expr &mdash; SymPy v0.7.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="top" title="SymPy v0.7.1 documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy v0.7.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.core.expr</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">core</span> <span class="kn">import</span> <span class="n">C</span>
<span class="kn">from</span> <span class="nn">basic</span> <span class="kn">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">singleton</span> <span class="kn">import</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">evalf</span> <span class="kn">import</span> <span class="n">EvalfMixin</span>
<span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">_sympifyit</span><span class="p">,</span> <span class="n">call_highest_priority</span>
<span class="kn">from</span> <span class="nn">cache</span> <span class="kn">import</span> <span class="n">cacheit</span>
<span class="kn">from</span> <span class="nn">compatibility</span> <span class="kn">import</span> <span class="nb">reduce</span>

<div class="viewcode-block" id="Expr"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr">[docs]</a><span class="k">class</span> <span class="nc">Expr</span><span class="p">(</span><span class="n">Basic</span><span class="p">,</span> <span class="n">EvalfMixin</span><span class="p">):</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># XXX: The order argument does not actually work</span>
        <span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">S</span>

        <span class="k">def</span> <span class="nf">key_inner</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Basic</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key_inner</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arg</span>

        <span class="n">coeff</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expr</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">expr</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expr</span><span class="p">),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">expr</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_ordered_terms</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span>

            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key_inner</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">class_key</span><span class="p">(),</span> <span class="n">args</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">coeff</span>


    <span class="c"># ***************</span>
    <span class="c"># * Arithmetics *</span>
    <span class="c"># ***************</span>

    <span class="c"># Expr and its sublcasses use _op_priority to determine which object</span>
    <span class="c"># passed to a binary special method (__mul__, etc.) will handle the</span>
    <span class="c"># operation. In general, the &#39;call_highest_priority&#39; decorator will choose</span>
    <span class="c"># the object with the highest _op_priority to handle the call.</span>
    <span class="c"># Custom subclasses that want to define their own binary special methods</span>
    <span class="c"># should set an _op_priority value that is higher than the default.</span>
    <span class="c">#</span>
    <span class="c"># **NOTE**:</span>
    <span class="c"># This is a temporary fix, and will eventually be replaced with</span>
    <span class="c"># something better and more powerful.  See issue 2411.</span>
    <span class="n">_op_priority</span> <span class="o">=</span> <span class="mf">10.0</span>

    <span class="k">def</span> <span class="nf">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__radd__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__add__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rsub__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)</span>
    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__sub__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rmul__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__mul__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rpow__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__pow__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Pow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__rdiv__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Pow</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">))</span>
    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">NotImplemented</span><span class="p">)</span>
    <span class="nd">@call_highest_priority</span><span class="p">(</span><span class="s">&#39;__div__&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Pow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">))</span>

    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>
    <span class="n">__rtruediv__</span> <span class="o">=</span> <span class="n">__rdiv__</span>


    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Symbolic value, can&#39;t compute&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalf</span><span class="p">()</span>
        <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">im</span><span class="p">))</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="c"># sympy &gt;  other</span>
    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span> <span class="o">!=</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">StrictInequality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>  <span class="c"># sympy &gt;  other</span>
    <span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span> <span class="o">!=</span>  <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">StrictInequality</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span> <span class="c"># sympy &gt;  other</span>
    <span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span> <span class="o">!=</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonpositive</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Inequality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@_sympifyit</span><span class="p">(</span><span class="s">&#39;other&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>  <span class="c"># sympy &gt;  other</span>
    <span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">dif</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span> <span class="o">!=</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dif</span><span class="o">.</span><span class="n">is_nonnegative</span>
        <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Inequality</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_from_mpmath</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;_mpf_&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_mpf_</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;_mpc_&quot;</span><span class="p">):</span>
            <span class="n">re</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_mpc_</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Float</span><span class="o">.</span><span class="n">_new</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span>
            <span class="k">return</span> <span class="n">re</span><span class="o">+</span><span class="n">im</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;expected mpmath number (mpf or mpc)&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="Expr.is_number"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.is_number">[docs]</a>    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if &#39;self&#39; is a number.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import log, Integral</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">           &gt;&gt;&gt; x.is_number</span>
<span class="sd">           False</span>
<span class="sd">           &gt;&gt;&gt; (2*x).is_number</span>
<span class="sd">           False</span>
<span class="sd">           &gt;&gt;&gt; (2 + log(2)).is_number</span>
<span class="sd">           True</span>
<span class="sd">           &gt;&gt;&gt; (2 + Integral(2, x)).is_number</span>
<span class="sd">           False</span>
<span class="sd">           &gt;&gt;&gt; (2 + Integral(2, (x, 1, 2))).is_number</span>
<span class="sd">           True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_basic_args</span><span class="p">())</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns evaluation over an interval.  For most functions this is:</span>

<span class="sd">        self.subs(x, b) - self.subs(x, a),</span>

<span class="sd">        possibly using limit() if NaN is returned from subs.</span>

<span class="sd">        If b or a is None, it only evaluates -self.subs(x, a) or self.subs(b, x),</span>
<span class="sd">        respectively.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series</span> <span class="kn">import</span> <span class="n">limit</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Both interval ends cannot be None.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">A</span>

        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">B</span> <span class="o">-</span> <span class="n">A</span>

    <span class="k">def</span> <span class="nf">_eval_power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_eval_conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">sympy.functions.elementary.complexes</span> <span class="kn">import</span> <span class="n">conjugate</span> <span class="k">as</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_order</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse and configure the ordering of terms. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys.monomialtools</span> <span class="kn">import</span> <span class="n">monomial_key</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;rev-&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">reverse</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
                <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>

        <span class="n">monom_key</span> <span class="o">=</span> <span class="n">monomial_key</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">neg</span><span class="p">(</span><span class="n">monom</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">monom</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neg</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="p">((</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">),</span> <span class="n">monom</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)</span> <span class="o">=</span> <span class="n">term</span>

            <span class="n">monom</span> <span class="o">=</span> <span class="n">neg</span><span class="p">(</span><span class="n">monom_key</span><span class="p">(</span><span class="n">monom</span><span class="p">))</span>
            <span class="n">ncpart</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span> <span class="n">e</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ncpart</span> <span class="p">])</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="p">((</span><span class="nb">bool</span><span class="p">(</span><span class="n">im</span><span class="p">),</span> <span class="n">im</span><span class="p">),</span> <span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">monom</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">,</span> <span class="n">coeff</span>

        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">reverse</span>

<div class="viewcode-block" id="Expr.as_ordered_factors"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_ordered_factors">[docs]</a>    <span class="k">def</span> <span class="nf">as_ordered_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform an expression to an ordered list of factors.</span>

<span class="sd">        **Examples**</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; (2*x*y*sin(x)*cos(x)).as_ordered_factors()</span>
<span class="sd">        [2, x, y, sin(x), cos(x)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>

        <span class="n">cpart</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ncpart</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">cpart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ncpart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cpart</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">expr</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">sort_key</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">))</span> <span class="o">+</span> <span class="n">ncpart</span>
</div>
<div class="viewcode-block" id="Expr.as_ordered_terms"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_ordered_terms">[docs]</a>    <span class="k">def</span> <span class="nf">as_ordered_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform an expression to an ordered list of terms.</span>

<span class="sd">        **Examples**</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()</span>
<span class="sd">        [sin(x)**2*cos(x), sin(x)**2, 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">reverse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_order</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">terms</span><span class="p">,</span> <span class="n">gens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_terms</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">term</span><span class="o">.</span><span class="n">is_Order</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">):</span>
            <span class="n">ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_terms</span><span class="p">,</span> <span class="n">_order</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="nb">repr</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">term</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
                    <span class="n">_terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="nb">repr</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_order</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="nb">repr</span><span class="p">))</span>

            <span class="n">ordered</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_terms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> \
                    <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_order</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ordered</span><span class="p">,</span> <span class="n">gens</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span> <span class="n">term</span> <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ordered</span> <span class="p">]</span>
</div>
<div class="viewcode-block" id="Expr.as_terms"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_terms">[docs]</a>    <span class="k">def</span> <span class="nf">as_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transform an expression to a list of terms. &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">S</span>
        <span class="kn">from</span> <span class="nn">sympy.core.exprtools</span> <span class="kn">import</span> <span class="n">decompose_power</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities</span> <span class="kn">import</span> <span class="n">default_sort_key</span>

        <span class="n">gens</span><span class="p">,</span> <span class="n">terms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([]),</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">_term</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_coeff_Mul</span><span class="p">()</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">_term</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">factor</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">_term</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_number</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">coeff</span> <span class="o">*=</span> <span class="nb">complex</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="k">pass</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">continue</span>

                    <span class="k">if</span> <span class="n">factor</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                        <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">decompose_power</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

                        <span class="n">cpart</span><span class="p">[</span><span class="n">base</span><span class="p">]</span> <span class="o">=</span> <span class="n">exp</span>
                        <span class="n">gens</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ncpart</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

            <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">coeff</span><span class="o">.</span><span class="n">imag</span>
            <span class="n">ncpart</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ncpart</span><span class="p">)</span>

            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)))</span>

        <span class="n">gens</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">gens</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">default_sort_key</span><span class="p">)</span>

        <span class="n">k</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gens</span><span class="p">),</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gens</span><span class="p">):</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">cpart</span><span class="p">,</span> <span class="n">ncpart</span><span class="p">)</span> <span class="ow">in</span> <span class="n">terms</span><span class="p">:</span>
            <span class="n">monom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">k</span>

            <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">exp</span> <span class="ow">in</span> <span class="n">cpart</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">monom</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">base</span><span class="p">]]</span> <span class="o">=</span> <span class="n">exp</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">monom</span><span class="p">),</span> <span class="n">ncpart</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">gens</span>

</div>
<div class="viewcode-block" id="Expr.removeO"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.removeO">[docs]</a>    <span class="k">def</span> <span class="nf">removeO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the additive O(..) symbol if there is one&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Expr.getO"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.getO">[docs]</a>    <span class="k">def</span> <span class="nf">getO</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the additive O(..) symbol if there is one, else None.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Expr.getn"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.getn">[docs]</a>    <span class="k">def</span> <span class="nf">getn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the order of the expression.</span>

<span class="sd">        The order is determined either from the O(...) term. If there</span>
<span class="sd">        is no O(...) term, it returns None.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import O</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1 + x + O(x**2)).getn()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (1 + x).getn()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">expr</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span> <span class="c"># x**n*log(x)**n or x**n/log(x)**n</span>
                <span class="k">for</span> <span class="n">oi</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
                    <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
                        <span class="n">syms</span> <span class="o">=</span> <span class="n">oi</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="n">oi</span> <span class="o">=</span> <span class="n">oi</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">oi</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">and</span> <span class="n">oi</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">oi</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;not sure of order of </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">o</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.count_ops"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.count_ops">[docs]</a>    <span class="k">def</span> <span class="nf">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;wrapper for count_ops that returns the operation count.&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">count_ops</span>
        <span class="k">return</span> <span class="n">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visual</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.args_cnc"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.args_cnc">[docs]</a>    <span class="k">def</span> <span class="nf">args_cnc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;treat self as Mul and split it into tuple (set, list)</span>
<span class="sd">        where ``set`` contains the commutative parts and ``list`` contains</span>
<span class="sd">        the ordered non-commutative args.</span>

<span class="sd">        A special treatment is that -1 is separated from a Rational:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; A, B = symbols(&#39;A B&#39;, commutative=0)</span>
<span class="sd">        &gt;&gt;&gt; x, y = symbols(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*y).args_cnc()</span>
<span class="sd">        [set([-1, 2, x, y]), []]</span>
<span class="sd">        &gt;&gt;&gt; (-2*x*A*B*y).args_cnc()</span>
<span class="sd">        [set([-1, 2, x, y]), [A, B]]</span>

<span class="sd">        The arg is treated as a Mul:</span>

<span class="sd">        &gt;&gt;&gt; (-2 + x + A).args_cnc()</span>
<span class="sd">        [set(), [x - 2 + A]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mi</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="n">nc</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">args</span>
            <span class="n">nc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">and</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
            <span class="n">c</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">nc</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Expr.coeff"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.coeff">[docs]</a>    <span class="k">def</span> <span class="nf">coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coefficient of the exact term &quot;x&quot; or None if there is no &quot;x&quot;.</span>

<span class="sd">        When x is noncommutative, the coeff to the left (default) or right of x</span>
<span class="sd">        can be returned. The keyword &#39;right&#39; is ignored when x is commutative.</span>

<span class="sd">        Examples::</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        You can select terms that have an explicit negative in front of them:</span>

<span class="sd">        &gt;&gt;&gt; (-x+2*y).coeff(-1)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (x-2*y).coeff(-1)</span>
<span class="sd">        2*y</span>

<span class="sd">        You can select terms with no rational coefficient:</span>

<span class="sd">        &gt;&gt;&gt; (x+2*y).coeff(1)</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; (3+2*x+4*x**2).coeff(1)</span>

<span class="sd">        You can select terms that have a numerical term in front of them:</span>

<span class="sd">        &gt;&gt;&gt; (-x-2*y).coeff(2)</span>
<span class="sd">        -y</span>
<span class="sd">        &gt;&gt;&gt; from sympy import sqrt</span>
<span class="sd">        &gt;&gt;&gt; (x+sqrt(2)*x).coeff(sqrt(2))</span>
<span class="sd">        x</span>

<span class="sd">        The matching is exact:</span>

<span class="sd">        &gt;&gt;&gt; (3+2*x+4*x**2).coeff(x)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; (3+2*x+4*x**2).coeff(x**2)</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; (3+2*x+4*x**2).coeff(x**3)</span>
<span class="sd">        &gt;&gt;&gt; (z*(x+y)**2).coeff((x+y)**2)</span>
<span class="sd">        z</span>
<span class="sd">        &gt;&gt;&gt; (z*(x+y)**2).coeff(x+y)</span>

<span class="sd">        In addition, no factoring is done, so 2 + y is not obtained from the</span>
<span class="sd">        following:</span>

<span class="sd">        &gt;&gt;&gt; (2*x+2+(x+1)*y).coeff(x+1)</span>
<span class="sd">        y</span>

<span class="sd">        &gt;&gt;&gt; n, m, o = symbols(&#39;n m o&#39;, commutative=False)</span>
<span class="sd">        &gt;&gt;&gt; n.coeff(n)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (3*n).coeff(n)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; (n*m + m*n*m).coeff(n) # = (1 + m)*n*m</span>
<span class="sd">        1 + m</span>
<span class="sd">        &gt;&gt;&gt; (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m</span>
<span class="sd">        m</span>

<span class="sd">        If there is more than one possible coefficient None is returned:</span>

<span class="sd">        &gt;&gt;&gt; (n*m + m*n).coeff(n)</span>

<span class="sd">        If there is only one possible coefficient, it is returned:</span>

<span class="sd">        &gt;&gt;&gt; (n*m + o*m*n).coeff(m*n)</span>
<span class="sd">        o</span>
<span class="sd">        &gt;&gt;&gt; (n*m + o*m*n).coeff(m*n, right=1)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span> <span class="c"># 0 or None</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span>
                <span class="c"># replace try/except with this</span>
                <span class="n">co</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                      <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">ai</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">a</span><span class="p">))]</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="n">co</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">])</span>
                      <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">ai</span><span class="o">.</span><span class="n">is_number</span> <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">]))]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">incommon</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">l1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l2</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">l2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">l2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">l1</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">l1</span><span class="p">[:]</span>

        <span class="k">def</span> <span class="nf">arglist</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Return list of x&#39;s args when treated as a Mul after checking</span>
<span class="sd">            to see if a negative Rational is present (in which case it is made</span>
<span class="sd">            positive and a -1 is added to the list).</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">margs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">)</span>
                <span class="c"># replace try/except with the following</span>
                <span class="k">if</span> <span class="n">margs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">margs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">and</span> <span class="n">margs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                    <span class="n">margs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">)</span>
                    <span class="n">margs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">margs</span> <span class="ow">and</span> <span class="n">margs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Rational</span> <span class="ow">and</span> <span class="n">margs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_negative</span> <span class="ow">and</span> <span class="n">margs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">:</span>
                    <span class="n">margs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span><span class="p">)</span>
                    <span class="n">margs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">margs</span>

        <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Find where list sub appears in list l. When ``first`` is True</span>
<span class="sd">            the first occurance from the left is returned, else the last</span>
<span class="sd">            occurance is returned. Return None if sub is not in l.</span>

<span class="sd">            &gt;&gt; l = range(5)*2</span>
<span class="sd">            &gt;&gt; find(l, [2, 3])</span>
<span class="sd">            2</span>
<span class="sd">            &gt;&gt; find(l, [2, 3], first=0)</span>
<span class="sd">            7</span>
<span class="sd">            &gt;&gt; find(l, [2, 4])</span>
<span class="sd">            None</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sub</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">l</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">sub</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">l</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">sub</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span>

        <span class="n">co</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">)</span>
            <span class="c"># replace try/except with this</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">or</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">]</span>
        <span class="n">self_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_commutative</span>
        <span class="n">x_c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">is_commutative</span>
        <span class="k">if</span> <span class="n">self_c</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x_c</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">self_c</span><span class="p">:</span>
            <span class="n">xargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arglist</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">margs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arglist</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">resid</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">co</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">elif</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_c</span><span class="p">:</span>
            <span class="n">xargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">arglist</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">margs</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="n">nc</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">co</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">elif</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># both nc</span>
            <span class="n">xargs</span><span class="p">,</span> <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
            <span class="c"># find the parts that pass the commutative terms</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">margs</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">resid</span> <span class="o">=</span> <span class="n">margs</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">xargs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">margs</span><span class="p">):</span>
                    <span class="n">co</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">resid</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>
            <span class="c"># now check the non-comm parts</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">co</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ii</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">co</span><span class="p">]),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">ii</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>
            <span class="n">beg</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">incommon</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">beg</span><span class="p">:</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ii</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="n">gcdc</span> <span class="o">=</span> <span class="n">co</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">co</span><span class="p">)):</span>
                            <span class="n">gcdc</span> <span class="o">=</span> <span class="n">gcdc</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">co</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">gcdc</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">gcdc</span><span class="p">)</span> <span class="o">+</span> <span class="n">beg</span><span class="p">[:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">ii</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="n">m</span><span class="p">:]))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">reduce</span><span class="p">(</span><span class="n">incommon</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">))))</span>
            <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ii</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">end</span><span class="p">)</span><span class="o">+</span><span class="n">ii</span><span class="p">]))</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">co</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>
            <span class="c"># look for single match</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">co</span><span class="p">):</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ii</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">hit</span><span class="p">:</span>
                        <span class="n">hit</span> <span class="o">=</span> <span class="n">ii</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hit</span><span class="p">:</span>
                    <span class="n">ii</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hit</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">[:</span><span class="n">ii</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">nx</span><span class="p">):])</span>

            <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Expr.as_expr"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_expr">[docs]</a>    <span class="k">def</span> <span class="nf">as_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a polynomial to a SymPy expression.</span>

<span class="sd">        **Examples**</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; f = (x**2 + x*y).as_poly(x, y)</span>
<span class="sd">        &gt;&gt;&gt; f.as_expr()</span>
<span class="sd">        x**2 + x*y</span>

<span class="sd">        &gt;&gt;&gt; sin(x).as_expr()</span>
<span class="sd">        sin(x)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Expr.as_coefficient"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">as_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts symbolic coefficient at the given expression. In</span>
<span class="sd">           other words, this functions separates &#39;self&#39; into product</span>
<span class="sd">           of &#39;expr&#39; and &#39;expr&#39;-free coefficient. If such separation</span>
<span class="sd">           is not possible it will return None.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import E, pi, sin, I, symbols</span>
<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">           &gt;&gt;&gt; E.as_coefficient(E)</span>
<span class="sd">           1</span>
<span class="sd">           &gt;&gt;&gt; (2*E).as_coefficient(E)</span>
<span class="sd">           2</span>
<span class="sd">           &gt;&gt;&gt; (2*sin(E)*E).as_coefficient(E)</span>

<span class="sd">           &gt;&gt;&gt; (2*E + x*E).as_coefficient(E)</span>
<span class="sd">           x + 2</span>
<span class="sd">           &gt;&gt;&gt; (2*E*x + x).as_coefficient(E)</span>

<span class="sd">           &gt;&gt;&gt; (E*(x + 1) + x).as_coefficient(E)</span>

<span class="sd">           &gt;&gt;&gt; (2*pi*I).as_coefficient(pi*I)</span>
<span class="sd">           2</span>
<span class="sd">           &gt;&gt;&gt; (2*I).as_coefficient(pi*I)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">r</span>
</div>
<div class="viewcode-block" id="Expr.as_independent"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_independent">[docs]</a>    <span class="k">def</span> <span class="nf">as_independent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">,</span> <span class="o">**</span><span class="n">hint</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A mostly naive separation of a Mul or Add into arguments that are not</span>
<span class="sd">        are dependent on deps. To obtain as complete a separation of variables</span>
<span class="sd">        as possible, use a separation method first, e.g.:</span>

<span class="sd">        * separatevars() to change Mul, Add and Pow (including exp) into Mul</span>
<span class="sd">        * .expand(mul=True) to change Add or Mul into Add</span>
<span class="sd">        * .expand(log=True) to change log expr into an Add</span>

<span class="sd">        The only non-naive thing that is done here is to respect noncommutative</span>
<span class="sd">        ordering of variables.</span>

<span class="sd">        The returned tuple (i, d) has the following interpretation:</span>

<span class="sd">        * i will has no variable that appears in deps</span>
<span class="sd">        * d will be 1 or else have terms that contain variables that are in deps</span>
<span class="sd">        * if self is an Add then self = i + d</span>
<span class="sd">        * if self is a Mul then self = i*d</span>
<span class="sd">        * if self is anything else, either tuple (self, S.One) or (S.One, self)</span>
<span class="sd">          is returned.</span>

<span class="sd">        To force the expression to be treated as an Add, use the hint as_Add=True</span>

<span class="sd">        Examples:</span>

<span class="sd">        -- self is an Add</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sin, cos, exp</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y, z</span>

<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(x)</span>
<span class="sd">        (0, x*y + x)</span>
<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; (2*x*sin(x) + y + x + z).as_independent(x)</span>
<span class="sd">        (y + z, 2*x*sin(x) + x)</span>
<span class="sd">        &gt;&gt;&gt; (2*x*sin(x) + y + x + z).as_independent(x, y)</span>
<span class="sd">        (z, 2*x*sin(x) + x + y)</span>

<span class="sd">        -- self is a Mul</span>

<span class="sd">        &gt;&gt;&gt; (x*sin(x)*cos(y)).as_independent(x)</span>
<span class="sd">        (cos(y), x*sin(x))</span>

<span class="sd">        non-commutative terms cannot always be separated out when self is a Mul</span>

<span class="sd">        &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">        &gt;&gt;&gt; n1, n2, n3 = symbols(&#39;n1 n2 n3&#39;, commutative=False)</span>
<span class="sd">        &gt;&gt;&gt; (n1 + n1*n2).as_independent(n2)</span>
<span class="sd">        (n1, n1*n2)</span>
<span class="sd">        &gt;&gt;&gt; (n2*n1 + n1*n2).as_independent(n2)</span>
<span class="sd">        (0, n1*n2 + n2*n1)</span>
<span class="sd">        &gt;&gt;&gt; (n1*n2*n3).as_independent(n1)</span>
<span class="sd">        (1, n1*n2*n3)</span>
<span class="sd">        &gt;&gt;&gt; (n1*n2*n3).as_independent(n2)</span>
<span class="sd">        (n1, n2*n3)</span>
<span class="sd">        &gt;&gt;&gt; ((x-n1)*(x-y)).as_independent(x)</span>
<span class="sd">        (1, (x - y)*(x - n1))</span>

<span class="sd">        -- self is anything else:</span>

<span class="sd">        &gt;&gt;&gt; (sin(x)).as_independent(x)</span>
<span class="sd">        (1, sin(x))</span>
<span class="sd">        &gt;&gt;&gt; (sin(x)).as_independent(y)</span>
<span class="sd">        (sin(x), 1)</span>
<span class="sd">        &gt;&gt;&gt; exp(x+y).as_independent(x)</span>
<span class="sd">        (1, exp(x + y))</span>

<span class="sd">        -- force self to be treated as an Add:</span>

<span class="sd">        &gt;&gt;&gt; (3*x).as_independent(x, as_Add=1)</span>
<span class="sd">        (0, 3*x)</span>

<span class="sd">        -- force self to be treated as a Mul:</span>

<span class="sd">        &gt;&gt;&gt; (3+x).as_independent(x, as_Add=0)</span>
<span class="sd">        (1, x + 3)</span>
<span class="sd">        &gt;&gt;&gt; (-3+x).as_independent(x, as_Add=0)</span>
<span class="sd">        (1, x - 3)</span>

<span class="sd">        Note how the below differs from the above in making the</span>
<span class="sd">        constant on the dep term positive.</span>

<span class="sd">        &gt;&gt;&gt; (y*(-3+x)).as_independent(x)</span>
<span class="sd">        (y, x - 3)</span>

<span class="sd">        Note: when trying to get independent terms, a separation method</span>
<span class="sd">        might need to be used first. In this case, it is important to keep</span>
<span class="sd">        track of what you send to this routine so you know how to interpret</span>
<span class="sd">        the returned values</span>

<span class="sd">        &gt;&gt;&gt; from sympy import separatevars, log</span>
<span class="sd">        &gt;&gt;&gt; separatevars(exp(x+y)).as_independent(x)</span>
<span class="sd">        (exp(y), exp(x))</span>
<span class="sd">        &gt;&gt;&gt; (x + x*y).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; separatevars(x + x*y).as_independent(y)</span>
<span class="sd">        (x, y + 1)</span>
<span class="sd">        &gt;&gt;&gt; (x*(1 + y)).as_independent(y)</span>
<span class="sd">        (x, y + 1)</span>
<span class="sd">        &gt;&gt;&gt; (x*(1 + y)).expand(mul=True).as_independent(y)</span>
<span class="sd">        (x, x*y)</span>
<span class="sd">        &gt;&gt;&gt; a, b=symbols(&#39;a b&#39;,positive=True)</span>
<span class="sd">        &gt;&gt;&gt; (log(a*b).expand(log=True)).as_independent(b)</span>
<span class="sd">        (log(a), log(b))</span>

<span class="sd">        See also: .separatevars(), .expand(log=True),</span>
<span class="sd">                  .as_two_terms(), .as_coeff_add(), .as_coeff_mul()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">sift</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span>
        <span class="k">if</span> <span class="n">hint</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;as_Add&#39;</span><span class="p">,</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">):</span>
            <span class="n">want</span> <span class="o">=</span> <span class="n">Add</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">want</span> <span class="o">=</span> <span class="n">Mul</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">func</span> <span class="ow">or</span>
            <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Add</span> <span class="ow">and</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Mul</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">want</span><span class="o">.</span><span class="n">identity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">want</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_cnc</span><span class="p">()</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">sift</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">))</span>
        <span class="n">depend</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">indep</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">Add</span><span class="p">:</span> <span class="c"># all terms were treated as commutative</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">indep</span><span class="p">),</span>
                    <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># handle noncommutative by stopping at first dependent term</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                    <span class="n">depend</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nc</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                    <span class="k">break</span>
                <span class="n">indep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">indep</span><span class="p">),</span> <span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="n">depend</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.as_real_imag"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_real_imag">[docs]</a>    <span class="k">def</span> <span class="nf">as_real_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs complex expansion on &#39;self&#39; and returns a tuple</span>
<span class="sd">           containing collected both real and imaginary parts. This</span>
<span class="sd">           method can&#39;t be confused with re() and im() functions,</span>
<span class="sd">           which does not perform complex expansion at evaluation.</span>

<span class="sd">           However it is possible to expand both re() and im()</span>
<span class="sd">           functions and get exactly the same results as with</span>
<span class="sd">           a single call to this function.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import symbols, I</span>

<span class="sd">           &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;, real=True)</span>

<span class="sd">           &gt;&gt;&gt; (x + y*I).as_real_imag()</span>
<span class="sd">           (x, y)</span>

<span class="sd">           &gt;&gt;&gt; from sympy.abc import z, w</span>

<span class="sd">           &gt;&gt;&gt; (z + w*I).as_real_imag()</span>
<span class="sd">           (-im(w) + re(z), im(z) + re(w))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">C</span><span class="o">.</span><span class="n">im</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">as_powers_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">as_base_exp</span><span class="p">()])</span>

    <span class="k">def</span> <span class="nf">as_base_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># a -&gt; b ** e</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="k">def</span> <span class="nf">as_coeff_terms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">use as_coeff_mul() instead of as_coeff_terms().&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_coeff_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">warnings</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">use as_coeff_add() instead of as_coeff_factors().&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>

<div class="viewcode-block" id="Expr.as_coeff_mul"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_mul">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple (c, args) where self is written as a Mul, ``m``.</span>

<span class="sd">        c should be a Rational multiplied by any terms of the Mul that are</span>
<span class="sd">        independent of deps.</span>

<span class="sd">        args should be a tuple of all other terms of m; args is empty</span>
<span class="sd">        if self is a Number or if self is independent of deps (when given).</span>

<span class="sd">        This should be used when you don&#39;t know if self is a Mul or not but</span>
<span class="sd">        you want to treat self as a Mul or if you want to process the</span>
<span class="sd">        individual arguments of the tail of self as a Mul.</span>

<span class="sd">        - if you know self is a Mul and want only the head, use self.args[0];</span>
<span class="sd">        - if you don&#39;t want to process the arguments of the tail but need the</span>
<span class="sd">          tail then use self.as_two_terms() which gives the head and tail;</span>
<span class="sd">        - if you want to split self into an independent and dependent parts</span>
<span class="sd">          use self.as_independent(\*deps)</span>

<span class="sd">        &gt;&gt;&gt; from sympy import S</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (S(3)).as_coeff_mul()</span>
<span class="sd">        (3, ())</span>
<span class="sd">        &gt;&gt;&gt; (3*x*y).as_coeff_mul()</span>
<span class="sd">        (3, (x, y))</span>
<span class="sd">        &gt;&gt;&gt; (3*x*y).as_coeff_mul(x)</span>
<span class="sd">        (3*y, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3*y).as_coeff_mul(x)</span>
<span class="sd">        (3*y, ())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
</div>
<div class="viewcode-block" id="Expr.as_coeff_add"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_add">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">deps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the tuple (c, args) where self is written as an Add, ``a``.</span>

<span class="sd">        c should be a Rational added to any terms of the Add that are</span>
<span class="sd">        independent of deps.</span>

<span class="sd">        args should be a tuple of all other terms of ``a``; args is empty</span>
<span class="sd">        if self is a Number or if self is independent of deps (when given).</span>

<span class="sd">        This should be used when you don&#39;t know if self is an Add or not but</span>
<span class="sd">        you want to treat self as an Add or if you want to process the</span>
<span class="sd">        individual arguments of the tail of self as an Add.</span>

<span class="sd">        - if you know self is an Add and want only the head, use self.args[0];</span>
<span class="sd">        - if you don&#39;t want to process the arguments of the tail but need the</span>
<span class="sd">          tail then use self.as_two_terms() which gives the head and tail.</span>
<span class="sd">        - if you want to split self into an independent and dependent parts</span>
<span class="sd">          use self.as_independent(\*deps)</span>

<span class="sd">        &gt;&gt;&gt; from sympy import S</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">        &gt;&gt;&gt; (S(3)).as_coeff_add()</span>
<span class="sd">        (3, ())</span>
<span class="sd">        &gt;&gt;&gt; (3 + x + y).as_coeff_add()</span>
<span class="sd">        (3, (y, x))</span>
<span class="sd">        &gt;&gt;&gt; (3 + x +y).as_coeff_add(x)</span>
<span class="sd">        (y + 3, (x,))</span>
<span class="sd">        &gt;&gt;&gt; (3 + y).as_coeff_add(x)</span>
<span class="sd">        (y + 3, ())</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="o">*</span><span class="n">deps</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>
</div>
<div class="viewcode-block" id="Expr.as_numer_denom"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_numer_denom">[docs]</a>    <span class="k">def</span> <span class="nf">as_numer_denom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; a/b -&gt; a,b</span>

<span class="sd">        This is just a stub that should be defined by</span>
<span class="sd">        an object&#39;s class methods to get anything else.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
</div>
    <span class="k">def</span> <span class="nf">normal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">/</span><span class="n">d</span>

<div class="viewcode-block" id="Expr.extract_multiplicatively"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.extract_multiplicatively">[docs]</a>    <span class="k">def</span> <span class="nf">extract_multiplicatively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None if it&#39;s not possible to make self in the form</span>
<span class="sd">           c * something in a nice way, i.e. preserving the properties</span>
<span class="sd">           of arguments of self.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import symbols, Rational</span>

<span class="sd">           &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;, real=True)</span>

<span class="sd">           &gt;&gt;&gt; ((x*y)**3).extract_multiplicatively(x**2 * y)</span>
<span class="sd">           x*y**2</span>

<span class="sd">           &gt;&gt;&gt; ((x*y)**3).extract_multiplicatively(x**4 * y)</span>

<span class="sd">           &gt;&gt;&gt; (2*x).extract_multiplicatively(2)</span>
<span class="sd">           x</span>

<span class="sd">           &gt;&gt;&gt; (2*x).extract_multiplicatively(3)</span>

<span class="sd">           &gt;&gt;&gt; (Rational(1,2)*x).extract_multiplicatively(3)</span>
<span class="sd">           x/6</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">as_two_terms</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">as_two_terms</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">quotient</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">/</span> <span class="n">c</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Infinity</span>
                <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">is_positive</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">is_zero</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">ComplexInfinity</span>
            <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">NaN</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_NumberSymbol</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">or</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">quotient</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">quotient</span>
            <span class="k">elif</span> <span class="n">quotient</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">quotient</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">newarg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newarg</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newarg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)):</span>
                <span class="n">newargs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="k">del</span><span class="p">(</span><span class="n">newargs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_rawargs</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">tmp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Pow</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Pow</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">base</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">new_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exp</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">new_exp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="p">:</span>
                <span class="n">new_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_exp</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">**</span> <span class="p">(</span><span class="n">new_exp</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.extract_additively"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.extract_additively">[docs]</a>    <span class="k">def</span> <span class="nf">extract_additively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return None if it&#39;s not possible to make self in the form</span>
<span class="sd">           something + c in a nice way, i.e. preserving the properties</span>
<span class="sd">           of arguments of self.</span>

<span class="sd">           &gt;&gt;&gt; from sympy import symbols</span>

<span class="sd">           &gt;&gt;&gt; x, y = symbols(&#39;x,y&#39;, real=True)</span>

<span class="sd">           &gt;&gt;&gt; ((x*y)**3).extract_additively(1)</span>

<span class="sd">           &gt;&gt;&gt; (x+1).extract_additively(x)</span>
<span class="sd">           1</span>

<span class="sd">           &gt;&gt;&gt; (x+1).extract_additively(2*x)</span>

<span class="sd">           &gt;&gt;&gt; (x+1).extract_additively(-x)</span>
<span class="sd">           2*x + 1</span>

<span class="sd">           &gt;&gt;&gt; (-x+1).extract_additively(2*x)</span>
<span class="sd">           -3*x + 1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="k">elif</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">as_two_terms</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">as_two_terms</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">c</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Number</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sub</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">sub</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sub</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sub</span><span class="o">.</span><span class="n">is_Rational</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">sub</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sub</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sub</span><span class="o">.</span><span class="n">is_Float</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">sub</span><span class="o">.</span><span class="n">is_negative</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sub</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_NumberSymbol</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Symbol</span> <span class="ow">or</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">S</span><span class="o">.</span><span class="n">ImaginaryUnit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">is_Mul</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">and</span> <span class="n">sub</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_positive</span> <span class="ow">and</span> <span class="n">sub</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sub</span>
            <span class="k">elif</span> <span class="n">sub</span><span class="o">.</span><span class="n">is_Integer</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sub</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
            <span class="n">terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_two_terms</span><span class="p">()</span>
            <span class="n">subs0</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subs0</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">subs0</span> <span class="o">+</span> <span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subs1</span> <span class="o">=</span> <span class="n">terms</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">subs1</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">subs1</span> <span class="o">+</span> <span class="n">terms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
            <span class="n">self_coeff</span><span class="p">,</span> <span class="n">self_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="n">c_coeff</span><span class="p">,</span> <span class="n">c_terms</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">c_terms</span> <span class="o">==</span> <span class="n">self_terms</span><span class="p">:</span>
                    <span class="n">new_coeff</span> <span class="o">=</span> <span class="n">self_coeff</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="n">c_coeff</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_coeff</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">new_coeff</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">_new_rawargs</span><span class="p">(</span><span class="o">*</span><span class="n">c_terms</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="n">self_terms</span><span class="p">:</span>
                <span class="n">new_coeff</span> <span class="o">=</span> <span class="n">self_coeff</span><span class="o">.</span><span class="n">extract_additively</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_coeff</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">new_coeff</span> <span class="o">*</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="Expr.could_extract_minus_sign"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.could_extract_minus_sign">[docs]</a>    <span class="k">def</span> <span class="nf">could_extract_minus_sign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Canonical way to choose an element in the set {e, -e} where</span>
<span class="sd">           e is any expression. If the canonical element is e, we have</span>
<span class="sd">           e.could_extract_minus_sign() == True, else</span>
<span class="sd">           e.could_extract_minus_sign() == False.</span>

<span class="sd">           For any expression, the set ``{e.could_extract_minus_sign(),</span>
<span class="sd">           (-e).could_extract_minus_sign()}`` must be ``{True, False}``.</span>

<span class="sd">           &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">           &gt;&gt;&gt; (x-y).could_extract_minus_sign() != (y-x).could_extract_minus_sign()</span>
<span class="sd">           True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">negative_self</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span>
        <span class="n">self_has_minus</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">negative_self_has_minus</span> <span class="o">=</span> <span class="p">((</span><span class="n">negative_self</span><span class="p">)</span><span class="o">.</span><span class="n">extract_multiplicatively</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">self_has_minus</span> <span class="o">!=</span> <span class="n">negative_self_has_minus</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self_has_minus</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="c"># We choose the one with less arguments with minus signs</span>
                <span class="n">all_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                <span class="n">negative_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="bp">False</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()])</span>
                <span class="n">positive_args</span> <span class="o">=</span> <span class="n">all_args</span> <span class="o">-</span> <span class="n">negative_args</span>
                <span class="k">if</span> <span class="n">positive_args</span> <span class="o">&gt;</span> <span class="n">negative_args</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="n">positive_args</span> <span class="o">&lt;</span> <span class="n">negative_args</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_Mul</span><span class="p">:</span>
                <span class="c"># We choose the one with an odd number of minus signs</span>
                <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_numer_denom</span><span class="p">()</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="n">Mul</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
                <span class="n">arg_signs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">could_extract_minus_sign</span><span class="p">()</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
                <span class="n">negative_args</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">arg_signs</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">negative_args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

            <span class="c"># As a last resort, we choose the one with greater hash</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">hash</span><span class="p">(</span><span class="n">negative_self</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="Expr.is_polynomial"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.is_polynomial">[docs]</a>    <span class="k">def</span> <span class="nf">is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if self is a polynomial in syms and False otherwise.</span>

<span class="sd">        This checks if self is an exact polynomial in syms.  This function</span>
<span class="sd">        returns False for expressions that are &quot;polynomials&quot; with symbolic</span>
<span class="sd">        exponents.  Thus, you should be able to apply polynomial algorithms to</span>
<span class="sd">        expressions for which this returns True, and Poly(expr, \*syms) should</span>
<span class="sd">        work only if and only if expr.is_polynomial(\*syms) returns True. The</span>
<span class="sd">        polynomial does not have to be in expanded form.  If no symbols are</span>
<span class="sd">        given, all free symbols in the expression will be used.</span>

<span class="sd">        This is not part of the assumptions system.  You cannot do</span>
<span class="sd">        Symbol(&#39;z&#39;, polynomial=True).</span>

<span class="sd">        **Examples**</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; x = Symbol(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ((x**2 + 1)**4).is_polynomial(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ((x**2 + 1)**4).is_polynomial()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (2**x + 1).is_polynomial(x)</span>
<span class="sd">        False</span>


<span class="sd">        &gt;&gt;&gt; n = Symbol(&#39;n&#39;, nonnegative=True, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; (x**n + 1).is_polynomial(x)</span>
<span class="sd">        False</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be a polynomial to</span>
<span class="sd">        become one.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, factor, cancel</span>
<span class="sd">        &gt;&gt;&gt; y = Symbol(&#39;y&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(y**2 + 2*y + 1)</span>
<span class="sd">        &gt;&gt;&gt; a.is_polynomial(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a)</span>
<span class="sd">        y + 1</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_polynomial(y)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; b = (y**2 + 2*y + 1)/(y + 1)</span>
<span class="sd">        &gt;&gt;&gt; b.is_polynomial(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; cancel(b)</span>
<span class="sd">        y + 1</span>
<span class="sd">        &gt;&gt;&gt; cancel(b).is_polynomial(y)</span>
<span class="sd">        True</span>

<span class="sd">        See also .is_rational_function()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="c"># constant polynomial</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_polynomial</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="Expr.is_rational_function"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.is_rational_function">[docs]</a>    <span class="k">def</span> <span class="nf">is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">syms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test whether function is a ratio of two polynomials in the given</span>
<span class="sd">        symbols, syms. When syms is not given, all free symbols will be used.</span>
<span class="sd">        The rational function does not have to be in expanded or in any kind of</span>
<span class="sd">        canonical form.</span>

<span class="sd">        This function returns False for expressions that are &quot;rational</span>
<span class="sd">        functions&quot; with symbolic exponents.  Thus, you should be able to call</span>
<span class="sd">        .as_numer_denom() and apply polynomial algorithms to the result for</span>
<span class="sd">        expressions for which this returns True.</span>

<span class="sd">        This is not part of the assumptions system.  You cannot do</span>
<span class="sd">        Symbol(&#39;z&#39;, rational_function=True).</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol, sin</span>
<span class="sd">        &gt;&gt;&gt; from sympy.abc import x, y</span>

<span class="sd">        &gt;&gt;&gt; (x/y).is_rational_function()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (x**2).is_rational_function()</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; (x/sin(y)).is_rational_function(y)</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; n = Symbol(&#39;n&#39;, integer=True)</span>
<span class="sd">        &gt;&gt;&gt; (x**n + 1).is_rational_function(x)</span>
<span class="sd">        False</span>

<span class="sd">        This function does not attempt any nontrivial simplifications that may</span>
<span class="sd">        result in an expression that does not appear to be a rational function</span>
<span class="sd">        to become one.</span>

<span class="sd">        &gt;&gt;&gt; from sympy import sqrt, factor, cancel</span>
<span class="sd">        &gt;&gt;&gt; y = Symbol(&#39;y&#39;, positive=True)</span>
<span class="sd">        &gt;&gt;&gt; a = sqrt(y**2 + 2*y + 1)/y</span>
<span class="sd">        &gt;&gt;&gt; a.is_rational_function(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; factor(a)</span>
<span class="sd">        (y + 1)/y</span>
<span class="sd">        &gt;&gt;&gt; factor(a).is_rational_function(y)</span>
<span class="sd">        True</span>

<span class="sd">        See also is_rational_function().</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">syms</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">syms</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span>

        <span class="k">if</span> <span class="n">syms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">([]):</span>
            <span class="c"># constant rational function</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_is_rational_function</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span>

    <span class="c">###################################################################################</span>
    <span class="c">##################### SERIES, LEADING TERM, LIMIT, ORDER METHODS ##################</span>
    <span class="c">###################################################################################</span>
</div>
<div class="viewcode-block" id="Expr.series"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.series">[docs]</a>    <span class="k">def</span> <span class="nf">series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&quot;+&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Series expansion of &quot;self&quot; around ``x = x0`` yielding either terms of</span>
<span class="sd">        the series one by one (the lazy series given when n=None), else</span>
<span class="sd">        all the terms at once when n != None.</span>

<span class="sd">        Note: when n != None, if an O() term is returned then the x in the</span>
<span class="sd">        in it and the entire expression represents x - x0, the displacement</span>
<span class="sd">        from x0. (If there is no O() term then the series was exact and x has</span>
<span class="sd">        it&#39;s normal meaning.) This is currently necessary since sympy&#39;s O()</span>
<span class="sd">        can only represent terms at x0=0. So instead of::</span>

<span class="sd">          cos(x).series(x0=1, n=2) --&gt; (1 - x)*sin(1) + cos(1) + O((x - 1)**2)</span>

<span class="sd">        which graphically looks like this::</span>

<span class="sd">               |</span>
<span class="sd">              .|.         . .</span>
<span class="sd">             . | \      .     .</span>
<span class="sd">            ---+----------------------</span>
<span class="sd">               |   . .          . .</span>
<span class="sd">               |    \</span>
<span class="sd">              x=0</span>

<span class="sd">        the following is returned instead::</span>

<span class="sd">        -x*sin(1) + cos(1) + O(x**2)</span>

<span class="sd">        whose graph is this::</span>

<span class="sd">               \ |</span>
<span class="sd">              . .|        . .</span>
<span class="sd">             .   \      .     .</span>
<span class="sd">            -----+\------------------.</span>
<span class="sd">                 | . .          . .</span>
<span class="sd">                 |  \</span>
<span class="sd">                x=0</span>

<span class="sd">        which is identical to ``cos(x + 1).series(n=2)``.</span>

<span class="sd">        Usage:</span>
<span class="sd">            Returns the series expansion of &quot;self&quot; around the point ``x = x0``</span>
<span class="sd">            with respect to ``x`` up to O(x**n) (default n is 6).</span>

<span class="sd">            If ``x=None`` and ``self`` is univariate, the univariate symbol will</span>
<span class="sd">            be supplied, otherwise an error will be raised.</span>

<span class="sd">            &gt;&gt;&gt; from sympy import cos, exp</span>
<span class="sd">            &gt;&gt;&gt; from sympy.abc import x, y</span>
<span class="sd">            &gt;&gt;&gt; cos(x).series()</span>
<span class="sd">            1 - x**2/2 + x**4/24 + O(x**6)</span>
<span class="sd">            &gt;&gt;&gt; cos(x).series(n=4)</span>
<span class="sd">            1 - x**2/2 + O(x**4)</span>
<span class="sd">            &gt;&gt;&gt; e = cos(x + exp(y))</span>
<span class="sd">            &gt;&gt;&gt; e.series(y, n=2)</span>
<span class="sd">            cos(x + 1) - y*sin(x + 1) + O(y**2)</span>
<span class="sd">            &gt;&gt;&gt; e.series(x, n=2)</span>
<span class="sd">            cos(exp(y)) - x*sin(exp(y)) + O(x**2)</span>

<span class="sd">            If ``n=None`` then an iterator of the series terms will be returned.</span>

<span class="sd">            &gt;&gt;&gt; term=cos(x).series(n=None)</span>
<span class="sd">            &gt;&gt;&gt; [term.next() for i in range(2)]</span>
<span class="sd">            [1, -x**2/2]</span>

<span class="sd">            For ``dir=+`` (default) the series is calculated from the right and</span>
<span class="sd">            for ``dir=-`` the series from the left. For smooth functions this</span>
<span class="sd">            flag will not alter the results.</span>

<span class="sd">            &gt;&gt;&gt; abs(x).series(dir=&quot;+&quot;)</span>
<span class="sd">            x</span>
<span class="sd">            &gt;&gt;&gt; abs(x).series(dir=&quot;-&quot;)</span>
<span class="sd">            -x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">syms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">C</span><span class="o">.</span><span class="n">Symbol</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">syms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;x must be given for multivariate functions.&#39;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">syms</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>

        <span class="c">## it seems like the following should be doable, but several failures</span>
        <span class="c">## then occur. Is this related to issue 1747 et al See also XPOS below.</span>
        <span class="c">#if x.is_positive is x.is_negative is None:</span>
        <span class="c">#    # replace x with an x that has a positive assumption</span>
        <span class="c">#    xpos = C.Dummy(&#39;x&#39;, positive=True)</span>
        <span class="c">#    rv = self.subs(x, xpos).series(xpos, x0, n, dir)</span>
        <span class="c">#    if n is None:</span>
        <span class="c">#        return (s.subs(xpos, x) for s in rv)</span>
        <span class="c">#    else:</span>
        <span class="c">#        return rv.subs(xpos, x)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s">&#39;+-&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dir must be &#39;+&#39; or &#39;-&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x0</span> <span class="ow">in</span> <span class="p">[</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">]:</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="p">{</span><span class="n">S</span><span class="o">.</span><span class="n">Infinity</span><span class="p">:</span> <span class="s">&#39;+&#39;</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">NegativeInfinity</span><span class="p">:</span> <span class="s">&#39;-&#39;</span><span class="p">}[</span><span class="n">x0</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
            <span class="c"># don&#39;t include the order term since it will eat the larger terms</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">)</span>

        <span class="c"># use rep to shift origin to x0 and change sign (if dir is negative)</span>
        <span class="c"># and undo the process with rep2</span>
        <span class="k">if</span> <span class="n">x0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">dir</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span> <span class="o">+</span> <span class="n">x0</span>
                <span class="n">rep2</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="n">x0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x0</span>
                <span class="n">rep2</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="o">-</span><span class="n">x0</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># lseries...</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep2</span> <span class="o">+</span> <span class="n">rep2b</span><span class="p">)</span> <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
            <span class="c"># nseries...</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">o</span> <span class="ow">and</span> <span class="n">x0</span><span class="p">:</span>
                <span class="n">rep2b</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># when O() can handle x0 != 0 this can be removed</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rep2</span> <span class="o">+</span> <span class="n">rep2b</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span>

        <span class="c"># from here on it&#39;s x0=0 and dir=&#39;+&#39; handling</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span> <span class="c"># nseries handling</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
            <span class="n">o</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span> <span class="ow">or</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="k">if</span> <span class="n">o</span><span class="p">:</span>
                <span class="c"># make sure the requested order is returned</span>
                <span class="n">ngot</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">ngot</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c"># leave o in its current form (e.g. with x*log(x)) so</span>
                    <span class="c"># it eats terms properly, then replace it below</span>
                    <span class="n">s1</span> <span class="o">+=</span> <span class="n">o</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="n">C</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ngot</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">ngot</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                    <span class="c"># increase the requested number of terms to get the desired</span>
                    <span class="c"># number keep increasing (up to 9) until the received order</span>
                    <span class="c"># is different than the original order and then predict how</span>
                    <span class="c"># many additional terms are needed</span>
                    <span class="k">for</span> <span class="n">more</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
                        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span> <span class="o">+</span> <span class="n">more</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
                        <span class="n">newn</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">newn</span> <span class="o">!=</span> <span class="n">ngot</span><span class="p">:</span>
                            <span class="n">ndo</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">ngot</span><span class="p">)</span><span class="o">*</span><span class="n">more</span><span class="o">/</span><span class="p">(</span><span class="n">newn</span> <span class="o">-</span> <span class="n">ngot</span><span class="p">)</span>
                            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">ndo</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
                            <span class="c"># if this assertion fails then our ndo calculation</span>
                            <span class="c"># needs modification</span>
                            <span class="k">assert</span> <span class="n">s1</span><span class="o">.</span><span class="n">getn</span><span class="p">()</span> <span class="o">==</span> <span class="n">n</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Could not calculate </span><span class="si">%s</span><span class="s"> terms for </span><span class="si">%s</span><span class="s">&#39;</span>
                                         <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="bp">self</span><span class="p">))</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">getO</span><span class="p">()</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s1</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">==</span> <span class="n">s1</span><span class="p">:</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

            <span class="k">return</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">o</span>

        <span class="k">else</span><span class="p">:</span> <span class="c"># lseries handling</span>
            <span class="k">def</span> <span class="nf">yield_lseries</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return terms of lseries one at a time.&quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">si</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">si</span>
                        <span class="k">continue</span>
                    <span class="c"># yield terms 1 at a time if possible</span>
                    <span class="c"># by increasing order until all the</span>
                    <span class="c"># terms have been returned</span>
                    <span class="n">yielded</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Order</span><span class="p">(</span><span class="n">si</span><span class="p">)</span><span class="o">*</span><span class="n">x</span>
                    <span class="n">ndid</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">ndo</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">si</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">do</span> <span class="o">=</span> <span class="p">(</span><span class="n">si</span> <span class="o">-</span> <span class="n">yielded</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
                        <span class="n">o</span> <span class="o">*=</span> <span class="n">x</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">do</span> <span class="ow">or</span> <span class="n">do</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">do</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                            <span class="n">ndid</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">do</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ndid</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="n">do</span>
                        <span class="k">if</span> <span class="n">ndid</span> <span class="o">==</span> <span class="n">ndo</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">StopIteration</span>
                        <span class="n">yielded</span> <span class="o">+=</span> <span class="n">do</span>

            <span class="k">return</span> <span class="n">yield_lseries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span><span class="o">.</span><span class="n">_eval_lseries</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Expr.lseries"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.lseries">[docs]</a>    <span class="k">def</span> <span class="nf">lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for series yielding an iterator of the terms of the series.</span>

<span class="sd">        Note: an infinite series will yield an infinite iterator. The following,</span>
<span class="sd">        for exaxmple, will never terminate. It will just keep printing terms</span>
<span class="sd">        of the sin(x) series::</span>

<span class="sd">          for term in sin(x).lseries(x):</span>
<span class="sd">              print term</span>

<span class="sd">        The advantage of lseries() over nseries() is that many times you are</span>
<span class="sd">        just interested in the next term in the series (i.e. the first term for</span>
<span class="sd">        example), but you don&#39;t know how many you should ask for in nseries()</span>
<span class="sd">        using the &quot;n&quot; parameter.</span>

<span class="sd">        See also nseries().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_lseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c"># default implementation of lseries is using nseries(), and adaptively</span>
        <span class="c"># increasing the &quot;n&quot;. As you can see, it is not very efficient, because</span>
        <span class="c"># we are calculating the series over and over again. Subclasses should</span>
        <span class="c"># override this method and implement much more efficient yielding of</span>
        <span class="c"># terms.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Add</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">series</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>

        <span class="k">while</span> <span class="n">series</span><span class="o">.</span><span class="n">is_Order</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
        <span class="k">yield</span> <span class="n">e</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">series</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">yield</span> <span class="n">series</span> <span class="o">-</span> <span class="n">e</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">series</span>

<div class="viewcode-block" id="Expr.nseries"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.nseries">[docs]</a>    <span class="k">def</span> <span class="nf">nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">,</span><span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper to _eval_nseries if assumptions allow, else to series.</span>

<span class="sd">        If x is given, x0 is 0, dir=&#39;+&#39;, and self has x, then _eval_nseries is</span>
<span class="sd">        called. This calculates &quot;n&quot; terms in the innermost expressions and</span>
<span class="sd">        then builds up the final series just by &quot;cross-multiplying&quot; everything</span>
<span class="sd">        out.</span>

<span class="sd">        Advantage -- it&#39;s fast, because we don&#39;t have to determine how many</span>
<span class="sd">        terms we need to calculate in advance.</span>

<span class="sd">        Disadvantage -- you may end up with less terms than you may have</span>
<span class="sd">        expected, but the O(x**n) term appended will always be correct and</span>
<span class="sd">        so the result, though perhaps shorter, will also be correct.</span>

<span class="sd">        If any of those assumptions is not met, this is treated like a</span>
<span class="sd">        wrapper to series which will try harder to return the correct</span>
<span class="sd">        number of terms.</span>

<span class="sd">        See also lseries().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">x0</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">!=</span> <span class="s">&#39;+&#39;</span><span class="p">:</span><span class="c">#{see XPOS above} or (x.is_positive == x.is_negative == None):</span>
            <span class="k">assert</span> <span class="n">logx</span> <span class="o">==</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_nseries</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="n">logx</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return terms of series for self up to O(x**n) at x=0</span>
<span class="sd">        from the positive direction.</span>

<span class="sd">        This is a method that should be overridden in subclasses. Users should</span>
<span class="sd">        never call this method directly (use .nseries() instead), so you don&#39;t</span>
<span class="sd">        have to write docstrings for _eval_nseries().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;(</span><span class="si">%s</span><span class="s">).nseries(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

<div class="viewcode-block" id="Expr.limit"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.limit">[docs]</a>    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute limit x-&gt;xlim.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series.limits</span> <span class="kn">import</span> <span class="n">limit</span>
        <span class="k">return</span> <span class="n">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xlim</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.compute_leading_term"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.compute_leading_term">[docs]</a>    <span class="k">def</span> <span class="nf">compute_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">skip_abs</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; as_leading_term is only allowed for results of .series()</span>
<span class="sd">            This is a wrapper to compute a series first.</span>
<span class="sd">            If skip_abs is true, the absolute term is assumed to be zero.</span>
<span class="sd">            (This is necessary because sometimes it cannot be simplified</span>
<span class="sd">             to zero without a lot of work, but is still known to be zero.</span>
<span class="sd">             See log._eval_nseries for an example.)</span>
<span class="sd">            If skip_log is true, log(x) is treated as an independent symbol.</span>
<span class="sd">            (This is needed for the gruntz algorithm.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.series.gruntz</span> <span class="kn">import</span> <span class="n">calculate_series</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cancel</span><span class="p">,</span> <span class="n">expand_mul</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">removeO</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">logx</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;logx&#39;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">skip_abs</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">C</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">calculate_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">skip_abs</span><span class="p">,</span> <span class="n">logx</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">cancel</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">skip_abs</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">expand_mul</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">as_independent</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</div>
    <span class="nd">@cacheit</span>
<div class="viewcode-block" id="Expr.as_leading_term"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_leading_term">[docs]</a>    <span class="k">def</span> <span class="nf">as_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the leading term.</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1+x+x**2).as_leading_term(x)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; (1/x**2+x+x**2).as_leading_term(x)</span>
<span class="sd">        x**(-2)</span>

<span class="sd">        Note:</span>

<span class="sd">        self is assumed to be the result returned by Basic.series().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">powsimp</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">is_Symbol</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;as_leading_term(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_as_leading_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Expr.as_coeff_exponent"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_exponent">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; c*x**e -&gt; c,e where x can be any symbolic expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">wc</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;wc&#39;</span><span class="p">)</span>
        <span class="n">we</span> <span class="o">=</span> <span class="n">Wild</span><span class="p">(</span><span class="s">&#39;we&#39;</span><span class="p">)</span>
        <span class="n">p</span>  <span class="o">=</span> <span class="n">wc</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">we</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">collect</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">we</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">wc</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="n">we</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
</div>
<div class="viewcode-block" id="Expr.leadterm"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.leadterm">[docs]</a>    <span class="k">def</span> <span class="nf">leadterm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the leading term a*x**b as a tuple (a, b).</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from sympy.abc import x</span>
<span class="sd">        &gt;&gt;&gt; (1+x+x**2).leadterm(x)</span>
<span class="sd">        (1, 0)</span>
<span class="sd">        &gt;&gt;&gt; (1/x**2+x+x**2).leadterm(x)</span>
<span class="sd">        (1, -2)</span>

<span class="sd">        Note:</span>

<span class="sd">        self is assumed to be the result returned by Basic.series().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">powsimp</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_coeff_exponent</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">powsimp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;exp&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">has</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cannot compute leadterm(</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">), got c=</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Expr.as_coeff_Mul"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.as_coeff_Mul">[docs]</a>    <span class="k">def</span> <span class="nf">as_coeff_Mul</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Efficiently extract the coefficient of a product. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="bp">self</span>

    <span class="c">###################################################################################</span>
    <span class="c">##################### DERIVATIVE, INTEGRAL, FUNCTIONAL METHODS ####################</span>
    <span class="c">###################################################################################</span>
</div>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">):</span>
        <span class="n">new_symbols</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">sympify</span><span class="p">,</span> <span class="n">symbols</span><span class="p">)</span> <span class="c"># e.g. x, 2, y, z</span>
        <span class="n">assumptions</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s">&quot;evaluate&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">new_symbols</span><span class="p">,</span> <span class="o">**</span><span class="n">assumptions</span><span class="p">)</span>

    <span class="c">###########################################################################</span>
    <span class="c">###################### EXPRESSION EXPANSION METHODS #######################</span>
    <span class="c">###########################################################################</span>

    <span class="c"># These should be overridden in subclasses</span>

    <span class="k">def</span> <span class="nf">_eval_expand_basic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_power_exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_power_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_multinomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_trig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_eval_expand_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Expr.expand"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.expand">[docs]</a>    <span class="k">def</span> <span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">modulus</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">power_base</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> \
            <span class="n">mul</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand an expression using hints.</span>

<span class="sd">        See the docstring in function.expand for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hints</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">power_base</span><span class="o">=</span><span class="n">power_base</span><span class="p">,</span> <span class="n">power_exp</span><span class="o">=</span><span class="n">power_exp</span><span class="p">,</span> <span class="n">mul</span><span class="o">=</span><span class="n">mul</span><span class="p">,</span> \
           <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span> <span class="n">multinomial</span><span class="o">=</span><span class="n">multinomial</span><span class="p">,</span> <span class="n">basic</span><span class="o">=</span><span class="n">basic</span><span class="p">)</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">hint</span><span class="p">,</span> <span class="n">use_hint</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">use_hint</span><span class="p">:</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s">&#39;_eval_expand_&#39;</span><span class="o">+</span><span class="n">hint</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">expr</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">,</span> <span class="o">**</span><span class="n">hints</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">modulus</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">modulus</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">modulus</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">modulus</span><span class="o">.</span><span class="n">is_Integer</span> <span class="ow">or</span> <span class="n">modulus</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;modulus must be a positive integer, got </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">modulus</span><span class="p">)</span>

            <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">Add</span><span class="o">.</span><span class="n">make_args</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                <span class="n">coeff</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">term</span><span class="o">.</span><span class="n">as_coeff_mul</span><span class="p">()</span>

                <span class="n">coeff</span> <span class="o">%=</span> <span class="n">modulus</span>

                <span class="k">if</span> <span class="n">coeff</span><span class="p">:</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">coeff</span><span class="p">,)</span> <span class="o">+</span> <span class="n">tail</span><span class="p">)))</span>

            <span class="n">expr</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">terms</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expr</span>

    <span class="c">###########################################################################</span>
    <span class="c">################### GLOBAL ACTION VERB WRAPPER METHODS ####################</span>
    <span class="c">###########################################################################</span>
</div>
<div class="viewcode-block" id="Expr.integrate"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.integrate">[docs]</a>    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the integrate function in sympy.integrals&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.integrals</span> <span class="kn">import</span> <span class="n">integrate</span>
        <span class="k">return</span> <span class="n">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.simplify"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.simplify">[docs]</a>    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the simplify function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">simplify</span>
        <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.nsimplify"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.nsimplify">[docs]</a>    <span class="k">def</span> <span class="nf">nsimplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="o">=</span><span class="p">[],</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the nsimplify function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">nsimplify</span>
        <span class="k">return</span> <span class="n">nsimplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">full</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.separate"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.separate">[docs]</a>    <span class="k">def</span> <span class="nf">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the separate function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">separate</span>
        <span class="k">return</span> <span class="n">separate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.collect"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.collect">[docs]</a>    <span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the collect function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">collect</span>
        <span class="k">return</span> <span class="n">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">,</span> <span class="n">evaluate</span><span class="p">,</span> <span class="n">exact</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.together"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.together">[docs]</a>    <span class="k">def</span> <span class="nf">together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the together function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">together</span>
        <span class="k">return</span> <span class="n">together</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.apart"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.apart">[docs]</a>    <span class="k">def</span> <span class="nf">apart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the apart function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">apart</span>
        <span class="k">return</span> <span class="n">apart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.ratsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.ratsimp">[docs]</a>    <span class="k">def</span> <span class="nf">ratsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the ratsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">ratsimp</span>
        <span class="k">return</span> <span class="n">ratsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.trigsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.trigsimp">[docs]</a>    <span class="k">def</span> <span class="nf">trigsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the trigsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">trigsimp</span>
        <span class="k">return</span> <span class="n">trigsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">,</span> <span class="n">recursive</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.radsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.radsimp">[docs]</a>    <span class="k">def</span> <span class="nf">radsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the radsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">radsimp</span>
        <span class="k">return</span> <span class="n">radsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.powsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.powsimp">[docs]</a>    <span class="k">def</span> <span class="nf">powsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the powsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">powsimp</span>
        <span class="k">return</span> <span class="n">powsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="p">,</span> <span class="n">combine</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.combsimp"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.combsimp">[docs]</a>    <span class="k">def</span> <span class="nf">combsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the combsimp function in sympy.simplify&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.simplify</span> <span class="kn">import</span> <span class="n">combsimp</span>
        <span class="k">return</span> <span class="n">combsimp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.factor"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.factor">[docs]</a>    <span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the factor() function in sympy.polys.polytools&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">factor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.refine"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.refine">[docs]</a>    <span class="k">def</span> <span class="nf">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumption</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the refine function in sympy.assumptions&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.assumptions</span> <span class="kn">import</span> <span class="n">refine</span>
        <span class="k">return</span> <span class="n">refine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumption</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.cancel"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.cancel">[docs]</a>    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the cancel function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">cancel</span>
        <span class="k">return</span> <span class="n">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">gens</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Expr.invert"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.Expr.invert">[docs]</a>    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;See the invert function in sympy.polys&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.polys</span> <span class="kn">import</span> <span class="n">invert</span>
        <span class="k">return</span> <span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

</div></div>
<div class="viewcode-block" id="AtomicExpr"><a class="viewcode-back" href="../../../modules/core.html#sympy.core.expr.AtomicExpr">[docs]</a><span class="k">class</span> <span class="nc">AtomicExpr</span><span class="p">(</span><span class="n">Atom</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A parent class for object which are both atoms and Exprs.</span>

<span class="sd">    Examples: Symbol, Number, Rational, Integer, ...</span>
<span class="sd">    But not: Add, Mul, Pow, ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_Atom</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

    <span class="k">def</span> <span class="nf">as_numer_denom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span>

    <span class="k">def</span> <span class="nf">_eval_is_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_eval_is_rational_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">syms</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_eval_nseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">logx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<span class="kn">from</span> <span class="nn">mul</span> <span class="kn">import</span> <span class="n">Mul</span>
<span class="kn">from</span> <span class="nn">add</span> <span class="kn">import</span> <span class="n">Add</span>
<span class="kn">from</span> <span class="nn">power</span> <span class="kn">import</span> <span class="n">Pow</span>
<span class="kn">from</span> <span class="nn">function</span> <span class="kn">import</span> <span class="n">Derivative</span>
<span class="kn">from</span> <span class="nn">sympify</span> <span class="kn">import</span> <span class="n">sympify</span>
<span class="kn">from</span> <span class="nn">symbol</span> <span class="kn">import</span> <span class="n">Wild</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy v0.7.1 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, 2009, 2010, 2011 SymPy Development Team.
      Last updated on Jul 29, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>