<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.polys.modulargcd &mdash; SymPy 0.7.5-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.5-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.5-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.5-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.polys.modulargcd</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">nextprime</span>
<span class="kn">from</span> <span class="nn">sympy.ntheory.modular</span> <span class="kn">import</span> <span class="n">crt</span>

<span class="kn">from</span> <span class="nn">sympy.polys.galoistools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">gf_gcd</span><span class="p">,</span> <span class="n">gf_from_dict</span><span class="p">,</span> <span class="n">gf_gcdex</span><span class="p">,</span> <span class="n">gf_div</span><span class="p">,</span> <span class="n">gf_lcm</span><span class="p">,</span> <span class="n">gf_rem</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sympy.polys.polyerrors</span> <span class="kn">import</span> <span class="n">ModularGCDFailed</span>
<span class="kn">from</span> <span class="nn">sympy.polys.domains</span> <span class="kn">import</span> <span class="n">PolynomialRing</span>

<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="nb">xrange</span>
<span class="kn">from</span> <span class="nn">sympy.mpmath</span> <span class="kn">import</span> <span class="n">sqrt</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Dummy</span>
<span class="kn">import</span> <span class="nn">random</span>


<span class="k">def</span> <span class="nf">_trivial_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials in trivial cases, i.e. when one</span>
<span class="sd">    or both polynomials are zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">f</span> <span class="ow">or</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">LC</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">g</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="o">-</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">LC</span> <span class="o">&lt;</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">_gf_gcd</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two univariate polynomials in `\mathbb{Z}_p[x]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="k">while</span> <span class="n">gp</span><span class="p">:</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">lcinv</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">gp</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">degrem</span> <span class="o">&lt;</span> <span class="n">deg</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="p">(</span><span class="n">rem</span> <span class="o">-</span> <span class="n">gp</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">((</span><span class="n">degrem</span> <span class="o">-</span> <span class="n">deg</span><span class="p">,))</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">lcinv</span> <span class="o">*</span> <span class="n">rem</span><span class="o">.</span><span class="n">LC</span><span class="p">))</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">gp</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">rem</span>

    <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">dom</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_degree_bound_univariate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute an upper bound for the degree of the GCD of two univariate</span>
<span class="sd">    integer polynomials `f` and `g`.</span>

<span class="sd">    The function chooses a suitable prime `p` and computes the GCD of</span>
<span class="sd">    `f` and `g` in `\mathbb{Z}_p[x]`. The choice of `p` guarantees that</span>
<span class="sd">    the degree in `\mathbb{Z}_p[x]` is greater than or equal to the degree</span>
<span class="sd">    in `\mathbb{Z}[x]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        univariate integer polynomial</span>
<span class="sd">    g : PolyElement</span>
<span class="sd">        univariate integer polynomial</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">gamma</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">hp</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">deghp</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">deghp</span>


<span class="k">def</span> <span class="nf">_chinese_remainder_reconstruction_univariate</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Construct a polynomial `h_{pq}` in `\mathbb{Z}_{p q}[x]` such that</span>

<span class="sd">    .. math ::</span>

<span class="sd">        h_{pq} = h_p \; \mathrm{mod} \, p</span>

<span class="sd">        h_{pq} = h_q \; \mathrm{mod} \, q</span>

<span class="sd">    for relatively prime integers `p` and `q` and polynomials</span>
<span class="sd">    `h_p` and `h_q` in `\mathbb{Z}_p[x]` and `\mathbb{Z}_q[x]`</span>
<span class="sd">    respectively.</span>

<span class="sd">    The coefficients of the polynomial `h_{pq}` are computed with the</span>
<span class="sd">    Chinese Remainder Theorem. The symmetric representation in</span>
<span class="sd">    `\mathbb{Z}_p[x]`, `\mathbb{Z}_q[x]` and `\mathbb{Z}_{p q}[x]` is used.</span>
<span class="sd">    It is assumed that `h_p` and `h_q` have the same degree.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    hp : PolyElement</span>
<span class="sd">        univariate integer polynomial with coefficients in `\mathbb{Z}_p`</span>
<span class="sd">    hq : PolyElement</span>
<span class="sd">        univariate integer polynomial with coefficients in `\mathbb{Z}_q`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        modulus of `h_p`, relatively prime to `q`</span>
<span class="sd">    q : Integer</span>
<span class="sd">        modulus of `h_q`, relatively prime to `p`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import _chinese_remainder_reconstruction_univariate</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x = ring(&quot;x&quot;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; p = 3</span>
<span class="sd">    &gt;&gt;&gt; q = 5</span>

<span class="sd">    &gt;&gt;&gt; hp = -x**3 - 1</span>
<span class="sd">    &gt;&gt;&gt; hq = 2*x**3 - 2*x**2 + x</span>

<span class="sd">    &gt;&gt;&gt; hpq = _chinese_remainder_reconstruction_univariate(hp, hq, p, q)</span>
<span class="sd">    &gt;&gt;&gt; hpq</span>
<span class="sd">    2*x**3 + 3*x**2 + 6*x + 5</span>

<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(p) == hp</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(q) == hq</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">hpq</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">hpq</span><span class="p">[(</span><span class="n">i</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">crt</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">],</span> <span class="p">[</span><span class="n">hp</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="p">),</span> <span class="n">hq</span><span class="o">.</span><span class="n">coeff</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">i</span><span class="p">)],</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">hpq</span><span class="o">.</span><span class="n">strip_zero</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">hpq</span>


<div class="viewcode-block" id="modgcd_univariate"><a class="viewcode-back" href="../../../modules/polys/internals.html#sympy.polys.modulargcd.modgcd_univariate">[docs]</a><span class="k">def</span> <span class="nf">modgcd_univariate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Computes the GCD of two polynomials in `\mathbb{Z}[x]` using a modular</span>
<span class="sd">    algorithm.</span>

<span class="sd">    The algorithm computes the GCD of two univariate integer polynomials</span>
<span class="sd">    `f` and `g` by computing the GCD in `\mathbb{Z}_p[x]` for suitable</span>
<span class="sd">    primes `p` and then reconstructing the coefficients with the Chinese</span>
<span class="sd">    Remainder Theorem. Trial division is only made for candidates which</span>
<span class="sd">    are very likely the desired GCD.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        univariate integer polynomial</span>
<span class="sd">    g : PolyElement</span>
<span class="sd">        univariate integer polynomial</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        GCD of the polynomials `f` and `g`</span>
<span class="sd">    cff : PolyElement</span>
<span class="sd">        cofactor of `f`, i.e. `\frac{f}{h}`</span>
<span class="sd">    cfg : PolyElement</span>
<span class="sd">        cofactor of `g`, i.e. `\frac{g}{h}`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import modgcd_univariate</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x = ring(&quot;x&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**5 - 1</span>
<span class="sd">    &gt;&gt;&gt; g = x - 1</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = modgcd_univariate(f, g)</span>
<span class="sd">    &gt;&gt;&gt; h, cff, cfg</span>
<span class="sd">    (x - 1, x**4 + x**3 + x**2 + x + 1, 1)</span>

<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; f = 6*x**2 - 6</span>
<span class="sd">    &gt;&gt;&gt; g = 2*x**2 + 4*x + 2</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = modgcd_univariate(f, g)</span>
<span class="sd">    &gt;&gt;&gt; h, cff, cfg</span>
<span class="sd">    (2*x + 2, 3*x - 3, x + 1)</span>

<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Monagan00]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">ring</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">is_ZZ</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">_trivial_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>

    <span class="n">cf</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">cg</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">cg</span><span class="p">)</span>

    <span class="n">bound</span> <span class="o">=</span> <span class="n">_degree_bound_univariate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bound</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ring</span><span class="p">(</span><span class="n">ch</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cf</span> <span class="o">//</span> <span class="n">ch</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cg</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>

    <span class="n">gamma</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">gamma</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">deghp</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">deghp</span> <span class="o">&gt;</span> <span class="n">bound</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">deghp</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">bound</span> <span class="o">=</span> <span class="n">deghp</span>
            <span class="k">continue</span>

        <span class="n">hp</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">hlastm</span> <span class="o">=</span> <span class="n">hp</span>
            <span class="k">continue</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction_univariate</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hlastm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">*=</span> <span class="n">p</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">hm</span> <span class="o">==</span> <span class="n">hlastm</span><span class="p">:</span>
            <span class="n">hlastm</span> <span class="o">=</span> <span class="n">hm</span>
            <span class="k">continue</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">quo_ground</span><span class="p">(</span><span class="n">hm</span><span class="o">.</span><span class="n">content</span><span class="p">())</span>
        <span class="n">fquo</span><span class="p">,</span> <span class="n">frem</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">gquo</span><span class="p">,</span> <span class="n">grem</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frem</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">grem</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">LC</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="o">-</span><span class="n">ch</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">cff</span> <span class="o">=</span> <span class="n">fquo</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cf</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="n">gquo</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cg</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">cff</span><span class="p">,</span> <span class="n">cfg</span>

</div>
<span class="k">def</span> <span class="nf">_primitive</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the content and the primitive part of a polynomial in</span>
<span class="sd">    `\mathbb{Z}_p[x_0, \ldots, x_{k-2}, y] \cong \mathbb{Z}_p[y][x_0, \ldots, x_{k-2}]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        integer polynomial in `\mathbb{Z}_p[x0, \ldots, x{k-2}, y]`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        modulus of `f`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    contf : PolyElement</span>
<span class="sd">        integer polynomial in `\mathbb{Z}_p[y]`, content of `f`</span>
<span class="sd">    ppf : PolyElement</span>
<span class="sd">        primitive part of `f`, i.e. `\frac{f}{contf}`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import _primitive</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; p = 3</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - y**2 - y</span>
<span class="sd">    &gt;&gt;&gt; _primitive(f, p)</span>
<span class="sd">    (y**2 + y, x**2 - 1)</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x*y*z - y**2*z**2</span>
<span class="sd">    &gt;&gt;&gt; _primitive(f, p)</span>
<span class="sd">    (z, x*y - y**2*z)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>

    <span class="n">coeffs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coeffs</span><span class="p">:</span>
            <span class="n">coeffs</span><span class="p">[</span><span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coeffs</span><span class="p">[</span><span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">monom</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">coeff</span>

    <span class="n">cont</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="n">gf_gcd</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">gf_from_dict</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">dom</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">dom</span><span class="p">)</span>

    <span class="n">yring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">ring</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">contf</span> <span class="o">=</span> <span class="n">yring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">cont</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">contf</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">quo</span><span class="p">(</span><span class="n">contf</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_deg</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the degree of a multivariate polynomial</span>
<span class="sd">    `f \in K[x_0, \ldots, x_{k-2}, y] \cong K[y][x_0, \ldots, x_{k-2}]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `K[x_0, \ldots, x_{k-2}, y]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    degf : Integer tuple</span>
<span class="sd">        degree of `f` in `x_0, \ldots, x_{k-2}`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import _deg</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - 1</span>
<span class="sd">    &gt;&gt;&gt; _deg(f)</span>
<span class="sd">    (2,)</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - 1</span>
<span class="sd">    &gt;&gt;&gt; _deg(f)</span>
<span class="sd">    (2, 2)</span>

<span class="sd">    &gt;&gt;&gt; f = x*y*z - y**2*z**2</span>
<span class="sd">    &gt;&gt;&gt; _deg(f)</span>
<span class="sd">    (1, 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>
    <span class="n">degf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">monom</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">itermonoms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">degf</span><span class="p">:</span>
            <span class="n">degf</span> <span class="o">=</span> <span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">degf</span>


<span class="k">def</span> <span class="nf">_LC</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the leading coefficient of a multivariate polynomial</span>
<span class="sd">    `f \in K[x_0, \ldots, x_{k-2}, y] \cong K[y][x_0, \ldots, x_{k-2}]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `K[x_0, \ldots, x_{k-2}, y]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    lcf : PolyElement</span>
<span class="sd">        polynomial in `K[y]`, leading coefficient of `f`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import _LC</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - 1</span>
<span class="sd">    &gt;&gt;&gt; _LC(f)</span>
<span class="sd">    y**2 + y</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y**2 + x**2*y - 1</span>
<span class="sd">    &gt;&gt;&gt; _LC(f)</span>
<span class="sd">    1</span>

<span class="sd">    &gt;&gt;&gt; f = x*y*z - y**2*z**2</span>
<span class="sd">    &gt;&gt;&gt; _LC(f)</span>
<span class="sd">    z</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>
    <span class="n">yring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">ring</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">yring</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">degf</span> <span class="o">=</span> <span class="n">_deg</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="n">lcf</span> <span class="o">=</span> <span class="n">yring</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">monom</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">degf</span><span class="p">:</span>
            <span class="n">lcf</span> <span class="o">+=</span> <span class="n">coeff</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="n">monom</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">lcf</span>


<span class="k">def</span> <span class="nf">_swap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make the variable `x_i` the leading one in a multivariate polynomial `f`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>
    <span class="n">fswap</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
        <span class="n">monomswap</span> <span class="o">=</span> <span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span> <span class="o">+</span> <span class="n">monom</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">monom</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">fswap</span><span class="p">[</span><span class="n">monomswap</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
    <span class="k">return</span> <span class="n">fswap</span>


<span class="k">def</span> <span class="nf">_degree_bound_bivariate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute upper degree bounds for the GCD of two bivariate</span>
<span class="sd">    integer polynomials `f` and `g`.</span>

<span class="sd">    The GCD is viewed as a polynomial in `\mathbb{Z}[y][x]` and the</span>
<span class="sd">    function returns an upper bound for its degree and one for the degree</span>
<span class="sd">    of its content. This is done by choosing a suitable prime `p` and</span>
<span class="sd">    computing the GCD of the contents of `f \; \mathrm{mod} \, p` and</span>
<span class="sd">    `g \; \mathrm{mod} \, p`. The choice of `p` guarantees that the degree</span>
<span class="sd">    of the content in `\mathbb{Z}_p[y]` is greater than or equal to the</span>
<span class="sd">    degree in `\mathbb{Z}[y]`. To obtain the degree bound in the variable</span>
<span class="sd">    `x`, the polynomials are evaluated at `y = a` for a suitable</span>
<span class="sd">    `a \in \mathbb{Z}_p` and then their GCD in `\mathbb{Z}_p[x]` is</span>
<span class="sd">    computed. If no such `a` exists, i.e. the degree in `\mathbb{Z}_p[x]`</span>
<span class="sd">    is always smaller than the one in `\mathbb{Z}[y][x]`, then the bound is</span>
<span class="sd">    set to the minimum of the degrees of `f` and `g` in `x`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        bivariate integer polynomial</span>
<span class="sd">    g : PolyElement</span>
<span class="sd">        bivariate integer polynomial</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    xbound : Integer</span>
<span class="sd">        upper bound for the degree of the GCD of the polynomials `f` and</span>
<span class="sd">        `g` in the variable `x`</span>
<span class="sd">    ycontbound : Integer</span>
<span class="sd">        upper bound for the degree of the content of the GCD of the</span>
<span class="sd">        polynomials `f` and `g` in the variable `y`</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Monagan00]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>

    <span class="n">gamma1</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>
    <span class="n">gamma2</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">_swap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">_swap</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>
    <span class="n">badprimes</span> <span class="o">=</span> <span class="n">gamma1</span> <span class="o">*</span> <span class="n">gamma2</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">badprimes</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">fp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">contfp</span><span class="p">,</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">contgp</span><span class="p">,</span> <span class="n">gp</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">conthp</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">contfp</span><span class="p">,</span> <span class="n">contgp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="c"># polynomial in Z_p[y]</span>
    <span class="n">ycontbound</span> <span class="o">=</span> <span class="n">conthp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="c"># polynomial in Z_p[y]</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">_LC</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="n">_LC</span><span class="p">(</span><span class="n">gp</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">delta</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">fpa</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">gpa</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">hpa</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">fpa</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">xbound</span> <span class="o">=</span> <span class="n">hpa</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">xbound</span><span class="p">,</span> <span class="n">ycontbound</span>

    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">degree</span><span class="p">(),</span> <span class="n">gp</span><span class="o">.</span><span class="n">degree</span><span class="p">()),</span> <span class="n">ycontbound</span>


<span class="k">def</span> <span class="nf">_chinese_remainder_reconstruction_multivariate</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Construct a polynomial `h_{pq}` in</span>
<span class="sd">    `\mathbb{Z}_{p q}[x_0, \ldots, x_{k-1}]` such that</span>

<span class="sd">    .. math ::</span>

<span class="sd">        h_{pq} = h_p \; \mathrm{mod} \, p</span>

<span class="sd">        h_{pq} = h_q \; \mathrm{mod} \, q</span>

<span class="sd">    for relatively prime integers `p` and `q` and polynomials</span>
<span class="sd">    `h_p` and `h_q` in `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]` and</span>
<span class="sd">    `\mathbb{Z}_q[x_0, \ldots, x_{k-1}]` respectively.</span>

<span class="sd">    The coefficients of the polynomial `h_{pq}` are computed with the</span>
<span class="sd">    Chinese Remainder Theorem. The symmetric representation in</span>
<span class="sd">    `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]`,</span>
<span class="sd">    `\mathbb{Z}_q[x_0, \ldots, x_{k-1}]` and</span>
<span class="sd">    `\mathbb{Z}_{p q}[x_0, \ldots, x_{k-1}]` is used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    hp : PolyElement</span>
<span class="sd">        multivariate integer polynomial with coefficients in `\mathbb{Z}_p`</span>
<span class="sd">    hq : PolyElement</span>
<span class="sd">        multivariate integer polynomial with coefficients in `\mathbb{Z}_q`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        modulus of `h_p`, relatively prime to `q`</span>
<span class="sd">    q : Integer</span>
<span class="sd">        modulus of `h_q`, relatively prime to `p`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import _chinese_remainder_reconstruction_multivariate</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; p = 3</span>
<span class="sd">    &gt;&gt;&gt; q = 5</span>

<span class="sd">    &gt;&gt;&gt; hp = x**3*y - x**2 - 1</span>
<span class="sd">    &gt;&gt;&gt; hq = -x**3*y - 2*x*y**2 + 2</span>

<span class="sd">    &gt;&gt;&gt; hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)</span>
<span class="sd">    &gt;&gt;&gt; hpq</span>
<span class="sd">    4*x**3*y + 5*x**2 + 3*x*y**2 + 2</span>

<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(p) == hp</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(q) == hq</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; p = 6</span>
<span class="sd">    &gt;&gt;&gt; q = 5</span>

<span class="sd">    &gt;&gt;&gt; hp = 3*x**4 - y**3*z + z</span>
<span class="sd">    &gt;&gt;&gt; hq = -2*x**4 + z</span>

<span class="sd">    &gt;&gt;&gt; hpq = _chinese_remainder_reconstruction_multivariate(hp, hq, p, q)</span>
<span class="sd">    &gt;&gt;&gt; hpq</span>
<span class="sd">    3*x**4 + 5*y**3*z + z</span>

<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(p) == hp</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; hpq.trunc_ground(q) == hq</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hpmonoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">monoms</span><span class="p">())</span>
    <span class="n">hqmonoms</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">hq</span><span class="o">.</span><span class="n">monoms</span><span class="p">())</span>
    <span class="n">monoms</span> <span class="o">=</span> <span class="n">hpmonoms</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">hqmonoms</span><span class="p">)</span>
    <span class="n">hpmonoms</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">monoms</span><span class="p">)</span>
    <span class="n">hqmonoms</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">monoms</span><span class="p">)</span>

    <span class="n">zero</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span>

    <span class="n">hpq</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">crt_</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction_multivariate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">crt_</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cq</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">crt</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">],</span> <span class="p">[</span><span class="n">cp</span><span class="p">,</span> <span class="n">cq</span><span class="p">],</span> <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">monom</span> <span class="ow">in</span> <span class="n">monoms</span><span class="p">:</span>
        <span class="n">hpq</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">crt_</span><span class="p">(</span><span class="n">hp</span><span class="p">[</span><span class="n">monom</span><span class="p">],</span> <span class="n">hq</span><span class="p">[</span><span class="n">monom</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">monom</span> <span class="ow">in</span> <span class="n">hpmonoms</span><span class="p">:</span>
        <span class="n">hpq</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">crt_</span><span class="p">(</span><span class="n">hp</span><span class="p">[</span><span class="n">monom</span><span class="p">],</span> <span class="n">zero</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">monom</span> <span class="ow">in</span> <span class="n">hqmonoms</span><span class="p">:</span>
        <span class="n">hpq</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">crt_</span><span class="p">(</span><span class="n">zero</span><span class="p">,</span> <span class="n">hq</span><span class="p">[</span><span class="n">monom</span><span class="p">],</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hpq</span>


<span class="k">def</span> <span class="nf">_interpolate_multivariate</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">hpeval</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ground</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a polynomial `h_p` in `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]`</span>
<span class="sd">    from a list of evaluation points in `\mathbb{Z}_p` and a list of</span>
<span class="sd">    polynomials in</span>
<span class="sd">    `\mathbb{Z}_p[x_0, \ldots, x_{i-1}, x_{i+1}, \ldots, x_{k-1}]`, which</span>
<span class="sd">    are the images of `h_p` evaluated in the variable `x_i`.</span>

<span class="sd">    It is also possible to reconstruct a parameter of the ground domain,</span>
<span class="sd">    i.e. if `h_p` is a polynomial over `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]`.</span>
<span class="sd">    In this case, one has to set ``ground=True``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    evalpoints : list of Integer objects</span>
<span class="sd">        list of evaluation points in `\mathbb{Z}_p`</span>
<span class="sd">    hpeval : list of PolyElement objects</span>
<span class="sd">        list of polynomials in (resp. over)</span>
<span class="sd">        `\mathbb{Z}_p[x_0, \ldots, x_{i-1}, x_{i+1}, \ldots, x_{k-1}]`,</span>
<span class="sd">        images of `h_p` evaluated in the variable `x_i`</span>
<span class="sd">    ring : PolyRing</span>
<span class="sd">        `h_p` will be an element of this ring</span>
<span class="sd">    i : Integer</span>
<span class="sd">        index of the variable which has to be reconstructed</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `h_p`</span>
<span class="sd">    ground : Boolean</span>
<span class="sd">        indicates whether `x_i` is in the ground domain, default is</span>
<span class="sd">        ``False``</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    hp : PolyElement</span>
<span class="sd">        interpolated polynomial in (resp. over)</span>
<span class="sd">        `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hp</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="n">ground</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">hpa</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">hpeval</span><span class="p">):</span>
        <span class="n">numer</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">one</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">evalpoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">a</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">numer</span> <span class="o">*=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">b</span>
            <span class="n">denom</span> <span class="o">*=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">denom</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">numer</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">denom</span><span class="p">)</span>
        <span class="n">hp</span> <span class="o">+=</span> <span class="n">hpa</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span> <span class="o">*</span> <span class="n">coeff</span>

    <span class="k">return</span> <span class="n">hp</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>


<div class="viewcode-block" id="modgcd_bivariate"><a class="viewcode-back" href="../../../modules/polys/internals.html#sympy.polys.modulargcd.modgcd_bivariate">[docs]</a><span class="k">def</span> <span class="nf">modgcd_bivariate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Computes the GCD of two polynomials in `\mathbb{Z}[x, y]` using a</span>
<span class="sd">    modular algorithm.</span>

<span class="sd">    The algorithm computes the GCD of two bivariate integer polynomials</span>
<span class="sd">    `f` and `g` by calculating the GCD in `\mathbb{Z}_p[x, y]` for</span>
<span class="sd">    suitable primes `p` and then reconstructing the coefficients with the</span>
<span class="sd">    Chinese Remainder Theorem. To compute the bivariate GCD over</span>
<span class="sd">    `\mathbb{Z}_p`, the polynomials `f \; \mathrm{mod} \, p` and</span>
<span class="sd">    `g \; \mathrm{mod} \, p` are evaluated at `y = a` for certain</span>
<span class="sd">    `a \in \mathbb{Z}_p` and then their univariate GCD in `\mathbb{Z}_p[x]`</span>
<span class="sd">    is computed. Interpolating those yields the bivariate GCD in</span>
<span class="sd">    `\mathbb{Z}_p[x, y]`. To verify the result in `\mathbb{Z}[x, y]`, trial</span>
<span class="sd">    division is done, but only for candidates which are very likely the</span>
<span class="sd">    desired GCD.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        bivariate integer polynomial</span>
<span class="sd">    g : PolyElement</span>
<span class="sd">        bivariate integer polynomial</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        GCD of the polynomials `f` and `g`</span>
<span class="sd">    cff : PolyElement</span>
<span class="sd">        cofactor of `f`, i.e. `\frac{f}{h}`</span>
<span class="sd">    cfg : PolyElement</span>
<span class="sd">        cofactor of `g`, i.e. `\frac{g}{h}`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import modgcd_bivariate</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2 - y**2</span>
<span class="sd">    &gt;&gt;&gt; g = x**2 + 2*x*y + y**2</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = modgcd_bivariate(f, g)</span>
<span class="sd">    &gt;&gt;&gt; h, cff, cfg</span>
<span class="sd">    (x + y, x - y, x + y)</span>

<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; f = x**2*y - x**2 - 4*y + 4</span>
<span class="sd">    &gt;&gt;&gt; g = x + 2</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = modgcd_bivariate(f, g)</span>
<span class="sd">    &gt;&gt;&gt; h, cff, cfg</span>
<span class="sd">    (x + 2, x*y - x - 2*y + 2, 1)</span>

<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Monagan00]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">ring</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">is_ZZ</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">_trivial_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>

    <span class="n">cf</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">cg</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">cg</span><span class="p">)</span>

    <span class="n">xbound</span><span class="p">,</span> <span class="n">ycontbound</span> <span class="o">=</span> <span class="n">_degree_bound_bivariate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xbound</span> <span class="o">==</span> <span class="n">ycontbound</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ring</span><span class="p">(</span><span class="n">ch</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cf</span> <span class="o">//</span> <span class="n">ch</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cg</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>

    <span class="n">fswap</span> <span class="o">=</span> <span class="n">_swap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">gswap</span> <span class="o">=</span> <span class="n">_swap</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">degyf</span> <span class="o">=</span> <span class="n">fswap</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degyg</span> <span class="o">=</span> <span class="n">gswap</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="n">ybound</span><span class="p">,</span> <span class="n">xcontbound</span> <span class="o">=</span> <span class="n">_degree_bound_bivariate</span><span class="p">(</span><span class="n">fswap</span><span class="p">,</span> <span class="n">gswap</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ybound</span> <span class="o">==</span> <span class="n">xcontbound</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ring</span><span class="p">(</span><span class="n">ch</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cf</span> <span class="o">//</span> <span class="n">ch</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cg</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>

    <span class="c"># TODO: to improve performance, choose the main variable here</span>

    <span class="n">gamma1</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>
    <span class="n">gamma2</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">fswap</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">gswap</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>
    <span class="n">badprimes</span> <span class="o">=</span> <span class="n">gamma1</span> <span class="o">*</span> <span class="n">gamma2</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">badprimes</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">contfp</span><span class="p">,</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">contgp</span><span class="p">,</span> <span class="n">gp</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">gp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">conthp</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">contfp</span><span class="p">,</span> <span class="n">contgp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="c"># monic polynomial in Z_p[y]</span>
        <span class="n">degconthp</span> <span class="o">=</span> <span class="n">conthp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">degconthp</span> <span class="o">&gt;</span> <span class="n">ycontbound</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">degconthp</span> <span class="o">&lt;</span> <span class="n">ycontbound</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ycontbound</span> <span class="o">=</span> <span class="n">degconthp</span>
            <span class="k">continue</span>

        <span class="c"># polynomial in Z_p[y]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">_LC</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="n">_LC</span><span class="p">(</span><span class="n">gp</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span>

        <span class="n">degcontfp</span> <span class="o">=</span> <span class="n">contfp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">degcontgp</span> <span class="o">=</span> <span class="n">contgp</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
        <span class="n">degdelta</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">degyf</span> <span class="o">-</span> <span class="n">degcontfp</span><span class="p">,</span> <span class="n">degyg</span> <span class="o">-</span> <span class="n">degcontgp</span><span class="p">,</span>
            <span class="n">ybound</span> <span class="o">-</span> <span class="n">ycontbound</span> <span class="o">+</span> <span class="n">degdelta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">evalpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hpeval</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">unlucky</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="n">deltaa</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">deltaa</span> <span class="o">%</span> <span class="n">p</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">fpa</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">gpa</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">hpa</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">fpa</span><span class="p">,</span> <span class="n">gpa</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="c"># monic polynomial in Z_p[x]</span>
            <span class="n">deghpa</span> <span class="o">=</span> <span class="n">hpa</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">deghpa</span> <span class="o">&gt;</span> <span class="n">xbound</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">deghpa</span> <span class="o">&lt;</span> <span class="n">xbound</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">xbound</span> <span class="o">=</span> <span class="n">deghpa</span>
                <span class="n">unlucky</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>

            <span class="n">hpa</span> <span class="o">=</span> <span class="n">hpa</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">deltaa</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">evalpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">hpeval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hpa</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">unlucky</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">hp</span> <span class="o">=</span> <span class="n">_interpolate_multivariate</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">hpeval</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="n">hp</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">p</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">hp</span> <span class="o">*</span> <span class="n">conthp</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">degyhp</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">degyhp</span> <span class="o">&gt;</span> <span class="n">ybound</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">degyhp</span> <span class="o">&lt;</span> <span class="n">ybound</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ybound</span> <span class="o">=</span> <span class="n">degyhp</span>
            <span class="k">continue</span>

        <span class="n">hp</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">gamma1</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">hlastm</span> <span class="o">=</span> <span class="n">hp</span>
            <span class="k">continue</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction_multivariate</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hlastm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">*=</span> <span class="n">p</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">hm</span> <span class="o">==</span> <span class="n">hlastm</span><span class="p">:</span>
            <span class="n">hlastm</span> <span class="o">=</span> <span class="n">hm</span>
            <span class="k">continue</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">quo_ground</span><span class="p">(</span><span class="n">hm</span><span class="o">.</span><span class="n">content</span><span class="p">())</span>
        <span class="n">fquo</span><span class="p">,</span> <span class="n">frem</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">gquo</span><span class="p">,</span> <span class="n">grem</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frem</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">grem</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">LC</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="o">-</span><span class="n">ch</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">cff</span> <span class="o">=</span> <span class="n">fquo</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cf</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="n">gquo</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cg</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">cff</span><span class="p">,</span> <span class="n">cfg</span>

</div>
<span class="k">def</span> <span class="nf">_modgcd_multivariate_p</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degbound</span><span class="p">,</span> <span class="n">contbound</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials in</span>
<span class="sd">    `\mathbb{Z}_p[x0, \ldots, x{k-1}]`.</span>

<span class="sd">    The algorithm reduces the problem step by step by evaluating the</span>
<span class="sd">    polynomials `f` and `g` at `x_{k-1} = a` for suitable</span>
<span class="sd">    `a \in \mathbb{Z}_p` and then calls itself recursively to compute the GCD</span>
<span class="sd">    in `\mathbb{Z}_p[x_0, \ldots, x_{k-2}]`. If these recursive calls are</span>
<span class="sd">    succsessful for enough evaluation points, the GCD in `k` variables is</span>
<span class="sd">    interpolated, otherwise the algorithm returns ``None``. Every time a GCD</span>
<span class="sd">    or a content is computed, their degrees are compared with the bounds. If</span>
<span class="sd">    a degree greater then the bound is encountered, then the current call</span>
<span class="sd">    returns ``None`` and a new evaluation point has to be chosen. If at some</span>
<span class="sd">    point the degree is smaller, the correspondent bound is updated and the</span>
<span class="sd">    algorithm fails.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        multivariate integer polynomial with coefficients in `\mathbb{Z}_p`</span>
<span class="sd">    g : PolyElement</span>
<span class="sd">        multivariate integer polynomial with coefficients in `\mathbb{Z}_p`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `f` and `g`</span>
<span class="sd">    degbound : list of Integer objects</span>
<span class="sd">        ``degbound[i]`` is an upper bound for the degree of the GCD of `f`</span>
<span class="sd">        and `g` in the variable `x_i`</span>
<span class="sd">    contbound : list of Integer objects</span>
<span class="sd">        ``contbound[i]`` is an upper bound for the degree of the content of</span>
<span class="sd">        the GCD in `\mathbb{Z}_p[x_i][x_0, \ldots, x_{i-1}]`,</span>
<span class="sd">        ``contbound[0]`` is not used can therefore be chosen</span>
<span class="sd">        arbitrarily.</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        GCD of the polynomials `f` and `g` or ``None``</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Monagan00]_</span>
<span class="sd">    2. [Brown71]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">degh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">degh</span> <span class="o">&gt;</span> <span class="n">degbound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">degh</span> <span class="o">&lt;</span> <span class="n">degbound</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">degbound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">degh</span>
            <span class="k">raise</span> <span class="n">ModularGCDFailed</span>

        <span class="k">return</span> <span class="n">h</span>

    <span class="n">degyf</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">degyg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">contf</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">contg</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">conth</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">contf</span><span class="p">,</span> <span class="n">contg</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="c"># polynomial in Z_p[y]</span>

    <span class="n">degcontf</span> <span class="o">=</span> <span class="n">contf</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degcontg</span> <span class="o">=</span> <span class="n">contg</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degconth</span> <span class="o">=</span> <span class="n">conth</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">degconth</span> <span class="o">&gt;</span> <span class="n">contbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">degconth</span> <span class="o">&lt;</span> <span class="n">contbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">contbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">degconth</span>
        <span class="k">raise</span> <span class="n">ModularGCDFailed</span>

    <span class="n">lcf</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">lcg</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">lcf</span><span class="p">,</span> <span class="n">lcg</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="c"># polynomial in Z_p[y]</span>

    <span class="n">evaltest</span> <span class="o">=</span> <span class="n">delta</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">evaltest</span> <span class="o">*=</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">_LC</span><span class="p">(</span><span class="n">_swap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">_LC</span><span class="p">(</span><span class="n">_swap</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">)),</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">degdelta</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">degyf</span> <span class="o">-</span> <span class="n">degcontf</span><span class="p">,</span> <span class="n">degyg</span> <span class="o">-</span> <span class="n">degcontg</span><span class="p">,</span>
            <span class="n">degbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">contbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">degdelta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">evalpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heval</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">points</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">evaltest</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">deltaa</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span>

        <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">ga</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="c"># polynomials in Z_p[x_0, ..., x_{k-2}]</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="n">_modgcd_multivariate_p</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">ga</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degbound</span><span class="p">,</span> <span class="n">contbound</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ha</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">ha</span><span class="o">.</span><span class="n">is_ground</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">conth</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">h</span>

        <span class="n">ha</span> <span class="o">=</span> <span class="n">ha</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">deltaa</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">evalpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">heval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">N</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">_interpolate_multivariate</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">heval</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

            <span class="n">h</span> <span class="o">=</span> <span class="n">_primitive</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">p</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">conth</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="n">degyh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">degyh</span> <span class="o">&gt;</span> <span class="n">degbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">degyh</span> <span class="o">&lt;</span> <span class="n">degbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">degbound</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">degyh</span>
                <span class="k">raise</span> <span class="n">ModularGCDFailed</span>

            <span class="k">return</span> <span class="n">h</span>

    <span class="k">return</span> <span class="bp">None</span>


<div class="viewcode-block" id="modgcd_multivariate"><a class="viewcode-back" href="../../../modules/polys/internals.html#sympy.polys.modulargcd.modgcd_multivariate">[docs]</a><span class="k">def</span> <span class="nf">modgcd_multivariate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials in `\mathbb{Z}[x_0, \ldots, x_{k-1}]`</span>
<span class="sd">    using a modular algorithm.</span>

<span class="sd">    The algorithm computes the GCD of two multivariate integer polynomials</span>
<span class="sd">    `f` and `g` by calculating the GCD in</span>
<span class="sd">    `\mathbb{Z}_p[x_0, \ldots, x_{k-1}]` for suitable primes `p` and then</span>
<span class="sd">    reconstructing the coefficients with the Chinese Remainder Theorem. To</span>
<span class="sd">    compute the multivariate GCD over `\mathbb{Z}_p` the recursive</span>
<span class="sd">    subroutine ``_modgcd_multivariate_p`` is used. To verify the result in</span>
<span class="sd">    `\mathbb{Z}[x_0, \ldots, x_{k-1}]`, trial division is done, but only for</span>
<span class="sd">    candidates which are very likely the desired GCD.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        multivariate integer polynomial</span>
<span class="sd">    g : PolyElement</span>
<span class="sd">        multivariate integer polynomial</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        GCD of the polynomials `f` and `g`</span>
<span class="sd">    cff : PolyElement</span>
<span class="sd">        cofactor of `f`, i.e. `\frac{f}{h}`</span>
<span class="sd">    cfg : PolyElement</span>
<span class="sd">        cofactor of `g`, i.e. `\frac{g}{h}`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import modgcd_multivariate</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&quot;x, y&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2 - y**2</span>
<span class="sd">    &gt;&gt;&gt; g = x**2 + 2*x*y + y**2</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = modgcd_multivariate(f, g)</span>
<span class="sd">    &gt;&gt;&gt; h, cff, cfg</span>
<span class="sd">    (x + y, x - y, x + y)</span>

<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; R, x, y, z = ring(&quot;x, y, z&quot;, ZZ)</span>

<span class="sd">    &gt;&gt;&gt; f = x*z**2 - y*z**2</span>
<span class="sd">    &gt;&gt;&gt; g = x**2*z + z</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = modgcd_multivariate(f, g)</span>
<span class="sd">    &gt;&gt;&gt; h, cff, cfg</span>
<span class="sd">    (z, x*z - y*z, x**2 + 1)</span>

<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Monagan00]_</span>
<span class="sd">    2. [Brown71]_</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    _modgcd_multivariate_p</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">ring</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">is_ZZ</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">_trivial_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>

    <span class="c"># divide out integer content</span>
    <span class="n">cf</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">cg</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">cg</span><span class="p">)</span>

    <span class="n">gamma</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>

    <span class="n">badprimes</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">badprimes</span> <span class="o">*=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">_swap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">,</span> <span class="n">_swap</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>

    <span class="n">degbound</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">fdeg</span><span class="p">,</span> <span class="n">gdeg</span><span class="p">)</span> <span class="k">for</span> <span class="n">fdeg</span><span class="p">,</span> <span class="n">gdeg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">degrees</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">degrees</span><span class="p">())]</span>
    <span class="n">contbound</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">degbound</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">badprimes</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c"># monic GCD of fp, gp in Z_p[x_0, ..., x_{k-2}, y]</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="n">_modgcd_multivariate_p</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">degbound</span><span class="p">,</span> <span class="n">contbound</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ModularGCDFailed</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">hp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">hp</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">p</span>
            <span class="n">hlastm</span> <span class="o">=</span> <span class="n">hp</span>
            <span class="k">continue</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction_multivariate</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">hlastm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">*=</span> <span class="n">p</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">hm</span> <span class="o">==</span> <span class="n">hlastm</span><span class="p">:</span>
            <span class="n">hlastm</span> <span class="o">=</span> <span class="n">hm</span>
            <span class="k">continue</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">primitive</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">fquo</span><span class="p">,</span> <span class="n">frem</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">gquo</span><span class="p">,</span> <span class="n">grem</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">frem</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">grem</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">LC</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="o">-</span><span class="n">ch</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">cff</span> <span class="o">=</span> <span class="n">fquo</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cf</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>
            <span class="n">cfg</span> <span class="o">=</span> <span class="n">gquo</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cg</span> <span class="o">//</span> <span class="n">ch</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">cff</span><span class="p">,</span> <span class="n">cfg</span>

</div>
<span class="k">def</span> <span class="nf">_gf_div</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute `\frac f g` modulo `p` for two univariate polynomials over</span>
<span class="sd">    `\mathbb Z_p`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">densequo</span><span class="p">,</span> <span class="n">denserem</span> <span class="o">=</span> <span class="n">gf_div</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">p</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">densequo</span><span class="p">),</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">denserem</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rational_function_reconstruction</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a rational function `\frac a b` in `\mathbb Z_p(t)` from</span>

<span class="sd">    .. math::</span>

<span class="sd">        c = \frac a b \; \mathrm{mod} \, m,</span>

<span class="sd">    where `c` and `m` are polynomials in `\mathbb Z_p[t]` and `m` has</span>
<span class="sd">    positive degree.</span>

<span class="sd">    The algorithm is based on the Euclidean Algorithm. In general, `m` is</span>
<span class="sd">    not irreducible, so it is possible that `b` is not invertible modulo</span>
<span class="sd">    `m`. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    c : PolyElement</span>
<span class="sd">        univariate polynomial in `\mathbb Z[t]`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number</span>
<span class="sd">    m : PolyElement</span>
<span class="sd">        modulus, not necessarily irreducible</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    frac : FracElement</span>
<span class="sd">        either `\frac a b` in `\mathbb Z(t)` or ``None``</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Hoeij04]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">M</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">r0</span><span class="p">,</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span>

    <span class="k">while</span> <span class="n">r1</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">quo</span> <span class="o">=</span> <span class="n">_gf_div</span><span class="p">(</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span> <span class="p">(</span><span class="n">r0</span> <span class="o">-</span> <span class="n">quo</span><span class="o">*</span><span class="n">r1</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">,</span> <span class="p">(</span><span class="n">s0</span> <span class="o">-</span> <span class="n">quo</span><span class="o">*</span><span class="n">s1</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span> <span class="n">s1</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">D</span> <span class="ow">or</span> <span class="n">_gf_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">lc</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">LC</span>
    <span class="k">if</span> <span class="n">lc</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">lcinv</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">lcinv</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">lcinv</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">field</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">to_field</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">field</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">field</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rational_reconstruction_func_coeffs</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct every coefficient `c_h` of a polynomial `h` in</span>
<span class="sd">    `\mathbb Z_p(t_k)[t_1, \ldots, t_{k-1}][x, z]` from the corresponding</span>
<span class="sd">    coefficient `c_{h_m}` of a polynomial `h_m` in</span>
<span class="sd">    `\mathbb Z_p[t_1, \ldots, t_k][x, z] \cong \mathbb Z_p[t_k][t_1, \ldots, t_{k-1}][x, z]`</span>
<span class="sd">    such that</span>

<span class="sd">    .. math::</span>

<span class="sd">        c_{h_m} = c_h \; \mathrm{mod} \, m,</span>

<span class="sd">    where `m \in \mathbb Z_p[t]`.</span>

<span class="sd">    The reconstruction is based on the Euclidean Algorithm. In general, `m`</span>
<span class="sd">    is not irreducible, so it is possible that this fails for some</span>
<span class="sd">    coefficient. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    hm : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `\mathbb Z_p`</span>
<span class="sd">    m : PolyElement</span>
<span class="sd">        modulus, polynomial in `\mathbb Z[t]`, not necessarily irreducible</span>
<span class="sd">    ring : PolyRing</span>
<span class="sd">        `\mathbb Z(t_k)[t_1, \ldots, t_{k-1}][x, z]`, `h` will be an</span>
<span class="sd">        element of this ring</span>
<span class="sd">    k : Integer</span>
<span class="sd">        index of the parameter `t_k` which will be reconstructed</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        reconstructed polynomial in</span>
<span class="sd">        `\mathbb Z(t_k)[t_1, \ldots, t_{k-1}][x, z]` or ``None``</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    _rational_function_reconstruction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">hm</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coeffh</span> <span class="o">=</span> <span class="n">_rational_function_reconstruction</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffh</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeffh</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span>
            <span class="k">for</span> <span class="n">mon</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">_rational_function_reconstruction</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>

                <span class="n">coeffh</span><span class="p">[</span><span class="n">mon</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span>

        <span class="n">h</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffh</span>

    <span class="k">return</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">_gf_gcdex</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Extended Euclidean Algorithm for two univariate polynomials over</span>
<span class="sd">    `\mathbb Z_p`.</span>

<span class="sd">    Returns polynomials `s, t` and `h`, such that `h` is the GCD of `f` and</span>
<span class="sd">    `g` and `sf + tg = h \; \mathrm{mod} \, p`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">gf_gcdex</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">p</span><span class="p">,</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_trunc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the reduced representation of a polynomial `f` in</span>
<span class="sd">    `\mathbb Z_p[z] / (\check m_{\alpha}(z))[x]`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        polynomial `\check m_{\alpha} \in \mathbb Z[z]`, not necessarily</span>
<span class="sd">        irreducible</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `\mathbb Z_p`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    ftrunc : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[x, z]`, reduced modulo</span>
<span class="sd">        `\check m_{\alpha}(z)` and `p`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">minpoly</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
    <span class="n">p_</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ground_new</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">rem</span><span class="p">([</span><span class="n">minpoly</span><span class="p">,</span> <span class="n">p_</span><span class="p">])</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_euclidean_algorithm</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the monic GCD of two univariate polynomials in</span>
<span class="sd">    `\mathbb{Z}_p[z]/(\check m_{\alpha}(z))[x]` with the Euclidean</span>
<span class="sd">    Algorithm.</span>

<span class="sd">    In general, `\check m_{\alpha}(z)` is not irreducible, so it is possible</span>
<span class="sd">    that some leading coefficient is not invertible modulo</span>
<span class="sd">    `\check m_{\alpha}(z)`. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, g : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Z[x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[z]`, not necessarily irreducible</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `\mathbb Z_p`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        GCD of `f` and `g` in `\mathbb Z[z, x]` or ``None``, coefficients</span>
<span class="sd">        are in `\left[ -\frac{p-1} 2, \frac{p-1} 2 \right]`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">_trunc</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">_trunc</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">g</span><span class="p">:</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">deg</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c"># degree in x</span>
        <span class="n">lcinv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">_gf_gcdex</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">dmp_LC</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">gcd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c"># degree in x</span>
            <span class="k">if</span> <span class="n">degrem</span> <span class="o">&lt;</span> <span class="n">deg</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">quo</span> <span class="o">=</span> <span class="p">(</span><span class="n">lcinv</span> <span class="o">*</span> <span class="n">ring</span><span class="o">.</span><span class="n">dmp_LC</span><span class="p">(</span><span class="n">rem</span><span class="p">))</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">_trunc</span><span class="p">(</span><span class="n">rem</span> <span class="o">-</span> <span class="n">g</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">((</span><span class="n">degrem</span> <span class="o">-</span> <span class="n">deg</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">*</span><span class="n">quo</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">g</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">rem</span>

    <span class="n">lcfinv</span> <span class="o">=</span> <span class="n">_gf_gcdex</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">dmp_LC</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_trunc</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">lcfinv</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_trial_division</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Check if `h` divides `f` in</span>
<span class="sd">    `\mathbb K[t_1, \ldots, t_k][z]/(m_{\alpha}(z))`, where `\mathbb K` is</span>
<span class="sd">    either `\mathbb Q` or `\mathbb Z_p`.</span>

<span class="sd">    This algorithm is based on pseudo division and does not use any</span>
<span class="sd">    fractions. By default `\mathbb K` is `\mathbb Q`, if a prime number `p`</span>
<span class="sd">    is given, `\mathbb Z_p` is chosen instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, h : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        polynomial `m_{\alpha}(z)` in `\mathbb Z[t_1, \ldots, t_k][z]`</span>
<span class="sd">    p : Integer or None</span>
<span class="sd">        if `p` is given, `\mathbb K` is set to `\mathbb Z_p` instead of</span>
<span class="sd">        `\mathbb Q`, default is ``None``</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    rem : PolyElement</span>
<span class="sd">        remainder of `\frac f h`</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Hoeij02]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="n">zxring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ring</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="n">minpoly</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>

    <span class="n">rem</span> <span class="o">=</span> <span class="n">f</span>

    <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degh</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>
    <span class="n">degm</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">lch</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
    <span class="n">lcm</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">LC</span>

    <span class="k">while</span> <span class="n">rem</span> <span class="ow">and</span> <span class="n">degrem</span> <span class="o">&gt;=</span> <span class="n">degh</span><span class="p">:</span>
        <span class="c"># polynomial in Z[t_1, ..., t_k][z]</span>
        <span class="n">lcrem</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">rem</span><span class="p">)</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">*</span><span class="n">lch</span> <span class="o">-</span> <span class="n">h</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">((</span><span class="n">degrem</span> <span class="o">-</span> <span class="n">degh</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">*</span><span class="n">lcrem</span>
        <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">rem</span> <span class="ow">and</span> <span class="n">degrem</span> <span class="o">&gt;=</span> <span class="n">degm</span><span class="p">:</span>
            <span class="c"># polynomial in Z[t_1, ..., t_k][x]</span>
            <span class="n">lcrem</span> <span class="o">=</span> <span class="n">_LC</span><span class="p">(</span><span class="n">rem</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">zxring</span><span class="p">))</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
            <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">lcm</span><span class="p">)</span> <span class="o">-</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">degrem</span> <span class="o">-</span> <span class="n">degm</span><span class="p">))</span><span class="o">*</span><span class="n">lcrem</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">rem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">degrem</span> <span class="o">=</span> <span class="n">rem</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">rem</span>


<span class="k">def</span> <span class="nf">_evaluate_ground</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a polynomial `f` at `a` in the `i`-th variable of the ground</span>
<span class="sd">    domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
        <span class="n">fa</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fa</span>


<span class="k">def</span> <span class="nf">_func_field_modgcd_p</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials `f` and `g` in</span>
<span class="sd">    `\mathbb Z_p(t_1, \ldots, t_k)[z]/(\check m_\alpha(z))[x]`.</span>

<span class="sd">    The algorithm reduces the problem step by step by evaluating the</span>
<span class="sd">    polynomials `f` and `g` at `t_k = a` for suitable `a \in \mathbb Z_p`</span>
<span class="sd">    and then calls itself recursively to compute the GCD in</span>
<span class="sd">    `\mathbb Z_p(t_1, \ldots, t_{k-1})[z]/(\check m_\alpha(z))[x]`. If these</span>
<span class="sd">    recursive calls are successful, the GCD over `k` variables is</span>
<span class="sd">    interpolated, otherwise the algorithm returns ``None``. After</span>
<span class="sd">    interpolation, Rational Function Reconstruction is used to obtain the</span>
<span class="sd">    correct coefficients. If this fails, a new evaluation point has to be</span>
<span class="sd">    chosen, otherwise the desired polynomial is obtained by clearing</span>
<span class="sd">    denominators. The result is verified with a fraction free trial</span>
<span class="sd">    division.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, g : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[t_1, \ldots, t_k][z]`, not necessarily</span>
<span class="sd">        irreducible</span>
<span class="sd">    p : Integer</span>
<span class="sd">        prime number, modulus of `\mathbb Z_p`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        primitive associate in `\mathbb Z[t_1, \ldots, t_k][x, z]` of the</span>
<span class="sd">        GCD of the polynomials `f` and `g`  or ``None``, coefficients are</span>
<span class="sd">        in `\left[ -\frac{p-1} 2, \frac{p-1} 2 \right]`</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Hoeij04]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span> <span class="c"># Z[t_1, ..., t_k]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ngens</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_euclidean_algorithm</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">qdomain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">to_field</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qdomain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">qdomain</span> <span class="o">=</span> <span class="n">qdomain</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">qdomain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">to_field</span><span class="p">())</span>

    <span class="n">qring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">qdomain</span><span class="p">)</span> <span class="c"># = Z(t_k)[t_1, ..., t_{k-1}][x, z]</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c"># polynomial in Z_p[t_1, ..., t_k][z]</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">dmp_LC</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">ring</span><span class="o">.</span><span class="n">dmp_LC</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="c"># polynomial in Z_p[t_1, ..., t_k]</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">LC</span>

    <span class="n">evalpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">heval</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">LMlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">points</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">points</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">points</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">gammaa</span> <span class="o">=</span> <span class="n">_evaluate_ground</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">minpolya</span> <span class="o">=</span> <span class="n">_evaluate_ground</span><span class="p">(</span><span class="n">minpoly</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gammaa</span><span class="o">.</span><span class="n">rem</span><span class="p">([</span><span class="n">minpolya</span><span class="p">,</span> <span class="n">gammaa</span><span class="o">.</span><span class="n">ring</span><span class="p">(</span><span class="n">p</span><span class="p">)])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">fa</span> <span class="o">=</span> <span class="n">_evaluate_ground</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">ga</span> <span class="o">=</span> <span class="n">_evaluate_ground</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="c"># polynomial in Z_p[x, t_1, ..., t_{k-1}, z]/(minpoly)</span>
        <span class="n">ha</span> <span class="o">=</span> <span class="n">_func_field_modgcd_p</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">ga</span><span class="p">,</span> <span class="n">minpolya</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ha</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">ha</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ha</span>

        <span class="n">LM</span> <span class="o">=</span> <span class="p">[</span><span class="n">ha</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">ha</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">LM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">coeff</span><span class="o">.</span><span class="n">LM</span> <span class="o">&gt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">LM</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="n">LM</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">LM</span>

        <span class="n">evalpoints_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="n">heval_a</span> <span class="o">=</span> <span class="p">[</span><span class="n">ha</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">get_ring</span><span class="p">()</span><span class="o">.</span><span class="n">one</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">get_ring</span><span class="p">()</span><span class="o">.</span><span class="n">one</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">gens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">hb</span><span class="p">,</span> <span class="n">LMhb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">evalpoints</span><span class="p">,</span> <span class="n">heval</span><span class="p">,</span> <span class="n">LMlist</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">LMhb</span> <span class="o">==</span> <span class="n">LM</span><span class="p">:</span>
                <span class="n">evalpoints_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="n">heval_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hb</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">*=</span> <span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">evalpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">heval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ha</span><span class="p">)</span>
        <span class="n">LMlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LM</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># polynomial in Z_p[t_1, ..., t_k][x, z]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_interpolate_multivariate</span><span class="p">(</span><span class="n">evalpoints_a</span><span class="p">,</span> <span class="n">heval_a</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ground</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># polynomial in Z_p(t_k)[t_1, ..., t_{k-1}][x, z]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_rational_reconstruction_func_coeffs</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">qring</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">h</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span>

            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">itercoeffs</span><span class="p">():</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">gf_lcm</span><span class="p">(</span><span class="n">den</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">coeff</span><span class="o">.</span><span class="n">denom</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span>
                        <span class="n">p</span><span class="p">,</span> <span class="n">dom</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">one</span>

            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">itercoeffs</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">itercoeffs</span><span class="p">():</span>
                    <span class="n">den</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">gf_lcm</span><span class="p">(</span><span class="n">den</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span> <span class="n">c</span><span class="o">.</span><span class="n">denom</span><span class="o">.</span><span class="n">to_dense</span><span class="p">(),</span>
                            <span class="n">p</span><span class="p">,</span> <span class="n">dom</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="n">den</span> <span class="o">=</span> <span class="n">qring</span><span class="o">.</span><span class="n">domain_new</span><span class="p">(</span><span class="n">den</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">den</span><span class="p">)</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_trial_division</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_trial_division</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">h</span>

    <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">_integer_rational_reconstruction</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">domain</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct a rational number `\frac a b` from</span>

<span class="sd">    .. math::</span>

<span class="sd">        c = \frac a b \; \mathrm{mod} \, m,</span>

<span class="sd">    where `c` and `m` are integers.</span>

<span class="sd">    The algorithm is based on the Euclidean Algorithm. In general, `m` is</span>
<span class="sd">    not a prime number, so it is possible that `b` is not invertible modulo</span>
<span class="sd">    `m`. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    c : Integer</span>
<span class="sd">        `c = \frac a b \; \mathrm{mod} \, m`</span>
<span class="sd">    m : Integer</span>
<span class="sd">        modulus, not necessarily prime</span>
<span class="sd">    domain : IntegerRing</span>
<span class="sd">        `a, b, c` are elements of ``domain``</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    frac : Rational</span>
<span class="sd">        either `\frac a b` in `\mathbb Q` or ``None``</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Wang81]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="n">m</span>

    <span class="n">r0</span><span class="p">,</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">zero</span>
    <span class="n">r1</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">one</span>

    <span class="n">bound</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">m</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="c"># still correct if replaced by ZZ.sqrt(m // 2) ?</span>

    <span class="k">while</span> <span class="n">r1</span> <span class="o">&gt;=</span> <span class="n">bound</span><span class="p">:</span>
        <span class="n">quo</span> <span class="o">=</span> <span class="n">r0</span> <span class="o">//</span> <span class="n">r1</span>
        <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span> <span class="o">-</span> <span class="n">quo</span><span class="o">*</span><span class="n">r1</span>
        <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s0</span> <span class="o">-</span> <span class="n">quo</span><span class="o">*</span><span class="n">s1</span>

    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">bound</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">if</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">r1</span><span class="p">,</span> <span class="o">-</span><span class="n">s1</span>
    <span class="k">elif</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">r1</span><span class="p">,</span> <span class="n">s1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">field</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">get_field</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">field</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="n">field</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rational_reconstruction_int_coeffs</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Reconstruct every rational coefficient `c_h` of a polynomial `h` in</span>
<span class="sd">    `\mathbb Q[t_1, \ldots, t_k][x, z]` from the corresponding integer</span>
<span class="sd">    coefficient `c_{h_m}` of a polynomial `h_m` in</span>
<span class="sd">    `\mathbb Z[t_1, \ldots, t_k][x, z]` such that</span>

<span class="sd">    .. math::</span>

<span class="sd">        c_{h_m} = c_h \; \mathrm{mod} \, m,</span>

<span class="sd">    where `m \in \mathbb Z`.</span>

<span class="sd">    The reconstruction is based on the Euclidean Algorithm. In general,</span>
<span class="sd">    `m` is not a prime number, so it is possible that this fails for some</span>
<span class="sd">    coefficient. In that case ``None`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    hm : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    m : Integer</span>
<span class="sd">        modulus, not necessarily prime</span>
<span class="sd">    ring : PolyRing</span>
<span class="sd">        `\mathbb Q[t_1, \ldots, t_k][x, z]`, `h` will be an element of this</span>
<span class="sd">        ring</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        reconstructed polynomial in `\mathbb Q[t_1, \ldots, t_k][x, z]` or</span>
<span class="sd">        ``None``</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    _integer_rational_reconstruction</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">reconstruction</span> <span class="o">=</span> <span class="n">_rational_reconstruction_int_coeffs</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reconstruction</span> <span class="o">=</span> <span class="n">_integer_rational_reconstruction</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">hm</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
        <span class="n">coeffh</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">domain</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">coeffh</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">h</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffh</span>

    <span class="k">return</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">_func_field_modgcd_m</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials in</span>
<span class="sd">    `\mathbb Q(t_1, \ldots, t_k)[z]/(m_{\alpha}(z))[x]` using a modular</span>
<span class="sd">    algorithm.</span>

<span class="sd">    The algorithm computes the GCD of two polynomials `f` and `g` by</span>
<span class="sd">    calculating the GCD in</span>
<span class="sd">    `\mathbb Z_p(t_1, \ldots, t_k)[z] / (\check m_{\alpha}(z))[x]` for</span>
<span class="sd">    suitable primes `p` and the primitive associate `\check m_{\alpha}(z)`</span>
<span class="sd">    of `m_{\alpha}(z)`. Then the coefficients are reconstructed with the</span>
<span class="sd">    Chinese Remainder Theorem and Rational Reconstruction. To compute the</span>
<span class="sd">    GCD over `\mathbb Z_p(t_1, \ldots, t_k)[z] / (\check m_{\alpha})[x]`,</span>
<span class="sd">    the recursive subroutine ``_func_field_modgcd_p`` is used. To verify the</span>
<span class="sd">    result in `\mathbb Q(t_1, \ldots, t_k)[z] / (m_{\alpha}(z))[x]`, a</span>
<span class="sd">    fraction free trial division is used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, g : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Z[t_1, \ldots, t_k][x, z]`</span>
<span class="sd">    minpoly : PolyElement</span>
<span class="sd">        irreducible polynomial in `\mathbb Z[t_1, \ldots, t_k][z]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        the primitive associate in `\mathbb Z[t_1, \ldots, t_k][x, z]` of</span>
<span class="sd">        the GCD of `f` and `g`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import _func_field_modgcd_m</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import ring, ZZ</span>

<span class="sd">    &gt;&gt;&gt; R, x, z = ring(&#39;x, z&#39;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; minpoly = (z**2 - 2).drop(0)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2 + 2*x*z + 2</span>
<span class="sd">    &gt;&gt;&gt; g = x + z</span>
<span class="sd">    &gt;&gt;&gt; _func_field_modgcd_m(f, g, minpoly)</span>
<span class="sd">    x + z</span>

<span class="sd">    &gt;&gt;&gt; D, t = ring(&#39;t&#39;, ZZ)</span>
<span class="sd">    &gt;&gt;&gt; R, x, z = ring(&#39;x, z&#39;, D)</span>
<span class="sd">    &gt;&gt;&gt; minpoly = (z**2-3).drop(0)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2 + (t + 1)*x*z + 3*t</span>
<span class="sd">    &gt;&gt;&gt; g = x*z + 3*t</span>
<span class="sd">    &gt;&gt;&gt; _func_field_modgcd_m(f, g, minpoly)</span>
<span class="sd">    x + t*z</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Hoeij04]_</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>

<span class="sd">    _func_field_modgcd_p</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ngens</span>
        <span class="n">QQdomain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">get_field</span><span class="p">())</span>
        <span class="n">QQring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">QQdomain</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">QQring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">domain</span><span class="o">=</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">get_field</span><span class="p">())</span>

    <span class="n">cf</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>
    <span class="n">cg</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">primitive</span><span class="p">()</span>

    <span class="c"># polynomial in Z[t_1, ..., t_k][z]</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">dmp_LC</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">ring</span><span class="o">.</span><span class="n">dmp_LC</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="c"># polynomial in Z[t_1, ..., t_k]</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">LC</span>

    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">primes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">hplist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">LMlist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">nextprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gamma</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span> <span class="o">%</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">fp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">gp</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">minpolyp</span> <span class="o">=</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">trunc_ground</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">hp</span> <span class="o">=</span> <span class="n">_func_field_modgcd_p</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">gp</span><span class="p">,</span> <span class="n">minpolyp</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">hp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ring</span><span class="o">.</span><span class="n">one</span>

        <span class="n">LM</span> <span class="o">=</span> <span class="p">[</span><span class="n">hp</span><span class="o">.</span><span class="n">degree</span><span class="p">()]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">k</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">hp</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">LM</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">coeff</span><span class="o">.</span><span class="n">LM</span> <span class="o">&gt;</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">LM</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="n">LM</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">LM</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">hp</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">p</span>

        <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">hq</span><span class="p">,</span> <span class="n">LMhq</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">primes</span><span class="p">,</span> <span class="n">hplist</span><span class="p">,</span> <span class="n">LMlist</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">LMhq</span> <span class="o">==</span> <span class="n">LM</span><span class="p">:</span>
                <span class="n">hm</span> <span class="o">=</span> <span class="n">_chinese_remainder_reconstruction_multivariate</span><span class="p">(</span><span class="n">hq</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">*=</span> <span class="n">q</span>

        <span class="n">primes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="n">hplist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hp</span><span class="p">)</span>
        <span class="n">LMlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LM</span><span class="p">)</span>

        <span class="n">hm</span> <span class="o">=</span> <span class="n">_rational_reconstruction_int_coeffs</span><span class="p">(</span><span class="n">hm</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">QQring</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hm</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">clear_denoms</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span>
            <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">hm</span><span class="o">.</span><span class="n">itercoeffs</span><span class="p">():</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">coeff</span><span class="o">.</span><span class="n">clear_denoms</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>

        <span class="c"># convert back to Z[t_1, ..., t_k][x, z] from Q[t_1, ..., t_k][x, z]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">primitive</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">_trial_division</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cf</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)</span> <span class="ow">or</span>
            <span class="n">_trial_division</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">mul_ground</span><span class="p">(</span><span class="n">cg</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">h</span>


<span class="k">def</span> <span class="nf">_to_ZZ_poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute an associate of a polynomial</span>
<span class="sd">    `f \in \mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]` in</span>
<span class="sd">    `\mathbb Z[x_1, \ldots, x_{n-1}][z] / (\check m_{\alpha}(z))[x_0]`,</span>
<span class="sd">    where `\check m_{\alpha}(z) \in \mathbb Z[z]` is the primitive associate</span>
<span class="sd">    of the minimal polynomial `m_{\alpha}(z)` of `\alpha` over</span>
<span class="sd">    `\mathbb Q`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`</span>
<span class="sd">    ring : PolyRing</span>
<span class="sd">        `\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    f_ : PolyElement</span>
<span class="sd">        associate of `f` in</span>
<span class="sd">        `\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f_</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>

    <span class="n">den</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">one</span>

    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">itercoeffs</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">rep</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">den</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">lcm</span><span class="p">(</span><span class="n">den</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">rep</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">PolynomialRing</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">mul_monom</span><span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">coeff</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">domain</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f_</span><span class="p">:</span>
                    <span class="n">f_</span><span class="p">[(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_</span><span class="p">[(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="k">return</span> <span class="n">f_</span>


<span class="k">def</span> <span class="nf">_to_ANP_poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Convert a polynomial</span>
<span class="sd">    `f \in \mathbb Z[x_1, \ldots, x_{n-1}][z]/(\check m_{\alpha}(z))[x_0]`</span>
<span class="sd">    to a polynomial in `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`,</span>
<span class="sd">    where `\check m_{\alpha}(z) \in \mathbb Z[z]` is the primitive associate</span>
<span class="sd">    of the minimal polynomial `m_{\alpha}(z)` of `\alpha` over</span>
<span class="sd">    `\mathbb Q`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Z[x_1, \ldots, x_{n-1}][x_0, z]`</span>
<span class="sd">    ring : PolyRing</span>
<span class="sd">        `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    f_ : PolyElement</span>
<span class="sd">        polynomial in `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">f_</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">PolynomialRing</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">mon</span><span class="p">,</span> <span class="n">coef</span> <span class="ow">in</span> <span class="n">coeff</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">mon</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">domain</span><span class="p">([</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">coef</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">monom</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f_</span><span class="p">:</span>
                    <span class="n">f_</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f_</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">iterterms</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">monom</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">domain</span><span class="p">([</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">coeff</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">monom</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">f_</span><span class="p">:</span>
                <span class="n">f_</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">c</span>

    <span class="k">return</span> <span class="n">f_</span>


<span class="k">def</span> <span class="nf">_minpoly_from_dense</span><span class="p">(</span><span class="n">minpoly</span><span class="p">,</span> <span class="n">ring</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Change representation of the minimal polynomial from ``DMP`` to</span>
<span class="sd">    ``PolyElement`` for a given ring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minpoly_</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">monom</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">minpoly</span><span class="o">.</span><span class="n">terms</span><span class="p">():</span>
        <span class="n">minpoly_</span><span class="p">[</span><span class="n">monom</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">minpoly_</span>


<span class="k">def</span> <span class="nf">_primitive_in_x0</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the content in `x_0` and the primitive part of a polynomial `f`</span>
<span class="sd">    in</span>
<span class="sd">    `\mathbb Q(\alpha)[x_0, x_1, \ldots, x_{n-1}] \cong \mathbb Q(\alpha)[x_1, \ldots, x_{n-1}][x_0]`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">fring</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">*</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fring</span><span class="o">.</span><span class="n">ngens</span><span class="p">))</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">f_</span> <span class="o">=</span> <span class="n">ring</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">as_expr</span><span class="p">())</span>
    <span class="n">cont</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">zero</span>

    <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">f_</span><span class="o">.</span><span class="n">itercoeffs</span><span class="p">():</span>
        <span class="n">cont</span> <span class="o">=</span> <span class="n">func_field_modgcd</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cont</span> <span class="o">==</span> <span class="n">dom</span><span class="o">.</span><span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cont</span><span class="p">,</span> <span class="n">f</span>

    <span class="k">return</span> <span class="n">cont</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">quo</span><span class="p">(</span><span class="n">cont</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">fring</span><span class="p">))</span>


<span class="c"># TODO: add support for algebraic function fields</span>
<div class="viewcode-block" id="func_field_modgcd"><a class="viewcode-back" href="../../../modules/polys/internals.html#sympy.polys.modulargcd.func_field_modgcd">[docs]</a><span class="k">def</span> <span class="nf">func_field_modgcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Compute the GCD of two polynomials `f` and `g` in</span>
<span class="sd">    `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]` using a modular algorithm.</span>

<span class="sd">    The algorithm first computes the primitive associate</span>
<span class="sd">    `\check m_{\alpha}(z)` of the minimal polynomial `m_{\alpha}` in</span>
<span class="sd">    `\mathbb{Z}[z]` and the primitive associates of `f` and `g` in</span>
<span class="sd">    `\mathbb{Z}[x_1, \ldots, x_{n-1}][z]/(\check m_{\alpha})[x_0]`. Then it</span>
<span class="sd">    computes the GCD in</span>
<span class="sd">    `\mathbb Q(x_1, \ldots, x_{n-1})[z]/(m_{\alpha}(z))[x_0]`.</span>
<span class="sd">    This is done by calculating the GCD in</span>
<span class="sd">    `\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]` for</span>
<span class="sd">    suitable primes `p` and then reconstructing the coefficients with the</span>
<span class="sd">    Chinese Remainder Theorem and Rational Reconstuction. The GCD over</span>
<span class="sd">    `\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]` is</span>
<span class="sd">    computed with a recursive subroutine, which evaluates the polynomials at</span>
<span class="sd">    `x_{n-1} = a` for suitable evaluation points `a \in \mathbb Z_p` and</span>
<span class="sd">    then calls itself recursively until the ground domain does no longer</span>
<span class="sd">    contain any parameters. For</span>
<span class="sd">    `\mathbb{Z}_p[z]/(\check m_{\alpha}(z))[x_0]` the Euclidean Algorithm is</span>
<span class="sd">    used. The results of those recursive calls are then interpolated and</span>
<span class="sd">    Rational Function Reconstruction is used to obtain the correct</span>
<span class="sd">    coefficients. The results, both in</span>
<span class="sd">    `\mathbb Q(x_1, \ldots, x_{n-1})[z]/(m_{\alpha}(z))[x_0]` and</span>
<span class="sd">    `\mathbb{Z}_p(x_1, \ldots, x_{n-1})[z]/(\check m_{\alpha}(z))[x_0]`, are</span>
<span class="sd">    verified by a fraction free trial division.</span>

<span class="sd">    Apart from the above GCD computation some GCDs in</span>
<span class="sd">    `\mathbb Q(\alpha)[x_1, \ldots, x_{n-1}]` have to be calculated,</span>
<span class="sd">    because treating the polynomials as univariate ones can result in</span>
<span class="sd">    a spurious content of the GCD. For this ``func_field_modgcd`` is</span>
<span class="sd">    called recursively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    f, g : PolyElement</span>
<span class="sd">        polynomials in `\mathbb Q(\alpha)[x_0, \ldots, x_{n-1}]`</span>

<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    h : PolyElement</span>
<span class="sd">        monic GCD of the polynomials `f` and `g`</span>
<span class="sd">    cff : PolyElement</span>
<span class="sd">        cofactor of `f`, i.e. `\frac f h`</span>
<span class="sd">    cfg : PolyElement</span>
<span class="sd">        cofactor of `g`, i.e. `\frac g h`</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.polys.modulargcd import func_field_modgcd</span>
<span class="sd">    &gt;&gt;&gt; from sympy.polys import AlgebraicField, QQ, ring</span>
<span class="sd">    &gt;&gt;&gt; from sympy import sqrt</span>

<span class="sd">    &gt;&gt;&gt; A = AlgebraicField(QQ, sqrt(2))</span>
<span class="sd">    &gt;&gt;&gt; R, x = ring(&#39;x&#39;, A)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2 - 2</span>
<span class="sd">    &gt;&gt;&gt; g = x + sqrt(2)</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = func_field_modgcd(f, g)</span>

<span class="sd">    &gt;&gt;&gt; h == x + sqrt(2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; R, x, y = ring(&#39;x, y&#39;, A)</span>

<span class="sd">    &gt;&gt;&gt; f = x**2 + 2*sqrt(2)*x*y + 2*y**2</span>
<span class="sd">    &gt;&gt;&gt; g = x + sqrt(2)*y</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = func_field_modgcd(f, g)</span>

<span class="sd">    &gt;&gt;&gt; h == x + sqrt(2)*y</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; f = x + sqrt(2)*y</span>
<span class="sd">    &gt;&gt;&gt; g = x + y</span>

<span class="sd">    &gt;&gt;&gt; h, cff, cfg = func_field_modgcd(f, g)</span>

<span class="sd">    &gt;&gt;&gt; h == R.one</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cff * h == f</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; cfg * h == g</span>
<span class="sd">    True</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    1. [Hoeij04]_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ring</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ring</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">ngens</span>

    <span class="k">assert</span> <span class="n">ring</span> <span class="o">==</span> <span class="n">g</span><span class="o">.</span><span class="n">ring</span> <span class="ow">and</span> <span class="n">domain</span><span class="o">.</span><span class="n">is_Algebraic</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">_trivial_gcd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;z&#39;</span><span class="p">)</span>

    <span class="n">ZZring</span> <span class="o">=</span> <span class="n">ring</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">ring</span><span class="o">.</span><span class="n">symbols</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span><span class="p">,),</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">get_ring</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">f_</span> <span class="o">=</span> <span class="n">_to_ZZ_poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ZZring</span><span class="p">)</span>
        <span class="n">g_</span> <span class="o">=</span> <span class="n">_to_ZZ_poly</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ZZring</span><span class="p">)</span>
        <span class="n">minpoly</span> <span class="o">=</span> <span class="n">ZZring</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">from_dense</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">mod</span><span class="o">.</span><span class="n">rep</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">_func_field_modgcd_m</span><span class="p">(</span><span class="n">f_</span><span class="p">,</span> <span class="n">g_</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_to_ANP_poly</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c"># contx0f in Q(a)[x_1, ..., x_{n-1}], f in Q(a)[x_0, ..., x_{n-1}]</span>
        <span class="n">contx0f</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">_primitive_in_x0</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">contx0g</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">_primitive_in_x0</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">contx0h</span> <span class="o">=</span> <span class="n">func_field_modgcd</span><span class="p">(</span><span class="n">contx0f</span><span class="p">,</span> <span class="n">contx0g</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ZZring_</span> <span class="o">=</span> <span class="n">ZZring</span><span class="o">.</span><span class="n">drop_to_ground</span><span class="p">(</span><span class="o">*</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="n">f_</span> <span class="o">=</span> <span class="n">_to_ZZ_poly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ZZring_</span><span class="p">)</span>
        <span class="n">g_</span> <span class="o">=</span> <span class="n">_to_ZZ_poly</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">ZZring_</span><span class="p">)</span>
        <span class="n">minpoly</span> <span class="o">=</span> <span class="n">_minpoly_from_dense</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">ZZring_</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">_func_field_modgcd_m</span><span class="p">(</span><span class="n">f_</span><span class="p">,</span> <span class="n">g_</span><span class="p">,</span> <span class="n">minpoly</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">_to_ANP_poly</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>

        <span class="n">contx0h_</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">_primitive_in_x0</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">*=</span> <span class="n">contx0h</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">*=</span> <span class="n">contx0f</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">*=</span> <span class="n">contx0g</span><span class="o">.</span><span class="n">set_ring</span><span class="p">(</span><span class="n">ring</span><span class="p">)</span>

    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">quo_ground</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">LC</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">quo</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">g</span><span class="o">.</span><span class="n">quo</span><span class="p">(</span><span class="n">h</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.5-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014 SymPy Development Team.
      Last updated on Jun 24, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>