<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.tensor.tensor &mdash; SymPy 0.7.5-git documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.5-git',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.5-git documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.5-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.tensor.tensor</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module defines tensors with abstract index notation.</span>

<span class="sd">The abstract index notation has been first formalized by Penrose.</span>

<span class="sd">Tensor indices are formal objects, with a tensor type; there is no</span>
<span class="sd">notion of index range, it is only possible to assign the dimension,</span>
<span class="sd">used to trace the Kronecker delta; the dimension can be a Symbol.</span>

<span class="sd">The Einstein summation convention is used.</span>
<span class="sd">The covariant indices are indicated with a minus sign in front of the index.</span>

<span class="sd">For instance the tensor ``t = p(a)*A(b,c)*q(-c)`` has the index ``c``</span>
<span class="sd">contracted.</span>

<span class="sd">A tensor expression ``t`` can be called; called with its</span>
<span class="sd">indices in sorted order it is equal to itself:</span>
<span class="sd">in the above example ``t(a, b) == t``;</span>
<span class="sd">one can call ``t`` with different indices; ``t(c, d) == p(c)*A(d,a)*q(-a)``.</span>

<span class="sd">The contracted indices are dummy indices, internally they have no name,</span>
<span class="sd">the indices being represented by a graph-like structure.</span>

<span class="sd">Tensors are put in canonical form using ``canon_bp``, which uses</span>
<span class="sd">the Butler-Portugal algorithm for canonicalization using the monoterm</span>
<span class="sd">symmetries of the tensors.</span>

<span class="sd">If there is a (anti)symmetric metric, the indices can be raised and</span>
<span class="sd">lowered when the tensor is put in canonical form.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">Rational</span>
<span class="kn">from</span> <span class="nn">sympy.combinatorics.tensor_can</span> <span class="kn">import</span> <span class="n">get_symmetric_group_sgs</span><span class="p">,</span> \
    <span class="n">bsgs_direct_product</span><span class="p">,</span> <span class="n">canonicalize</span><span class="p">,</span> <span class="n">riemann_bsgs</span>
<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">Basic</span><span class="p">,</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">Add</span><span class="p">,</span> <span class="n">S</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">sympy.core.containers</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">sympy.core.decorators</span> <span class="kn">import</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">sympy.core.symbol</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">sympy.core.sympify</span> <span class="kn">import</span> <span class="n">CantSympify</span>
<span class="kn">from</span> <span class="nn">sympy.external</span> <span class="kn">import</span> <span class="n">import_module</span>
<span class="kn">from</span> <span class="nn">sympy.utilities.decorator</span> <span class="kn">import</span> <span class="n">doctest_depends_on</span>
<span class="kn">from</span> <span class="nn">sympy.matrices</span> <span class="kn">import</span> <span class="n">eye</span>


<span class="k">class</span> <span class="nc">TIDS</span><span class="p">(</span><span class="n">CantSympify</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tensor internal data structure. This contains internal data structures about</span>
<span class="sd">    components of a tensor expression, its free and dummy indices.</span>

<span class="sd">    To create a ``TIDS`` object via the standard constructor, the required</span>
<span class="sd">    arguments are</span>

<span class="sd">    WARNING: this class is meant as an internal representation of tensor data</span>
<span class="sd">    structures and should not be directly accessed by end users.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    components : ``TensorHead`` objects representing the components of the tensor expression.</span>

<span class="sd">    free : Free indices in their internal representation.</span>

<span class="sd">    dum : Dummy indices in their internal representation.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, TIDS, tensorhead</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; m0, m1, m2, m3 = tensor_indices(&#39;m0,m1,m2,m3&#39;, Lorentz)</span>
<span class="sd">    &gt;&gt;&gt; T = tensorhead(&#39;T&#39;, [Lorentz]*4, [[1]*4])</span>
<span class="sd">    &gt;&gt;&gt; TIDS([T], [(m0, 0, 0), (m3, 3, 0)], [(1, 2, 0, 0)])</span>
<span class="sd">    TIDS([T(Lorentz,Lorentz,Lorentz,Lorentz)], [(m0, 0, 0), (m3, 3, 0)], [(1, 2, 0, 0)])</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    In short, this has created the components, free and dummy indices for</span>
<span class="sd">    the internal representation of a tensor T(m0, m1, -m1, m3).</span>

<span class="sd">    Free indices are represented as a list of triplets. The elements of</span>
<span class="sd">    each triplet identify a single free index and are</span>

<span class="sd">    1. TensorIndex object</span>
<span class="sd">    2. position inside the component</span>
<span class="sd">    3. component number</span>

<span class="sd">    Dummy indices are represented as a list of 4-plets. Each 4-plet stands</span>
<span class="sd">    for couple for contracted indices, their original TensorIndex is not</span>
<span class="sd">    stored as it is no longer required. The four elements of the 4-plet</span>
<span class="sd">    are</span>

<span class="sd">    1. position inside the component of the first index.</span>
<span class="sd">    2. position inside the component of the second index.</span>
<span class="sd">    3. component number of the first index.</span>
<span class="sd">    4. component number of the second index.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free</span> <span class="o">=</span> <span class="n">free</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dum</span> <span class="o">=</span> <span class="n">dum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ext_rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_components_with_free_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of components with their associated indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, TIDS, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m0, m1, m2, m3 = tensor_indices(&#39;m0,m1,m2,m3&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; T = tensorhead(&#39;T&#39;, [Lorentz]*4, [[1]*4])</span>
<span class="sd">        &gt;&gt;&gt; A = tensorhead(&#39;A&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; t = TIDS.from_components_and_indices([T], [m0, m1, -m1, m3])</span>
<span class="sd">        &gt;&gt;&gt; t.get_components_with_free_indices()</span>
<span class="sd">        [(T(Lorentz,Lorentz,Lorentz,Lorentz), [(m0, 0, 0), (m3, 3, 0)])]</span>
<span class="sd">        &gt;&gt;&gt; t2 = (A(m0)*A(-m0))._tids</span>
<span class="sd">        &gt;&gt;&gt; t2.get_components_with_free_indices()</span>
<span class="sd">        [(A(Lorentz), []), (A(Lorentz), [])]</span>
<span class="sd">        &gt;&gt;&gt; t3 = (A(m0)*A(-m1)*A(-m0)*A(m1))._tids</span>
<span class="sd">        &gt;&gt;&gt; t3.get_components_with_free_indices()</span>
<span class="sd">        [(A(Lorentz), []), (A(Lorentz), []), (A(Lorentz), []), (A(Lorentz), [])]</span>
<span class="sd">        &gt;&gt;&gt; t4 = (A(m0)*A(m1)*A(-m0))._tids</span>
<span class="sd">        &gt;&gt;&gt; t4.get_components_with_free_indices()</span>
<span class="sd">        [(A(Lorentz), []), (A(Lorentz), [(m1, 0, 1)]), (A(Lorentz), [])]</span>
<span class="sd">        &gt;&gt;&gt; t5 = (A(m0)*A(m1)*A(m2))._tids</span>
<span class="sd">        &gt;&gt;&gt; t5.get_components_with_free_indices()</span>
<span class="sd">        [(A(Lorentz), [(m0, 0, 0)]), (A(Lorentz), [(m1, 0, 1)]), (A(Lorentz), [(m2, 0, 2)])]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="n">ret_comp</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">free_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">comp</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">components</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">):</span>
            <span class="n">c_free</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">free_counter</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">[</span><span class="n">free_counter</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">c_free</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">[</span><span class="n">free_counter</span><span class="p">])</span>
                <span class="n">free_counter</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">free_counter</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="n">ret_comp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">comp</span><span class="p">,</span> <span class="n">c_free</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ret_comp</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_components_and_indices</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new ``TIDS`` object from ``components`` and ``indices``</span>

<span class="sd">        ``components``  ``TensorHead`` objects representing the components</span>
<span class="sd">                        of the tensor expression.</span>

<span class="sd">        ``indices``     ``TensorIndex`` objects, the indices. Contractions are</span>
<span class="sd">                        detected upon construction.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, TIDS, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m0, m1, m2, m3 = tensor_indices(&#39;m0,m1,m2,m3&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; T = tensorhead(&#39;T&#39;, [Lorentz]*4, [[1]*4])</span>
<span class="sd">        &gt;&gt;&gt; TIDS.from_components_and_indices([T], [m0, m1, -m1, m3])</span>
<span class="sd">        TIDS([T(Lorentz,Lorentz,Lorentz,Lorentz)], [(m0, 0, 0), (m3, 3, 0)], [(1, 2, 0, 0)])</span>

<span class="sd">        In case of many components the same indices have slightly different</span>
<span class="sd">        indexes:</span>

<span class="sd">        &gt;&gt;&gt; A = tensorhead(&#39;A&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; TIDS.from_components_and_indices([A]*4, [m0, m1, -m1, m3])</span>
<span class="sd">        TIDS([A(Lorentz), A(Lorentz), A(Lorentz), A(Lorentz)], [(m0, 0, 0), (m3, 0, 3)], [(0, 0, 1, 2)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tids</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">cur_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="n">tids_sing</span> <span class="o">=</span> <span class="n">TIDS</span><span class="p">([</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">TIDS</span><span class="o">.</span><span class="n">free_dum_from_indices</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">[</span><span class="n">cur_pos</span><span class="p">:</span><span class="n">cur_pos</span><span class="o">+</span><span class="n">i</span><span class="o">.</span><span class="n">rank</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">tids</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">tids</span> <span class="o">=</span> <span class="n">tids_sing</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tids</span> <span class="o">*=</span> <span class="n">tids_sing</span>
            <span class="n">cur_pos</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="n">rank</span>

        <span class="k">if</span> <span class="n">tids</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tids</span> <span class="o">=</span> <span class="n">TIDS</span><span class="p">([],</span> <span class="p">[],</span> <span class="p">[])</span>

        <span class="n">tids</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">tids</span><span class="o">.</span><span class="n">dum</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">tids</span>

    <span class="k">def</span> <span class="nf">to_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of indices, creating new tensor indices to complete dummy indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">component_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">component_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">i</span><span class="o">.</span><span class="n">rank</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">:</span>
            <span class="n">component_indices</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dummy_pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dum</span><span class="p">):</span>
            <span class="n">tensor_index_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">dummy_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dummy_index</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="s">&#39;dummy_index_{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">tensor_index_type</span><span class="p">)</span>
            <span class="n">component_indices</span><span class="p">[</span><span class="n">dummy_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]][</span><span class="n">dummy_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dummy_index</span>
            <span class="n">component_indices</span><span class="p">[</span><span class="n">dummy_pos</span><span class="p">[</span><span class="mi">3</span><span class="p">]][</span><span class="n">dummy_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">dummy_index</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">component_indices</span><span class="p">:</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">free_dum_from_indices</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert ``indices`` into ``free``, ``dum`` for single component tensor</span>

<span class="sd">        ``free``     list of tuples ``(index, pos, 0)``,</span>
<span class="sd">                     where ``pos`` is the position of index in</span>
<span class="sd">                     the list of indices formed by the component tensors</span>

<span class="sd">        ``dum``      list of tuples ``(pos_contr, pos_cov, 0, 0)``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, TIDS</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m0, m1, m2, m3 = tensor_indices(&#39;m0,m1,m2,m3&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; TIDS.free_dum_from_indices(m0, m1, -m1, m3)</span>
<span class="sd">        ([(m0, 0, 0), (m3, 3, 0)], [(1, 2, 0, 0)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[]</span>

        <span class="c"># find the positions of the free indices and of the dummy indices</span>
        <span class="n">free</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">index_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">_name</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span>
            <span class="n">contr</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">_is_up</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="p">)</span> <span class="ow">in</span> <span class="n">index_dict</span><span class="p">:</span>
                <span class="c"># found a pair of dummy indices</span>
                <span class="n">is_contr</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">index_dict</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="p">)]</span>
                <span class="c"># check consistency and update free</span>
                <span class="k">if</span> <span class="n">is_contr</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">contr</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;two equal contravariant indices in slots </span><span class="si">%d</span><span class="s"> and </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">free</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">free</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">contr</span><span class="p">:</span>
                        <span class="n">free</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="n">free</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;two equal covariant indices in slots </span><span class="si">%d</span><span class="s"> and </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">contr</span><span class="p">:</span>
                    <span class="n">dum</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dum</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index_dict</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="p">)]</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">_is_up</span><span class="p">,</span> <span class="n">i</span>

        <span class="n">free</span> <span class="o">=</span> <span class="p">[(</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="k">if</span> <span class="n">free</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">free</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The algorithms performing the multiplication of two ``TIDS`` instances.</span>

<span class="sd">        In short, it forms a new ``TIDS`` object, joining components and indices,</span>
<span class="sd">        checking that abstract indices are compatible, and possibly contracting</span>
<span class="sd">        them.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, TIDS, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m0, m1, m2, m3 = tensor_indices(&#39;m0,m1,m2,m3&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; T = tensorhead(&#39;T&#39;, [Lorentz]*4, [[1]*4])</span>
<span class="sd">        &gt;&gt;&gt; A = tensorhead(&#39;A&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; tids_1 = TIDS.from_components_and_indices([T], [m0, m1, -m1, m3])</span>
<span class="sd">        &gt;&gt;&gt; tids_2 = TIDS.from_components_and_indices([A], [m2])</span>
<span class="sd">        &gt;&gt;&gt; tids_1 * tids_2</span>
<span class="sd">        TIDS([T(Lorentz,Lorentz,Lorentz,Lorentz), A(Lorentz)],\</span>
<span class="sd">            [(m0, 0, 0), (m3, 3, 0), (m2, 0, 1)], [(1, 2, 0, 0)])</span>

<span class="sd">        In this case no contraction has been performed.</span>

<span class="sd">        &gt;&gt;&gt; tids_3 = TIDS.from_components_and_indices([A], [-m3])</span>
<span class="sd">        &gt;&gt;&gt; tids_1 * tids_3</span>
<span class="sd">        TIDS([T(Lorentz,Lorentz,Lorentz,Lorentz), A(Lorentz)],\</span>
<span class="sd">            [(m0, 0, 0)], [(1, 2, 0, 0), (3, 0, 0, 1)])</span>

<span class="sd">        Free indices ``m3`` and ``-m3`` are identified as a contracted couple, and are</span>
<span class="sd">        therefore transformed into dummy indices.</span>

<span class="sd">        A wrong index construction (for example, trying to contract two</span>
<span class="sd">        contravariant indices or using indices multiple times) would result in</span>
<span class="sd">        an exception:</span>

<span class="sd">        &gt;&gt;&gt; tids_4 = TIDS.from_components_and_indices([A], [m3])</span>
<span class="sd">        &gt;&gt;&gt; # This raises an exception:</span>
<span class="sd">        &gt;&gt;&gt; # tids_1 * tids_4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index_up</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">u</span> <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">is_up</span> <span class="k">else</span> <span class="o">-</span><span class="n">u</span>

        <span class="c"># find out which free indices of f and g are contracted</span>
        <span class="n">free_dict1</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_up</span> <span class="k">else</span> <span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">cpos</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">cpos</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>
        <span class="n">free_dict2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_up</span> <span class="k">else</span> <span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">cpos</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">cpos</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>

        <span class="n">free_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">free_dict1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">free_dict2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c"># find the new `free` and `dum`</span>
        <span class="n">nc1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">components</span><span class="p">)</span>
        <span class="n">dum2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">c1</span> <span class="o">+</span> <span class="n">nc1</span><span class="p">,</span> <span class="n">c2</span> <span class="o">+</span> <span class="n">nc1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">dum</span><span class="p">]</span>
        <span class="n">free1</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ind</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">index_up</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">free_names</span><span class="p">]</span>
        <span class="n">free2</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ind</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">nc1</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">free</span> <span class="k">if</span> <span class="n">index_up</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">free_names</span><span class="p">]</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">free1</span> <span class="o">+</span> <span class="n">free2</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">dum</span> <span class="o">+</span> <span class="n">dum2</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">free_names</span><span class="p">:</span>
            <span class="n">ipos1</span><span class="p">,</span> <span class="n">cpos1</span><span class="p">,</span> <span class="n">ind1</span> <span class="o">=</span> <span class="n">free_dict1</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">ipos2</span><span class="p">,</span> <span class="n">cpos2</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">free_dict2</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">cpos2</span> <span class="o">+=</span> <span class="n">nc1</span>
            <span class="k">if</span> <span class="n">ind1</span><span class="o">.</span><span class="n">_is_up</span> <span class="o">==</span> <span class="n">ind2</span><span class="o">.</span><span class="n">_is_up</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;wrong index construction {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ind1</span><span class="o">.</span><span class="n">_is_up</span><span class="p">:</span>
                <span class="n">new_dummy</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipos1</span><span class="p">,</span> <span class="n">ipos2</span><span class="p">,</span> <span class="n">cpos1</span><span class="p">,</span> <span class="n">cpos2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_dummy</span> <span class="o">=</span> <span class="p">(</span><span class="n">ipos2</span><span class="p">,</span> <span class="n">ipos1</span><span class="p">,</span> <span class="n">cpos2</span><span class="p">,</span> <span class="n">cpos1</span><span class="p">)</span>
            <span class="n">dum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_dummy</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">components</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TIDS</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;TIDS({0}, {1}, {2})&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sorted_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``TIDS`` with sorted components</span>

<span class="sd">        The sorting is done taking into account the commutation group</span>
<span class="sd">        of the component tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">sympy.combinatorics.permutations</span> <span class="kn">import</span> <span class="n">_af_invert</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">))))</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cv</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">commutes_with</span><span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_types</span><span class="p">,</span> <span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span> <span class="o">&gt;</span> \
                        <span class="p">(</span><span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_types</span><span class="p">,</span> <span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_name</span><span class="p">):</span>
                    <span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cv</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">c</span><span class="p">:</span>
                        <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="n">sign</span>

        <span class="c"># perm_inv[new_pos] = old_pos</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cv</span><span class="p">]</span>
        <span class="n">perm_inv</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cv</span><span class="p">]</span>
        <span class="n">perm</span> <span class="o">=</span> <span class="n">_af_invert</span><span class="p">(</span><span class="n">perm_inv</span><span class="p">)</span>
        <span class="n">free</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ind</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">perm</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">]</span>
        <span class="n">free</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">perm</span><span class="p">[</span><span class="n">c1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">c2</span><span class="p">])</span> <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dum</span><span class="p">]</span>
        <span class="n">dum</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">components</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">TIDS</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">),</span> <span class="n">sign</span>

    <span class="k">def</span> <span class="nf">canon_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ``(g, dummies, msym, v)``, the entries of ``canonicalize``</span>

<span class="sd">        see ``canonicalize`` in ``tensor_can.py``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># to be called after sorted_components</span>
        <span class="kn">from</span> <span class="nn">sympy.combinatorics.permutations</span> <span class="kn">import</span> <span class="n">_af_new</span>
<span class="c">#         types = list(set(self._types))</span>
<span class="c">#         types.sort(key = lambda x: x._name)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ext_rank</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">vpos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="n">vpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">_rank</span>
        <span class="c"># ordered indices: first the free indices, ordered by types</span>
        <span class="c"># then the dummy indices, ordered by types and contravariant before</span>
        <span class="c"># covariant</span>
        <span class="c"># g[position in tensor] = position in ordered indices</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">vpos</span><span class="p">[</span><span class="n">cpos</span><span class="p">]</span> <span class="o">+</span> <span class="n">ipos</span>
            <span class="n">g</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">)</span>
        <span class="n">dummies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">msym</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ipos1</span><span class="p">,</span> <span class="n">ipos2</span><span class="p">,</span> <span class="n">cpos1</span><span class="p">,</span> <span class="n">cpos2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dum</span><span class="p">:</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="n">vpos</span><span class="p">[</span><span class="n">cpos1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ipos1</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="n">vpos</span><span class="p">[</span><span class="n">cpos2</span><span class="p">]</span> <span class="o">+</span> <span class="n">ipos2</span>
            <span class="n">g</span><span class="p">[</span><span class="n">pos1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">g</span><span class="p">[</span><span class="n">pos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">typ</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">cpos1</span><span class="p">]</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="n">ipos1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">typ</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
                    <span class="n">dummies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">typ</span>
                <span class="n">msym</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">typ</span><span class="o">.</span><span class="n">metric_antisym</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
            <span class="n">dummies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">numtyp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">prev</span><span class="p">:</span>
                <span class="n">numtyp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">t</span>
                <span class="n">numtyp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">prev</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numtyp</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span><span class="o">.</span><span class="n">_comm</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">h</span><span class="o">.</span><span class="n">_comm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">comm</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">_comm</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">comm</span> <span class="o">=</span> <span class="n">TensorManager</span><span class="o">.</span><span class="n">get_comm</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">_comm</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">_comm</span><span class="p">)</span>
            <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h</span><span class="o">.</span><span class="n">_symmetry</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">_symmetry</span><span class="o">.</span><span class="n">generators</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">comm</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">_af_new</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">dummies</span><span class="p">,</span> <span class="n">msym</span><span class="p">,</span> <span class="n">v</span>

    <span class="k">def</span> <span class="nf">perm2tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">canon_bp</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``TIDS`` instance corresponding to the permutation ``g``</span>

<span class="sd">        ``g``  permutation corresponding to the tensor in the representation</span>
<span class="sd">        used in canonicalization</span>

<span class="sd">        ``canon_bp``   if True, then ``g`` is the permutation</span>
<span class="sd">        corresponding to the canonical form of the tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vpos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="n">vpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">_rank</span>
        <span class="n">sorted_free</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">]</span>
        <span class="n">sorted_free</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">nfree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_free</span><span class="p">)</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ext_rank</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="mi">4</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="n">rank</span> <span class="o">-</span> <span class="n">nfree</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)]</span>
        <span class="n">free</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">icomp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">vpos</span><span class="p">:</span>
                <span class="n">icomp</span> <span class="o">+=</span> <span class="n">vpos</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">pos0</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">ipos</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">pos0</span>
            <span class="n">gi</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">gi</span> <span class="o">&lt;</span> <span class="n">nfree</span><span class="p">:</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">sorted_free</span><span class="p">[</span><span class="n">gi</span><span class="p">]</span>
                <span class="n">free</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">icomp</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">gi</span> <span class="o">-</span> <span class="n">nfree</span>
                <span class="n">idum</span><span class="p">,</span> <span class="n">cov</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cov</span><span class="p">:</span>
                    <span class="n">dum</span><span class="p">[</span><span class="n">idum</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipos</span>
                    <span class="n">dum</span><span class="p">[</span><span class="n">idum</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">icomp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dum</span><span class="p">[</span><span class="n">idum</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipos</span>
                    <span class="n">dum</span><span class="p">[</span><span class="n">idum</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">icomp</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dum</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">TIDS</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">VTIDS</span><span class="p">(</span><span class="n">TIDS</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DEPRECATED: DO NOT USE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;TIDS&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">VTIDS</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;TIDS&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">parse_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: DO NOT USE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">parse_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;TIDS&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">correct_signature_from_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: DO NOT USE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_correct_signature_from_indices</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="n">useinstead</span><span class="o">=</span><span class="s">&quot;TIDS&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">flip_index_by_metric</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: DO NOT USE.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_flip_index_by_metric</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_TensorDataLazyEvaluator</span><span class="p">(</span><span class="n">CantSympify</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    EXPERIMENTAL: do not rely on this class, it may change without deprecation</span>
<span class="sd">    warnings in future versions of SymPy.</span>

<span class="sd">    This object contains the logic to associate components data to a tensor</span>
<span class="sd">    expression. Components data are set via the ``.data`` property of tensor</span>
<span class="sd">    expressions, is stored inside this class as a mapping between the tensor</span>
<span class="sd">    expression and the ``ndarray``.</span>

<span class="sd">    Computations are executed lazily: whereas the tensor expressions can have</span>
<span class="sd">    contractions, tensor products, and additions, components data are not</span>
<span class="sd">    computed until they are accessed by reading the ``.data`` property</span>
<span class="sd">    associated to the tensor expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_substitutions_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">_substitutions_dict_tensmul</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dat</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dat</span>

        <span class="k">if</span> <span class="n">dat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dat</span><span class="p">[()]</span>
        <span class="k">elif</span> <span class="n">dat</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dat</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dat</span>

    <span class="k">def</span> <span class="nf">_get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve ``data`` associated with ``key``.</span>

<span class="sd">        This algorithm looks into ``self._substitutions_dict`` for all</span>
<span class="sd">        ``TensorHead`` in the ``TensExpr`` (or just ``TensorHead`` if key is a</span>
<span class="sd">        TensorHead instance). It reconstructs the components data that the</span>
<span class="sd">        tensor expression should have by performing on components data the</span>
<span class="sd">        operations that correspond to the abstract tensor operations applied.</span>

<span class="sd">        Metric tensor is handled in a different manner: it is pre-computed in</span>
<span class="sd">        ``self._substitutions_dict_tensmul``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">TensorHead</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">):</span>
            <span class="n">tensmul_list</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensmul_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tensmul_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># special case to handle metrics. Metric tensors cannot be</span>
                <span class="c"># constructed through contraction by the metric, their</span>
                <span class="c"># components show if they are a matrix or its inverse.</span>
                <span class="n">signature</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">is_up</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tensmul_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()])</span>
                <span class="n">srch</span> <span class="o">=</span> <span class="p">(</span><span class="n">tensmul_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">signature</span>
                <span class="k">if</span> <span class="n">srch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict_tensmul</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict_tensmul</span><span class="p">[</span><span class="n">srch</span><span class="p">]</span>
            <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data_tensmul_from_tensorhead</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tensmul_list</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Mixing tensors with associated components &quot;</span>\
                                 <span class="s">&quot;data with tensors without components data&quot;</span><span class="p">)</span>
            <span class="n">data_result</span><span class="p">,</span> <span class="n">tensmul_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_product_tensors</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">tensmul_list</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data_result</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="n">sumvar</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
            <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]):</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">i</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Mixing tensors with associated components &quot;</span>\
                                 <span class="s">&quot;data with tensors without components data&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">:</span>
                <span class="n">sumvar</span> <span class="o">+=</span> <span class="n">i</span>
            <span class="k">return</span> <span class="n">sumvar</span>

        <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">data_tensorhead_from_tensmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">tensmul</span><span class="p">,</span> <span class="n">tensorhead</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is used when assigning components data to a ``TensMul``</span>
<span class="sd">        object, it converts components data to a fully contravariant ndarray,</span>
<span class="sd">        which is then stored according to the ``TensorHead`` key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_signature_from_indices</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">tensmul</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(),</span>
            <span class="n">tensmul</span><span class="o">.</span><span class="n">free</span><span class="p">,</span>
            <span class="n">tensmul</span><span class="o">.</span><span class="n">dum</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">data_tensmul_from_tensorhead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tensmul</span><span class="p">,</span> <span class="n">tensorhead</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method corrects the components data to the right signature</span>
<span class="sd">        (covariant/contravariant) using the metric associated with each</span>
<span class="sd">        ``TensorIndexType``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tensorhead</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_signature_from_indices</span><span class="p">(</span>
            <span class="n">tensorhead</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="n">tensmul</span><span class="o">.</span><span class="n">get_indices</span><span class="p">(),</span>
            <span class="n">tensmul</span><span class="o">.</span><span class="n">free</span><span class="p">,</span>
            <span class="n">tensmul</span><span class="o">.</span><span class="n">dum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">data_product_tensors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_list</span><span class="p">,</span> <span class="n">tensmul_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a ``data_list``, list of ``ndarray``&#39;s and a ``tensmul_list``,</span>
<span class="sd">        list of ``TensMul`` instances, compute the resulting ``ndarray``,</span>
<span class="sd">        after tensor products and contractions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">data_mul</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Multiplies two ``ndarray`` objects, it first calls ``TIDS.mul``,</span>
<span class="sd">            then checks which indices have been contracted, and finally</span>
<span class="sd">            contraction operation on data, according to the contracted indices.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">data1</span><span class="p">,</span> <span class="n">tensmul1</span> <span class="o">=</span> <span class="n">f</span>
            <span class="n">data2</span><span class="p">,</span> <span class="n">tensmul2</span> <span class="o">=</span> <span class="n">g</span>
            <span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span> <span class="o">=</span> <span class="n">TIDS</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">tensmul1</span><span class="p">,</span> <span class="n">tensmul2</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_contract_ndarray</span><span class="p">(</span><span class="n">tensmul1</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">tensmul2</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">)</span>
            <span class="c"># TODO: do this more efficiently... maybe by just passing an index list</span>
            <span class="c"># to .data_product_tensor(...)</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">TIDS</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">data_mul</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">tensmul_list</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_assign_data_to_tensor_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot assign data to TensAdd&#39;</span><span class="p">)</span>
        <span class="c"># here it is assumed that `key` is a `TensMul` instance.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot assign data to TensMul with multiple components&#39;</span><span class="p">)</span>
        <span class="n">tensorhead</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">newdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_tensorhead_from_tensmul</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">tensorhead</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tensorhead</span><span class="p">,</span> <span class="n">newdata</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the components data of a tensor object/expression.</span>

<span class="sd">        Components data are transformed to the all-contravariant form and stored</span>
<span class="sd">        with the corresponding ``TensorHead`` object. If a ``TensorHead`` object</span>
<span class="sd">        cannot be uniquely identified, it will raise an error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">parse_data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c"># TensorHead and TensorIndexType can be assigned data directly, while</span>
        <span class="c"># TensMul must first convert data to a fully contravariant form, and</span>
        <span class="c"># assign it to its corresponding TensorHead single component.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">TensorHead</span><span class="p">,</span> <span class="n">TensorIndexType</span><span class="p">)):</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assign_data_to_tensor_expr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">TensorHead</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">indextype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">index_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">indextype</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;index type {} has no components data&quot;</span>\
                    <span class="s">&quot; associated (needed to raise/lower index)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indextype</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">indextype</span><span class="o">.</span><span class="n">dim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="n">indextype</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;wrong dimension of ndarray&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_contract_ndarray</span><span class="p">(</span><span class="n">free1</span><span class="p">,</span> <span class="n">free2</span><span class="p">,</span> <span class="n">ndarray1</span><span class="p">,</span> <span class="n">ndarray2</span><span class="p">):</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ikey</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">free1</span> <span class="o">=</span> <span class="n">free1</span><span class="p">[:]</span>
        <span class="n">free2</span> <span class="o">=</span> <span class="n">free2</span><span class="p">[:]</span>
        <span class="n">free1</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">ikey</span><span class="p">)</span>
        <span class="n">free2</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">ikey</span><span class="p">)</span>
        <span class="n">self_free</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">free1</span><span class="p">]</span>
        <span class="n">axes1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">axes2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">jpos</span><span class="p">,</span> <span class="n">jindex</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">free2</span><span class="p">):</span>
            <span class="k">if</span> <span class="o">-</span><span class="n">jindex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">self_free</span><span class="p">:</span>
                <span class="n">nidx</span> <span class="o">=</span> <span class="n">self_free</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="o">-</span><span class="n">jindex</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">axes1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nidx</span><span class="p">)</span>
            <span class="n">axes2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jpos</span><span class="p">)</span>

        <span class="n">contracted_ndarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span>
            <span class="n">ndarray1</span><span class="p">,</span>
            <span class="n">ndarray2</span><span class="p">,</span>
            <span class="p">(</span><span class="n">axes1</span><span class="p">,</span> <span class="n">axes2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">contracted_ndarray</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_tensor_mul</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">mul_function</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_contract_ndarray</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_substitutions_dict</span><span class="p">[</span><span class="n">prod</span><span class="p">]</span> <span class="o">=</span> <span class="n">mul_function</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_tensor_add</span><span class="p">(</span><span class="n">addition</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">add_function</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">data</span>

        <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_substitutions_dict</span><span class="p">[</span><span class="n">addition</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_function</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_metric_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign data to the ``metric`` tensor. The metric tensor behaves in an</span>
<span class="sd">        anomalous way when raising and lowering indices.</span>

<span class="sd">        A fully covariant metric is the inverse transpose of the fully</span>
<span class="sd">        contravariant metric (it is meant matrix inverse). If the metric is</span>
<span class="sd">        symmetric, the transpose is not necessary and mixed</span>
<span class="sd">        covariant/contravariant metrics are Kronecker deltas.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># hard assignment, data should not be added to `TensorHead` for metric:</span>
        <span class="c"># the problem with `TensorHead` is that the metric is anomalous, i.e.</span>
        <span class="c"># raising and lowering the index means considering the metric or its</span>
        <span class="c"># inverse, this is not the case for other tensors.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict_tensmul</span><span class="p">[</span><span class="n">metric</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">inverse_transpose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_transpose_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c"># in symmetric spaces, the traspose is the same as the original matrix,</span>
        <span class="c"># the full covariant metric tensor is the inverse transpose, so this</span>
        <span class="c"># code will be able to handle non-symmetric metrics.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict_tensmul</span><span class="p">[</span><span class="n">metric</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_transpose</span>
        <span class="c"># now mixed cases, these are identical to the unit matrix if the metric</span>
        <span class="c"># is symmetric.</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">invt</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">inverse_transpose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict_tensmul</span><span class="p">[</span><span class="n">metric</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">invt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_substitutions_dict_tensmul</span><span class="p">[</span><span class="n">metric</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">]</span> <span class="o">=</span> <span class="n">invt</span> <span class="o">*</span> <span class="n">m</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_flip_index_by_metric</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span>
                <span class="n">metric</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">inverse_matrix</span><span class="p">(</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">parse_data</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">inverse_transpose_matrix</span><span class="p">(</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">parse_data</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_correct_signature_from_indices</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility function to correct the values inside the components data</span>
<span class="sd">        ndarray according to whether indices are covariant or contravariant.</span>

<span class="sd">        It uses the metric matrix to lower values of covariant indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="c"># change the ndarray values according covariantness/contravariantness of the indices</span>
        <span class="c"># use the metric</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indx</span><span class="o">.</span><span class="n">is_up</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">inverse</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_flip_index_by_metric</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indx</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">indx</span><span class="o">.</span><span class="n">is_up</span> <span class="ow">and</span> <span class="n">inverse</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_flip_index_by_metric</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">,</span>
                    <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">inverse_matrix</span><span class="p">(</span><span class="n">indx</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                    <span class="n">i</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c">### perform contractions ###</span>
            <span class="n">axes1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">axes2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indx1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nd</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="o">-</span><span class="n">indx1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">axes1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
                <span class="n">axes2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes1</span><span class="p">,</span> <span class="n">axes2</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">ax2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sort_data_axes</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="n">old</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">old_free</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old</span><span class="o">.</span><span class="n">free</span><span class="p">]</span>
        <span class="n">new_free</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new</span><span class="o">.</span><span class="n">free</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_free</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_free</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">old_free</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_free</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">old_free</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">old_free</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_free</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">old_free</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">new_data</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_rearrange_tensmul_parts</span><span class="p">(</span><span class="n">new_tensmul</span><span class="p">,</span> <span class="n">old_tensmul</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">sorted_compo</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_sort_data_axes</span><span class="p">(</span><span class="n">old_tensmul</span><span class="p">,</span> <span class="n">new_tensmul</span><span class="p">)</span>

        <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">_substitutions_dict</span><span class="p">[</span><span class="n">new_tensmul</span><span class="p">]</span> <span class="o">=</span> <span class="n">sorted_compo</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">parse_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform ``data`` to a numpy ndarray. The parameter ``data`` may</span>
<span class="sd">        contain data in various formats, e.g. nested lists, sympy ``Matrix``,</span>
<span class="sd">        and so on.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import _TensorDataLazyEvaluator</span>
<span class="sd">        &gt;&gt;&gt; _TensorDataLazyEvaluator.parse_data([1, 3, -6, 12])</span>
<span class="sd">        [1 3 -6 12]</span>

<span class="sd">        &gt;&gt;&gt; _TensorDataLazyEvaluator.parse_data([[1, 2], [4, 7]])</span>
<span class="sd">        [[1 2]</span>
<span class="sd">         [4 7]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;__call__&#39;</span><span class="p">):</span>

                <span class="k">def</span> <span class="nf">fromfunction_sympify</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">sympify</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="o">*</span><span class="n">x</span><span class="p">))</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">(</span><span class="n">fromfunction_sympify</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vsympify</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">sympify</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">vsympify</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">data</span>

<span class="n">_tensor_data_substitution_dict</span> <span class="o">=</span> <span class="n">_TensorDataLazyEvaluator</span><span class="p">()</span>


<div class="viewcode-block" id="_TensorManager"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor._TensorManager">[docs]</a><span class="k">class</span> <span class="nc">_TensorManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to manage tensor properties.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    Tensors belong to tensor commutation groups; each group has a label</span>
<span class="sd">    ``comm``; there are predefined labels:</span>

<span class="sd">    ``0``   tensors commuting with any other tensor</span>

<span class="sd">    ``1``   tensors anticommuting among themselves</span>

<span class="sd">    ``2``   tensors not commuting, apart with those with ``comm=0``</span>

<span class="sd">    Other groups can be defined using ``set_comm``; tensors in those</span>
<span class="sd">    groups commute with those with ``comm=0``; by default they</span>
<span class="sd">    do not commute with any other group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm_init</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_comm_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm_i2symbol</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span>

<div class="viewcode-block" id="_TensorManager.comm_symbols2i"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor._TensorManager.comm_symbols2i">[docs]</a>    <span class="k">def</span> <span class="nf">comm_symbols2i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the commutation group number corresponding to ``i``</span>

<span class="sd">        ``i`` can be a symbol or a number or a string</span>

<span class="sd">        If ``i`` is not already defined its commutation group number</span>
<span class="sd">        is set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm_i2symbol</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="_TensorManager.comm_i2symbol"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor._TensorManager.comm_i2symbol">[docs]</a>    <span class="k">def</span> <span class="nf">comm_i2symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the symbol corresponding to the commutation group number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm_i2symbol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="_TensorManager.set_comm"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor._TensorManager.set_comm">[docs]</a>    <span class="k">def</span> <span class="nf">set_comm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set the commutation parameter ``c`` for commutation groups ``i, j``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        i, j : symbols representing commutation groups</span>

<span class="sd">        c  :  group commutation number</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        ``i, j`` can be symbols, strings or numbers,</span>
<span class="sd">        apart from ``0, 1`` and ``2`` which are reserved respectively</span>
<span class="sd">        for commuting, anticommuting tensors and tensors not commuting</span>
<span class="sd">        with any other group apart with the commuting tensors.</span>
<span class="sd">        For the remaining cases, use this method to set the commutation rules;</span>
<span class="sd">        by default ``c=None``.</span>

<span class="sd">        The group commutation number ``c`` is assigned in correspondence</span>
<span class="sd">        to the group commutation symbols; it can be</span>

<span class="sd">        0        commuting</span>

<span class="sd">        1        anticommuting</span>

<span class="sd">        None     no commutation property</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        ``G`` and ``GH`` do not commute with themselves and commute with</span>
<span class="sd">        each other; A is commuting.</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead, TensorManager</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;)</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4 = tensor_indices(&#39;i0:5&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A = tensorhead(&#39;A&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; G = tensorhead(&#39;G&#39;, [Lorentz], [[1]], &#39;Gcomm&#39;)</span>
<span class="sd">        &gt;&gt;&gt; GH = tensorhead(&#39;GH&#39;, [Lorentz], [[1]], &#39;GHcomm&#39;)</span>
<span class="sd">        &gt;&gt;&gt; TensorManager.set_comm(&#39;Gcomm&#39;, &#39;GHcomm&#39;, 0)</span>
<span class="sd">        &gt;&gt;&gt; (GH(i1)*G(i0)).canon_bp()</span>
<span class="sd">        G(i0)*GH(i1)</span>
<span class="sd">        &gt;&gt;&gt; (G(i1)*G(i0)).canon_bp()</span>
<span class="sd">        G(i1)*G(i0)</span>
<span class="sd">        &gt;&gt;&gt; (G(i1)*A(i0)).canon_bp()</span>
<span class="sd">        A(i0)*G(i1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;`c` can assume only the values 0, 1 or None&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm_i2symbol</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comm_i2symbol</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">ni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">nj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm_symbols2i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">nj</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="n">nj</span><span class="p">][</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
</div>
<div class="viewcode-block" id="_TensorManager.set_comms"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor._TensorManager.set_comms">[docs]</a>    <span class="k">def</span> <span class="nf">set_comms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set the commutation group numbers ``c`` for symbols ``i, j``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        args : sequence of ``(i, j, c)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_comm</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="_TensorManager.get_comm"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor._TensorManager.get_comm">[docs]</a>    <span class="k">def</span> <span class="nf">get_comm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the commutation parameter for commutation group numbers ``i, j``</span>

<span class="sd">        see ``_TensorManager.set_comm``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">None</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="_TensorManager.clear"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor._TensorManager.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the TensorManager.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comm_init</span><span class="p">()</span>

</div></div>
<span class="n">TensorManager</span> <span class="o">=</span> <span class="n">_TensorManager</span><span class="p">()</span>


<span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensorIndexType"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndexType">[docs]</a><span class="k">class</span> <span class="nc">TensorIndexType</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A TensorIndexType is characterized by its name and its metric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    name : name of the tensor type</span>

<span class="sd">    metric : metric symmetry or metric object or ``None``</span>


<span class="sd">    dim : dimension, it can be a symbol or an integer or ``None``</span>

<span class="sd">    eps_dim : dimension of the epsilon tensor</span>

<span class="sd">    dummy_fmt : name of the head of dummy indices</span>

<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    ``name``</span>
<span class="sd">    ``metric_name`` : it is &#39;metric&#39; or metric.name</span>
<span class="sd">    ``metric_antisym``</span>
<span class="sd">    ``metric`` : the metric tensor</span>
<span class="sd">    ``delta`` : ``Kronecker delta``</span>
<span class="sd">    ``epsilon`` : the ``Levi-Civita epsilon`` tensor</span>
<span class="sd">    ``dim``</span>
<span class="sd">    ``dim_eps``</span>
<span class="sd">    ``dummy_fmt``</span>
<span class="sd">    ``data`` : a property to add ``ndarray`` values, to work in a specified basis.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    The ``metric`` parameter can be:</span>
<span class="sd">    ``metric = False`` symmetric metric (in Riemannian geometry)</span>

<span class="sd">    ``metric = True`` antisymmetric metric (for spinor calculus)</span>

<span class="sd">    ``metric = None``  there is no metric</span>

<span class="sd">    ``metric`` can be an object having ``name`` and ``antisym`` attributes.</span>


<span class="sd">    If there is a metric the metric is used to raise and lower indices.</span>

<span class="sd">    In the case of antisymmetric metric, the following raising and</span>
<span class="sd">    lowering conventions will be adopted:</span>

<span class="sd">    ``psi(a) = g(a, b)*psi(-b); chi(-a) = chi(b)*g(-b, -a)``</span>

<span class="sd">    ``g(-a, b) = delta(-a, b); g(b, -a) = -delta(a, -b)``</span>

<span class="sd">    where ``delta(-a, b) = delta(b, -a)`` is the ``Kronecker delta``</span>
<span class="sd">    (see ``TensorIndex`` for the conventions on indices).</span>

<span class="sd">    If there is no metric it is not possible to raise or lower indices;</span>
<span class="sd">    e.g. the index of the defining representation of ``SU(N)``</span>
<span class="sd">    is &#39;covariant&#39; and the conjugate representation is</span>
<span class="sd">    &#39;contravariant&#39;; for ``N &gt; 2`` they are linearly independent.</span>

<span class="sd">    ``eps_dim`` is by default equal to ``dim``, if the latter is an integer;</span>
<span class="sd">    else it can be assigned (for use in naive dimensional regularization);</span>
<span class="sd">    if ``eps_dim`` is not an integer ``epsilon`` is ``None``.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Lorentz.metric</span>
<span class="sd">    metric(Lorentz,Lorentz)</span>

<span class="sd">    Examples with metric components data added, this means it is working on a</span>
<span class="sd">    fixed basis:</span>

<span class="sd">    &gt;&gt;&gt; Lorentz.data = [1, -1, -1, -1]</span>
<span class="sd">    &gt;&gt;&gt; Lorentz</span>
<span class="sd">    TensorIndexType(Lorentz, 0)</span>
<span class="sd">    &gt;&gt;&gt; Lorentz.data</span>
<span class="sd">    [[1 0 0 0]</span>
<span class="sd">    [0 -1 0 0]</span>
<span class="sd">    [0 0 -1 0]</span>
<span class="sd">    [0 0 0 -1]]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">eps_dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">dummy_fmt</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="k">if</span> <span class="n">metric</span> <span class="k">else</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dummy_fmt</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_dummy_fmt</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%%</span><span class="s">d&#39;</span> <span class="o">%</span> <span class="n">obj</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_dummy_fmt</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%%</span><span class="s">d&#39;</span> <span class="o">%</span> <span class="n">dummy_fmt</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">metric_antisym</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">metric_name</span> <span class="o">=</span> <span class="s">&#39;metric&#39;</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">metric_antisym</span> <span class="o">=</span> <span class="n">metric</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metric_name</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">name</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">metric_antisym</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">antisym</span>
            <span class="n">sym2</span> <span class="o">=</span> <span class="n">TensorSymmetry</span><span class="p">(</span><span class="n">get_symmetric_group_sgs</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">metric_antisym</span><span class="p">))</span>
            <span class="n">S2</span> <span class="o">=</span> <span class="n">TensorType</span><span class="p">([</span><span class="n">obj</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">sym2</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">S2</span><span class="p">(</span><span class="n">metric_name</span><span class="p">)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">_matrix_behavior</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_delta</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_kronecker_delta</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_eps_dim</span> <span class="o">=</span> <span class="n">eps_dim</span> <span class="k">if</span> <span class="n">eps_dim</span> <span class="k">else</span> <span class="n">dim</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_epsilon</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_epsilon</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_autogenerated</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">auto_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_auto_right&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_right</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="s">&quot;auto_right&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_right</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">auto_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_auto_left&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_left</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="s">&quot;auto_left&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_left</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">auto_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_auto_index&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_index</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="s">&quot;auto_index&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="nd">@data.setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">parse_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;data have to be of rank 1 (diagonal metric) or 2.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">nda_dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">nda_dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dimension mismatch&quot;</span><span class="p">)</span>

            <span class="n">dim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">newndarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="n">newndarray</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">newndarray</span>
        <span class="n">dim1</span><span class="p">,</span> <span class="n">dim2</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">dim1</span> <span class="o">!=</span> <span class="n">dim2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Non-square matrix tensor.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">dim1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Dimension mismatch&quot;</span><span class="p">)</span>
        <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">_tensor_data_substitution_dict</span><span class="o">.</span><span class="n">add_metric_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kronecker_delta</span><span class="p">()</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="s">&#39;i1&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="s">&#39;i2&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">delta</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="o">-</span><span class="n">i2</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">_TensorDataLazyEvaluator</span><span class="o">.</span><span class="n">parse_data</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">dim1</span><span class="p">))</span>

    <span class="nd">@data.deleter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delta</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">eps_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eps_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">epsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_epsilon</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dummy_fmt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dummy_fmt</span>

    <span class="k">def</span> <span class="nf">get_kronecker_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">sym2</span> <span class="o">=</span> <span class="n">TensorSymmetry</span><span class="p">(</span><span class="n">get_symmetric_group_sgs</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">S2</span> <span class="o">=</span> <span class="n">TensorType</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">sym2</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">S2</span><span class="p">(</span><span class="s">&#39;KD&#39;</span><span class="p">)</span>
        <span class="n">delta</span><span class="o">.</span><span class="n">_matrix_behavior</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">get_epsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eps_dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">TensorSymmetry</span><span class="p">(</span><span class="n">get_symmetric_group_sgs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eps_dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Sdim</span> <span class="o">=</span> <span class="n">TensorType</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_eps_dim</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="n">Sdim</span><span class="p">(</span><span class="s">&#39;Eps&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">epsilon</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="n">__repr__</span> <span class="o">=</span> <span class="n">__str__</span>

    <span class="k">def</span> <span class="nf">_components_data_full_destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL: do not rely on this API method.</span>

<span class="sd">        This destroys components data associated to the ``TensorIndexType``, if</span>
<span class="sd">        any, specifically:</span>

<span class="sd">        * metric tensor data</span>
<span class="sd">        * Kronecker tensor data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">delete_tensmul_data</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="o">.</span><span class="n">_substitutions_dict_tensmul</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="o">.</span><span class="n">_substitutions_dict_tensmul</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c"># delete metric data:</span>
        <span class="n">delete_tensmul_data</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
        <span class="n">delete_tensmul_data</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>
        <span class="n">delete_tensmul_data</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">))</span>
        <span class="n">delete_tensmul_data</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>

        <span class="c"># delete delta tensor data:</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kronecker_delta</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">delta</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="n">delta</span><span class="p">]</span>

</div>
<span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensorIndex"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensorIndex">[docs]</a><span class="k">class</span> <span class="nc">TensorIndex</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents an abstract tensor index.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    name : name of the index, or ``True`` if you want it to be automatically assigned</span>
<span class="sd">    tensortype : ``TensorIndexType`` of the index</span>
<span class="sd">    is_up :  flag for contravariant index</span>

<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    ``name``</span>
<span class="sd">    ``tensortype``</span>
<span class="sd">    ``is_up``</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    Tensor indices are contracted with the Einstein summation convention.</span>

<span class="sd">    An index can be in contravariant or in covariant form; in the latter</span>
<span class="sd">    case it is represented prepending a ``-`` to the index name.</span>

<span class="sd">    Dummy indices have a name with head given by ``tensortype._dummy_fmt``</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, TensorIndex, TensorSymmetry, TensorType, get_symmetric_group_sgs</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; i = TensorIndex(&#39;i&#39;, Lorentz); i</span>
<span class="sd">    i</span>
<span class="sd">    &gt;&gt;&gt; sym1 = TensorSymmetry(*get_symmetric_group_sgs(1))</span>
<span class="sd">    &gt;&gt;&gt; S1 = TensorType([Lorentz], sym1)</span>
<span class="sd">    &gt;&gt;&gt; A, B = S1(&#39;A,B&#39;)</span>
<span class="sd">    &gt;&gt;&gt; A(i)*B(-i)</span>
<span class="sd">    A(L_0)*B(-L_0)</span>

<span class="sd">    If you want the index name to be automatically assigned, just put ``True``</span>
<span class="sd">    in the ``name`` field, it will be generated using the reserved character</span>
<span class="sd">    ``_`` in front of its name, in order to avoid conflicts with possible</span>
<span class="sd">    existing indices:</span>

<span class="sd">    &gt;&gt;&gt; i0 = TensorIndex(True, Lorentz)</span>
<span class="sd">    &gt;&gt;&gt; i0</span>
<span class="sd">    _i0</span>
<span class="sd">    &gt;&gt;&gt; i1 = TensorIndex(True, Lorentz)</span>
<span class="sd">    &gt;&gt;&gt; i1</span>
<span class="sd">    _i1</span>
<span class="sd">    &gt;&gt;&gt; A(i0)*B(-i1)</span>
<span class="sd">    A(_i0)*B(-_i1)</span>
<span class="sd">    &gt;&gt;&gt; A(i0)*B(-i0)</span>
<span class="sd">    A(L_0)*B(-L_0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tensortype</span><span class="p">,</span> <span class="n">is_up</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">name_symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="n">name_symbol</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;_i{0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tensortype</span><span class="o">.</span><span class="n">_autogenerated</span><span class="p">))</span>
            <span class="n">name_symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">tensortype</span><span class="o">.</span><span class="n">_autogenerated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_symbol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid name&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name_symbol</span><span class="p">,</span> <span class="n">tensortype</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span> <span class="k">if</span> <span class="n">is_up</span> <span class="k">else</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_tensortype</span> <span class="o">=</span> <span class="n">tensortype</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_up</span> <span class="o">=</span> <span class="n">is_up</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tensortype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensortype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_up</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_up</span>

    <span class="k">def</span> <span class="nf">_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_up</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="s">&#39;-</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">,</span>
                <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_up</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">t1</span>
</div>
<div class="viewcode-block" id="tensor_indices"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.tensor_indices">[docs]</a><span class="k">def</span> <span class="nf">tensor_indices</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns list of tensor indices given their names and their types</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    s : string of comma separated names of indices</span>

<span class="sd">    typ : list of ``TensorIndexType`` of the indices</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a, b, c, d = tensor_indices(&#39;a,b,c,d&#39;, Lorentz)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expecting a string&#39;</span><span class="p">)</span>

    <span class="n">tilist</span> <span class="o">=</span> <span class="p">[</span><span class="n">TensorIndex</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">typ</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tilist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tilist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tilist</span>

</div>
<span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensorSymmetry"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensorSymmetry">[docs]</a><span class="k">class</span> <span class="nc">TensorSymmetry</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Monoterm symmetry of a tensor</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    bsgs : tuple ``(base, sgs)`` BSGS of the symmetry of the tensor</span>

<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    ``base`` : base of the BSGS</span>
<span class="sd">    ``generators`` : generators of the BSGS</span>
<span class="sd">    ``rank`` : rank of the tensor</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    A tensor can have an arbitrary monoterm symmetry provided by its BSGS.</span>
<span class="sd">    Multiterm symmetries, like the cyclic symmetry of the Riemann tensor,</span>
<span class="sd">    are not covered.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.combinatorics.tensor_can.get_symmetric_group_sgs</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    Define a symmetric tensor</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, TensorSymmetry, TensorType, get_symmetric_group_sgs</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sym2 = TensorSymmetry(get_symmetric_group_sgs(2))</span>
<span class="sd">    &gt;&gt;&gt; S2 = TensorType([Lorentz]*2, sym2)</span>
<span class="sd">    &gt;&gt;&gt; V = S2(&#39;V&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">generators</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">base</span><span class="p">,</span> <span class="n">generators</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;bsgs required, either two separate parameters or one tuple&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">base</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">generators</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">):</span>
            <span class="n">generators</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">generators</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">generators</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">generators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span>

</div>
<div class="viewcode-block" id="tensorsymmetry"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.tensorsymmetry">[docs]</a><span class="k">def</span> <span class="nf">tensorsymmetry</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a ``TensorSymmetry`` object.</span>

<span class="sd">    One can represent a tensor with any monoterm slot symmetry group</span>
<span class="sd">    using a BSGS.</span>

<span class="sd">    ``args`` can be a BSGS</span>
<span class="sd">    ``args[0]``    base</span>
<span class="sd">    ``args[1]``    sgs</span>

<span class="sd">    Usually tensors are in (direct products of) representations</span>
<span class="sd">    of the symmetric group;</span>
<span class="sd">    ``args`` can be a list of lists representing the shapes of Young tableaux</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    For instance:</span>
<span class="sd">    ``[[1]]``       vector</span>
<span class="sd">    ``[[1]*n]``     symmetric tensor of rank ``n``</span>
<span class="sd">    ``[[n]]``       antisymmetric tensor of rank ``n``</span>
<span class="sd">    ``[[2, 2]]``    monoterm slot symmetry of the Riemann tensor</span>
<span class="sd">    ``[[1],[1]]``   vector*vector</span>
<span class="sd">    ``[[2],[1],[1]`` (antisymmetric tensor)*vector*vector</span>

<span class="sd">    Notice that with the shape ``[2, 2]`` we associate only the monoterm</span>
<span class="sd">    symmetries of the Riemann tensor; this is an abuse of notation,</span>
<span class="sd">    since the shape ``[2, 2]`` corresponds usually to the irreducible</span>
<span class="sd">    representation characterized by the monoterm symmetries and by the</span>
<span class="sd">    cyclic symmetry.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    Symmetric tensor using a Young tableau</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, TensorType, tensorsymmetry</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sym2 = tensorsymmetry([1, 1])</span>
<span class="sd">    &gt;&gt;&gt; S2 = TensorType([Lorentz]*2, sym2)</span>
<span class="sd">    &gt;&gt;&gt; V = S2(&#39;V&#39;)</span>

<span class="sd">    Symmetric tensor using a ``BSGS`` (base, strong generator set)</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorSymmetry, get_symmetric_group_sgs</span>
<span class="sd">    &gt;&gt;&gt; sym2 = tensorsymmetry(*get_symmetric_group_sgs(2))</span>
<span class="sd">    &gt;&gt;&gt; S2 = TensorType([Lorentz]*2, sym2)</span>
<span class="sd">    &gt;&gt;&gt; V = S2(&#39;V&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sympy.combinatorics</span> <span class="kn">import</span> <span class="n">Permutation</span>

    <span class="k">def</span> <span class="nf">tableau2bsgs</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># antisymmetric vector</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">bsgs</span> <span class="o">=</span> <span class="n">get_symmetric_group_sgs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">):</span>
                <span class="c"># symmetric vector</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">bsgs</span> <span class="o">=</span> <span class="n">get_symmetric_group_sgs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="n">bsgs</span> <span class="o">=</span> <span class="n">riemann_bsgs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">return</span> <span class="n">bsgs</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TensorSymmetry</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(),</span> <span class="n">Tuple</span><span class="p">(</span><span class="n">Permutation</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">Permutation</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensorSymmetry</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">sgs</span> <span class="o">=</span> <span class="n">tableau2bsgs</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">basex</span><span class="p">,</span> <span class="n">sgsx</span> <span class="o">=</span> <span class="n">tableau2bsgs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">base</span><span class="p">,</span> <span class="n">sgs</span> <span class="o">=</span> <span class="n">bsgs_direct_product</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">sgs</span><span class="p">,</span> <span class="n">basex</span><span class="p">,</span> <span class="n">sgsx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TensorSymmetry</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">sgs</span><span class="p">))</span>

</div>
<span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensorType"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensorType">[docs]</a><span class="k">class</span> <span class="nc">TensorType</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class of tensor types.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    index_types : list of ``TensorIndexType`` of the tensor indices</span>
<span class="sd">    symmetry : ``TensorSymmetry`` of the tensor</span>

<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    ``index_types``</span>
<span class="sd">    ``symmetry``</span>
<span class="sd">    ``types`` : list of ``TensorIndexType`` without repetitions</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    Define a symmetric tensor</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensorsymmetry, TensorType</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sym2 = tensorsymmetry([1, 1])</span>
<span class="sd">    &gt;&gt;&gt; S2 = TensorType([Lorentz]*2, sym2)</span>
<span class="sd">    &gt;&gt;&gt; V = S2(&#39;V&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">index_types</span><span class="p">,</span> <span class="n">symmetry</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">symmetry</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_types</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">index_types</span><span class="p">),</span> <span class="n">symmetry</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;TensorType(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">matrix_behavior</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a TensorHead object or a list of TensorHead objects.</span>

<span class="sd">        ``s``  name or string of names</span>

<span class="sd">        ``comm``: commutation group number</span>
<span class="sd">        see ``_TensorManager.set_comm``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        Define symmetric tensors ``V``, ``W`` and ``G``, respectively</span>
<span class="sd">        commuting, anticommuting and with no commutation symmetry</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorsymmetry, TensorType, canon_bp</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a, b = tensor_indices(&#39;a,b&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; sym2 = tensorsymmetry([1]*2)</span>
<span class="sd">        &gt;&gt;&gt; S2 = TensorType([Lorentz]*2, sym2)</span>
<span class="sd">        &gt;&gt;&gt; V = S2(&#39;V&#39;)</span>
<span class="sd">        &gt;&gt;&gt; W = S2(&#39;W&#39;, 1)</span>
<span class="sd">        &gt;&gt;&gt; G = S2(&#39;G&#39;, 2)</span>
<span class="sd">        &gt;&gt;&gt; canon_bp(V(a, b)*V(-b, -a))</span>
<span class="sd">        V(L_0, L_1)*V(-L_0, -L_1)</span>
<span class="sd">        &gt;&gt;&gt; canon_bp(W(a, b)*W(-b, -a))</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expecting a string&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">TensorHead</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">matrix_behavior</span><span class="o">=</span><span class="n">matrix_behavior</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">TensorHead</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">matrix_behavior</span><span class="o">=</span><span class="n">matrix_behavior</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

</div>
<span class="k">def</span> <span class="nf">tensorhead</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">sym</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">matrix_behavior</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function generating tensorhead(s).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    name : name or sequence of names (as in ``symbol``)</span>

<span class="sd">    typ :  index types</span>

<span class="sd">    sym :  same as ``*args`` in ``tensorsymmetry``</span>

<span class="sd">    comm : commutation group number</span>
<span class="sd">    see ``_TensorManager.set_comm``</span>


<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a, b = tensor_indices(&#39;a,b&#39;, Lorentz)</span>
<span class="sd">    &gt;&gt;&gt; A = tensorhead(&#39;A&#39;, [Lorentz]*2, [[1]*2])</span>
<span class="sd">    &gt;&gt;&gt; A(a, -b)</span>
<span class="sd">    A(a, -b)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">tensorsymmetry</span><span class="p">(</span><span class="o">*</span><span class="n">sym</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">TensorType</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">sym</span><span class="p">)</span>
    <span class="n">th</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">comm</span><span class="p">,</span> <span class="n">matrix_behavior</span><span class="o">=</span><span class="n">matrix_behavior</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">th</span>


<span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensorHead"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensorHead">[docs]</a><span class="k">class</span> <span class="nc">TensorHead</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Tensor head of the tensor</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    name : name of the tensor</span>

<span class="sd">    typ : list of TensorIndexType</span>

<span class="sd">    comm : commutation group number</span>

<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    ``name``</span>
<span class="sd">    ``index_types``</span>
<span class="sd">    ``rank``</span>
<span class="sd">    ``types``  :  equal to ``typ.types``</span>
<span class="sd">    ``symmetry`` : equal to ``typ.symmetry``</span>
<span class="sd">    ``comm`` : commutation group</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    A ``TensorHead`` belongs to a commutation group, defined by a</span>
<span class="sd">    symbol on number ``comm`` (see ``_TensorManager.set_comm``);</span>
<span class="sd">    tensors in a commutation group have the same commutation properties;</span>
<span class="sd">    by default ``comm`` is ``0``, the group of the commuting tensors.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensorsymmetry, TensorType</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sym2 = tensorsymmetry([1], [1])</span>
<span class="sd">    &gt;&gt;&gt; S2 = TensorType([Lorentz]*2, sym2)</span>
<span class="sd">    &gt;&gt;&gt; A = S2(&#39;A&#39;)</span>

<span class="sd">    Examples with ndarray values, the components data assigned to the</span>
<span class="sd">    ``TensorHead`` object are assumed to be in a fully-contravariant</span>
<span class="sd">    representation. In case it is necessary to assign components data which</span>
<span class="sd">    represents the values of a non-fully covariant tensor, see the other</span>
<span class="sd">    examples.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">    &gt;&gt;&gt; Lorentz.data = [1, -1, -1, -1]</span>
<span class="sd">    &gt;&gt;&gt; i0, i1 = tensor_indices(&#39;i0:2&#39;, Lorentz)</span>
<span class="sd">    &gt;&gt;&gt; A.data = [[j+2*i for j in range(4)] for i in range(4)]</span>

<span class="sd">    in order to retrieve data, it is also necessary to specify abstract indices</span>
<span class="sd">    enclosed by round brackets, then numerical indices inside square brackets.</span>

<span class="sd">    &gt;&gt;&gt; A(i0, i1)[0, 0]</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; A(i0, i1)[2, 3] == 3+2*2</span>
<span class="sd">    True</span>

<span class="sd">    Notice that square brackets create a valued tensor expression instance:</span>

<span class="sd">    &gt;&gt;&gt; A(i0, i1)</span>
<span class="sd">    A(i0, i1)</span>

<span class="sd">    To view the data, just type:</span>

<span class="sd">    &gt;&gt;&gt; A.data</span>
<span class="sd">    [[0 1 2 3]</span>
<span class="sd">     [2 3 4 5]</span>
<span class="sd">     [4 5 6 7]</span>
<span class="sd">     [6 7 8 9]]</span>

<span class="sd">    Turning to a tensor expression, covariant indices get the corresponding</span>
<span class="sd">    components data corrected by the metric:</span>

<span class="sd">    &gt;&gt;&gt; A(i0, -i1).data</span>
<span class="sd">    [[0 -1 -2 -3]</span>
<span class="sd">     [2 -3 -4 -5]</span>
<span class="sd">     [4 -5 -6 -7]</span>
<span class="sd">     [6 -7 -8 -9]]</span>

<span class="sd">    &gt;&gt;&gt; A(-i0, -i1).data</span>
<span class="sd">    [[0 -1 -2 -3]</span>
<span class="sd">     [-2 3 4 5]</span>
<span class="sd">     [-4 5 6 7]</span>
<span class="sd">     [-6 7 8 9]]</span>

<span class="sd">    while if all indices are contravariant, the ``ndarray`` remains the same</span>

<span class="sd">    &gt;&gt;&gt; A(i0, i1).data</span>
<span class="sd">     [[0 1 2 3]</span>
<span class="sd">     [2 3 4 5]</span>
<span class="sd">     [4 5 6 7]</span>
<span class="sd">     [6 7 8 9]]</span>

<span class="sd">    When all indices are contracted and components data are added to the tensor,</span>
<span class="sd">    accessing the data will return a scalar, no numpy object. In fact, numpy</span>
<span class="sd">    ndarrays are dropped to scalars if they contain only one element.</span>

<span class="sd">    &gt;&gt;&gt; A(i0, -i0)</span>
<span class="sd">    A(L_0, -L_0)</span>
<span class="sd">    &gt;&gt;&gt; A(i0, -i0).data</span>
<span class="sd">    -18</span>

<span class="sd">    It is also possible to assign components data to an indexed tensor, i.e. a</span>
<span class="sd">    tensor with specified covariant and contravariant components. In this</span>
<span class="sd">    example, the covariant components data of the Electromagnetic tensor are</span>
<span class="sd">    injected into `A`:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; Ex, Ey, Ez, Bx, By, Bz = symbols(&#39;E_x E_y E_z B_x B_y B_z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; c = symbols(&#39;c&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; A(-i0, -i1).data = [</span>
<span class="sd">    ... [0, Ex/c, Ey/c, Ez/c],</span>
<span class="sd">    ... [-Ex/c, 0, -Bz, By],</span>
<span class="sd">    ... [-Ey/c, Bz, 0, -Bx],</span>
<span class="sd">    ... [-Ez/c, -By, Bx, 0]]</span>

<span class="sd">    Now it is possible to retrieve the contravariant form of the Electromagnetic</span>
<span class="sd">    tensor:</span>

<span class="sd">    &gt;&gt;&gt; A(i0, i1).data</span>
<span class="sd">    [[0 -E_x/c -E_y/c -E_z/c]</span>
<span class="sd">     [E_x/c 0 -B_z B_y]</span>
<span class="sd">     [E_y/c B_z 0 -B_x]</span>
<span class="sd">     [E_z/c -B_y B_x 0]]</span>

<span class="sd">    and the mixed contravariant-covariant form:</span>

<span class="sd">    &gt;&gt;&gt; A(i0, -i1).data</span>
<span class="sd">    [[0 E_x/c E_y/c E_z/c]</span>
<span class="sd">     [E_x/c 0 B_z -B_y]</span>
<span class="sd">     [E_y/c -B_z 0 B_x]</span>
<span class="sd">     [E_z/c B_y -B_x 0]]</span>

<span class="sd">    To convert the numpy&#39;s ndarray to a sympy matrix, just cast:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import Matrix</span>
<span class="sd">    &gt;&gt;&gt; Matrix(A.data)</span>
<span class="sd">    Matrix([</span>
<span class="sd">    [    0, -E_x/c, -E_y/c, -E_z/c],</span>
<span class="sd">    [E_x/c,      0,   -B_z,    B_y],</span>
<span class="sd">    [E_y/c,    B_z,      0,   -B_x],</span>
<span class="sd">    [E_z/c,   -B_y,    B_x,      0]])</span>

<span class="sd">    Still notice, in this last example, that accessing components data from a</span>
<span class="sd">    tensor without specifying the indices is equivalent to assume that all</span>
<span class="sd">    indices are contravariant.</span>

<span class="sd">    It is also possible to store symbolic components data inside a tensor, for</span>
<span class="sd">    example, define a four-momentum-like tensor:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import symbols</span>
<span class="sd">    &gt;&gt;&gt; P = tensorhead(&#39;P&#39;, [Lorentz], [[1]])</span>
<span class="sd">    &gt;&gt;&gt; E, px, py, pz = symbols(&#39;E p_x p_y p_z&#39;, positive=True)</span>
<span class="sd">    &gt;&gt;&gt; P.data = [E, px, py, pz]</span>

<span class="sd">    The contravariant and covariant components are, respectively:</span>

<span class="sd">    &gt;&gt;&gt; P(i0).data</span>
<span class="sd">    [E p_x p_y p_z]</span>
<span class="sd">    &gt;&gt;&gt; P(-i0).data</span>
<span class="sd">    [E -p_x -p_y -p_z]</span>

<span class="sd">    The contraction of a 1-index tensor by itself is usually indicated by a</span>
<span class="sd">    power by two:</span>

<span class="sd">    &gt;&gt;&gt; P(i0)**2</span>
<span class="sd">    E**2 - p_x**2 - p_y**2 - p_z**2</span>

<span class="sd">    As the power by two is clearly identical to `P_\mu P^\mu`, it is possible to</span>
<span class="sd">    simply contract the ``TensorHead`` object, without specifying the indices</span>

<span class="sd">    &gt;&gt;&gt; P**2</span>
<span class="sd">    E**2 - p_x**2 - p_y**2 - p_z**2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">matrix_behavior</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">name_symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="n">name_symbol</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;invalid name&quot;</span><span class="p">)</span>

        <span class="n">comm2i</span> <span class="o">=</span> <span class="n">TensorManager</span><span class="o">.</span><span class="n">comm_symbols2i</span><span class="p">(</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name_symbol</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">_matrix_behavior</span> <span class="o">=</span> <span class="n">matrix_behavior</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">index_types</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_types</span> <span class="o">=</span> <span class="n">typ</span><span class="o">.</span><span class="n">types</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_symmetry</span> <span class="o">=</span> <span class="n">typ</span><span class="o">.</span><span class="n">symmetry</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_comm</span> <span class="o">=</span> <span class="n">comm2i</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">symmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symmetry</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">typ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comm</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index_types</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">index_types</span><span class="p">)</span>

<div class="viewcode-block" id="TensorHead.commutes_with"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensorHead.commutes_with">[docs]</a>    <span class="k">def</span> <span class="nf">commutes_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ``0`` if ``self`` and ``other`` commute, ``1`` if they anticommute.</span>

<span class="sd">        Returns ``None`` if ``self`` and ``other`` neither commute nor anticommute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">TensorManager</span><span class="o">.</span><span class="n">get_comm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comm</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_comm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
</div>
    <span class="k">def</span> <span class="nf">_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_check_auto_matrix_indices_in_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">matrix_behavior_kinds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_behavior</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;wrong number of indices&#39;</span><span class="p">)</span>

            <span class="c"># _matrix_behavior is True, so take the last one or two missing</span>
            <span class="c"># indices as auto-matrix indices:</span>
            <span class="n">ldiff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ldiff</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;wrong number of indices&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ldiff</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">mat_ind</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ldiff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mat_ind</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span>
            <span class="n">not_equal</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_equal</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">mat_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mat_ind</span><span class="p">:</span>
                <span class="n">not_equal</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">indices</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">True</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">TensorIndex</span><span class="p">):</span>
                    <span class="n">not_equal</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">_tensortype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">not_equal</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">not_equal</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">mat_ind</span><span class="p">:</span>
                <span class="n">eltyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="n">el</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">eltyp</span> <span class="ow">in</span> <span class="n">matrix_behavior_kinds</span><span class="p">:</span>
                    <span class="n">elind</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">auto_right</span>
                    <span class="n">matrix_behavior_kinds</span><span class="p">[</span><span class="n">eltyp</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elind</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">elind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">auto_left</span>
                    <span class="n">matrix_behavior_kinds</span><span class="p">[</span><span class="n">eltyp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">elind</span><span class="p">]</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[:</span><span class="n">el</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">elind</span><span class="p">,)</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">el</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">indices</span><span class="p">,</span> <span class="n">matrix_behavior_kinds</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tensor with indices.</span>

<span class="sd">        There is a special behavior in case of indices denoted by ``True``,</span>
<span class="sd">        they are considered auto-matrix indices, their slots are automatically</span>
<span class="sd">        filled, and confer to the tensor the behavior of a matrix or vector</span>
<span class="sd">        upon multiplication with another tensor containing auto-matrix indices</span>
<span class="sd">        of the same ``TensorIndexType``. This means indices get summed over the</span>
<span class="sd">        same way as in matrix multiplication. For matrix behavior, define two</span>
<span class="sd">        auto-matrix indices, for vector behavior define just one.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a, b = tensor_indices(&#39;a,b&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A = tensorhead(&#39;A&#39;, [Lorentz]*2, [[1]*2])</span>
<span class="sd">        &gt;&gt;&gt; t = A(a, -b)</span>
<span class="sd">        &gt;&gt;&gt; t</span>
<span class="sd">        A(a, -b)</span>

<span class="sd">        To use the auto-matrix index behavior, just put a ``True`` on the</span>
<span class="sd">        desired index position.</span>

<span class="sd">        &gt;&gt;&gt; r = A(True, True)</span>
<span class="sd">        &gt;&gt;&gt; r</span>
<span class="sd">        A(auto_left, -auto_right)</span>

<span class="sd">        Here ``auto_left`` and ``auto_right`` are automatically generated</span>
<span class="sd">        tensor indices, they are only two for every ``TensorIndexType`` and</span>
<span class="sd">        can be assigned to just one or two indices of a given type.</span>

<span class="sd">        Auto-matrix indices can be assigned many times in a tensor, if indices</span>
<span class="sd">        are of different ``TensorIndexType``</span>

<span class="sd">        &gt;&gt;&gt; Spinor = TensorIndexType(&#39;Spinor&#39;, dummy_fmt=&#39;S&#39;)</span>
<span class="sd">        &gt;&gt;&gt; B = tensorhead(&#39;B&#39;, [Lorentz, Lorentz, Spinor, Spinor], [[1]*4])</span>
<span class="sd">        &gt;&gt;&gt; s = B(True, True, True, True)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        B(auto_left, -auto_right, auto_left, -auto_right)</span>

<span class="sd">        Here, ``auto_left`` and ``auto_right`` are repeated twice, but they are</span>
<span class="sd">        not the same indices, as they refer to different ``TensorIndexType``s.</span>

<span class="sd">        Auto-matrix indices are automatically contracted upon multiplication,</span>

<span class="sd">        &gt;&gt;&gt; r*s</span>
<span class="sd">        A(auto_left, -L_0)*B(L_0, -auto_right, auto_left, -auto_right)</span>

<span class="sd">        The multiplication algorithm has found an ``auto_right`` index in ``A``</span>
<span class="sd">        and an ``auto_left`` index in ``B`` referring to the same</span>
<span class="sd">        ``TensorIndexType`` (``Lorentz``), so they have been contracted.</span>

<span class="sd">        Auto-matrix indices can be accessed from the ``TensorIndexType``:</span>

<span class="sd">        &gt;&gt;&gt; Lorentz.auto_right</span>
<span class="sd">        auto_right</span>
<span class="sd">        &gt;&gt;&gt; Lorentz.auto_left</span>
<span class="sd">        auto_left</span>

<span class="sd">        There is a special case, in which the ``True`` parameter is not needed</span>
<span class="sd">        to declare an auto-matrix index, i.e. when the matrix behavior has been</span>
<span class="sd">        declared upon ``TensorHead`` construction, in that case the last one or</span>
<span class="sd">        two tensor indices may be omitted, so that they automatically become</span>
<span class="sd">        auto-matrix indices:</span>

<span class="sd">        &gt;&gt;&gt; C = tensorhead(&#39;C&#39;, [Lorentz, Lorentz], [[1]*2], matrix_behavior=True)</span>
<span class="sd">        &gt;&gt;&gt; C()</span>
<span class="sd">        C(auto_left, -auto_right)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">indices</span><span class="p">,</span> <span class="n">matrix_behavior_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_auto_matrix_indices_in_call</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="n">tids</span> <span class="o">=</span> <span class="n">TIDS</span><span class="o">.</span><span class="n">from_components_and_indices</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

        <span class="n">tmul</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="n">tids</span><span class="p">)</span>
        <span class="n">tmul</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span> <span class="o">=</span> <span class="n">matrix_behavior_kinds</span>

        <span class="k">return</span> <span class="n">tmul</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No power on abstract tensors.&quot;</span><span class="p">)</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="n">marray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
            <span class="n">marray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">marray</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">marray</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">pow2</span> <span class="o">=</span> <span class="n">marray</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">pow2</span> <span class="o">**</span> <span class="p">(</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="nd">@data.setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="nd">@data.deleter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_components_data_full_destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL: do not rely on this API method.</span>

<span class="sd">        Destroy components data associated to the ``TensorHead`` object, this</span>
<span class="sd">        checks for attached components data, and destroys components data too.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># do not garbage collect Kronecker tensor (it should be done by</span>
        <span class="c"># ``TensorIndexType`` garbage collection)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&quot;KD&quot;</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># the data attached to a tensor must be deleted only by the TensorHead</span>
        <span class="c"># destructor. If the TensorHead is deleted, it means that there are no</span>
        <span class="c"># more instances of that tensor anywhere.</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

</div>
<span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensExpr"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensExpr">[docs]</a><span class="k">class</span> <span class="nc">TensExpr</span><span class="p">(</span><span class="n">Basic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for tensor expressions</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    A tensor expression is an expression formed by tensors;</span>
<span class="sd">    currently the sums of tensors are distributed.</span>

<span class="sd">    A ``TensExpr`` can be a ``TensAdd`` or a ``TensMul``.</span>

<span class="sd">    ``TensAdd`` objects are put in canonical form using the Butler-Portugal</span>
<span class="sd">    algorithm for canonicalization under monoterm symmetries.</span>

<span class="sd">    ``TensMul`` objects are formed by products of component tensors,</span>
<span class="sd">    and include a coefficient, which is a SymPy expression.</span>


<span class="sd">    In the internal representation contracted indices are represented</span>
<span class="sd">    by ``(ipos1, ipos2, icomp1, icomp2)``, where ``icomp1`` is the position</span>
<span class="sd">    of the component tensor with contravariant index, ``ipos1`` is the</span>
<span class="sd">    slot which the index occupies in that component tensor.</span>

<span class="sd">    Contracted indices are therefore nameless in the internal representation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_op_priority</span> <span class="o">=</span> <span class="mf">11.0</span>
    <span class="n">is_commutative</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">S</span><span class="o">.</span><span class="n">NegativeOne</span>

    <span class="k">def</span> <span class="nf">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No power without ndarray data.&quot;</span><span class="p">)</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">)</span>
        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span>

        <span class="n">marray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">free</span><span class="p">:</span>
            <span class="n">marray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span>
                <span class="n">marray</span><span class="p">,</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span>
                    <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">marray</span><span class="p">,</span>
                    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">pow2</span> <span class="o">=</span> <span class="n">marray</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">pow2</span> <span class="o">**</span> <span class="p">(</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>
    <span class="n">__rtruediv__</span> <span class="o">=</span> <span class="n">__rdiv__</span>

    <span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensExpr.get_matrix"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensExpr.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ndarray components data as a matrix, if components data are</span>
<span class="sd">        available and ndarray dimension does not exceed 2.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensorsymmetry, TensorType</span>
<span class="sd">        &gt;&gt;&gt; from sympy import ones</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sym2 = tensorsymmetry([1]*2)</span>
<span class="sd">        &gt;&gt;&gt; S2 = TensorType([Lorentz]*2, sym2)</span>
<span class="sd">        &gt;&gt;&gt; A = S2(&#39;A&#39;)</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz.data = [1, -1, -1, -1]</span>
<span class="sd">        &gt;&gt;&gt; i0, i1 = tensor_indices(&#39;i0:2&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A.data = [[j+2*i for j in range(4)] for i in range(4)]</span>
<span class="sd">        &gt;&gt;&gt; A(i0, i1).get_matrix()</span>
<span class="sd">         Matrix([</span>
<span class="sd">        [0, 1, 2, 3],</span>
<span class="sd">        [2, 3, 4, 5],</span>
<span class="sd">        [4, 5, 6, 7],</span>
<span class="sd">        [6, 7, 8, 9]])</span>

<span class="sd">        It is possible to perform usual operation on matrices, such as the</span>
<span class="sd">        matrix multiplication:</span>

<span class="sd">        &gt;&gt;&gt; A(i0, i1).get_matrix()*ones(4, 1)</span>
<span class="sd">        Matrix([</span>
<span class="sd">        [ 6],</span>
<span class="sd">        [14],</span>
<span class="sd">        [22],</span>
<span class="sd">        [30]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">mat_list</span> <span class="o">=</span> <span class="p">[]</span> <span class="o">*</span> <span class="n">rows</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                    <span class="n">mat_list</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
                        <span class="n">mat_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mat_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">rows</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
                    <span class="n">mat_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Matrix</span><span class="p">(</span><span class="n">mat_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s">&quot;missing multidimensional reduction to matrix.&quot;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_eval_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">measure</span><span class="p">):</span>
        <span class="c"># this is a way to simplify a tensor expression.</span>

        <span class="c"># This part walks for all `TensorHead`s appearing in the tensor expr</span>
        <span class="c"># and looks for `simplify_this_type`, to specifically act on a subexpr</span>
        <span class="c"># containing one type of `TensorHead` instance only:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">&#39;simplify_this_type&#39;</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">simplify_this_type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c"># TODO: missing feature, perform metric contraction.</span>
        <span class="k">return</span> <span class="n">expr</span>

</div>
<span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensAdd"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensAdd">[docs]</a><span class="k">class</span> <span class="nc">TensAdd</span><span class="p">(</span><span class="n">TensExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum of tensors</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    free_args : list of the free indices</span>

<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    ``args`` : tuple of addends</span>
<span class="sd">    ``rank`` : rank of the tensor</span>
<span class="sd">    ``free_args`` : list of the free indices in sorted order</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    Sum of more than one tensor are put automatically in canonical form.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensorhead, tensor_indices</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a, b = tensor_indices(&#39;a,b&#39;, Lorentz)</span>
<span class="sd">    &gt;&gt;&gt; p, q = tensorhead(&#39;p,q&#39;, [Lorentz], [[1]])</span>
<span class="sd">    &gt;&gt;&gt; t = p(a) + q(a); t</span>
<span class="sd">    p(a) + q(a)</span>
<span class="sd">    &gt;&gt;&gt; t(b)</span>
<span class="sd">    p(b) + q(b)</span>

<span class="sd">    Examples with components data added to the tensor expression:</span>

<span class="sd">    &gt;&gt;&gt; from sympy import eye</span>
<span class="sd">    &gt;&gt;&gt; Lorentz.data = [1, -1, -1, -1]</span>
<span class="sd">    &gt;&gt;&gt; a, b = tensor_indices(&#39;a, b&#39;, Lorentz)</span>
<span class="sd">    &gt;&gt;&gt; p.data = [2, 3, -2, 7]</span>
<span class="sd">    &gt;&gt;&gt; q.data = [2, 3, -2, 7]</span>
<span class="sd">    &gt;&gt;&gt; t = p(a) + q(a); t</span>
<span class="sd">    p(a) + q(a)</span>
<span class="sd">    &gt;&gt;&gt; t(b)</span>
<span class="sd">    p(b) + q(b)</span>

<span class="sd">    The following are: 2**2 - 3**2 - 2**2 - 7**2 ==&gt; -58</span>

<span class="sd">    &gt;&gt;&gt; (p(a)*p(-a)).data</span>
<span class="sd">    -58</span>
<span class="sd">    &gt;&gt;&gt; p(a)**2</span>
<span class="sd">    -58</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">sympify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="o">.</span><span class="n">_tensAdd_flatten</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c"># replace auto-matrix indices so that they are the same in all addends</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="o">.</span><span class="n">_tensAdd_check_automatrix</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c"># now check that all addends have the same indices:</span>
        <span class="n">TensAdd</span><span class="o">.</span><span class="n">_tensAdd_check</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c"># if TensAdd has only 1 TensMul element in its `args`:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TensMul</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="c"># canonicalize all TensMul</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">canon_bp</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="n">x</span><span class="p">]</span>

        <span class="c"># if there are no more args (i.e. have cancelled out),</span>
        <span class="c"># just return zero:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>

        <span class="c"># collect canonicalized terms</span>
        <span class="n">args</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dum</span><span class="p">))</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="o">.</span><span class="n">_tensAdd_collect_terms</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="c"># it there is only a component tensor return it</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">args</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_tensAdd_flatten</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># flatten TensAdd, coerce terms which are not tensors to tensors</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="n">args1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
                        <span class="n">args1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">args1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">args1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args1</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">_coeff</span><span class="p">]</span>
            <span class="n">args2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">)]</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="n">args2</span><span class="p">),</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[])</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">t1</span><span class="p">]</span> <span class="o">+</span> <span class="n">args1</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
                <span class="n">a</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">_coeff</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_tensAdd_check_automatrix</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># check that all automatrix indices are the same.</span>

        <span class="c"># if there are no addends, just return.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>

        <span class="c"># @type auto_left_types: set</span>
        <span class="n">auto_left_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="n">auto_right_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
        <span class="n">args_auto_left_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args_auto_right_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">arg_auto_left_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="n">arg_auto_right_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">get_indices</span><span class="p">():</span>
                <span class="c"># @type index: TensorIndex</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="o">-</span><span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">auto_left</span><span class="p">):</span>
                    <span class="n">auto_left_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">)</span>
                    <span class="n">arg_auto_left_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">auto_right</span><span class="p">,</span> <span class="o">-</span><span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">auto_right</span><span class="p">):</span>
                    <span class="n">auto_right_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">)</span>
                    <span class="n">arg_auto_right_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">)</span>
            <span class="n">args_auto_left_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg_auto_left_types</span><span class="p">)</span>
            <span class="n">args_auto_right_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg_auto_right_types</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">aas_left</span><span class="p">,</span> <span class="n">aas_right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">args_auto_left_types</span><span class="p">,</span> <span class="n">args_auto_right_types</span><span class="p">):</span>
            <span class="n">missing_left</span> <span class="o">=</span> <span class="n">auto_left_types</span> <span class="o">-</span> <span class="n">aas_left</span>
            <span class="n">missing_right</span> <span class="o">=</span> <span class="n">auto_right_types</span> <span class="o">-</span> <span class="n">aas_right</span>
            <span class="n">missing_intersection</span> <span class="o">=</span> <span class="n">missing_left</span> <span class="o">&amp;</span> <span class="n">missing_right</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">missing_intersection</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">j</span><span class="o">.</span><span class="n">delta</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">auto_left</span><span class="p">,</span> <span class="o">-</span><span class="n">j</span><span class="o">.</span><span class="n">auto_right</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">missing_left</span> <span class="o">!=</span> <span class="n">missing_right</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;cannot determine how to add auto-matrix indices on some args&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">args</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_tensAdd_check</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># check that all addends have the same free indices</span>
        <span class="n">indices0</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>
        <span class="n">list_indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">free</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">indices0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_indices</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;all tensors must have the same indices&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_tensAdd_collect_terms</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="c"># collect TensMul terms differing at most by their coefficient</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">prev_coeff</span> <span class="o">=</span> <span class="n">prev</span><span class="o">.</span><span class="n">_coeff</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c"># if x and prev have the same tensor, update the coeff of prev</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">components</span> <span class="o">==</span> <span class="n">prev</span><span class="o">.</span><span class="n">components</span> \
                    <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">free</span> <span class="o">==</span> <span class="n">prev</span><span class="o">.</span><span class="n">free</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">dum</span> <span class="o">==</span> <span class="n">prev</span><span class="o">.</span><span class="n">dum</span><span class="p">:</span>
                <span class="n">prev_coeff</span> <span class="o">=</span> <span class="n">prev_coeff</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">_coeff</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">op</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># x and prev are different; if not changed, prev has not</span>
                <span class="c"># been updated; store it</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">changed</span><span class="p">:</span>
                    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># get a tensor from prev with coeff=prev_coeff and store it</span>
                    <span class="k">if</span> <span class="n">prev_coeff</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">prev_coeff</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">components</span><span class="p">,</span>
                            <span class="n">prev</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">dum</span><span class="p">)</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="c"># move x to prev</span>
                <span class="n">op</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">pprev</span><span class="p">,</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="p">,</span> <span class="n">x</span>
                <span class="n">pprev_coeff</span><span class="p">,</span> <span class="n">prev_coeff</span> <span class="o">=</span> <span class="n">prev_coeff</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">_coeff</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># if the case op=0 prev was not stored; store it now</span>
        <span class="c"># in the case op=1 x was not stored; store it now (as prev)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">prev_coeff</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">prev_coeff</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">prev</span><span class="o">.</span><span class="n">dum</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rank</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">free_args</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns tensor with ordered free indices replaced by ``indices``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        indices</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; D = Symbol(&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dim=D, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4 = tensor_indices(&#39;i0:5&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p,q&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; g = Lorentz.metric</span>
<span class="sd">        &gt;&gt;&gt; t = p(i0)*p(i1) + g(i0,i1)*q(i2)*q(-i2)</span>
<span class="sd">        &gt;&gt;&gt; t(i0,i2)</span>
<span class="sd">        metric(i0, i2)*q(L_0)*q(-L_0) + p(i0)*p(i2)</span>
<span class="sd">        &gt;&gt;&gt; t(i0,i1) - t(i1,i0)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">free_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_args</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_tensortype</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_tensortype</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">free_args</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;incompatible types&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="o">==</span> <span class="n">free_args</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">index_tuples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free_args</span><span class="p">,</span> <span class="n">indices</span><span class="p">))</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">TensMul</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="o">*</span><span class="n">index_tuples</span><span class="p">)</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="TensAdd.canon_bp"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensAdd.canon_bp">[docs]</a>    <span class="k">def</span> <span class="nf">canon_bp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        canonicalize using the Butler-Portugal algorithm for canonicalization</span>
<span class="sd">        under monoterm symmetries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">canon_bp</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">rank</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">other</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">other</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot divide by a tensor&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">other</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot divide by a tensor&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>
    <span class="n">__truerdiv__</span> <span class="o">=</span> <span class="n">__rdiv__</span>

    <span class="k">def</span> <span class="nf">contract_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">contract_delta</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">canon_bp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<div class="viewcode-block" id="TensAdd.contract_metric"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensAdd.contract_metric">[docs]</a>    <span class="k">def</span> <span class="nf">contract_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise or lower indices with the metric ``g``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        g :  metric</span>

<span class="sd">        contract_all : if True, eliminate all ``g`` which are contracted</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        see the ``TensorIndexType`` docstring for the contraction conventions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">canon_bp</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TensAdd.fun_eval"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensAdd.fun_eval">[docs]</a>    <span class="k">def</span> <span class="nf">fun_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">index_tuples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tensor with free indices substituted according to ``index_tuples``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        index_types : list of tuples ``(old_index, new_index)``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; i, j, k, l = tensor_indices(&#39;i,j,k,l&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A, B = tensorhead(&#39;A,B&#39;, [Lorentz]*2, [[1]*2])</span>
<span class="sd">        &gt;&gt;&gt; t = A(i, k)*B(-k, -j) + A(i, -j)</span>
<span class="sd">        &gt;&gt;&gt; t.fun_eval((i, k),(-j, l))</span>
<span class="sd">        A(k, L_0)*B(l, -L_0) + A(k, l)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>
        <span class="n">args1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="o">*</span><span class="n">index_tuples</span><span class="p">)</span>
            <span class="n">args1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">args1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="TensAdd.substitute_indices"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensAdd.substitute_indices">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">index_tuples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tensor with free indices substituted according to ``index_tuples``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        index_types : list of tuples ``(old_index, new_index)``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; i, j, k, l = tensor_indices(&#39;i,j,k,l&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A, B = tensorhead(&#39;A,B&#39;, [Lorentz]*2, [[1]*2])</span>
<span class="sd">        &gt;&gt;&gt; t = A(i, k)*B(-k, -j); t</span>
<span class="sd">        A(i, L_0)*B(-L_0, -j)</span>
<span class="sd">        &gt;&gt;&gt; t.substitute_indices((i,j), (j, k))</span>
<span class="sd">        A(j, L_0)*B(-L_0, -k)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>
        <span class="n">args1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">(</span><span class="o">*</span><span class="n">index_tuples</span><span class="p">)</span>
            <span class="n">args1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">args1</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;+ -&#39;</span><span class="p">,</span> <span class="s">&#39;- &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="TensAdd.from_TIDS_list"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensAdd.from_TIDS_list">[docs]</a>    <span class="k">def</span> <span class="nf">from_TIDS_list</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of coefficients and a list of ``TIDS`` objects, construct</span>
<span class="sd">        a ``TensAdd`` instance, equivalent to the one that would result from</span>
<span class="sd">        creating single instances of ``TensMul`` and then adding them.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead, TensAdd</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; i, j = tensor_indices(&#39;i,j&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A, B = tensorhead(&#39;A,B&#39;, [Lorentz]*2, [[1]*2])</span>
<span class="sd">        &gt;&gt;&gt; eA = 3*A(i, j)</span>
<span class="sd">        &gt;&gt;&gt; eB = 2*B(j, i)</span>
<span class="sd">        &gt;&gt;&gt; t1 = eA._tids</span>
<span class="sd">        &gt;&gt;&gt; t2 = eB._tids</span>
<span class="sd">        &gt;&gt;&gt; c1 = eA.coeff</span>
<span class="sd">        &gt;&gt;&gt; c2 = eB.coeff</span>
<span class="sd">        &gt;&gt;&gt; TensAdd.from_TIDS_list([c1, c2], [t1, t2])</span>
<span class="sd">        2*B(i, j) + 3*A(i, j)</span>

<span class="sd">        If the coefficient parameter is a scalar, then it will be applied</span>
<span class="sd">        as a coefficient on all ``TIDS`` objects.</span>

<span class="sd">        &gt;&gt;&gt; TensAdd.from_TIDS_list(4, [t1, t2])</span>
<span class="sd">        4*A(i, j) + 4*B(i, j)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">)):</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="p">[</span><span class="n">coeff</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tids_list</span><span class="p">)</span>
        <span class="n">tensmul_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids_list</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">tensmul_list</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="nd">@data.setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c"># TODO: check data compatibility with properties of tensor.</span>
        <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="nd">@data.deleter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No iteration on abstract tensors&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

</div>
<span class="nd">@doctest_depends_on</span><span class="p">(</span><span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;numpy&#39;</span><span class="p">,))</span>
<div class="viewcode-block" id="TensMul"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul">[docs]</a><span class="k">class</span> <span class="nc">TensMul</span><span class="p">(</span><span class="n">TensExpr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Product of tensors</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    coeff : SymPy coefficient of the tensor</span>
<span class="sd">    args</span>

<span class="sd">    Attributes</span>
<span class="sd">    ==========</span>

<span class="sd">    ``components`` : list of ``TensorHead`` of the component tensors</span>
<span class="sd">    ``types`` : list of nonrepeated ``TensorIndexType``</span>
<span class="sd">    ``free`` : list of ``(ind, ipos, icomp)``, see Notes</span>
<span class="sd">    ``dum`` : list of ``(ipos1, ipos2, icomp1, icomp2)``, see Notes</span>
<span class="sd">    ``ext_rank`` : rank of the tensor counting the dummy indices</span>
<span class="sd">    ``rank`` : rank of the tensor</span>
<span class="sd">    ``coeff`` : SymPy coefficient of the tensor</span>
<span class="sd">    ``free_args`` : list of the free indices in sorted order</span>
<span class="sd">    ``is_canon_bp`` : ``True`` if the tensor in in canonical form</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    ``args[0]``   list of ``TensorHead`` of the component tensors.</span>

<span class="sd">    ``args[1]``   list of ``(ind, ipos, icomp)``</span>
<span class="sd">    where ``ind`` is a free index, ``ipos`` is the slot position</span>
<span class="sd">    of ``ind`` in the ``icomp``-th component tensor.</span>

<span class="sd">    ``args[2]`` list of tuples representing dummy indices.</span>
<span class="sd">    ``(ipos1, ipos2, icomp1, icomp2)`` indicates that the contravariant</span>
<span class="sd">    dummy index is the ``ipos1``-th slot position in the ``icomp1``-th</span>
<span class="sd">    component tensor; the corresponding covariant index is</span>
<span class="sd">    in the ``ipos2`` slot position in the ``icomp2``-th component tensor.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">tids</span> <span class="o">=</span> <span class="n">TIDS</span><span class="o">.</span><span class="n">from_components_and_indices</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tids</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">components</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">components</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">to_indices</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;wrong construction&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">TensorIndex</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;i should be of type TensorIndex&quot;</span><span class="p">)</span>

        <span class="n">t_components</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">components</span><span class="p">)</span>
        <span class="n">t_indices</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">Basic</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">t_components</span><span class="p">,</span> <span class="n">t_indices</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tids</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_types</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">_types</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_tids</span> <span class="o">=</span> <span class="n">tids</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_ext_rank</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">dum</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">=</span> <span class="n">coeff</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_is_canon_bp</span> <span class="o">=</span> <span class="n">kw_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;is_canon_bp&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_data</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="n">tids</span> <span class="o">=</span> <span class="n">TIDS</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensMul</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">components</span><span class="p">[:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">free</span><span class="p">[:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">dum</span><span class="p">[:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types</span><span class="p">[:]</span>

    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">def</span> <span class="nf">_get_compar_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">canon_bp</span><span class="p">()</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">_coeff</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">components</span><span class="p">),</span> \
                    <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">free</span><span class="p">)),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">dum</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="k">return</span> <span class="n">_get_compar_comp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">_get_compar_comp</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="TensMul.get_indices"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul.get_indices">[docs]</a>    <span class="k">def</span> <span class="nf">get_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of indices of the tensor</span>

<span class="sd">        The indices are listed in the order in which they appear in the</span>
<span class="sd">        component tensors.</span>
<span class="sd">        The dummy indices are given a name which does not collide with</span>
<span class="sd">        the names of the free indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m0, m1, m2 = tensor_indices(&#39;m0,m1,m2&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; g = Lorentz.metric</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p,q&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; t = p(m1)*g(m0,m2)</span>
<span class="sd">        &gt;&gt;&gt; t.get_indices()</span>
<span class="sd">        [m1, m0, m2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_ext_rank</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">vpos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="n">vpos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">_rank</span>
        <span class="n">cdt</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c"># if the free indices have names with dummy_fmt, start with an</span>
        <span class="c"># index higher than those for the dummy indices</span>
        <span class="c"># to avoid name collisions</span>
        <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indx</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">indx</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">_dummy_fmt</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]:</span>
                <span class="n">cdt</span><span class="p">[</span><span class="n">indx</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cdt</span><span class="p">[</span><span class="n">indx</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">indx</span><span class="o">.</span><span class="n">_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">vpos</span><span class="p">[</span><span class="n">cpos</span><span class="p">]</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="n">ipos</span><span class="p">]</span> <span class="o">=</span> <span class="n">indx</span>
        <span class="k">for</span> <span class="n">ipos1</span><span class="p">,</span> <span class="n">ipos2</span><span class="p">,</span> <span class="n">cpos1</span><span class="p">,</span> <span class="n">cpos2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dum</span><span class="p">:</span>
            <span class="n">start1</span> <span class="o">=</span> <span class="n">vpos</span><span class="p">[</span><span class="n">cpos1</span><span class="p">]</span>
            <span class="n">start2</span> <span class="o">=</span> <span class="n">vpos</span><span class="p">[</span><span class="n">cpos2</span><span class="p">]</span>
            <span class="n">typ1</span> <span class="o">=</span> <span class="n">components</span><span class="p">[</span><span class="n">cpos1</span><span class="p">]</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="n">ipos1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">typ1</span> <span class="o">==</span> <span class="n">components</span><span class="p">[</span><span class="n">cpos2</span><span class="p">]</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="n">ipos2</span><span class="p">]</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="n">typ1</span><span class="o">.</span><span class="n">_dummy_fmt</span>
            <span class="n">nd</span> <span class="o">=</span> <span class="n">cdt</span><span class="p">[</span><span class="n">typ1</span><span class="p">]</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">start1</span> <span class="o">+</span> <span class="n">ipos1</span><span class="p">]</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="n">nd</span><span class="p">,</span> <span class="n">typ1</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">start2</span> <span class="o">+</span> <span class="n">ipos2</span><span class="p">]</span> <span class="o">=</span> <span class="n">TensorIndex</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="n">nd</span><span class="p">,</span> <span class="n">typ1</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
            <span class="n">cdt</span><span class="p">[</span><span class="n">typ1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">indices</span>
</div>
<div class="viewcode-block" id="TensMul.split"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of tensors, whose product is ``self``</span>

<span class="sd">        Dummy indices contracted among different tensor components</span>
<span class="sd">        become free indices with the same name as the one used to</span>
<span class="sd">        represent the dummy indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a, b, c, d = tensor_indices(&#39;a,b,c,d&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A, B = tensorhead(&#39;A,B&#39;, [Lorentz]*2, [[1]*2])</span>
<span class="sd">        &gt;&gt;&gt; t = A(a,b)*B(-b,c)</span>
<span class="sd">        &gt;&gt;&gt; t</span>
<span class="sd">        A(a, L_0)*B(-L_0, c)</span>
<span class="sd">        &gt;&gt;&gt; t.split()</span>
<span class="sd">        [A(a, L_0), B(-L_0, c)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">components</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[])]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">_rank</span><span class="p">])</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">_rank</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">dum</span><span class="p">,</span> <span class="n">is_canon_bp</span><span class="o">=</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_is_canon_bp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">-</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply two tensors using Einstein summation convention.</span>

<span class="sd">        If the two tensors have an index in common, one contravariant</span>
<span class="sd">        and the other covariant, in their product the indices are summed</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m0, m1, m2 = tensor_indices(&#39;m0,m1,m2&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; g = Lorentz.metric</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p,q&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; t1 = p(m0)</span>
<span class="sd">        &gt;&gt;&gt; t2 = q(-m0)</span>
<span class="sd">        &gt;&gt;&gt; t1*t2</span>
<span class="sd">        p(L_0)*q(-L_0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="o">*</span><span class="n">other</span>
            <span class="n">tmul</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="p">,</span> <span class="n">is_canon_bp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_canon_bp</span><span class="p">)</span>
            <span class="n">tmul</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span>
            <span class="k">return</span> <span class="n">tmul</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensAdd</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">*</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>

        <span class="n">matrix_behavior_kinds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">self_matrix_behavior_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span>
        <span class="n">other_matrix_behavior_kinds</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">self_matrix_behavior_kinds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">other_matrix_behavior_kinds</span><span class="p">:</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">other_matrix_behavior_kinds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">matrix_behavior_kinds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">auto_index</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">_tensortype</span><span class="o">.</span><span class="n">auto_index</span>
                    <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">auto_index</span><span class="p">))</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">auto_index</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">matrix_behavior_kinds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">matrix_behavior_kinds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">matrix_behavior_kinds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">v1</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">other_matrix_behavior_kinds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">self_matrix_behavior_kinds</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">matrix_behavior_kinds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">v2</span>

        <span class="n">new_tids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">_tids</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">_coeff</span>
        <span class="n">tmul</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">new_tids</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tmul</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
            <span class="n">tmul</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span> <span class="o">=</span> <span class="n">matrix_behavior_kinds</span>

        <span class="k">return</span> <span class="n">tmul</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">other</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span>
        <span class="n">tmul</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="p">)</span>
        <span class="n">tmul</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span>
        <span class="k">return</span> <span class="n">tmul</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">sympify</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot divide by a tensor&#39;</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="o">/</span><span class="n">other</span>
        <span class="n">tmul</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="p">,</span> <span class="n">is_canon_bp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_canon_bp</span><span class="p">)</span>
        <span class="n">tmul</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span>
        <span class="k">return</span> <span class="n">tmul</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;cannot divide by a tensor&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="n">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>
    <span class="n">__truerdiv__</span> <span class="o">=</span> <span class="n">__rdiv__</span>

<div class="viewcode-block" id="TensMul.sorted_components"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul.sorted_components">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_components</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tensor with sorted components</span>
<span class="sd">        calling the corresponding method in a ``TIDS`` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_tids</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">sorted_components</span><span class="p">()</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">new_tids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>
</div>
<div class="viewcode-block" id="TensMul.perm2tensor"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul.perm2tensor">[docs]</a>    <span class="k">def</span> <span class="nf">perm2tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">canon_bp</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tensor corresponding to the permutation ``g``</span>

<span class="sd">        For further details, see the method in ``TIDS`` with the same name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_tids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">perm2tensor</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">canon_bp</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span>
        <span class="k">if</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">new_tids</span><span class="p">,</span> <span class="n">is_canon_bp</span><span class="o">=</span><span class="n">canon_bp</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
<div class="viewcode-block" id="TensMul.canon_bp"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul.canon_bp">[docs]</a>    <span class="k">def</span> <span class="nf">canon_bp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Canonicalize using the Butler-Portugal algorithm for canonicalization</span>
<span class="sd">        under monoterm symmetries.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m0, m1, m2 = tensor_indices(&#39;m0,m1,m2&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A = tensorhead(&#39;A&#39;, [Lorentz]*2, [[2]])</span>
<span class="sd">        &gt;&gt;&gt; t = A(m0,-m1)*A(m1,-m0)</span>
<span class="sd">        &gt;&gt;&gt; t.canon_bp()</span>
<span class="sd">        -A(L_0, L_1)*A(-L_0, -L_1)</span>
<span class="sd">        &gt;&gt;&gt; t = A(m0,-m1)*A(m1,-m2)*A(m2,-m0)</span>
<span class="sd">        &gt;&gt;&gt; t.canon_bp()</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_canon_bp</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_components</span><span class="p">()</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">dummies</span><span class="p">,</span> <span class="n">msym</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_tids</span><span class="o">.</span><span class="n">canon_args</span><span class="p">()</span>
        <span class="n">can</span> <span class="o">=</span> <span class="n">canonicalize</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">dummies</span><span class="p">,</span> <span class="n">msym</span><span class="p">,</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">can</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">Zero</span>
        <span class="n">tmul</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">perm2tensor</span><span class="p">(</span><span class="n">can</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">tmul</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_behavior_kinds</span>
        <span class="k">return</span> <span class="n">tmul</span>
</div>
    <span class="k">def</span> <span class="nf">contract_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contract_metric</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>

<div class="viewcode-block" id="TensMul.contract_metric"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul.contract_metric">[docs]</a>    <span class="k">def</span> <span class="nf">contract_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise or lower indices with the metric ``g``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        g : metric</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        see the ``TensorIndexType`` docstring for the contraction conventions</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m0, m1, m2 = tensor_indices(&#39;m0,m1,m2&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; g = Lorentz.metric</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p,q&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; t = p(m0)*q(m1)*g(-m0, -m1)</span>
<span class="sd">        &gt;&gt;&gt; t.canon_bp()</span>
<span class="sd">        metric(L_0, L_1)*p(-L_0)*q(-L_1)</span>
<span class="sd">        &gt;&gt;&gt; t.contract_metric(g).canon_bp()</span>
<span class="sd">        p(L_0)*q(-L_0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">components</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span>
        <span class="n">antisym</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">metric_antisym</span>
        <span class="c">#if not any(x == g for x in components):</span>
        <span class="c">#    return self</span>
        <span class="c"># list of positions of the metric ``g``</span>
        <span class="n">gpos</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">g</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gpos</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span>
        <span class="n">tids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tids</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">dum</span><span class="p">[:]</span>
        <span class="n">free</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">free</span><span class="p">[:]</span>
        <span class="n">elim</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">gposx</span> <span class="ow">in</span> <span class="n">gpos</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gposx</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">free1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">free</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">gposx</span><span class="p">]</span>
            <span class="n">dum1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dum</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">gposx</span> <span class="ow">or</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">gposx</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dum1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">elim</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gposx</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">antisym</span><span class="p">:</span>
                    <span class="n">dum10</span><span class="p">,</span> <span class="n">dum11</span> <span class="o">=</span> <span class="n">dum1</span>
                    <span class="k">if</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">gposx</span><span class="p">:</span>
                        <span class="c"># the index with pos p0 and component c0 is contravariant</span>
                        <span class="n">c0</span> <span class="o">=</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">p0</span> <span class="o">=</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># the index with pos p0 and component c0 is covariant</span>
                        <span class="n">c0</span> <span class="o">=</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="n">p0</span> <span class="o">=</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">gposx</span><span class="p">:</span>
                        <span class="c"># the index with pos p1 and component c1 is contravariant</span>
                        <span class="n">c1</span> <span class="o">=</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># the index with pos p1 and component c1 is covariant</span>
                        <span class="n">c1</span> <span class="o">=</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dum</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dum10</span><span class="p">,</span> <span class="n">dum11</span> <span class="o">=</span> <span class="n">dum1</span>
                    <span class="c"># change the sign to bring the indices of the metric to contravariant</span>
                    <span class="c"># form; change the sign if dum10 has the metric index in position 0</span>
                    <span class="k">if</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">gposx</span><span class="p">:</span>
                        <span class="c"># the index with pos p0 and component c0 is contravariant</span>
                        <span class="n">c0</span> <span class="o">=</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">p0</span> <span class="o">=</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># the index with pos p0 and component c0 is covariant</span>
                        <span class="n">c0</span> <span class="o">=</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="n">p0</span> <span class="o">=</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">dum10</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
                    <span class="k">if</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">gposx</span><span class="p">:</span>
                        <span class="c"># the index with pos p1 and component c1 is contravariant</span>
                        <span class="n">c1</span> <span class="o">=</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># the index with pos p1 and component c1 is covariant</span>
                        <span class="n">c1</span> <span class="o">=</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">dum11</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dum</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dum1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">antisym</span><span class="p">:</span>
                    <span class="n">dp0</span><span class="p">,</span> <span class="n">dp1</span><span class="p">,</span> <span class="n">dc0</span><span class="p">,</span> <span class="n">dc1</span> <span class="o">=</span> <span class="n">dum1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">dc0</span> <span class="o">==</span> <span class="n">dc1</span><span class="p">:</span>
                        <span class="c"># g(i, -i)</span>
                        <span class="n">typ</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">typ</span><span class="o">.</span><span class="n">_dim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;dimension not assigned&#39;</span><span class="p">)</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">*</span><span class="n">typ</span><span class="o">.</span><span class="n">_dim</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># g(i0, i1)*p(-i1)</span>
                        <span class="k">if</span> <span class="n">dc0</span> <span class="o">==</span> <span class="n">gposx</span><span class="p">:</span>
                            <span class="n">p1</span> <span class="o">=</span> <span class="n">dp1</span>
                            <span class="n">c1</span> <span class="o">=</span> <span class="n">dc1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">p1</span> <span class="o">=</span> <span class="n">dp0</span>
                            <span class="n">c1</span> <span class="o">=</span> <span class="n">dc0</span>
                        <span class="n">ind</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">free1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">free</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dp0</span><span class="p">,</span> <span class="n">dp1</span><span class="p">,</span> <span class="n">dc0</span><span class="p">,</span> <span class="n">dc1</span> <span class="o">=</span> <span class="n">dum1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">dc0</span> <span class="o">==</span> <span class="n">dc1</span><span class="p">:</span>
                        <span class="c"># g(i, -i)</span>
                        <span class="n">typ</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">index_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">typ</span><span class="o">.</span><span class="n">_dim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;dimension not assigned&#39;</span><span class="p">)</span>
                        <span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">*</span><span class="n">typ</span><span class="o">.</span><span class="n">_dim</span>

                        <span class="k">if</span> <span class="n">dp0</span> <span class="o">&lt;</span> <span class="n">dp1</span><span class="p">:</span>
                            <span class="c"># g(i, -i) = -D with antisymmetric metric</span>
                            <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c"># g(i0, i1)*p(-i1)</span>
                        <span class="k">if</span> <span class="n">dc0</span> <span class="o">==</span> <span class="n">gposx</span><span class="p">:</span>
                            <span class="n">p1</span> <span class="o">=</span> <span class="n">dp1</span>
                            <span class="n">c1</span> <span class="o">=</span> <span class="n">dc1</span>
                            <span class="k">if</span> <span class="n">dp0</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">coeff</span> <span class="o">=</span> <span class="o">-</span><span class="n">coeff</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">p1</span> <span class="o">=</span> <span class="n">dp0</span>
                            <span class="n">c1</span> <span class="o">=</span> <span class="n">dc0</span>
                        <span class="n">ind</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">free1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">free</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c1</span><span class="p">))</span>
            <span class="n">dum</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dum</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dum1</span><span class="p">]</span>
            <span class="n">free</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">free</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">free1</span><span class="p">]</span>

        <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">:</span>
                <span class="n">shift</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="n">free</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ind</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span> <span class="o">-</span> <span class="n">shifts</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">free</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">]</span>
        <span class="n">dum</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c0</span> <span class="o">-</span> <span class="n">shifts</span><span class="p">[</span><span class="n">c0</span><span class="p">],</span> <span class="n">c1</span> <span class="o">-</span> <span class="n">shifts</span><span class="p">[</span><span class="n">c1</span><span class="p">])</span> <span class="k">for</span>  <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dum</span><span class="p">)</span> <span class="k">if</span> <span class="n">c0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elim</span> <span class="ow">and</span> <span class="n">c1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">]</span>
        <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">components</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">elim</span><span class="p">]</span>
        <span class="n">tids</span> <span class="o">=</span> <span class="n">TIDS</span><span class="p">(</span><span class="n">components</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">dum</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_TIDS</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">tids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
</div>
<div class="viewcode-block" id="TensMul.substitute_indices"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul.substitute_indices">[docs]</a>    <span class="k">def</span> <span class="nf">substitute_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">index_tuples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tensor with free indices substituted according to ``index_tuples``</span>

<span class="sd">        ``index_types`` list of tuples ``(old_index, new_index)``</span>

<span class="sd">        Note: this method will neither raise or lower the indices, it will just replace their symbol.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; i, j, k, l = tensor_indices(&#39;i,j,k,l&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A, B = tensorhead(&#39;A,B&#39;, [Lorentz]*2, [[1]*2])</span>
<span class="sd">        &gt;&gt;&gt; t = A(i, k)*B(-k, -j); t</span>
<span class="sd">        A(i, L_0)*B(-L_0, -j)</span>
<span class="sd">        &gt;&gt;&gt; t.substitute_indices((i,j), (j, k))</span>
<span class="sd">        A(j, L_0)*B(-L_0, -k)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span>
        <span class="n">free1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span> <span class="ow">in</span> <span class="n">free</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index_tuples</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">_name</span> <span class="ow">and</span> <span class="n">i</span><span class="o">.</span><span class="n">_tensortype</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">_tensortype</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">_is_up</span> <span class="o">==</span> <span class="n">j</span><span class="o">.</span><span class="n">_is_up</span><span class="p">:</span>
                        <span class="n">free1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">free1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="o">-</span><span class="n">v</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span><span class="p">))</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">free1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span><span class="p">))</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">free1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dum</span><span class="p">)</span>

        <span class="c"># object is rebuilt in order to make sure that all contracted indices get recognized as dummies.</span>
        <span class="c"># t2 = TensMul(*t.args)</span>
        <span class="k">return</span> <span class="n">t</span>
</div>
<div class="viewcode-block" id="TensMul.fun_eval"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.TensMul.fun_eval">[docs]</a>    <span class="k">def</span> <span class="nf">fun_eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">index_tuples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tensor with free indices substituted according to ``index_tuples``</span>

<span class="sd">        ``index_types`` list of tuples ``(old_index, new_index)``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; i, j, k, l = tensor_indices(&#39;i,j,k,l&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; A, B = tensorhead(&#39;A,B&#39;, [Lorentz]*2, [[1]*2])</span>
<span class="sd">        &gt;&gt;&gt; t = A(i, k)*B(-k, -j); t</span>
<span class="sd">        A(i, L_0)*B(-L_0, -j)</span>
<span class="sd">        &gt;&gt;&gt; t.fun_eval((i, k),(-j, l))</span>
<span class="sd">        A(k, L_0)*B(-L_0, l)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">free</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free</span>
        <span class="n">free1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span> <span class="ow">in</span> <span class="n">free</span><span class="p">:</span>
            <span class="c"># search j in index_tuples</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index_tuples</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">free1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span><span class="p">))</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">free1</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">ipos</span><span class="p">,</span> <span class="n">cpos</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="n">free1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dum</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns tensor with ordered free indices replaced by ``indices``</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy import Symbol</span>
<span class="sd">        &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead</span>
<span class="sd">        &gt;&gt;&gt; D = Symbol(&#39;D&#39;)</span>
<span class="sd">        &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dim=D, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">        &gt;&gt;&gt; i0,i1,i2,i3,i4 = tensor_indices(&#39;i0:5&#39;, Lorentz)</span>
<span class="sd">        &gt;&gt;&gt; g = Lorentz.metric</span>
<span class="sd">        &gt;&gt;&gt; p, q = tensorhead(&#39;p,q&#39;, [Lorentz], [[1]])</span>
<span class="sd">        &gt;&gt;&gt; t = p(i0)*q(i1)*q(-i1)</span>
<span class="sd">        &gt;&gt;&gt; t(i1)</span>
<span class="sd">        p(i1)*q(L_0)*q(-L_0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">free_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_args</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_tensortype</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_tensortype</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">free_args</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;incompatible types&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="o">==</span> <span class="n">free_args</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fun_eval</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">free_args</span><span class="p">,</span> <span class="n">indices</span><span class="p">)))</span>

        <span class="c"># object is rebuilt in order to make sure that all contracted indices</span>
        <span class="c"># get recognized as dummies, but only if there are contracted indices.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">is_up</span> <span class="k">else</span> <span class="o">-</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_indices</span><span class="p">()]</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">_rank</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">_rank</span><span class="p">])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">_rank</span>
        <span class="n">res</span> <span class="o">=</span> <span class="s">&#39;*&#39;</span><span class="o">.</span> <span class="n">join</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">==</span> <span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">==</span> <span class="o">-</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;-</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">res</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="o">.</span><span class="n">is_Atom</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">*</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;(</span><span class="si">%s</span><span class="s">)*</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dat</span> <span class="o">=</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dat</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span> <span class="o">*</span> <span class="n">dat</span>

    <span class="nd">@data.setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c"># TODO: check data compatibility with properties of tensor.</span>
        <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="nd">@data.deleter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_tensor_data_substitution_dict</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;No iteration on abstract tensors&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="canon_bp"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.canon_bp">[docs]</a><span class="k">def</span> <span class="nf">canon_bp</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Butler-Portugal canonicalization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">TensExpr</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">canon_bp</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">p</span>
</div>
<div class="viewcode-block" id="tensor_mul"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.tensor_mul">[docs]</a><span class="k">def</span> <span class="nf">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    product of tensors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TensMul</span><span class="o">.</span><span class="n">from_data</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">One</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[])</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">tx</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">tx</span>
    <span class="k">return</span> <span class="n">t</span>

</div>
<div class="viewcode-block" id="riemann_cyclic_replace"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.riemann_cyclic_replace">[docs]</a><span class="k">def</span> <span class="nf">riemann_cyclic_replace</span><span class="p">(</span><span class="n">t_r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    replace Riemann tensor with an equivalent expression</span>

<span class="sd">    ``R(m,n,p,q) -&gt; 2/3*R(m,n,p,q) - 1/3*R(m,q,n,p) + 1/3*R(m,p,n,q)``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">free</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">t_r</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">free</span><span class="p">]</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">t_r</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="o">-</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">t_r</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">),(</span><span class="n">n</span><span class="p">,</span><span class="n">q</span><span class="p">),(</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">),(</span><span class="n">q</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">t_r</span><span class="o">.</span><span class="n">substitute_indices</span><span class="p">((</span><span class="n">m</span><span class="p">,</span><span class="n">m</span><span class="p">),(</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">),(</span><span class="n">p</span><span class="p">,</span><span class="n">n</span><span class="p">),(</span><span class="n">q</span><span class="p">,</span><span class="n">q</span><span class="p">))</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span>
    <span class="k">return</span> <span class="n">t3</span>
</div>
<div class="viewcode-block" id="riemann_cyclic"><a class="viewcode-back" href="../../../modules/tensor/tensor.html#sympy.tensor.tensor.riemann_cyclic">[docs]</a><span class="k">def</span> <span class="nf">riemann_cyclic</span><span class="p">(</span><span class="n">t2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    replace each Riemann tensor with an equivalent expression</span>
<span class="sd">    satisfying the cyclic identity.</span>

<span class="sd">    This trick is discussed in the reference guide to Cadabra.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.tensor.tensor import TensorIndexType, tensor_indices, tensorhead, riemann_cyclic</span>
<span class="sd">    &gt;&gt;&gt; Lorentz = TensorIndexType(&#39;Lorentz&#39;, dummy_fmt=&#39;L&#39;)</span>
<span class="sd">    &gt;&gt;&gt; i, j, k, l = tensor_indices(&#39;i,j,k,l&#39;, Lorentz)</span>
<span class="sd">    &gt;&gt;&gt; R = tensorhead(&#39;R&#39;, [Lorentz]*4, [[2, 2]])</span>
<span class="sd">    &gt;&gt;&gt; t = R(i,j,k,l)*(R(-i,-j,-k,-l) - 2*R(-i,-k,-j,-l))</span>
<span class="sd">    &gt;&gt;&gt; riemann_cyclic(t)</span>
<span class="sd">    0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">TensMul</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">t2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">args</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">riemann_cyclic_replace</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span> <span class="k">for</span> <span class="n">tx</span> <span class="ow">in</span> <span class="n">y</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">a1</span><span class="p">]</span>
    <span class="n">a3</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensor_mul</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">a2</span><span class="p">]</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="n">TensAdd</span><span class="p">(</span><span class="o">*</span><span class="n">a3</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">t3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">canon_bp</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>
</div>
<span class="k">def</span> <span class="nf">get_lines</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">index_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns ``(lines, traces, rest)`` for an index type,</span>
<span class="sd">    where ``lines`` is the list of list of positions of a matrix line,</span>
<span class="sd">    ``traces`` is the list of list of traced matrix lines,</span>
<span class="sd">    ``rest`` is the rest of the elements ot the tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_join_lines</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">xend</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="n">hit</span><span class="p">:</span>
                <span class="n">hit</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">xend</span><span class="p">:</span>
                        <span class="n">hit</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">x</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
                        <span class="n">xend</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="n">tids</span> <span class="o">=</span> <span class="n">ex</span><span class="o">.</span><span class="n">_tids</span>
    <span class="n">components</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">components</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">components</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dt</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">index_types</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">index_types</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">index_types</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">index_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="n">index_type</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;at most two indices of type </span><span class="si">%s</span><span class="s"> allowed&#39;</span> <span class="o">%</span> <span class="n">index_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">dt</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">dum</span> <span class="o">=</span> <span class="n">tids</span><span class="o">.</span><span class="n">dum</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">traces</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">traces1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span> <span class="ow">in</span> <span class="n">dum</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">components</span><span class="p">[</span><span class="n">c0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dt</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">c0</span> <span class="o">==</span> <span class="n">c1</span><span class="p">:</span>
            <span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">c0</span><span class="p">])</span>
            <span class="k">continue</span>
        <span class="n">ta0</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="n">c0</span><span class="p">]]</span>
        <span class="n">ta1</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="n">c1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">p0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ta0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">ta0</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="o">==</span> <span class="n">ta1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p1</span><span class="p">):</span>
            <span class="c"># case gamma(i,s0,-s1)in c0, gamma(j,-s0,s2) in c1;</span>
            <span class="c"># to deal with this case one could add to the position</span>
            <span class="c"># a flag for transposition;</span>
            <span class="c"># one could write [(c0, False), (c1, True)]</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="c"># if p0 == ta0[1] then G in pos c0 is mult on the right by G in c1</span>
        <span class="c"># if p0 == ta0[0] then G in pos c1 is mult on the right by G in c0</span>
        <span class="n">ta0</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="n">components</span><span class="p">[</span><span class="n">c0</span><span class="p">]]</span>
        <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">)</span> <span class="k">if</span> <span class="n">p0</span> <span class="o">==</span> <span class="n">ta0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="k">else</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c0</span><span class="p">)</span>
        <span class="n">lines1</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b1</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
                    <span class="n">traces1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="n">traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">+</span> <span class="n">line</span><span class="p">[:</span><span class="n">n</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">b1</span><span class="p">:</span>
                <span class="n">line</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b0</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lines1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">])</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">traces1</span><span class="p">]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">_join_lines</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="n">rest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">traces</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="n">rest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">))</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rest</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">traces</span><span class="p">,</span> <span class="n">rest</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.5-git documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014 SymPy Development Team.
      Last updated on Jun 24, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>