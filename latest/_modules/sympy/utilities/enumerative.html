

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>sympy.utilities.enumerative &mdash; SymPy 0.7.5 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.7.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.5 documentation" href="../../../index.html" />
    <link rel="up" title="sympy" href="../../sympy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.5 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" accesskey="U">sympy</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for sympy.utilities.enumerative</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">sympy.core.compatibility</span> <span class="kn">import</span> <span class="nb">xrange</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Algorithms and classes to support enumerative combinatorics.</span>

<span class="sd">Currently just multiset partitions, but more could be added.</span>

<span class="sd">Terminology (following Knuth, algorithm 7.1.2.5M TAOCP)</span>
<span class="sd">*multiset* aaabbcccc has a *partition* aaabc | bccc</span>

<span class="sd">The submultisets, aaabc and bccc of the partition are called</span>
<span class="sd">*parts*, or sometimes *vectors*.  (Knuth notes that multiset</span>
<span class="sd">partitions can be thought of as partitions of vectors of integers,</span>
<span class="sd">where the ith element of the vector gives the multiplicity of</span>
<span class="sd">element i.)</span>

<span class="sd">The values a, b and c are *components* of the multiset.  These</span>
<span class="sd">correspond to elements of a set, but in a multiset can be present</span>
<span class="sd">with a multiplicity greater than 1.</span>

<span class="sd">The algorithm deserves some explanation.</span>

<span class="sd">Think of the part aaabc from the multiset above.  If we impose an</span>
<span class="sd">ordering on the components of the multiset, we can represent a part</span>
<span class="sd">with a vector, in which the value of the first element of the vector</span>
<span class="sd">corresponds to the multiplicity of the first component in that</span>
<span class="sd">part. Thus, aaabc can be represented by the vector [3, 1, 1].  We</span>
<span class="sd">can also define an ordering on parts, based on the lexicographic</span>
<span class="sd">ordering of the vector (leftmost vector element, i.e., the element</span>
<span class="sd">with the smallest component number, is the most significant), so</span>
<span class="sd">that [3, 1, 1] &gt; [3, 1, 0] and [3, 1, 1] &gt; [2, 1, 4].  The ordering</span>
<span class="sd">on parts can be extended to an ordering on partitions: First, sort</span>
<span class="sd">the parts in each partition, left-to-right in decreasing order. Then</span>
<span class="sd">partition A is greater than partition B if A&#39;s leftmost/greatest</span>
<span class="sd">part is greater than B&#39;s leftmost part.  If the leftmost parts are</span>
<span class="sd">equal, compare the second parts, and so on.</span>

<span class="sd">In this ordering, the greatest partion of a given multiset has only</span>
<span class="sd">one part.  The least partition is the one in which the components</span>
<span class="sd">are spread out, one per part.</span>

<span class="sd">The enumeration algorithms in this file yield the partitions of the</span>
<span class="sd">argument multiset in decreasing order.  The main data structure is a</span>
<span class="sd">stack of parts, corresponding to the current partition.  An</span>
<span class="sd">important invariant is that the parts on the stack are themselves in</span>
<span class="sd">decreasing order.  This data structure is decremented to find the</span>
<span class="sd">next smaller partition.  Most often, decrementing the partition will</span>
<span class="sd">only involve adjustments to the smallest parts at the top of the</span>
<span class="sd">stack, much as adjacent integers *usually* differ only in their last</span>
<span class="sd">few digits.</span>

<span class="sd">Knuth&#39;s algorithm uses two main operations on parts:</span>

<span class="sd">Decrement - change the part so that it is smaller in the</span>
<span class="sd">  (vector) lexicographic order, but reduced by the smallest amount possible.</span>
<span class="sd">  For example, if the multiset has vector [5,</span>
<span class="sd">  3, 1], and the bottom/greatest part is [4, 2, 1], this part would</span>
<span class="sd">  decrement to [4, 2, 0], while [4, 0, 0] would decrement to [3, 3,</span>
<span class="sd">  1].  A singleton part is never decremented -- [1, 0, 0] is not</span>
<span class="sd">  decremented to [0, 3, 1].  Instead, the decrement operator needs</span>
<span class="sd">  to fail for this case.  In Knuth&#39;s psuedocode, the decrement</span>
<span class="sd">  operator is step m5.</span>

<span class="sd">Spread unallocated multiplicity - Once a part has been decremented,</span>
<span class="sd">  it cannot be the rightmost part in the partition.  There is some</span>
<span class="sd">  multiplicity that has not been allocated, and new parts must be</span>
<span class="sd">  created above it in the stack to use up this multiplicity.  To</span>
<span class="sd">  maintain the invariant that the parts on the stack are in</span>
<span class="sd">  decreasing order, these new parts must be less than or equal to</span>
<span class="sd">  the decremented part.</span>
<span class="sd">  For example, if the multiset is [5, 3, 1], and its most</span>
<span class="sd">  significant part has just been decremented to [5, 3, 0], the</span>
<span class="sd">  spread operation will add a new part so that the stack becomes</span>
<span class="sd">  [[5, 3, 0], [0, 0, 1]].  If the most significant part (for the</span>
<span class="sd">  same multiset) has been decremented to [2, 0, 0] the stack becomes</span>
<span class="sd">  [[2, 0, 0], [2, 0, 0], [1, 3, 1]].  In the psuedocode, the spread</span>
<span class="sd">  operation for one part is step m2.  The complete spread operation</span>
<span class="sd">  is a loop of steps m2 and m3.</span>

<span class="sd">In order to facilitate the spread operation, Knuth stores, for each</span>
<span class="sd">component of each part, not just the multiplicity of that component</span>
<span class="sd">in the part, but also the total multiplicity available for this</span>
<span class="sd">component in this part or any lesser part above it on the stack.</span>

<span class="sd">One added twist is that Knuth does not represent the part vectors as</span>
<span class="sd">arrays. Instead, he uses a sparse representation, in which a</span>
<span class="sd">component of a part is represented as a component number (c), plus</span>
<span class="sd">the multiplicity of the component in that part (v) as well as the</span>
<span class="sd">total multiplicity available for that component (u).  This saves</span>
<span class="sd">time that would be spent skipping over zeros.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">PartComponent</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal class used in support of the multiset partitions</span>
<span class="sd">    enumerators and the associated visitor functions.</span>

<span class="sd">    Represents one component of one part of the current partition.</span>

<span class="sd">    A stack of these, plus an auxiliary frame array, f, represents a</span>
<span class="sd">    partition of the multiset.</span>

<span class="sd">    Knuth&#39;s psuedocode makes c, u, and v separate arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span> <span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;v&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># Component number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># The as yet unpartitioned amount in component c</span>
                     <span class="c"># *before* it is allocated by this triple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># Amount of c component in the current part</span>
                     <span class="c"># (v&lt;=u).  An invariant of the representation is</span>
                     <span class="c"># that the next higher triple for this component</span>
                     <span class="c"># (if there is one) will have a value of u-v in</span>
                     <span class="c"># its u attribute.</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">&quot;for debug/algorithm animation purposes&quot;</span>
        <span class="k">return</span> <span class="s">&#39;c:</span><span class="si">%d</span><span class="s"> u:</span><span class="si">%d</span><span class="s"> v:</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define  value oriented equality, which is useful for testers&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">c</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">u</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Defined for consistency with __eq__&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>


<span class="c"># This function tries to be a faithful implementation of algorithm</span>
<span class="c"># 7.1.2.5M in Volume 4A, Combinatoral Algorithms, Part 1, of The Art</span>
<span class="c"># of Computer Programming, by Donald Knuth.  This includes using</span>
<span class="c"># (mostly) the same variable names, etc.  This makes for rather</span>
<span class="c"># low-level Python.</span>

<span class="c"># Changes from Knuth&#39;s psuedocode include</span>
<span class="c"># - use PartComponent struct/object instead of 3 arrays</span>
<span class="c"># - make the function a generator</span>
<span class="c"># - map (with some difficulty) the GOTOs to Python control structures.</span>
<span class="c"># - Knuth uses 1-based numbering for components, this code is 0-based</span>
<span class="c"># - renamed variable l to lpart.</span>
<span class="c"># - flag variable x takes on values True/False instead of 1/0</span>
<span class="c">#</span>
<div class="viewcode-block" id="multiset_partitions_taocp"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.multiset_partitions_taocp">[docs]</a><span class="k">def</span> <span class="nf">multiset_partitions_taocp</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Enumerates partions of a multiset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    multiplicities</span>
<span class="sd">         list of integer multiplicities of the components of the multiset.</span>

<span class="sd">    Yields</span>
<span class="sd">    ======</span>

<span class="sd">    state</span>
<span class="sd">        Internal data structure which encodes a particular partition.</span>
<span class="sd">        This output is then usually processed by a vistor function</span>
<span class="sd">        which combines the information from this data structure with</span>
<span class="sd">        the components themselves to produce an actual partition.</span>

<span class="sd">        Unless they wish to create their own visitor function, users will</span>
<span class="sd">        have little need to look inside this data structure.  But, for</span>
<span class="sd">        reference, it is a 3-element list with components:</span>

<span class="sd">        f</span>
<span class="sd">            is a frame array, which is used to divide pstack into parts.</span>

<span class="sd">        lpart</span>
<span class="sd">            points to the base of the topmost part.</span>

<span class="sd">        pstack</span>
<span class="sd">            is an array of PartComponent objects.</span>

<span class="sd">        The ``state`` output offers a peek into the internal data</span>
<span class="sd">        structures of the enumeration function.  The client should</span>
<span class="sd">        treat this as read-only; any modification of the data</span>
<span class="sd">        structure will cause unpredictable (and almost certainly</span>
<span class="sd">        incorrect) results.  Also, the components of ``state`` are</span>
<span class="sd">        modified in place at each iteration.  Hence, the visitor must</span>
<span class="sd">        be called at each loop iteration.  Accumulating the ``state``</span>
<span class="sd">        instances and processing them later will not work.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor</span>
<span class="sd">    &gt;&gt;&gt; from sympy.utilities.enumerative import multiset_partitions_taocp</span>
<span class="sd">    &gt;&gt;&gt; # variables components and multiplicities represent the multiset &#39;abb&#39;</span>
<span class="sd">    &gt;&gt;&gt; components = &#39;ab&#39;</span>
<span class="sd">    &gt;&gt;&gt; multiplicities = [1, 2]</span>
<span class="sd">    &gt;&gt;&gt; states = multiset_partitions_taocp(multiplicities)</span>
<span class="sd">    &gt;&gt;&gt; list(list_visitor(state, components) for state in states)</span>
<span class="sd">    [[[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">    [[&#39;a&#39;, &#39;b&#39;], [&#39;b&#39;]],</span>
<span class="sd">    [[&#39;a&#39;], [&#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">    [[&#39;a&#39;], [&#39;b&#39;], [&#39;b&#39;]]]</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>

<span class="sd">    sympy.utilities.iterables.multiset_partititions: Takes a multiset</span>
<span class="sd">        as input and directly yields multiset partitions.  It</span>
<span class="sd">        dispatches to a number of functions, including this one, for</span>
<span class="sd">        implementation.  Most users will find it more convenient to</span>
<span class="sd">        use than multiset_partitions_taocp.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Important variables.</span>
    <span class="c"># m is the number of components, i.e., number of distinct elements</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>
    <span class="c"># n is the cardinality, total number of elements whether or not distinct</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>

    <span class="c"># The main data structure, f segments pstack into parts.  See</span>
    <span class="c"># list_visitor() for example code indicating how this internal</span>
    <span class="c"># state corresponds to a partition.</span>

    <span class="c"># Note: allocation of space for stack is conservative.  Knuth&#39;s</span>
    <span class="c"># exercise 7.2.1.5.68 gives some indication of how to tighten this</span>
    <span class="c"># bound, but this is not implemented.</span>
    <span class="n">pstack</span> <span class="o">=</span> <span class="p">[</span><span class="n">PartComponent</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Step M1 in Knuth (Initialize)</span>
    <span class="c"># Initial state - entire multiset in one part.</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">multiplicities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">ps</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">multiplicities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="c"># Other variables</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lpart</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">m</span>  <span class="c"># in general, current stack frame is from a to b - 1</span>

    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># Step M2 (Subtract v from u)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">b</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">-</span> <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span>
                <span class="k">if</span> <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
                    <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">c</span>
                    <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">&lt;</span> <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c"># x is True</span>
                    <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">c</span>
                    <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c"># Note: x is True iff v has changed</span>

            <span class="c"># Step M3 (Push if nonzero.)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">k</span>
                <span class="n">lpart</span> <span class="o">=</span> <span class="n">lpart</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">f</span><span class="p">[</span><span class="n">lpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
                <span class="c"># Return to M2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>  <span class="c"># Continue to M4</span>

        <span class="c"># M4  Visit a partition</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span> <span class="n">lpart</span><span class="p">,</span> <span class="n">pstack</span><span class="p">]</span>
        <span class="k">yield</span> <span class="n">state</span>

        <span class="c"># M5 (Decrease v)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">b</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># M6 (Backtrack)</span>
                <span class="k">if</span> <span class="n">lpart</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">lpart</span> <span class="o">=</span> <span class="n">lpart</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">lpart</span><span class="p">]</span>
                <span class="c"># Return to M5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                    <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>
                <span class="k">break</span>  <span class="c"># GOTO M2</span>

<span class="c"># --------------- Visitor functions for multiset partitions ---------------</span>
<span class="c"># A visitor takes the partition state generated by</span>
<span class="c"># multiset_partitions_taocp or other enumerator, and produces useful</span>
<span class="c"># output (such as the actual partition).</span>

</div>
<div class="viewcode-block" id="factoring_visitor"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.factoring_visitor">[docs]</a><span class="k">def</span> <span class="nf">factoring_visitor</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">primes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use with multiset_partitions_taocp to enumerate the ways a</span>
<span class="sd">    number can be expressed as a product of factors.  For this usage,</span>
<span class="sd">    the exponents of the prime factors of a number are arguments to</span>
<span class="sd">    the partition enumerator, while the corresponding prime factors</span>
<span class="sd">    are input here.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    To enumerate the factorings of a number we can think of the elements of the</span>
<span class="sd">    partition as being the prime factors and the multiplicities as being their</span>
<span class="sd">    exponents.</span>

<span class="sd">    &gt;&gt;&gt; from sympy.utilities.enumerative import factoring_visitor</span>
<span class="sd">    &gt;&gt;&gt; from sympy.utilities.enumerative import multiset_partitions_taocp</span>
<span class="sd">    &gt;&gt;&gt; from sympy import factorint</span>
<span class="sd">    &gt;&gt;&gt; primes, multiplicities = zip(*factorint(24).items())</span>
<span class="sd">    &gt;&gt;&gt; primes</span>
<span class="sd">    (2, 3)</span>
<span class="sd">    &gt;&gt;&gt; multiplicities</span>
<span class="sd">    (3, 1)</span>
<span class="sd">    &gt;&gt;&gt; states = multiset_partitions_taocp(multiplicities)</span>
<span class="sd">    &gt;&gt;&gt; list(factoring_visitor(state, primes) for state in states)</span>
<span class="sd">    [[24], [8, 3], [12, 2], [4, 6], [4, 2, 3], [6, 2, 2], [2, 2, 2, 3]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">lpart</span><span class="p">,</span> <span class="n">pstack</span> <span class="o">=</span> <span class="n">state</span>
    <span class="n">factoring</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">lpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">pstack</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]:</span>
            <span class="k">if</span> <span class="n">ps</span><span class="o">.</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">factor</span> <span class="o">*=</span> <span class="n">primes</span><span class="p">[</span><span class="n">ps</span><span class="o">.</span><span class="n">c</span><span class="p">]</span> <span class="o">**</span> <span class="n">ps</span><span class="o">.</span><span class="n">v</span>
        <span class="n">factoring</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">factoring</span>

</div>
<div class="viewcode-block" id="list_visitor"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.list_visitor">[docs]</a><span class="k">def</span> <span class="nf">list_visitor</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">components</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of lists to represent the partition.</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor</span>
<span class="sd">    &gt;&gt;&gt; from sympy.utilities.enumerative import multiset_partitions_taocp</span>
<span class="sd">    &gt;&gt;&gt; states = multiset_partitions_taocp([1, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; s = next(states)</span>
<span class="sd">    &gt;&gt;&gt; list_visitor(s, &#39;abc&#39;)  # for multiset &#39;a b b c&#39;</span>
<span class="sd">    [[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; s = next(states)</span>
<span class="sd">    &gt;&gt;&gt; list_visitor(s, [1, 2, 3])  # for multiset &#39;1 2 2 3</span>
<span class="sd">    [[1, 2, 2], [3]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">lpart</span><span class="p">,</span> <span class="n">pstack</span> <span class="o">=</span> <span class="n">state</span>

    <span class="n">partition</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">lpart</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">part</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">pstack</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]:</span>
            <span class="k">if</span> <span class="n">ps</span><span class="o">.</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">part</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">components</span><span class="p">[</span><span class="n">ps</span><span class="o">.</span><span class="n">c</span><span class="p">]]</span> <span class="o">*</span> <span class="n">ps</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
        <span class="n">partition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">partition</span>

</div>
<div class="viewcode-block" id="MultisetPartitionTraverser"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.MultisetPartitionTraverser">[docs]</a><span class="k">class</span> <span class="nc">MultisetPartitionTraverser</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Has methods to ``enumerate`` and ``count`` the partitions of a multiset.</span>

<span class="sd">    This implements a refactored and extended version of Knuth&#39;s algorithm</span>
<span class="sd">    7.1.2.5M [AOCP]_.&quot;</span>

<span class="sd">    The enumeration methods of this class are generators and return</span>
<span class="sd">    data structures which can be interpreted by the same visitor</span>
<span class="sd">    functions used for the output of ``multiset_partitions_taocp``.</span>

<span class="sd">    See Also</span>
<span class="sd">    ========</span>
<span class="sd">    multiset_partitions_taocp</span>
<span class="sd">    sympy.utilities.iterables.multiset_partititions</span>

<span class="sd">    Examples</span>
<span class="sd">    ========</span>

<span class="sd">    &gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser</span>
<span class="sd">    &gt;&gt;&gt; m = MultisetPartitionTraverser()</span>
<span class="sd">    &gt;&gt;&gt; m.count_partitions([4,4,4,2])</span>
<span class="sd">    127750</span>
<span class="sd">    &gt;&gt;&gt; m.count_partitions([3,3,3])</span>
<span class="sd">    686</span>

<span class="sd">    References</span>
<span class="sd">    ==========</span>

<span class="sd">    .. [AOCP] Algorithm 7.1.2.5M in Volume 4A, Combinatoral Algorithms,</span>
<span class="sd">           Part 1, of The Art of Computer Programming, by Donald Knuth.</span>

<span class="sd">    .. [Factorisatio] On a Problem of Oppenheim concerning</span>
<span class="sd">           &quot;Factorisatio Numerorum&quot; E. R. Canfield, Paul Erdos, Carl</span>
<span class="sd">           Pomerance, JOURNAL OF NUMBER THEORY, Vol. 17, No. 1. August</span>
<span class="sd">           1983.  See section 7 for a description of an algorithm</span>
<span class="sd">           similar to Knuth&#39;s.</span>

<span class="sd">    .. [Yorgey] Generating Multiset Partitions, Brent Yorgey, The</span>
<span class="sd">           Monad.Reader, Issue 8, September 2007.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c"># TRACING variables.  These are useful for gathering</span>
        <span class="c"># statistics on the algorithm itself, but have no particular</span>
        <span class="c"># benefit to a user of the code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p1</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">db_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Useful for usderstanding/debugging the algorithms.  Not</span>
<span class="sd">        generally activated in end-user code.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="n">letters</span> <span class="o">=</span> <span class="s">&#39;abcdefghijklmnopqrstuvwxyz&#39;</span>
            <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">]</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;DBG:&quot;</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span>
                  <span class="p">[</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">list_visitor</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">letters</span><span class="p">)],</span>
                  <span class="n">animation_visitor</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

    <span class="c">#</span>
    <span class="c"># Helper methods for enumeration</span>
    <span class="c">#</span>
    <span class="k">def</span> <span class="nf">_initialize_enumeration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allocates and initializes the partition stack.</span>

<span class="sd">        This is called from the enumeration/counting routines, so</span>
<span class="sd">        there is no need to call it separately.&quot;&quot;&quot;</span>

        <span class="n">num_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>
        <span class="c"># cardinality is the total number of elements, whether or not distinct</span>
        <span class="n">cardinality</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>

        <span class="c"># pstack is the partition stack, which is segmented by</span>
        <span class="c"># f into parts.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span> <span class="o">=</span> <span class="p">[</span><span class="n">PartComponent</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                       <span class="nb">xrange</span><span class="p">(</span><span class="n">num_components</span> <span class="o">*</span> <span class="n">cardinality</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">cardinality</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c"># Initial state - entire multiset in one part.</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">num_components</span><span class="p">):</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">j</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">multiplicities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">multiplicities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">num_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># The decrement_part() method corresponds to step M5 in Knuth&#39;s</span>
    <span class="c"># algorithm.  This is the base version for enum_all().  Modified</span>
    <span class="c"># versions of this method are needed if we want to restrict</span>
    <span class="c"># sizes of the partitions produced.</span>
    <span class="k">def</span> <span class="nf">decrement_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decrements part (a subrange of pstack), if possible, returning</span>
<span class="sd">        True iff the part was successfully decremented.</span>

<span class="sd">        If you think of the v values in the part as a multi-digit</span>
<span class="sd">        integer (least significant digit on the right) this is</span>
<span class="sd">        basically decrementing that integer, but with the extra</span>
<span class="sd">        constraint that the leftmost digit cannot be decremented to 0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        part</span>
<span class="sd">           The part, represented as a list of PartComponent objects,</span>
<span class="sd">           which is to be decremented.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">plen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">part</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">part</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c"># found val to decrement</span>
                <span class="n">part</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="c"># Reset trailing parts back to maximum</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">plen</span><span class="p">):</span>
                    <span class="n">part</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">part</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="c"># Version to allow number of parts to be bounded from above.</span>
    <span class="c"># Corresponds to (a modified) step M5.</span>
    <span class="k">def</span> <span class="nf">decrement_part_small</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decrements part (a subrange of pstack), if possible, returning</span>
<span class="sd">        True iff the part was successfully decremented.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        part</span>
<span class="sd">            part to be decremented (topmost part on the stack)</span>

<span class="sd">        ub</span>
<span class="sd">            the maximum number of parts allowed in a partition</span>
<span class="sd">            returned by the calling traversal.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        The goal of this modification of the ordinary decrement method</span>
<span class="sd">        is to fail (meaning that the subtree rooted at this part is to</span>
<span class="sd">        be skipped) when it can be proved that this part can only have</span>
<span class="sd">        child partitions which are larger than allowed by ``ub``. If a</span>
<span class="sd">        decision is made to fail, it must be accurate, otherwise the</span>
<span class="sd">        enumeration will miss some partitions.  But, it is OK not to</span>
<span class="sd">        capture all the possible failures -- if a part is passed that</span>
<span class="sd">        shouldn&#39;t be, the resulting too-large partitions are filtered</span>
<span class="sd">        by the enumeration one level up.  However, as is usual in</span>
<span class="sd">        constrained enumerations, failing early is advantageous.</span>

<span class="sd">        The tests used by this method catch the most common cases,</span>
<span class="sd">        although this implementation is by no means the last word on</span>
<span class="sd">        this problem.  The tests include:</span>

<span class="sd">        1) ``lpart`` must be less than ``ub`` by at least 2.  This is because</span>
<span class="sd">           once a part has been decremented, the partition</span>
<span class="sd">           will gain at least one child in the spread step.</span>

<span class="sd">        2) If the leading component of the part is about to be</span>
<span class="sd">           decremented, check for how many parts will be added in</span>
<span class="sd">           order to use up the unallocated multiplicity in that</span>
<span class="sd">           leading component, and fail if this number is greater than</span>
<span class="sd">           allowed by ``ub``.  (See code for the exact expression.)  This</span>
<span class="sd">           test is given in the answer to Knuth&#39;s problem 7.2.1.5.69.</span>

<span class="sd">        3) If there is *exactly* enough room to expand the leading</span>
<span class="sd">           component by the above test, check the next component (if</span>
<span class="sd">           it exists) once decrementing has finished.  If this has</span>
<span class="sd">           ``v == 0``, this next component will push the expansion over the</span>
<span class="sd">           limit by 1, so fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">&gt;=</span> <span class="n">ub</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p1</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># increment to keep track of usefulness of tests</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">plen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c"># Knuth&#39;s mod, (answer to problem 7.2.1.5.69)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">u</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">part</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">part</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c"># found val to decrement</span>
                <span class="n">part</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="c"># Reset trailing parts back to maximum</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">plen</span><span class="p">):</span>
                    <span class="n">part</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">part</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>

                <span class="c"># Have now decremented part, but are we doomed to</span>
                <span class="c"># failure when it is expanded?  Check one oddball case</span>
                <span class="c"># that turns out to be surprisingly common - exactly</span>
                <span class="c"># enough room to expand the leading component, but no</span>
                <span class="c"># room for the second component, which has v=0.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">plen</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">-</span> <span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span>
                        <span class="p">((</span><span class="n">ub</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k2</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;Decrement fails test 3&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">decrement_part_large</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">amt</span><span class="p">,</span> <span class="n">lb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decrements part, while respecting size constraint.</span>

<span class="sd">        A part can have no children which are of sufficient size (as</span>
<span class="sd">        indicated by ``lb``) unless that part has sufficient</span>
<span class="sd">        unallocated multiplicity.  When enforcing the size constraint,</span>
<span class="sd">        this method will decrement the part (if necessary) by an</span>
<span class="sd">        amount needed to ensure sufficient unallocated multiplicity.</span>

<span class="sd">        Returns True iff the part was successfully decremented.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        part</span>
<span class="sd">            part to be decremented (topmost part on the stack)</span>

<span class="sd">        amt</span>
<span class="sd">            Can only take values 0 or 1.  A value of 1 means that the</span>
<span class="sd">            part must be decremented, and then the size constraint is</span>
<span class="sd">            enforced.  A value of 0 means just to enforce the ``lb``</span>
<span class="sd">            size constraint.</span>

<span class="sd">        lb</span>
<span class="sd">            The partitions produced by the calling enumeration must</span>
<span class="sd">            have more parts than this value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">amt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># In this case we always need to increment, *before*</span>
            <span class="c"># enforcing the &quot;sufficient unallocated multiplicity&quot;</span>
            <span class="c"># constraint.  Easiest for this is just to call the</span>
            <span class="c"># regular decrement method.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="c"># Next, perform any needed additional decrementing to respect</span>
        <span class="c"># &quot;sufficient unallocated multiplicity&quot; (or fail if this is</span>
        <span class="c"># not possible).</span>
        <span class="n">min_unalloc</span> <span class="o">=</span> <span class="n">lb</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span>
        <span class="k">if</span> <span class="n">min_unalloc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="n">total_mult</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">u</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">part</span><span class="p">)</span>
        <span class="n">total_alloc</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">v</span> <span class="k">for</span> <span class="n">pc</span> <span class="ow">in</span> <span class="n">part</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_mult</span> <span class="o">&lt;=</span> <span class="n">min_unalloc</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">deficit</span> <span class="o">=</span> <span class="n">min_unalloc</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_mult</span> <span class="o">-</span> <span class="n">total_alloc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deficit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">deficit</span><span class="p">:</span>
                    <span class="n">part</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">-=</span> <span class="n">deficit</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>  <span class="c"># This shouldn&#39;t happen, due to above check</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">&gt;=</span> <span class="n">deficit</span><span class="p">:</span>
                    <span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">-=</span> <span class="n">deficit</span>
                    <span class="k">return</span> <span class="bp">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">deficit</span> <span class="o">-=</span> <span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">v</span>
                    <span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">decrement_part_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decrements part (a subrange of pstack), if possible, returning</span>
<span class="sd">        True iff the part was successfully decremented.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">         part</span>
<span class="sd">            part to be decremented (topmost part on the stack)</span>

<span class="sd">        ub</span>
<span class="sd">            the maximum number of parts allowed in a partition</span>
<span class="sd">            returned by the calling traversal.</span>

<span class="sd">        lb</span>
<span class="sd">            The partitions produced by the calling enumeration must</span>
<span class="sd">            have more parts than this value.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Combines the constraints of _small and _large decrement</span>
<span class="sd">        methods.  If returns success, part has been decremented at</span>
<span class="sd">        least once, but perhaps by quite a bit more if needed to meet</span>
<span class="sd">        the lb constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Constraint in the range case is just enforcing both the</span>
        <span class="c"># constraints from _small and _large cases.  Note the 0 as the</span>
        <span class="c"># second argument to the _large call -- this is the signal to</span>
        <span class="c"># decrement only as needed to for constraint enforcement.  The</span>
        <span class="c"># short circuiting and left-to-right order of the &#39;and&#39;</span>
        <span class="c"># operator is important for this to work correctly.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_small</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_large</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lb</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">spread_part_multiplicity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns True if a new part has been created, and</span>
<span class="sd">        adjusts pstack, f and lpart as needed.</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        Spreads unallocated multiplicity from the current top part</span>
<span class="sd">        into a new part created above the current on the stack.  This</span>
<span class="sd">        new part is constrained to be less than or equal to the old in</span>
<span class="sd">        terms of the part ordering.</span>

<span class="sd">        This call does nothing (and returns False) if the current top</span>
<span class="sd">        part has no unallocated multiplicity.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">]</span>  <span class="c"># base of current top part</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>  <span class="c"># ub of current; potential base of next</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">k</span>  <span class="c"># save for later comparison</span>

        <span class="n">changed</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># Set to true when the new part (so far) is</span>
                         <span class="c"># strictly less than (as opposed to less than</span>
                         <span class="c"># or equal) to the old.</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">c</span>
                <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>  <span class="c"># Put all available multiplicity in this part</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c"># Still maintaining ordering constraint</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">u</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">v</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">base</span><span class="p">:</span>
            <span class="c"># Adjust for the new part on stack</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">top_part</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return current top part on the stack, as a slice of pstack.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

    <span class="c"># Same interface and funtionality as multiset_partitions_taocp(),</span>
    <span class="c"># but some might find this refactored version easier to follow.</span>
<div class="viewcode-block" id="MultisetPartitionTraverser.enum_all"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.MultisetPartitionTraverser.enum_all">[docs]</a>    <span class="k">def</span> <span class="nf">enum_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enumerate the partitions of a multiset.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>
<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor</span>
<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser</span>
<span class="sd">        &gt;&gt;&gt; m = MultisetPartitionTraverser()</span>
<span class="sd">        &gt;&gt;&gt; states = m.enum_all([2,2])</span>
<span class="sd">        &gt;&gt;&gt; list(list_visitor(state, &#39;ab&#39;) for state in states)</span>
<span class="sd">        [[[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [&#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;a&#39;], [&#39;b&#39;], [&#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;], [&#39;a&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;], [&#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;], [&#39;a&#39;], [&#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;], [&#39;a&#39;], [&#39;b&#39;], [&#39;b&#39;]]]</span>

<span class="sd">        See also</span>
<span class="sd">        ========</span>

<span class="sd">        multiset_partitions_taocp():</span>
<span class="sd">            which provides the same result as this method, but is</span>
<span class="sd">            about twice as fast.  Hence, enum_all is primarily useful</span>
<span class="sd">            for testing.  Also see the function for a discussion of</span>
<span class="sd">            states and visitors.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_enumeration</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">spread_part_multiplicity</span><span class="p">():</span>
                <span class="k">pass</span>

            <span class="c"># M4  Visit a partition</span>
            <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">state</span>

            <span class="c"># M5 (Decrease v)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">()):</span>
                <span class="c"># M6 (Backtrack)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">-=</span> <span class="mi">1</span>
</div>
<div class="viewcode-block" id="MultisetPartitionTraverser.enum_small"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.MultisetPartitionTraverser.enum_small">[docs]</a>    <span class="k">def</span> <span class="nf">enum_small</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicities</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enumerate multiset partitions with no more than ``ub`` parts.</span>

<span class="sd">        Equivalent to enum_range(multiplicities, 0, ub)</span>

<span class="sd">        See also</span>
<span class="sd">        ========</span>
<span class="sd">        enum_all, enum_large, enum_range</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        multiplicities</span>
<span class="sd">             list of multiplicities of the components of the multiset.</span>

<span class="sd">        ub</span>
<span class="sd">            Maximum number of parts</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor</span>
<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser</span>
<span class="sd">        &gt;&gt;&gt; m = MultisetPartitionTraverser()</span>
<span class="sd">        &gt;&gt;&gt; states = m.enum_small([2,2], 2)</span>
<span class="sd">        &gt;&gt;&gt; list(list_visitor(state, &#39;ab&#39;) for state in states)</span>
<span class="sd">        [[[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [&#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;], [&#39;a&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;b&#39;]]]</span>

<span class="sd">        The implementation is based, in part, on the answer given to</span>
<span class="sd">        exercise 69, in Knuth [AOCP]_.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Keep track of iterations which do not yield a partition.</span>
        <span class="c"># Clearly, we would like to keep this number small.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ub</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_enumeration</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">good_partition</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">spread_part_multiplicity</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;spread 1&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">&gt;=</span> <span class="n">ub</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_partition</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;  Discarding&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">=</span> <span class="n">ub</span> <span class="o">-</span> <span class="mi">2</span>
                    <span class="k">break</span>

            <span class="c"># M4  Visit a partition</span>
            <span class="k">if</span> <span class="n">good_partition</span><span class="p">:</span>
                <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">]</span>
                <span class="k">yield</span> <span class="n">state</span>

            <span class="c"># M5 (Decrease v)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_small</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">(),</span> <span class="n">ub</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;Failed decrement, going to backtrack&quot;</span><span class="p">)</span>
                <span class="c"># M6 (Backtrack)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;Backtracked to&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;decrement ok, about to expand&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="MultisetPartitionTraverser.enum_large"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.MultisetPartitionTraverser.enum_large">[docs]</a>    <span class="k">def</span> <span class="nf">enum_large</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicities</span><span class="p">,</span> <span class="n">lb</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enumerate the partitions of a multiset with lb &lt; num(parts)</span>

<span class="sd">        Equivalent to enum_range(multiplicities, lb, sum(multiplicities))</span>

<span class="sd">        See also</span>
<span class="sd">        ========</span>
<span class="sd">        enum_all, enum_small, enum_range</span>

<span class="sd">        Parameters</span>
<span class="sd">        ==========</span>

<span class="sd">        multiplicities</span>
<span class="sd">            list of multiplicities of the components of the multiset.</span>

<span class="sd">        lb</span>
<span class="sd">            Number of parts in the partition must be greater than</span>
<span class="sd">            this lower bound.</span>


<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor</span>
<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser</span>
<span class="sd">        &gt;&gt;&gt; m = MultisetPartitionTraverser()</span>
<span class="sd">        &gt;&gt;&gt; states = m.enum_large([2,2], 2)</span>
<span class="sd">        &gt;&gt;&gt; list(list_visitor(state, &#39;ab&#39;) for state in states)</span>
<span class="sd">        [[[&#39;a&#39;, &#39;a&#39;], [&#39;b&#39;], [&#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;], [&#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;], [&#39;a&#39;], [&#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;], [&#39;a&#39;], [&#39;b&#39;], [&#39;b&#39;]]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">lb</span> <span class="o">&gt;=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_enumeration</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_large</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lb</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">good_partition</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">spread_part_multiplicity</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_large</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lb</span><span class="p">):</span>
                    <span class="c"># Failure here should be rare/impossible</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_partition</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>

            <span class="c"># M4  Visit a partition</span>
            <span class="k">if</span> <span class="n">good_partition</span><span class="p">:</span>
                <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">]</span>
                <span class="k">yield</span> <span class="n">state</span>

            <span class="c"># M5 (Decrease v)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_large</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lb</span><span class="p">):</span>
                <span class="c"># M6 (Backtrack)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">-=</span> <span class="mi">1</span>
</div>
<div class="viewcode-block" id="MultisetPartitionTraverser.enum_range"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.MultisetPartitionTraverser.enum_range">[docs]</a>    <span class="k">def</span> <span class="nf">enum_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicities</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;Enumerate the partitions of a multiset with</span>
<span class="sd">        ``lb &lt; num(parts) &lt;= ub``.</span>

<span class="sd">        In particular, if partitions with exactly ``k`` parts are</span>
<span class="sd">        desired, call with ``(multiplicities, k - 1, k)``.  This</span>
<span class="sd">        method generalizes enum_all, enum_small, and enum_large.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import list_visitor</span>
<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser</span>
<span class="sd">        &gt;&gt;&gt; m = MultisetPartitionTraverser()</span>
<span class="sd">        &gt;&gt;&gt; states = m.enum_range([2,2], 1, 2)</span>
<span class="sd">        &gt;&gt;&gt; list(list_visitor(state, &#39;ab&#39;) for state in states)</span>
<span class="sd">        [[[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], [&#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;a&#39;], [&#39;b&#39;, &#39;b&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;b&#39;, &#39;b&#39;], [&#39;a&#39;]],</span>
<span class="sd">        [[&#39;a&#39;, &#39;b&#39;], [&#39;a&#39;, &#39;b&#39;]]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># combine the constraints of the _large and _small</span>
        <span class="c"># enumerations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ub</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">lb</span> <span class="o">&gt;=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_enumeration</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_large</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lb</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">good_partition</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">spread_part_multiplicity</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;spread 1&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_large</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lb</span><span class="p">):</span>
                    <span class="c"># Failure here - possible in range case?</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;  Discarding (large cons)&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_partition</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">&gt;=</span> <span class="n">ub</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">discarded</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">good_partition</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;  Discarding small cons&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">=</span> <span class="n">ub</span> <span class="o">-</span> <span class="mi">2</span>
                    <span class="k">break</span>

            <span class="c"># M4  Visit a partition</span>
            <span class="k">if</span> <span class="n">good_partition</span><span class="p">:</span>
                <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstack</span><span class="p">]</span>
                <span class="k">yield</span> <span class="n">state</span>

            <span class="c"># M5 (Decrease v)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">(),</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;Failed decrement, going to backtrack&quot;</span><span class="p">)</span>
                <span class="c"># M6 (Backtrack)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;Backtracked to&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">db_trace</span><span class="p">(</span><span class="s">&quot;decrement ok, about to expand&quot;</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">count_partitions_slow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of partitions of a multiset whose elements</span>
<span class="sd">        have the multiplicities given in ``multiplicities``.</span>

<span class="sd">        Primarily for comparison purposes.  It follows the same path as</span>
<span class="sd">        enumerate, and counts, rather than generates, the partitions.</span>

<span class="sd">        See Also</span>
<span class="sd">        ========</span>

<span class="sd">        count_partitions</span>
<span class="sd">            Has the same calling interface, but is much faster.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># number of partitions so far in the enumeration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_enumeration</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">spread_part_multiplicity</span><span class="p">():</span>
                <span class="k">pass</span>

            <span class="c"># M4  Visit (count) a partition</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c"># M5 (Decrease v)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">()):</span>
                <span class="c"># M6 (Backtrack)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">-=</span> <span class="mi">1</span>

<div class="viewcode-block" id="MultisetPartitionTraverser.count_partitions"><a class="viewcode-back" href="../../../modules/utilities/enumerative.html#sympy.utilities.enumerative.MultisetPartitionTraverser.count_partitions">[docs]</a>    <span class="k">def</span> <span class="nf">count_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplicities</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of partitions of a multiset whose components</span>
<span class="sd">        have the multiplicities given in ``multiplicities``.</span>

<span class="sd">        For larger counts, this method is much faster than calling one</span>
<span class="sd">        of the enumerators and counting the result.  Uses dynamic</span>
<span class="sd">        programming to cut down on the number of nodes actually</span>
<span class="sd">        explored.  The dictionary used in order to accelerate the</span>
<span class="sd">        counting process is stored in the ``MultisetPartitionTraverser``</span>
<span class="sd">        object and persists across calls.  If the the user does not</span>
<span class="sd">        expect to call ``count_partitions`` for any additional</span>
<span class="sd">        multisets, the object should be cleared to save memory.  On</span>
<span class="sd">        the other hand, the cache built up from one count run can</span>
<span class="sd">        significantly speed up subsequent calls to ``count_partitions``,</span>
<span class="sd">        so it may be advantageous not to clear the object.</span>

<span class="sd">        Examples</span>
<span class="sd">        ========</span>

<span class="sd">        &gt;&gt;&gt; from sympy.utilities.enumerative import MultisetPartitionTraverser</span>
<span class="sd">        &gt;&gt;&gt; m = MultisetPartitionTraverser()</span>
<span class="sd">        &gt;&gt;&gt; m.count_partitions([9,8,2])</span>
<span class="sd">        288716</span>
<span class="sd">        &gt;&gt;&gt; m.count_partitions([2,2])</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt; del m</span>

<span class="sd">        Notes</span>
<span class="sd">        =====</span>

<span class="sd">        If one looks at the workings of Knuth&#39;s algorithm M [AOCP]_, it</span>
<span class="sd">        can be viewed as a traversal of a binary tree of parts.  A</span>
<span class="sd">        part has (up to) two children, the left child resulting from</span>
<span class="sd">        the spread operation, and the right child from the decrement</span>
<span class="sd">        operation.  The ordinary enumeration of multiset partitions is</span>
<span class="sd">        an in-order traversal of this tree, and with the partitions</span>
<span class="sd">        corresponding to paths from the root to the leaves. The</span>
<span class="sd">        mapping from paths to partitions is a little complicated,</span>
<span class="sd">        since the partition would contain only those parts which are</span>
<span class="sd">        leaves or the parents of a spread link, not those which are</span>
<span class="sd">        parents of a decrement link.</span>

<span class="sd">        For counting purposes, it is sufficient to count leaves, and</span>
<span class="sd">        this can be done with a recursive in-order traversal.  The</span>
<span class="sd">        number of leaves of a subtree rooted at a particular part is a</span>
<span class="sd">        function only of that part itself, so memoizing has the</span>
<span class="sd">        potential to speed up the counting dramatically.</span>

<span class="sd">        This method follows a computational approach which is similar</span>
<span class="sd">        to the hypothetical memoized recursive function, but with two</span>
<span class="sd">        differences:</span>

<span class="sd">        1) This method is iterative, borrowing its structure from the</span>
<span class="sd">           other enumerations and maintaining an explicit stack of</span>
<span class="sd">           parts which are in the process of being counted.  (There</span>
<span class="sd">           may be multisets which can be counted reasonably quickly by</span>
<span class="sd">           this implementation, but which would overflow the default</span>
<span class="sd">           Python recursion limit with a recursive implementation.)</span>

<span class="sd">        2) Instead of using the part data structure directly, a more</span>
<span class="sd">           compact key is constructed.  This saves space, but more</span>
<span class="sd">           importantly coalesces some parts which would remain</span>
<span class="sd">           separate with physical keys.</span>

<span class="sd">        Unlike the enumeration functions, there is currently no _range</span>
<span class="sd">        version of count_partitions.  If someone wants to stretch</span>
<span class="sd">        their brain, it should be possible to construct one by</span>
<span class="sd">        memoizing with a histogram of counts rather than a single</span>
<span class="sd">        count, and combining the histograms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># number of partitions so far in the enumeration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c"># dp_stack is list of lists of (part_key, start_count) pairs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dp_stack</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># dp_map is map part_key-&gt; count, where count represents the</span>
        <span class="c"># number of multiset which are descendants of a part with this</span>
        <span class="c"># key, **or any of its decrements**</span>

        <span class="c"># Thus, when we find a part in the map, we add its count</span>
        <span class="c"># value to the running total, cut off the enumeration, and</span>
        <span class="c"># backtrack</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;dp_map&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dp_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_enumeration</span><span class="p">(</span><span class="n">multiplicities</span><span class="p">)</span>
        <span class="n">pkey</span> <span class="o">=</span> <span class="n">part_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dp_stack</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">pkey</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">])</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">spread_part_multiplicity</span><span class="p">():</span>
                <span class="n">pkey</span> <span class="o">=</span> <span class="n">part_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">pkey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp_map</span><span class="p">:</span>
                    <span class="c"># Already have a cached value for the count of the</span>
                    <span class="c"># subtree rooted at this part.  Add it to the</span>
                    <span class="c"># running counter, and break out of the spread</span>
                    <span class="c"># loop.  The -1 below is to compensate for the</span>
                    <span class="c"># leaf that this code path would otherwise find,</span>
                    <span class="c"># and which gets incremented for below.</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dp_map</span><span class="p">[</span><span class="n">pkey</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dp_stack</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">pkey</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span><span class="p">),</span> <span class="p">])</span>

            <span class="c"># M4  count a leaf partition</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c"># M5 (Decrease v)</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrement_part</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">()):</span>
                <span class="c"># M6 (Backtrack)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">oldcount</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dp_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dp_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span> <span class="o">-</span> <span class="n">oldcount</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lpart</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="c"># At this point have successfully decremented the part on</span>
            <span class="c"># the stack and it does not appear in the cache.  It needs</span>
            <span class="c"># to be added to the list at the top of dp_stack</span>
            <span class="n">pkey</span> <span class="o">=</span> <span class="n">part_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top_part</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dp_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pkey</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcount</span><span class="p">),)</span>

</div></div>
<span class="k">def</span> <span class="nf">part_key</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper for MultisetPartitionTraverser.count_partitions that</span>
<span class="sd">    creates a key for ``part``, that only includes information which can</span>
<span class="sd">    affect the count for that part.  (Any irrelevant information just</span>
<span class="sd">    reduces the effectiveness of dynamic programming.)</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>

<span class="sd">    This member function is a candidate for future exploration. There</span>
<span class="sd">    are likely symmetries that can be exploited to coalesce some</span>
<span class="sd">    ``part_key`` values, and thereby save space and improve</span>
<span class="sd">    performance.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># The component number is irrelevant for counting partitions, so</span>
    <span class="c"># leave it out of the memo key.</span>
    <span class="n">rval</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
        <span class="n">rval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>
        <span class="n">rval</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ps</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rval</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../../index.html">SymPy 0.7.5 documentation</a> &raquo;</li>
          <li><a href="../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../../sympy.html" >sympy</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014 SymPy Development Team.
      Last updated on Feb 22, 2014.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>