
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ODE &#8212; SymPy 1.1.1 documentation</title>
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link href="http://docs.sympy.org/latest/modules/solvers/ode.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="PDE" href="pde.html" />
    <link rel="prev" title="Stats" href="../stats.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pde.html" title="PDE"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../stats.html" title="Stats"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">SymPy Modules Reference</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ode">
<span id="ode-docs"></span><h1>ODE<a class="headerlink" href="#ode" title="Permalink to this headline">¶</a></h1>
<div class="section" id="user-functions">
<h2>User Functions<a class="headerlink" href="#user-functions" title="Permalink to this headline">¶</a></h2>
<p>These are functions that are imported into the global namespace with <code class="docutils literal"><span class="pre">from</span>
<span class="pre">sympy</span> <span class="pre">import</span> <span class="pre">*</span></code>.  These functions (unlike <a class="reference internal" href="#hint-functions">Hint Functions</a>, below) are
intended for use by ordinary users of SymPy.</p>
<div class="section" id="dsolve">
<h3><code class="xref py py-func docutils literal"><span class="pre">dsolve()</span></code><a class="headerlink" href="#dsolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.dsolve">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">dsolve</code><span class="sig-paren">(</span><em>eq</em>, <em>func=None</em>, <em>hint='default'</em>, <em>simplify=True</em>, <em>ics=None</em>, <em>xi=None</em>, <em>eta=None</em>, <em>x0=0</em>, <em>n=6</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#dsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.dsolve" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Solves any (supported) kind of ordinary differential equation and
system of ordinary differential equations.</div></blockquote>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">Eq(f(x), C1*sin(3*x) + C2*cos(3*x))</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -acos(C1/cos(x)) + 2*pi), Eq(f(x), acos(C1/cos(x)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -acos(C1/sqrt(-cos(x)**2)) + 2*pi), Eq(f(x), acos(C1/sqrt(-cos(x)**2)))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, y&#39;</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">12</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span> <span class="mi">21</span><span class="o">*</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[Eq(x(t), C1*x0 + C2*x0*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0**2, t)),</span>
<span class="go">Eq(y(t), C1*y0 + C2(y0*Integral(8*exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0**2, t) +</span>
<span class="go">exp(Integral(7*t, t))*exp(Integral(12*t, t))/x0))]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">Derivative</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="n">t</span><span class="p">),</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">{Eq(x(t), -exp(C1)/(C2*exp(C1) - cos(t))), Eq(y(t), -1/(C1 - cos(t)))}</span>
</pre></div>
</div>
<p class="rubric">For Single Ordinary Differential Equation</p>
<p>It is classified under this when number of equation in <code class="docutils literal"><span class="pre">eq</span></code> is one.
<strong>Usage</strong></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span> <span class="pre">hint)</span></code> -&gt; Solve ordinary differential equation
<code class="docutils literal"><span class="pre">eq</span></code> for function <code class="docutils literal"><span class="pre">f(x)</span></code>, using method <code class="docutils literal"><span class="pre">hint</span></code>.</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">eq</span></code> can be any supported ordinary differential equation (see the</dt>
<dd><a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal"><span class="pre">ode</span></code></a> docstring for supported methods).
This can either be an <a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal"><span class="pre">Equality</span></code></a>,
or an expression, which is assumed to be equal to <code class="docutils literal"><span class="pre">0</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">f(x)</span></code> is a function of one variable whose derivatives in that</dt>
<dd>variable make up the ordinary differential equation <code class="docutils literal"><span class="pre">eq</span></code>.  In
many cases it is not necessary to provide this; it will be
autodetected (and an error raised if it couldn’t be detected).</dd>
<dt><code class="docutils literal"><span class="pre">hint</span></code> is the solving method that you want dsolve to use.  Use</dt>
<dd><code class="docutils literal"><span class="pre">classify_ode(eq,</span> <span class="pre">f(x))</span></code> to get all of the possible hints for an
ODE.  The default hint, <code class="docutils literal"><span class="pre">default</span></code>, will use whatever hint is
returned first by <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a>.  See
Hints below for more options that you can use for hint.</dd>
<dt><code class="docutils literal"><span class="pre">simplify</span></code> enables simplification by</dt>
<dd><a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a>.  See its docstring for more
information.  Turn this off, for example, to disable solving of
solutions for <code class="docutils literal"><span class="pre">func</span></code> or simplification of arbitrary constants.
It will still integrate with this hint. Note that the solution may
contain more arbitrary constants than the order of the ODE with
this option enabled.</dd>
<dt><code class="docutils literal"><span class="pre">xi</span></code> and <code class="docutils literal"><span class="pre">eta</span></code> are the infinitesimal functions of an ordinary</dt>
<dd>differential equation. They are the infinitesimals of the Lie group
of point transformations for which the differential equation is
invariant. The user can specify values for the infinitesimals. If
nothing is specified, <code class="docutils literal"><span class="pre">xi</span></code> and <code class="docutils literal"><span class="pre">eta</span></code> are calculated using
<a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal"><span class="pre">infinitesimals()</span></code></a> with the help of various
heuristics.</dd>
<dt><code class="docutils literal"><span class="pre">ics</span></code> is the set of boundary conditions for the differential equation.</dt>
<dd>It should be given in the form of <code class="docutils literal"><span class="pre">{f(x0):</span> <span class="pre">x1,</span> <span class="pre">f(x).diff(x).subs(x,</span> <span class="pre">x2):</span>
<span class="pre">x3}</span></code> and so on. For now initial conditions are implemented only for
power series solutions of first-order differential equations which should
be given in the form of <code class="docutils literal"><span class="pre">{f(x0):</span> <span class="pre">x1}</span></code> (See issue 4720). If nothing is
specified for this case <code class="docutils literal"><span class="pre">f(0)</span></code> is assumed to be <code class="docutils literal"><span class="pre">C0</span></code> and the power
series solution is calculated about 0.</dd>
<dt><code class="docutils literal"><span class="pre">x0</span></code> is the point about which the power series solution of a differential</dt>
<dd>equation is to be evaluated.</dd>
<dt><code class="docutils literal"><span class="pre">n</span></code> gives the exponent of the dependent variable up to which the power series</dt>
<dd>solution of a differential equation is to be evaluated.</dd>
</dl>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote>
<div><p>Aside from the various solving methods, there are also some meta-hints
that you can pass to <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>:</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">default</span></code>:</dt>
<dd>This uses whatever hint is returned first by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a>. This is the
default argument to <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>.</dd>
<dt><code class="docutils literal"><span class="pre">all</span></code>:</dt>
<dd><p class="first">To make <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> apply all
relevant classification hints, use <code class="docutils literal"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&quot;all&quot;)</span></code>.  This will return a dictionary of
<code class="docutils literal"><span class="pre">hint:solution</span></code> terms.  If a hint causes dsolve to raise the
<code class="docutils literal"><span class="pre">NotImplementedError</span></code>, value of that hint’s key will be the
exception object raised.  The dictionary will also include
some special keys:</p>
<ul class="last simple">
<li><code class="docutils literal"><span class="pre">order</span></code>: The order of the ODE.  See also
<a class="reference internal" href="solvers.html#sympy.solvers.deutils.ode_order" title="sympy.solvers.deutils.ode_order"><code class="xref py py-meth docutils literal"><span class="pre">ode_order()</span></code></a> in
<code class="docutils literal"><span class="pre">deutils.py</span></code>.</li>
<li><code class="docutils literal"><span class="pre">best</span></code>: The simplest hint; what would be returned by
<code class="docutils literal"><span class="pre">best</span></code> below.</li>
<li><code class="docutils literal"><span class="pre">best_hint</span></code>: The hint that would produce the solution
given by <code class="docutils literal"><span class="pre">best</span></code>.  If more than one hint produces the best
solution, the first one in the tuple returned by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> is chosen.</li>
<li><code class="docutils literal"><span class="pre">default</span></code>: The solution that would be returned by default.
This is the one produced by the hint that appears first in
the tuple returned by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a>.</li>
</ul>
</dd>
<dt><code class="docutils literal"><span class="pre">all_Integral</span></code>:</dt>
<dd>This is the same as <code class="docutils literal"><span class="pre">all</span></code>, except if a hint also has a
corresponding <code class="docutils literal"><span class="pre">_Integral</span></code> hint, it only returns the
<code class="docutils literal"><span class="pre">_Integral</span></code> hint.  This is useful if <code class="docutils literal"><span class="pre">all</span></code> causes
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> to hang because of a
difficult or impossible integral.  This meta-hint will also be
much faster than <code class="docutils literal"><span class="pre">all</span></code>, because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal"><span class="pre">integrate()</span></code></a> is an expensive
routine.</dd>
<dt><code class="docutils literal"><span class="pre">best</span></code>:</dt>
<dd>To have <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> try all methods
and return the simplest one.  This takes into account whether
the solution is solvable in the function, whether it contains
any Integral classes (i.e.  unevaluatable integrals), and
which one is the shortest in size.</dd>
</dl>
<p>See also the <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> docstring for
more info on hints, and the <a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal"><span class="pre">ode</span></code></a> docstring for
a list of all supported hints.</p>
</div></blockquote>
<p><strong>Tips</strong></p>
<blockquote>
<div><ul>
<li><p class="first">You can declare the derivative of an unknown function this way:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span> <span class="c1"># x is the independent variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># f is a function of x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># f_ will be the derivative of f with respect to x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_</span> <span class="o">=</span> <span class="n">Derivative</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">See <code class="docutils literal"><span class="pre">test_ode.py</span></code> for many tests, which serves also as a set of
examples for how to use <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>.</p>
</li>
<li><p class="first"><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> always returns an
<a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal"><span class="pre">Equality</span></code></a> class (except for the
case when the hint is <code class="docutils literal"><span class="pre">all</span></code> or <code class="docutils literal"><span class="pre">all_Integral</span></code>).  If possible, it
solves the solution explicitly for the function being solved for.
Otherwise, it returns an implicit solution.</p>
</li>
<li><p class="first">Arbitrary constants are symbols named <code class="docutils literal"><span class="pre">C1</span></code>, <code class="docutils literal"><span class="pre">C2</span></code>, and so on.</p>
</li>
<li><p class="first">Because all solutions should be mathematically equivalent, some
hints may return the exact same result for an ODE. Often, though,
two different hints will return the same solution formatted
differently.  The two should be equivalent. Also note that sometimes
the values of the arbitrary constants in two different solutions may
not be the same, because one constant may have “absorbed” other
constants into it.</p>
</li>
<li><p class="first">Do <code class="docutils literal"><span class="pre">help(ode.ode_&lt;hintname&gt;)</span></code> to get help more information on a
specific hint, where <code class="docutils literal"><span class="pre">&lt;hintname&gt;</span></code> is the name of a hint without
<code class="docutils literal"><span class="pre">_Integral</span></code>.</p>
</li>
</ul>
</div></blockquote>
<p class="rubric">For System Of Ordinary Differential Equations</p>
<dl class="docutils">
<dt><strong>Usage</strong></dt>
<dd><blockquote class="first">
<div><code class="docutils literal"><span class="pre">dsolve(eq,</span> <span class="pre">func)</span></code> -&gt; Solve a system of ordinary differential
equations <code class="docutils literal"><span class="pre">eq</span></code> for <code class="docutils literal"><span class="pre">func</span></code> being list of functions including
<span class="math">\(x(t)\)</span>, <span class="math">\(y(t)\)</span>, <span class="math">\(z(t)\)</span> where number of functions in the list depends
upon the number of equations provided in <code class="docutils literal"><span class="pre">eq</span></code>.</div></blockquote>
<p><strong>Details</strong></p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">eq</span></code> can be any supported system of ordinary differential equations
This can either be an <a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal"><span class="pre">Equality</span></code></a>,
or an expression, which is assumed to be equal to <code class="docutils literal"><span class="pre">0</span></code>.</p>
<p><code class="docutils literal"><span class="pre">func</span></code> holds <code class="docutils literal"><span class="pre">x(t)</span></code> and <code class="docutils literal"><span class="pre">y(t)</span></code> being functions of one variable which
together with some of their derivatives make up the system of ordinary
differential equation <code class="docutils literal"><span class="pre">eq</span></code>. It is not necessary to provide this; it
will be autodetected (and an error raised if it couldn’t be detected).</p>
</div></blockquote>
<p><strong>Hints</strong></p>
<blockquote class="last">
<div>The hints are formed by parameters returned by classify_sysode, combining
them give hints name used later for forming method name.</div></blockquote>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="classify-ode">
<h3><code class="xref py py-func docutils literal"><span class="pre">classify_ode()</span></code><a class="headerlink" href="#classify-ode" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.classify_ode">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">classify_ode</code><span class="sig-paren">(</span><em>eq</em>, <em>func=None</em>, <em>dict=False</em>, <em>ics=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#classify_ode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.classify_ode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of possible <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>
classifications for an ODE.</p>
<p>The tuple is ordered so that first item is the classification that
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> uses to solve the ODE by default.  In
general, classifications at the near the beginning of the list will
produce better solutions faster than those near the end, thought there are
always exceptions.  To make <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> use a
different classification, use <code class="docutils literal"><span class="pre">dsolve(ODE,</span> <span class="pre">func,</span>
<span class="pre">hint=&lt;classification&gt;)</span></code>.  See also the
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> docstring for different meta-hints
you can use.</p>
<p>If <code class="docutils literal"><span class="pre">dict</span></code> is true, <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> will
return a dictionary of <code class="docutils literal"><span class="pre">hint:match</span></code> expression terms. This is intended
for internal use by <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>.  Note that
because dictionaries are ordered arbitrarily, this will most likely not be
in the same order as the tuple.</p>
<p>You can get help on different hints by executing
<code class="docutils literal"><span class="pre">help(ode.ode_hintname)</span></code>, where <code class="docutils literal"><span class="pre">hintname</span></code> is the name of the hint
without <code class="docutils literal"><span class="pre">_Integral</span></code>.</p>
<p>See <a class="reference internal" href="#sympy.solvers.ode.allhints" title="sympy.solvers.ode.allhints"><code class="xref py py-data docutils literal"><span class="pre">allhints</span></code></a> or the
<a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal"><span class="pre">ode</span></code></a> docstring for a list of all supported hints
that can be returned from <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a>.</p>
<p class="rubric">Notes</p>
<p>These are remarks on hint names.</p>
<p><code class="docutils literal"><span class="pre">_Integral</span></code></p>
<blockquote>
<div><p>If a classification has <code class="docutils literal"><span class="pre">_Integral</span></code> at the end, it will return the
expression with an unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a>
class in it.  Note that a hint may do this anyway if
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal"><span class="pre">integrate()</span></code></a> cannot do the integral,
though just using an <code class="docutils literal"><span class="pre">_Integral</span></code> will do so much faster.  Indeed, an
<code class="docutils literal"><span class="pre">_Integral</span></code> hint will always be faster than its corresponding hint
without <code class="docutils literal"><span class="pre">_Integral</span></code> because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal"><span class="pre">integrate()</span></code></a> is an expensive routine.
If <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> hangs, it is probably because
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal"><span class="pre">integrate()</span></code></a> is hanging on a tough or
impossible integral.  Try using an <code class="docutils literal"><span class="pre">_Integral</span></code> hint or
<code class="docutils literal"><span class="pre">all_Integral</span></code> to get it return something.</p>
<p>Note that some hints do not have <code class="docutils literal"><span class="pre">_Integral</span></code> counterparts.  This is
because <code class="xref py py-meth docutils literal"><span class="pre">integrate()</span></code> is not used in solving
the ODE for those method. For example, <span class="math">\(n\)</span>th order linear homogeneous
ODEs with constant coefficients do not require integration to solve,
so there is no <code class="docutils literal"><span class="pre">nth_linear_homogeneous_constant_coeff_Integrate</span></code>
hint. You can easily evaluate any unevaluated
<a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a>s in an expression by doing
<code class="docutils literal"><span class="pre">expr.doit()</span></code>.</p>
</div></blockquote>
<p>Ordinals</p>
<blockquote>
<div>Some hints contain an ordinal such as <code class="docutils literal"><span class="pre">1st_linear</span></code>.  This is to help
differentiate them from other hints, as well as from other methods
that may not be implemented yet. If a hint has <code class="docutils literal"><span class="pre">nth</span></code> in it, such as
the <code class="docutils literal"><span class="pre">nth_linear</span></code> hints, this means that the method used to applies
to ODEs of any order.</div></blockquote>
<p><code class="docutils literal"><span class="pre">indep</span></code> and <code class="docutils literal"><span class="pre">dep</span></code></p>
<blockquote>
<div>Some hints contain the words <code class="docutils literal"><span class="pre">indep</span></code> or <code class="docutils literal"><span class="pre">dep</span></code>.  These reference
the independent variable and the dependent function, respectively. For
example, if an ODE is in terms of <span class="math">\(f(x)\)</span>, then <code class="docutils literal"><span class="pre">indep</span></code> will refer to
<span class="math">\(x\)</span> and <code class="docutils literal"><span class="pre">dep</span></code> will refer to <span class="math">\(f\)</span>.</div></blockquote>
<p><code class="docutils literal"><span class="pre">subs</span></code></p>
<blockquote>
<div>If a hints has the word <code class="docutils literal"><span class="pre">subs</span></code> in it, it means the the ODE is solved
by substituting the expression given after the word <code class="docutils literal"><span class="pre">subs</span></code> for a
single dummy variable.  This is usually in terms of <code class="docutils literal"><span class="pre">indep</span></code> and
<code class="docutils literal"><span class="pre">dep</span></code> as above.  The substituted expression will be written only in
characters allowed for names of Python objects, meaning operators will
be spelled out.  For example, <code class="docutils literal"><span class="pre">indep</span></code>/<code class="docutils literal"><span class="pre">dep</span></code> will be written as
<code class="docutils literal"><span class="pre">indep_div_dep</span></code>.</div></blockquote>
<p><code class="docutils literal"><span class="pre">coeff</span></code></p>
<blockquote>
<div>The word <code class="docutils literal"><span class="pre">coeff</span></code> in a hint refers to the coefficients of something
in the ODE, usually of the derivative terms.  See the docstring for
the individual methods for more info (<code class="docutils literal"><span class="pre">help(ode)</span></code>).  This is
contrast to <code class="docutils literal"><span class="pre">coefficients</span></code>, as in <code class="docutils literal"><span class="pre">undetermined_coefficients</span></code>,
which refers to the common name of a method.</div></blockquote>
<p><code class="docutils literal"><span class="pre">_best</span></code></p>
<blockquote>
<div>Methods that have more than one fundamental way to solve will have a
hint for each sub-method and a <code class="docutils literal"><span class="pre">_best</span></code> meta-classification. This
will evaluate all hints and return the best, using the same
considerations as the normal <code class="docutils literal"><span class="pre">best</span></code> meta-hint.</div></blockquote>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">classify_ode</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">(&#39;separable&#39;, &#39;1st_linear&#39;, &#39;1st_homogeneous_coeff_best&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;,</span>
<span class="go">&#39;1st_power_series&#39;, &#39;lie_group&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_homogeneous&#39;,</span>
<span class="go">&#39;separable_Integral&#39;, &#39;1st_linear_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;,</span>
<span class="go">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">classify_ode</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;,</span>
<span class="go">&#39;nth_linear_constant_coeff_variation_of_parameters_Integral&#39;)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="checkodesol">
<h3><code class="xref py py-func docutils literal"><span class="pre">checkodesol()</span></code><a class="headerlink" href="#checkodesol" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.checkodesol">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">checkodesol</code><span class="sig-paren">(</span><em>ode</em>, <em>sol</em>, <em>func=None</em>, <em>order='auto'</em>, <em>solve_for_func=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#checkodesol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.checkodesol" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitutes <code class="docutils literal"><span class="pre">sol</span></code> into <code class="docutils literal"><span class="pre">ode</span></code> and checks that the result is <code class="docutils literal"><span class="pre">0</span></code>.</p>
<p>This only works when <code class="docutils literal"><span class="pre">func</span></code> is one function, like <span class="math">\(f(x)\)</span>.  <code class="docutils literal"><span class="pre">sol</span></code> can
be a single solution or a list of solutions.  Each solution may be an
<a class="reference internal" href="../core.html#sympy.core.relational.Equality" title="sympy.core.relational.Equality"><code class="xref py py-class docutils literal"><span class="pre">Equality</span></code></a> that the solution satisfies,
e.g. <code class="docutils literal"><span class="pre">Eq(f(x),</span> <span class="pre">C1),</span> <span class="pre">Eq(f(x)</span> <span class="pre">+</span> <span class="pre">C1,</span> <span class="pre">0)</span></code>; or simply an
<a class="reference internal" href="../core.html#sympy.core.expr.Expr" title="sympy.core.expr.Expr"><code class="xref py py-class docutils literal"><span class="pre">Expr</span></code></a>, e.g. <code class="docutils literal"><span class="pre">f(x)</span> <span class="pre">-</span> <span class="pre">C1</span></code>. In most cases it
will not be necessary to explicitly identify the function, but if the
function cannot be inferred from the original equation it can be supplied
through the <code class="docutils literal"><span class="pre">func</span></code> argument.</p>
<p>If a sequence of solutions is passed, the same sort of container will be
used to return the result for each solution.</p>
<p>It tries the following methods, in order, until it finds zero equivalence:</p>
<ol class="arabic simple">
<li>Substitute the solution for <span class="math">\(f\)</span> in the original equation.  This only
works if <code class="docutils literal"><span class="pre">ode</span></code> is solved for <span class="math">\(f\)</span>.  It will attempt to solve it first
unless <code class="docutils literal"><span class="pre">solve_for_func</span> <span class="pre">==</span> <span class="pre">False</span></code>.</li>
<li>Take <span class="math">\(n\)</span> derivatives of the solution, where <span class="math">\(n\)</span> is the order of
<code class="docutils literal"><span class="pre">ode</span></code>, and check to see if that is equal to the solution.  This only
works on exact ODEs.</li>
<li>Take the 1st, 2nd, …, <span class="math">\(n\)</span>th derivatives of the solution, each time
solving for the derivative of <span class="math">\(f\)</span> of that order (this will always be
possible because <span class="math">\(f\)</span> is a linear operator). Then back substitute each
derivative into <code class="docutils literal"><span class="pre">ode</span></code> in reverse order.</li>
</ol>
<p>This function returns a tuple.  The first item in the tuple is <code class="docutils literal"><span class="pre">True</span></code> if
the substitution results in <code class="docutils literal"><span class="pre">0</span></code>, and <code class="docutils literal"><span class="pre">False</span></code> otherwise. The second
item in the tuple is what the substitution results in.  It should always
be <code class="docutils literal"><span class="pre">0</span></code> if the first item is <code class="docutils literal"><span class="pre">True</span></code>. Note that sometimes this function
will <code class="docutils literal"><span class="pre">False</span></code>, but with an expression that is identically equal to <code class="docutils literal"><span class="pre">0</span></code>,
instead of returning <code class="docutils literal"><span class="pre">True</span></code>.  This is because
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.simplify" title="sympy.simplify.simplify.simplify"><code class="xref py py-meth docutils literal"><span class="pre">simplify()</span></code></a> cannot reduce the expression
to <code class="docutils literal"><span class="pre">0</span></code>.  If an expression returned by this function vanishes
identically, then <code class="docutils literal"><span class="pre">sol</span></code> really is a solution to <code class="docutils literal"><span class="pre">ode</span></code>.</p>
<p>If this function seems to hang, it is probably because of a hard
simplification.</p>
<p>To use this function to test, test the first item of the tuple.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">checkodesol</span><span class="p">,</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">(True, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(False, 2)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="homogeneous-order">
<h3><code class="xref py py-func docutils literal"><span class="pre">homogeneous_order()</span></code><a class="headerlink" href="#homogeneous-order" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.homogeneous_order">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">homogeneous_order</code><span class="sig-paren">(</span><em>eq</em>, <em>*symbols</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#homogeneous_order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.homogeneous_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the order <span class="math">\(n\)</span> if <span class="math">\(g\)</span> is homogeneous and <code class="docutils literal"><span class="pre">None</span></code> if it is not
homogeneous.</p>
<p>Determines if a function is homogeneous and if so of what order.  A
function <span class="math">\(f(x, y, \cdots)\)</span> is homogeneous of order <span class="math">\(n\)</span> if <span class="math">\(f(t x, t y,
\cdots) = t^n f(x, y, \cdots)\)</span>.</p>
<p>If the function is of two variables, <span class="math">\(F(x, y)\)</span>, then <span class="math">\(f\)</span> being homogeneous
of any order is equivalent to being able to rewrite <span class="math">\(F(x, y)\)</span> as <span class="math">\(G(x/y)\)</span>
or <span class="math">\(H(y/x)\)</span>.  This fact is used to solve 1st order ordinary differential
equations whose coefficients are homogeneous of the same order (see the
docstrings of
<code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code> and
<code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code>).</p>
<p>Symbols can be functions, but every argument of the function must be a
symbol, and the arguments of the function that appear in the expression
must match those given in the list of symbols.  If a declared function
appears with different arguments than given in the list of symbols,
<code class="docutils literal"><span class="pre">None</span></code> is returned.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">homogeneous_order</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">homogeneous_order</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="infinitesimals">
<h3><code class="xref py py-func docutils literal"><span class="pre">infinitesimals()</span></code><a class="headerlink" href="#infinitesimals" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.infinitesimals">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">infinitesimals</code><span class="sig-paren">(</span><em>eq</em>, <em>func=None</em>, <em>order=None</em>, <em>hint='default'</em>, <em>match=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#infinitesimals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.infinitesimals" title="Permalink to this definition">¶</a></dt>
<dd><p>The infinitesimal functions of an ordinary differential equation, <span class="math">\(\xi(x,y)\)</span>
and <span class="math">\(\eta(x,y)\)</span>, are the infinitesimals of the Lie group of point transformations
for which the differential equation is invariant. So, the ODE <span class="math">\(y'=f(x,y)\)</span>
would admit a Lie group <span class="math">\(x^*=X(x,y;\varepsilon)=x+\varepsilon\xi(x,y)\)</span>,
<span class="math">\(y^*=Y(x,y;\varepsilon)=y+\varepsilon\eta(x,y)\)</span> such that <span class="math">\((y^*)'=f(x^*, y^*)\)</span>.
A change of coordinates, to <span class="math">\(r(x,y)\)</span> and <span class="math">\(s(x,y)\)</span>, can be performed so this Lie group
becomes the translation group, <span class="math">\(r^*=r\)</span> and <span class="math">\(s^*=s+\varepsilon\)</span>.
They are tangents to the coordinate curves of the new system.</p>
<p>Consider the transformation <span class="math">\((x, y) \to (X, Y)\)</span> such that the
differential equation remains invariant. <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span> are the tangents to
the transformed coordinates <span class="math">\(X\)</span> and <span class="math">\(Y\)</span>, at <span class="math">\(\varepsilon=0\)</span>.</p>
<div class="math">
\[\left(\frac{\partial X(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \xi,
\left(\frac{\partial Y(x,y;\varepsilon)}{\partial\varepsilon
  }\right)|_{\varepsilon=0} = \eta,\]</div>
<p>The infinitesimals can be found by solving the following PDE:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">,</span> <span class="s1">&#39;eta&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># dy/dx = h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">eta</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">h</span>
<span class="gp">... </span><span class="o">-</span> <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">xi</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">/d               d           \                     d              2       d</span>
<span class="go">|--(eta(x, y)) - --(xi(x, y))|*h(x, y) - eta(x, y)*--(h(x, y)) - h (x, y)*--(x</span>
<span class="go">\dy              dx          /                     dy                     dy</span>

<span class="go">                    d             d</span>
<span class="go">i(x, y)) - xi(x, y)*--(h(x, y)) + --(eta(x, y)) = 0</span>
<span class="go">                    dx            dx</span>
</pre></div>
</div>
<p>Solving the above mentioned PDE is not trivial, and can be solved only by
making intelligent assumptions for <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span> (heuristics). Once an
infinitesimal is found, the attempt to find more heuristics stops. This is done to
optimise the speed of solving the differential equation. If a list of all the
infinitesimals is needed, <code class="docutils literal"><span class="pre">hint</span></code> should be flagged as <code class="docutils literal"><span class="pre">all</span></code>, which gives
the complete list of infinitesimals. If the infinitesimals for a particular
heuristic needs to be found, it can be passed as a flag to <code class="docutils literal"><span class="pre">hint</span></code>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">infinitesimals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">infinitesimals</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>
<span class="go">[{eta(x, f(x)): exp(x**3/3), xi(x, f(x)): 0}]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="checkinfsol">
<h3><code class="xref py py-func docutils literal"><span class="pre">checkinfsol()</span></code><a class="headerlink" href="#checkinfsol" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.checkinfsol">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">checkinfsol</code><span class="sig-paren">(</span><em>eq</em>, <em>infinitesimals</em>, <em>func=None</em>, <em>order=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#checkinfsol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.checkinfsol" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is used to check if the given infinitesimals are the
actual infinitesimals of the given first order differential equation.
This method is specific to the Lie Group Solver of ODEs.</p>
<p>As of now, it simply checks, by substituting the infinitesimals in the
partial differential equation.</p>
<div class="math">
\[\frac{\partial \eta}{\partial x} + \left(\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x}\right)*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi\frac{\partial h}{\partial x} - \eta\frac{\partial h}{\partial y} = 0\]</div>
<p>where <span class="math">\(\eta\)</span>, and <span class="math">\(\xi\)</span> are the infinitesimals and <span class="math">\(h(x,y) = \frac{dy}{dx}\)</span></p>
<p>The infinitesimals should be given in the form of a list of dicts
<code class="docutils literal"><span class="pre">[{xi(x,</span> <span class="pre">y):</span> <span class="pre">inf,</span> <span class="pre">eta(x,</span> <span class="pre">y):</span> <span class="pre">inf}]</span></code>, corresponding to the
output of the function infinitesimals. It returns a list
of values of the form <code class="docutils literal"><span class="pre">[(True/False,</span> <span class="pre">sol)]</span></code> where <code class="docutils literal"><span class="pre">sol</span></code> is the value
obtained after substituting the infinitesimals in the PDE. If it
is <code class="docutils literal"><span class="pre">True</span></code>, then <code class="docutils literal"><span class="pre">sol</span></code> would be 0.</p>
</dd></dl>

</div>
</div>
<div class="section" id="hint-functions">
<h2>Hint Functions<a class="headerlink" href="#hint-functions" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> and others.  Unlike <a class="reference internal" href="#user-functions">User Functions</a>,
above, these are not intended for every-day use by ordinary SymPy users.
Instead, functions such as <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> should be used.
Nonetheless, these functions contain useful information in their docstrings on
the various ODE solving methods. For this reason, they are documented here.</p>
<div class="section" id="allhints">
<h3><code class="xref py py-obj docutils literal"><span class="pre">allhints</span></code><a class="headerlink" href="#allhints" title="Permalink to this headline">¶</a></h3>
<dl class="data">
<dt id="sympy.solvers.ode.allhints">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">allhints</code><em class="property"> = ('separable', '1st_exact', '1st_linear', 'Bernoulli', 'Riccati_special_minus2', '1st_homogeneous_coeff_best', '1st_homogeneous_coeff_subs_indep_div_dep', '1st_homogeneous_coeff_subs_dep_div_indep', 'almost_linear', 'linear_coefficients', 'separable_reduced', '1st_power_series', 'lie_group', 'nth_linear_constant_coeff_homogeneous', 'nth_linear_euler_eq_homogeneous', 'nth_linear_constant_coeff_undetermined_coefficients', 'nth_linear_euler_eq_nonhomogeneous_undetermined_coefficients', 'nth_linear_constant_coeff_variation_of_parameters', 'nth_linear_euler_eq_nonhomogeneous_variation_of_parameters', 'Liouville', '2nd_power_series_ordinary', '2nd_power_series_regular', 'separable_Integral', '1st_exact_Integral', '1st_linear_Integral', 'Bernoulli_Integral', '1st_homogeneous_coeff_subs_indep_div_dep_Integral', '1st_homogeneous_coeff_subs_dep_div_indep_Integral', 'almost_linear_Integral', 'linear_coefficients_Integral', 'separable_reduced_Integral', 'nth_linear_constant_coeff_variation_of_parameters_Integral', 'nth_linear_euler_eq_nonhomogeneous_variation_of_parameters_Integral', 'Liouville_Integral')</em><a class="headerlink" href="#sympy.solvers.ode.allhints" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a list of hints in the order that they should be preferred by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a>. In general, hints earlier in the
list should produce simpler solutions than those later in the list (for
ODEs that fit both).  For now, the order of this list is based on empirical
observations by the developers of SymPy.</p>
<p>The hint used by <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> for a specific ODE
can be overridden (see the docstring).</p>
<p>In general, <code class="docutils literal"><span class="pre">_Integral</span></code> hints are grouped at the end of the list, unless
there is a method that returns an unevaluable integral most of the time
(which go near the end of the list anyway).  <code class="docutils literal"><span class="pre">default</span></code>, <code class="docutils literal"><span class="pre">all</span></code>,
<code class="docutils literal"><span class="pre">best</span></code>, and <code class="docutils literal"><span class="pre">all_Integral</span></code> meta-hints should not be included in this
list, but <code class="docutils literal"><span class="pre">_best</span></code> and <code class="docutils literal"><span class="pre">_Integral</span></code> hints should be included.</p>
</dd></dl>

</div>
<div class="section" id="odesimp">
<h3><code class="xref py py-obj docutils literal"><span class="pre">odesimp</span></code><a class="headerlink" href="#odesimp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.odesimp">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">odesimp</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>constants</em>, <em>hint</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#odesimp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.odesimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies ODEs, including trying to solve for <code class="docutils literal"><span class="pre">func</span></code> and running
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal"><span class="pre">constantsimp()</span></code></a>.</p>
<p>It may use knowledge of the type of solution that the hint returns to
apply additional simplifications.</p>
<p>It also attempts to integrate any <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a>s
in the expression, if the hint is not an <code class="docutils literal"><span class="pre">_Integral</span></code> hint.</p>
<p>This function should have no effect on expressions returned by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>, as
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> already calls
<a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a>, but the individual hint functions
do not call <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a> (because the
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> wrapper does).  Therefore, this
function is designed for mainly internal use.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">odesimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,u2,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">                        x</span>
<span class="go">                       ----</span>
<span class="go">                       f(x)</span>
<span class="go">                         /</span>
<span class="go">                        |</span>
<span class="go">                        |   /        1   \</span>
<span class="go">                        |  -|u2 + -------|</span>
<span class="go">                        |   |        /1 \|</span>
<span class="go">                        |   |     sin|--||</span>
<span class="go">                        |   \        \u2//</span>
<span class="go">log(f(x)) = log(C1) +   |  ---------------- d(u2)</span>
<span class="go">                        |          2</span>
<span class="go">                        |        u2</span>
<span class="go">                        |</span>
<span class="go">                       /</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">odesimp</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">},</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span>
<span class="gp">... </span><span class="p">))</span> 
<span class="go">    x</span>
<span class="go">--------- = C1</span>
<span class="go">   /f(x)\</span>
<span class="go">tan|----|</span>
<span class="go">   \2*x /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constant-renumber">
<h3><code class="xref py py-obj docutils literal"><span class="pre">constant_renumber</span></code><a class="headerlink" href="#constant-renumber" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.constant_renumber">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">constant_renumber</code><span class="sig-paren">(</span><em>expr</em>, <em>symbolname</em>, <em>startnumber</em>, <em>endnumber</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#constant_renumber"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.constant_renumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Renumber arbitrary constants in <code class="docutils literal"><span class="pre">expr</span></code> to have numbers 1 through <span class="math">\(N\)</span>
where <span class="math">\(N\)</span> is <code class="docutils literal"><span class="pre">endnumber</span> <span class="pre">-</span> <span class="pre">startnumber</span> <span class="pre">+</span> <span class="pre">1</span></code> at most.
In the process, this reorders expression terms in a standard way.</p>
<p>This is a simple function that goes through and renumbers any
<a class="reference internal" href="../core.html#sympy.core.symbol.Symbol" title="sympy.core.symbol.Symbol"><code class="xref py py-class docutils literal"><span class="pre">Symbol</span></code></a> with a name in the form <code class="docutils literal"><span class="pre">symbolname</span>
<span class="pre">+</span> <span class="pre">num</span></code> where <code class="docutils literal"><span class="pre">num</span></code> is in the range from <code class="docutils literal"><span class="pre">startnumber</span></code> to
<code class="docutils literal"><span class="pre">endnumber</span></code>.</p>
<p>Symbols are renumbered based on <code class="docutils literal"><span class="pre">.sort_key()</span></code>, so they should be
numbered roughly in the order that they appear in the final, printed
expression.  Note that this ordering is based in part on hashes, so it can
produce different results on different machines.</p>
<p>The structure of this function is very similar to that of
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal"><span class="pre">constantsimp()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">constant_renumber</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,C:5&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Only constants in the given range (inclusive) are renumbered;
the renumbering always starts from 1:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C4</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">C1 + C2 + C4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="n">C1</span> <span class="o">+</span> <span class="n">C3</span> <span class="o">+</span> <span class="n">C4</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">C0 + 2*C1 + C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">C1</span> <span class="o">+</span> <span class="n">C2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">C1 + 3*C2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="go">                2</span>
<span class="go">C1*x + C2 + C3*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">constant_renumber</span><span class="p">(</span><span class="n">C2</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">                2</span>
<span class="go">C1 + C2*x + C3*x</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="constantsimp">
<h3><code class="xref py py-obj docutils literal"><span class="pre">constantsimp</span></code><a class="headerlink" href="#constantsimp" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.constantsimp">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">constantsimp</code><span class="sig-paren">(</span><em>expr</em>, <em>constants</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#constantsimp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.constantsimp" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplifies an expression with arbitrary constants in it.</p>
<p>This function is written specifically to work with
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>, and is not intended for general use.</p>
<p>Simplification is done by “absorbing” the arbitrary constants into other
arbitrary constants, numbers, and symbols that they are not independent
of.</p>
<p>The symbols must all have the same name with numbers after it, for
example, <code class="docutils literal"><span class="pre">C1</span></code>, <code class="docutils literal"><span class="pre">C2</span></code>, <code class="docutils literal"><span class="pre">C3</span></code>.  The <code class="docutils literal"><span class="pre">symbolname</span></code> here would be
‘<code class="docutils literal"><span class="pre">C</span></code>’, the <code class="docutils literal"><span class="pre">startnumber</span></code> would be 1, and the <code class="docutils literal"><span class="pre">endnumber</span></code> would be 3.
If the arbitrary constants are independent of the variable <code class="docutils literal"><span class="pre">x</span></code>, then the
independent symbol would be <code class="docutils literal"><span class="pre">x</span></code>.  There is no need to specify the
dependent function, such as <code class="docutils literal"><span class="pre">f(x)</span></code>, because it already has the
independent symbol, <code class="docutils literal"><span class="pre">x</span></code>, in it.</p>
<p>Because terms are “absorbed” into arbitrary constants and because
constants are renumbered after simplifying, the arbitrary constants in
expr are not necessarily equal to the ones of the same name in the
returned result.</p>
<p>If two or more arbitrary constants are added, multiplied, or raised to the
power of each other, they are first absorbed together into a single
arbitrary constant.  Then the new constant is combined into other terms if
necessary.</p>
<p>Absorption of constants is done with limited assistance:</p>
<ol class="arabic simple">
<li>terms of <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal"><span class="pre">Add</span></code></a>s are collected to try join
constants so <span class="math">\(e^x (C_1 \cos(x) + C_2 \cos(x))\)</span> will simplify to <span class="math">\(e^x
C_1 \cos(x)\)</span>;</li>
<li>powers with exponents that are <a class="reference internal" href="../core.html#sympy.core.add.Add" title="sympy.core.add.Add"><code class="xref py py-class docutils literal"><span class="pre">Add</span></code></a>s are
expanded so <span class="math">\(e^{C_1 + x}\)</span> will be simplified to <span class="math">\(C_1 e^x\)</span>.</li>
</ol>
<p>Use <a class="reference internal" href="#sympy.solvers.ode.constant_renumber" title="sympy.solvers.ode.constant_renumber"><code class="xref py py-meth docutils literal"><span class="pre">constant_renumber()</span></code></a> to renumber constants
after simplification or else arbitrary numbers on constants may appear,
e.g. <span class="math">\(C_1 + C_3 x\)</span>.</p>
<p>In rare cases, a single constant can be “simplified” into two constants.
Every differential equation solution should have as many arbitrary
constants as the order of the differential equation.  The result here will
be technically correct, but it may, for example, have <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> in
an expression, when <span class="math">\(C_1\)</span> is actually equal to <span class="math">\(C_2\)</span>.  Use your discretion
in such situations, and also take advantage of the ability to use hints in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">constantsimp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;C1, C2, C3, x, y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1*x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1 + x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">constantsimp</span><span class="p">(</span><span class="n">C1</span><span class="o">*</span><span class="n">C2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">C2</span> <span class="o">+</span> <span class="n">C3</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">{</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">})</span>
<span class="go">C1 + C3*x</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="sol-simplicity">
<h3><code class="xref py py-obj docutils literal"><span class="pre">sol_simplicity</span></code><a class="headerlink" href="#sol-simplicity" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_sol_simplicity">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_sol_simplicity</code><span class="sig-paren">(</span><em>sol</em>, <em>func</em>, <em>trysolving=True</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_sol_simplicity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_sol_simplicity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an extended integer representing how simple a solution to an ODE
is.</p>
<p>The following things are considered, in order from most simple to least:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">sol</span></code> is solved for <code class="docutils literal"><span class="pre">func</span></code>.</li>
<li><code class="docutils literal"><span class="pre">sol</span></code> is not solved for <code class="docutils literal"><span class="pre">func</span></code>, but can be if passed to solve (e.g.,
a solution returned by <code class="docutils literal"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">simplify=False</span></code>).</li>
<li>If <code class="docutils literal"><span class="pre">sol</span></code> is not solved for <code class="docutils literal"><span class="pre">func</span></code>, then base the result on the
length of <code class="docutils literal"><span class="pre">sol</span></code>, as computed by <code class="docutils literal"><span class="pre">len(str(sol))</span></code>.</li>
<li>If <code class="docutils literal"><span class="pre">sol</span></code> has any unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a>s,
this will automatically be considered less simple than any of the above.</li>
</ul>
<p>This function returns an integer such that if solution A is simpler than
solution B by above metric, then <code class="docutils literal"><span class="pre">ode_sol_simplicity(sola,</span> <span class="pre">func)</span> <span class="pre">&lt;</span>
<span class="pre">ode_sol_simplicity(solb,</span> <span class="pre">func)</span></code>.</p>
<p>Currently, the following are the numbers returned, but if the heuristic is
ever improved, this may change.  Only the ordering is guaranteed.</p>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Simplicity</th>
<th class="head">Return</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">sol</span></code> solved for <code class="docutils literal"><span class="pre">func</span></code></td>
<td><code class="docutils literal"><span class="pre">-2</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">sol</span></code> not solved for <code class="docutils literal"><span class="pre">func</span></code> but can be</td>
<td><code class="docutils literal"><span class="pre">-1</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">sol</span></code> is not solved nor solvable for
<code class="docutils literal"><span class="pre">func</span></code></td>
<td><code class="docutils literal"><span class="pre">len(str(sol))</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">sol</span></code> contains an
<a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a></td>
<td><code class="docutils literal"><span class="pre">oo</span></code></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">oo</span></code> here means the SymPy infinity, which should compare greater than
any integer.</p>
<p>If you already know <a class="reference internal" href="solvers.html#sympy.solvers.solvers.solve" title="sympy.solvers.solvers.solve"><code class="xref py py-meth docutils literal"><span class="pre">solve()</span></code></a> cannot solve
<code class="docutils literal"><span class="pre">sol</span></code>, you can use <code class="docutils literal"><span class="pre">trysolving=False</span></code> to skip that step, which is the
only potentially slow step.  For example,
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> with the <code class="docutils literal"><span class="pre">simplify=False</span></code> flag
should do this.</p>
<p>If <code class="docutils literal"><span class="pre">sol</span></code> is a list of solutions, if the worst solution in the list
returns <code class="docutils literal"><span class="pre">oo</span></code> it returns that, otherwise it returns <code class="docutils literal"><span class="pre">len(str(sol))</span></code>,
that is, the length of the string representation of the whole list.</p>
<p class="rubric">Examples</p>
<p>This function is designed to be passed to <code class="docutils literal"><span class="pre">min</span></code> as the key argument,
such as <code class="docutils literal"><span class="pre">min(listofsolutions,</span> <span class="pre">key=lambda</span> <span class="pre">i:</span> <span class="pre">ode_sol_simplicity(i,</span>
<span class="pre">f(x)))</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">tan</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">Integral</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">ode_sol_simplicity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x, C1, C2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">C1</span><span class="o">*</span><span class="n">Integral</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq1</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)),</span> <span class="n">C1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">tan</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">C2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">]]</span>
<span class="go">[28, 35]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">min</span><span class="p">([</span><span class="n">eq1</span><span class="p">,</span> <span class="n">eq2</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">ode_sol_simplicity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="go">Eq(f(x)/tan(f(x)/(2*x)), C1)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-exact">
<h3><code class="xref py py-obj docutils literal"><span class="pre">1st_exact</span></code><a class="headerlink" href="#st-exact" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_exact">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_1st_exact</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_exact"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_exact" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order exact ordinary differential equations.</p>
<p>A 1st order differential equation is called exact if it is the total
differential of a function. That is, the differential equation</p>
<div class="math">
\[P(x, y) \,\partial{}x + Q(x, y) \,\partial{}y = 0\]</div>
<p>is exact if there is some function <span class="math">\(F(x, y)\)</span> such that <span class="math">\(P(x, y) =
\partial{}F/\partial{}x\)</span> and <span class="math">\(Q(x, y) = \partial{}F/\partial{}y\)</span>.  It can
be shown that a necessary and sufficient condition for a first order ODE
to be exact is that <span class="math">\(\partial{}P/\partial{}y = \partial{}Q/\partial{}x\)</span>.
Then, the solution will be as given below:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">C1</span><span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y,t,x0,y0,C1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">Integral</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">Integral</span><span class="p">(</span><span class="n">Q</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y</span><span class="p">))),</span> <span class="n">C1</span><span class="p">))</span>
<span class="go">            x                y</span>
<span class="go">            /                /</span>
<span class="go">           |                |</span>
<span class="go">F(x, y) =  |  P(t, y) dt +  |  Q(x0, t) dt = C1</span>
<span class="go">           |                |</span>
<span class="go">          /                /</span>
<span class="go">          x0               y0</span>
</pre></div>
</div>
<p>Where the first partials of <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> exist and are continuous in a
simply connected region.</p>
<p>A note: SymPy currently has no way to represent inert substitution on an
expression, so the hint <code class="docutils literal"><span class="pre">1st_exact_Integral</span></code> will return an integral
with <span class="math">\(dy\)</span>.  This is supposed to represent the function that you are
solving for.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Exact_differential_equation">http://en.wikipedia.org/wiki/Exact_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 73</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_exact&#39;</span><span class="p">)</span>
<span class="go">Eq(x*cos(f(x)) + f(x)**3/3, C1)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-best">
<h3><code class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_best</span></code><a class="headerlink" href="#st-homogeneous-coeff-best" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_best">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_1st_homogeneous_coeff_best</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_best"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the best solution to an ODE from the two hints
<code class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></code> and
<code class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></code>.</p>
<p>This is as determined by <a class="reference internal" href="#sympy.solvers.ode.ode_sol_simplicity" title="sympy.solvers.ode.ode_sol_simplicity"><code class="xref py py-meth docutils literal"><span class="pre">ode_sol_simplicity()</span></code></a>.</p>
<p>See the
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code></a>
and
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code></a>
docstrings for more information on these hints.  Note that there is no
<code class="docutils literal"><span class="pre">ode_1st_homogeneous_coeff_best_Integral</span></code> hint.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_best&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-subs-dep-div-indep">
<h3><code class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></code><a class="headerlink" href="#st-homogeneous-coeff-subs-dep-div-indep" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_1st_homogeneous_coeff_subs_dep_div_indep</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_subs_dep_div_indep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <span class="math">\(u_1 = \frac{\text{&lt;dependent
variable&gt;}}{\text{&lt;independent variable&gt;}}\)</span>.</p>
<p>This is a differential equation</p>
<div class="math">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
<p>such that <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are homogeneous and of the same order.  A function
<span class="math">\(F(x, y)\)</span> is homogeneous of order <span class="math">\(n\)</span> if <span class="math">\(F(x t, y t) = t^n F(x, y)\)</span>.
Equivalently, <span class="math">\(F(x, y)\)</span> can be rewritten as <span class="math">\(G(y/x)\)</span> or <span class="math">\(H(x/y)\)</span>.  See
also the docstring of <a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal"><span class="pre">homogeneous_order()</span></code></a>.</p>
<p>If the coefficients <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <span class="math">\(y = u_1 x\)</span> (i.e. <span class="math">\(u_1 = y/x\)</span>) will turn the differential
equation into an equation separable in the variables <span class="math">\(x\)</span> and <span class="math">\(u\)</span>.  If
<span class="math">\(h(u_1)\)</span> is the function that results from making the substitution <span class="math">\(u_1 =
f(x)/x\)</span> on <span class="math">\(P(x, f(x))\)</span> and <span class="math">\(g(u_2)\)</span> is the function that results from the
substitution on <span class="math">\(Q(x, f(x))\)</span> in the differential equation <span class="math">\(P(x, f(x)) +
Q(x, f(x)) f'(x) = 0\)</span>, then the general solution is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> /f(x)\    /f(x)\ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \ x  /    \ x  / dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_dep_div_indep_Integral&#39;</span><span class="p">))</span>
<span class="go">               f(x)</span>
<span class="go">               ----</span>
<span class="go">                x</span>
<span class="go">                 /</span>
<span class="go">                |</span>
<span class="go">                |       -h(u1)</span>
<span class="go">log(x) = C1 +   |  ---------------- d(u1)</span>
<span class="go">                |  u1*h(u1) + g(u1)</span>
<span class="go">                |</span>
<span class="go">               /</span>
</pre></div>
</div>
<p>Where <span class="math">\(u_1 h(u_1) + g(u_1) \ne 0\)</span> and <span class="math">\(x \ne 0\)</span>.</p>
<p>See also the docstrings of
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_best"><code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code></a> and
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code></a>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_dep_div_indep&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                      /          3   \</span>
<span class="go">                      |3*f(x)   f (x)|</span>
<span class="go">                   log|------ + -----|</span>
<span class="go">                      |  x         3 |</span>
<span class="go">                      \           x  /</span>
<span class="go">log(x) = log(C1) - -------------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-homogeneous-coeff-subs-indep-div-dep">
<h3><code class="xref py py-obj docutils literal"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></code><a class="headerlink" href="#st-homogeneous-coeff-subs-indep-div-dep" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_1st_homogeneous_coeff_subs_indep_div_dep</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_homogeneous_coeff_subs_indep_div_dep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a 1st order differential equation with homogeneous coefficients
using the substitution <span class="math">\(u_2 = \frac{\text{&lt;independent
variable&gt;}}{\text{&lt;dependent variable&gt;}}\)</span>.</p>
<p>This is a differential equation</p>
<div class="math">
\[P(x, y) + Q(x, y) dy/dx = 0\]</div>
<p>such that <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are homogeneous and of the same order.  A function
<span class="math">\(F(x, y)\)</span> is homogeneous of order <span class="math">\(n\)</span> if <span class="math">\(F(x t, y t) = t^n F(x, y)\)</span>.
Equivalently, <span class="math">\(F(x, y)\)</span> can be rewritten as <span class="math">\(G(y/x)\)</span> or <span class="math">\(H(x/y)\)</span>.  See
also the docstring of <a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal"><span class="pre">homogeneous_order()</span></code></a>.</p>
<p>If the coefficients <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> in the differential equation above are
homogeneous functions of the same order, then it can be shown that the
substitution <span class="math">\(x = u_2 y\)</span> (i.e. <span class="math">\(u_2 = x/y\)</span>) will turn the differential
equation into an equation separable in the variables <span class="math">\(y\)</span> and <span class="math">\(u_2\)</span>.  If
<span class="math">\(h(u_2)\)</span> is the function that results from making the substitution <span class="math">\(u_2 =
x/f(x)\)</span> on <span class="math">\(P(x, f(x))\)</span> and <span class="math">\(g(u_2)\)</span> is the function that results from the
substitution on <span class="math">\(Q(x, f(x))\)</span> in the differential equation <span class="math">\(P(x, f(x)) +
Q(x, f(x)) f'(x) = 0\)</span>, then the general solution is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go"> / x  \    / x  \ d</span>
<span class="go">g|----| + h|----|*--(f(x))</span>
<span class="go"> \f(x)/    \f(x)/ dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep_Integral&#39;</span><span class="p">))</span>
<span class="go">             x</span>
<span class="go">            ----</span>
<span class="go">            f(x)</span>
<span class="go">              /</span>
<span class="go">             |</span>
<span class="go">             |       -g(u2)</span>
<span class="go">             |  ---------------- d(u2)</span>
<span class="go">             |  u2*g(u2) + h(u2)</span>
<span class="go">             |</span>
<span class="go">            /</span>

<span class="go">f(x) = C1*e</span>
</pre></div>
</div>
<p>Where <span class="math">\(u_2 g(u_2) + h(u_2) \ne 0\)</span> and <span class="math">\(f(x) \ne 0\)</span>.</p>
<p>See also the docstrings of
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_best"><code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code></a> and
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code></a>.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_differential_equation">http://en.wikipedia.org/wiki/Homogeneous_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 59</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_homogeneous_coeff_subs_indep_div_dep&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">                         /    2    \</span>
<span class="go">                         | 3*x     |</span>
<span class="go">                      log|----- + 1|</span>
<span class="go">                         | 2       |</span>
<span class="go">                         \f (x)    /</span>
<span class="go">log(f(x)) = log(C1) - --------------</span>
<span class="go">                            3</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-linear">
<h3><code class="xref py py-obj docutils literal"><span class="pre">1st_linear</span></code><a class="headerlink" href="#st-linear" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_linear">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_1st_linear</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 1st order linear differential equations.</p>
<p>These are differential equations of the form</p>
<div class="math">
\[dy/dx + P(x) y = Q(x)\text{.}\]</div>
<p>These kinds of differential equations can be solved in a general way.  The
integrating factor <span class="math">\(e^{\int P(x) \,dx}\)</span> will turn the equation into a
separable equation.  The general solution is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">sin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_linear_Integral&#39;</span><span class="p">))</span>
<span class="go">       /       /                   \</span>
<span class="go">       |      |                    |</span>
<span class="go">       |      |         /          |     /</span>
<span class="go">       |      |        |           |    |</span>
<span class="go">       |      |        | P(x) dx   |  - | P(x) dx</span>
<span class="go">       |      |        |           |    |</span>
<span class="go">       |      |       /            |   /</span>
<span class="go">f(x) = |C1 +  | Q(x)*e           dx|*e</span>
<span class="go">       |      |                    |</span>
<span class="go">       \     /                     /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation">http://en.wikipedia.org/wiki/Linear_differential_equation#First_order_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 92</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;1st_linear&#39;</span><span class="p">))</span>
<span class="go">f(x) = x*(C1 - cos(x))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="bernoulli">
<h3><code class="xref py py-obj docutils literal"><span class="pre">Bernoulli</span></code><a class="headerlink" href="#bernoulli" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Bernoulli">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_Bernoulli</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Bernoulli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Bernoulli" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves Bernoulli differential equations.</p>
<p>These are equations of the form</p>
<div class="math">
\[dy/dx + P(x) y = Q(x) y^n\text{, }n \ne 1`\text{.}\]</div>
<p>The substitution <span class="math">\(w = 1/y^{1-n}\)</span> will transform an equation of this form
into one that is linear (see the docstring of
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_linear" title="sympy.solvers.ode.ode_1st_linear"><code class="xref py py-meth docutils literal"><span class="pre">ode_1st_linear()</span></code></a>).  The general solution is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">            d                n</span>
<span class="go">P(x)*f(x) + --(f(x)) = Q(x)*f (x)</span>
<span class="go">            dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Bernoulli_Integral&#39;</span><span class="p">))</span> 
<span class="go">                                                                               1</span>
<span class="go">                                                                              ----</span>
<span class="go">                                                                             1 - n</span>
<span class="go">       //                /                            \                     \</span>
<span class="go">       ||               |                             |                     |</span>
<span class="go">       ||               |                  /          |             /       |</span>
<span class="go">       ||               |                 |           |            |        |</span>
<span class="go">       ||               |        (1 - n)* | P(x) dx   |  (-1 + n)* | P(x) dx|</span>
<span class="go">       ||               |                 |           |            |        |</span>
<span class="go">       ||               |                /            |           /         |</span>
<span class="go">f(x) = ||C1 + (-1 + n)* | -Q(x)*e                   dx|*e                   |</span>
<span class="go">       ||               |                             |                     |</span>
<span class="go">       \\               /                            /                     /</span>
</pre></div>
</div>
<p>Note that the equation is separable when <span class="math">\(n = 1\)</span> (see the docstring of
<a class="reference internal" href="#sympy.solvers.ode.ode_separable" title="sympy.solvers.ode.ode_separable"><code class="xref py py-meth docutils literal"><span class="pre">ode_separable()</span></code></a>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go"> f(x)</span>
<span class="go">   /</span>
<span class="go">  |                /</span>
<span class="go">  |  1            |</span>
<span class="go">  |  - dy = C1 +  | (-P(x) + Q(x)) dx</span>
<span class="go">  |  y            |</span>
<span class="go">  |              /</span>
<span class="go"> /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Bernoulli_differential_equation">http://en.wikipedia.org/wiki/Bernoulli_differential_equation</a></li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 95</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Bernoulli&#39;</span><span class="p">))</span>
<span class="go">                1</span>
<span class="go">f(x) = -------------------</span>
<span class="go">         /     log(x)   1\</span>
<span class="go">       x*|C1 + ------ + -|</span>
<span class="go">         \       x      x/</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="liouville">
<h3><code class="xref py py-obj docutils literal"><span class="pre">Liouville</span></code><a class="headerlink" href="#liouville" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Liouville">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_Liouville</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Liouville"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Liouville" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves 2nd order Liouville differential equations.</p>
<p>The general form of a Liouville ODE is</p>
<div class="math">
\[\frac{d^2 y}{dx^2} + g(y) \left(\!
\frac{dy}{dx}\!\right)^2 + h(x)
\frac{dy}{dx}\text{.}\]</div>
<p>The general solution is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">diff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                  2                    2</span>
<span class="go">        /d       \         d          d</span>
<span class="go">g(f(x))*|--(f(x))|  + h(x)*--(f(x)) + ---(f(x)) = 0</span>
<span class="go">        \dx      /         dx           2</span>
<span class="go">                                      dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Liouville_Integral&#39;</span><span class="p">))</span>
<span class="go">                                  f(x)</span>
<span class="go">          /                     /</span>
<span class="go">         |                     |</span>
<span class="go">         |     /               |     /</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |  - | h(x) dx        |    | g(y) dy</span>
<span class="go">         |    |                |    |</span>
<span class="go">         |   /                 |   /</span>
<span class="go">C1 + C2* | e            dx +   |  e           dy = 0</span>
<span class="go">         |                     |</span>
<span class="go">        /                     /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Goldstein and Braun, “Advanced Methods for the Solution of Differential
Equations”, pp. 98</li>
<li><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Liouville</a></li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="n">diff</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;Liouville&#39;</span><span class="p">))</span>
<span class="go">           ________________           ________________</span>
<span class="go">[f(x) = -\/ C1 + C2*log(x) , f(x) = \/ C1 + C2*log(x) ]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="riccati-special-minus2">
<h3><code class="xref py py-obj docutils literal"><span class="pre">Riccati_special_minus2</span></code><a class="headerlink" href="#riccati-special-minus2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_Riccati_special_minus2">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_Riccati_special_minus2</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_Riccati_special_minus2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_Riccati_special_minus2" title="Permalink to this definition">¶</a></dt>
<dd><p>The general Riccati equation has the form</p>
<div class="math">
\[dy/dx = f(x) y^2 + g(x) y + h(x)\text{.}\]</div>
<p>While it does not have a general solution [1], the “special” form, <span class="math">\(dy/dx
= a y^2 - b x^c\)</span>, does have solutions in many cases [2].  This routine
returns a solution for <span class="math">\(a(dy/dx) = b y^2 + c y/x + d/x^2\)</span> that is obtained
by using a suitable change of variables to reduce it to the special form
and is valid when neither <span class="math">\(a\)</span> nor <span class="math">\(b\)</span> are zero and either <span class="math">\(c\)</span> or <span class="math">\(d\)</span> is
zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">checkodesol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">Function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="o">*</span><span class="n">y</span><span class="o">/</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span><span class="o">/</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sol</span> <span class="o">=</span> <span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">wrap_line</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">        /                                 /        __________________       \\</span>
<span class="go">        |           __________________    |       /                2        ||</span>
<span class="go">        |          /                2     |     \/  4*b*d - (a + c)  *log(x)||</span>
<span class="go">       -|a + c - \/  4*b*d - (a + c)  *tan|C1 + ----------------------------||</span>
<span class="go">        \                                 \                 2*a             //</span>
<span class="go">f(x) = ------------------------------------------------------------------------</span>
<span class="go">                                        2*b*x</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">checkodesol</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati">http://www.maplesoft.com/support/help/Maple/view.aspx?path=odeadvisor/Riccati</a></li>
<li><a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0106.pdf</a> -
<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf">http://eqworld.ipmnet.ru/en/solutions/ode/ode0123.pdf</a></li>
</ol>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-homogeneous">
<h3><code class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_homogeneous</span></code><a class="headerlink" href="#nth-linear-constant-coeff-homogeneous" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_nth_linear_constant_coeff_homogeneous</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em>, <em>returns='sol'</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_homogeneous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_homogeneous" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math">\(n\)</span>th order linear homogeneous differential equation with
constant coefficients.</p>
<p>This is an equation of the form</p>
<div class="math">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = 0\text{.}\]</div>
<p>These equations can be solved in a general manner, by taking the roots of
the characteristic equation <span class="math">\(a_n m^n + a_{n-1} m^{n-1} + \cdots + a_1 m +
a_0 = 0\)</span>.  The solution will then be the sum of <span class="math">\(C_n x^i e^{r x}\)</span> terms,
for each where <span class="math">\(C_n\)</span> is an arbitrary constant, <span class="math">\(r\)</span> is a root of the
characteristic equation and <span class="math">\(i\)</span> is one of each from 0 to the multiplicity
of the root - 1 (for example, a root 3 of multiplicity 2 would create the
terms <span class="math">\(C_1 e^{3 x} + C_2 x e^{3 x}\)</span>).  The exponential is usually expanded
for complex roots using Euler’s equation <span class="math">\(e^{I x} = \cos(x) + I \sin(x)\)</span>.
Complex roots always come in conjugate pairs in polynomials with real
coefficients, so the two roots will be represented (after simplifying the
constants) as <span class="math">\(e^{a x} \left(C_1 \cos(b x) + C_2 \sin(b x)\right)\)</span>.</p>
<p>If SymPy cannot find exact roots to the characteristic equation, a
<code class="xref py py-class docutils literal"><span class="pre">CRootOf</span></code> instance will be return
instead.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">)</span>
<span class="gp">... </span>
<span class="go">Eq(f(x), C1*exp(x*CRootOf(_x**5 + 10*_x - 2, 0)) +</span>
<span class="go">C2*exp(x*CRootOf(_x**5 + 10*_x - 2, 1)) +</span>
<span class="go">C3*exp(x*CRootOf(_x**5 + 10*_x - 2, 2)) +</span>
<span class="go">C4*exp(x*CRootOf(_x**5 + 10*_x - 2, 3)) +</span>
<span class="go">C5*exp(x*CRootOf(_x**5 + 10*_x - 2, 4)))</span>
</pre></div>
</div>
<p>Note that because this method does not involve integration, there is no
<code class="docutils literal"><span class="pre">nth_linear_constant_coeff_homogeneous_Integral</span></code> hint.</p>
<p>The following is for internal use:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'sol'</span></code> returns the solution to the ODE.</li>
<li><code class="docutils literal"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'list'</span></code> returns a list of linearly independent solutions,
for use with non homogeneous solution methods like variation of
parameters and undetermined coefficients.  Note that, though the
solutions should be linearly independent, this function does not
explicitly check that.  You can do <code class="docutils literal"><span class="pre">assert</span> <span class="pre">simplify(wronskian(sollist))</span>
<span class="pre">!=</span> <span class="pre">0</span></code> to check for linear independence.  Also, <code class="docutils literal"><span class="pre">assert</span> <span class="pre">len(sollist)</span> <span class="pre">==</span>
<span class="pre">order</span></code> will need to pass.</li>
<li><code class="docutils literal"><span class="pre">returns</span> <span class="pre">=</span> <span class="pre">'both'</span></code>, return a dictionary <code class="docutils literal"><span class="pre">{'sol':</span> <span class="pre">&lt;solution</span> <span class="pre">to</span> <span class="pre">ODE&gt;,</span>
<span class="pre">'list':</span> <span class="pre">&lt;list</span> <span class="pre">of</span> <span class="pre">linearly</span> <span class="pre">independent</span> <span class="pre">solutions&gt;}</span></code>.</li>
</ul>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Linear_differential_equation">http://en.wikipedia.org/wiki/Linear_differential_equation</a> section:
Nonhomogeneous_equation_with_constant_coefficients</li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 211</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_homogeneous&#39;</span><span class="p">))</span>
<span class="go">                    x                            -2*x</span>
<span class="go">f(x) = (C1 + C2*x)*e  + (C3*sin(x) + C4*cos(x))*e</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-undetermined-coefficients">
<h3><code class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></code><a class="headerlink" href="#nth-linear-constant-coeff-undetermined-coefficients" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_nth_linear_constant_coeff_undetermined_coefficients</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_undetermined_coefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_undetermined_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math">\(n\)</span>th order linear differential equation with constant
coefficients using the method of undetermined coefficients.</p>
<p>This method works on differential equations of the form</p>
<div class="math">
\[a_n f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x)
+ a_0 f(x) = P(x)\text{,}\]</div>
<p>where <span class="math">\(P(x)\)</span> is a function that has a finite number of linearly
independent derivatives.</p>
<p>Functions that fit this requirement are finite sums functions of the form
<span class="math">\(a x^i e^{b x} \sin(c x + d)\)</span> or <span class="math">\(a x^i e^{b x} \cos(c x + d)\)</span>, where <span class="math">\(i\)</span>
is a non-negative integer and <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, <span class="math">\(c\)</span>, and <span class="math">\(d\)</span> are constants.  For
example any polynomial in <span class="math">\(x\)</span>, functions like <span class="math">\(x^2 e^{2 x}\)</span>, <span class="math">\(x \sin(x)\)</span>,
and <span class="math">\(e^x \cos(x)\)</span> can all be used.  Products of <span class="math">\(\sin\)</span>‘s and <span class="math">\(\cos\)</span>‘s have
a finite number of derivatives, because they can be expanded into <span class="math">\(\sin(a
x)\)</span> and <span class="math">\(\cos(b x)\)</span> terms.  However, SymPy currently cannot do that
expansion, so you will need to manually rewrite the expression in terms of
the above to use this method.  So, for example, you will need to manually
convert <span class="math">\(\sin^2(x)\)</span> into <span class="math">\((1 + \cos(2 x))/2\)</span> to properly apply the method
of undetermined coefficients on it.</p>
<p>This method works by creating a trial function from the expression and all
of its linear independent derivatives and substituting them into the
original ODE.  The coefficients for each term will be a system of linear
equations, which are be solved for and substituted, giving the solution.
If any of the trial functions are linearly dependent on the solution to
the homogeneous equation, they are multiplied by sufficient <span class="math">\(x\)</span> to make
them linearly independent.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients">http://en.wikipedia.org/wiki/Method_of_undetermined_coefficients</a></li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 221</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">cos</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span>
<span class="gp">... </span><span class="mi">4</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_undetermined_coefficients&#39;</span><span class="p">))</span>
<span class="go">       /             4\</span>
<span class="go">       |            x |  -x   4*sin(2*x)   3*cos(2*x)</span>
<span class="go">f(x) = |C1 + C2*x + --|*e   - ---------- + ----------</span>
<span class="go">       \            3 /           25           25</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nth-linear-constant-coeff-variation-of-parameters">
<h3><code class="xref py py-obj docutils literal"><span class="pre">nth_linear_constant_coeff_variation_of_parameters</span></code><a class="headerlink" href="#nth-linear-constant-coeff-variation-of-parameters" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_nth_linear_constant_coeff_variation_of_parameters</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_nth_linear_constant_coeff_variation_of_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_nth_linear_constant_coeff_variation_of_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an <span class="math">\(n\)</span>th order linear differential equation with constant
coefficients using the method of variation of parameters.</p>
<p>This method works on any differential equations of the form</p>
<div class="math">
\[f^{(n)}(x) + a_{n-1} f^{(n-1)}(x) + \cdots + a_1 f'(x) + a_0
f(x) = P(x)\text{.}\]</div>
<p>This method works by assuming that the particular solution takes the form</p>
<div class="math">
\[\sum_{x=1}^{n} c_i(x) y_i(x)\text{,}\]</div>
<p>where <span class="math">\(y_i\)</span> is the <span class="math">\(i\)</span>th solution to the homogeneous equation.  The
solution is then solved using Wronskian’s and Cramer’s Rule.  The
particular solution is given by</p>
<div class="math">
\[\sum_{x=1}^n \left( \int \frac{W_i(x)}{W(x)} \,dx
\right) y_i(x) \text{,}\]</div>
<p>where <span class="math">\(W(x)\)</span> is the Wronskian of the fundamental system (the system of <span class="math">\(n\)</span>
linearly independent solutions to the homogeneous equation), and <span class="math">\(W_i(x)\)</span>
is the Wronskian of the fundamental system with the <span class="math">\(i\)</span>th column replaced
with <span class="math">\([0, 0, \cdots, 0, P(x)]\)</span>.</p>
<p>This method is general enough to solve any <span class="math">\(n\)</span>th order inhomogeneous
linear differential equation with constant coefficients, but sometimes
SymPy cannot simplify the Wronskian well enough to integrate it.  If this
method hangs, try using the
<code class="docutils literal"><span class="pre">nth_linear_constant_coeff_variation_of_parameters_Integral</span></code> hint and
simplifying the integrals manually.  Also, prefer using
<code class="docutils literal"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></code> when it
applies, because it doesn’t use integration, making it faster and more
reliable.</p>
<p>Warning, using simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters’ in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> may cause it to hang, because it will
not attempt to simplify the Wronskian before integrating.  It is
recommended that you only use simplify=False with
‘nth_linear_constant_coeff_variation_of_parameters_Integral’ for this
method, especially if the solution to the homogeneous equation has
trigonometric functions in it.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Variation_of_parameters">http://en.wikipedia.org/wiki/Variation_of_parameters</a></li>
<li><a class="reference external" href="http://planetmath.org/VariationOfParameters">http://planetmath.org/VariationOfParameters</a></li>
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 233</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
<span class="gp">... </span><span class="mi">3</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;nth_linear_constant_coeff_variation_of_parameters&#39;</span><span class="p">))</span>
<span class="go">       /                     3                \</span>
<span class="go">       |                2   x *(6*log(x) - 11)|  x</span>
<span class="go">f(x) = |C1 + C2*x + C3*x  + ------------------|*e</span>
<span class="go">       \                            36        /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="separable">
<h3><code class="xref py py-obj docutils literal"><span class="pre">separable</span></code><a class="headerlink" href="#separable" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_separable">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_separable</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_separable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_separable" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves separable 1st order differential equations.</p>
<p>This is any differential equation that can be written as <span class="math">\(P(y)
\tfrac{dy}{dx} = Q(x)\)</span>.  The solution can then just be found by
rearranging terms and integrating: <span class="math">\(\int P(y) \,dy = \int Q(x) \,dx\)</span>.
This hint uses <a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.separatevars" title="sympy.simplify.simplify.separatevars"><code class="xref py py-meth docutils literal"><span class="pre">sympy.simplify.simplify.separatevars()</span></code></a> as its back
end, so if a separable equation is not caught by this solver, it is most
likely the fault of that function.
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.separatevars" title="sympy.simplify.simplify.separatevars"><code class="xref py py-meth docutils literal"><span class="pre">separatevars()</span></code></a> is
smart enough to do most expansion and factoring necessary to convert a
separable equation <span class="math">\(F(x, y)\)</span> into the proper form <span class="math">\(P(x)\cdot{}Q(y)\)</span>.  The
general solution is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">             d</span>
<span class="go">a(x)*b(f(x))*--(f(x)) = c(x)*d(f(x))</span>
<span class="go">             dx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_Integral&#39;</span><span class="p">))</span>
<span class="go">     f(x)</span>
<span class="go">   /                  /</span>
<span class="go">  |                  |</span>
<span class="go">  |  b(y)            | c(x)</span>
<span class="go">  |  ---- dy = C1 +  | ---- dx</span>
<span class="go">  |  d(y)            | a(x)</span>
<span class="go">  |                  |</span>
<span class="go"> /                  /</span>
</pre></div>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>M. Tenenbaum &amp; H. Pollard, “Ordinary Differential Equations”,
Dover 1963, pp. 52</li>
</ul>
<p># indirect doctest</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable&#39;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
<span class="go">   /   2       \         2</span>
<span class="go">log\3*f (x) - 1/        x</span>
<span class="go">---------------- = C1 + --</span>
<span class="go">       6                2</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="almost-linear">
<h3><code class="xref py py-obj docutils literal"><span class="pre">almost_linear</span></code><a class="headerlink" href="#almost-linear" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_almost_linear">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_almost_linear</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_almost_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_almost_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an almost-linear differential equation.</p>
<p>The general form of an almost linear differential equation is</p>
<div class="math">
\[f(x) g(y) y + k(x) l(y) + m(x) = 0
\text{where} l'(y) = g(y)\text{.}\]</div>
<p>This can be solved by substituting <span class="math">\(l(y) = u(y)\)</span>.  Making the given
substitution reduces it to a linear differential equation of the form <span class="math">\(u'
+ P(x) u + Q(x) = 0\)</span>.</p>
<p>The general solution is</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">Eq</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">+</span> <span class="n">k</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">l</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">     d</span>
<span class="go">f(x)*--(l(y)) + g(x) + k(x)*l(y) = 0</span>
<span class="go">     dy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span> <span class="o">=</span> <span class="s1">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">       /     //   -y*g(x)                  \\</span>
<span class="go">       |     ||   --------     for k(x) = 0||</span>
<span class="go">       |     ||     f(x)                   ||  -y*k(x)</span>
<span class="go">       |     ||                            ||  --------</span>
<span class="go">       |     ||       y*k(x)               ||    f(x)</span>
<span class="go">l(y) = |C1 + |&lt;       ------               ||*e</span>
<span class="go">       |     ||        f(x)                ||</span>
<span class="go">       |     ||-g(x)*e                     ||</span>
<span class="go">       |     ||--------------   otherwise  ||</span>
<span class="go">       |     ||     k(x)                   ||</span>
<span class="go">       \     \\                            //</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.ode.ode_1st_linear" title="sympy.solvers.ode.ode_1st_linear"><code class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_1st_linear()</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">)</span>
<span class="go">Eq(f(x), (C1 - Ei(x))*exp(-x))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;almost_linear&#39;</span><span class="p">))</span>
<span class="go">                     -x</span>
<span class="go">f(x) = (C1 - Ei(x))*e</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="linear-coefficients">
<h3><code class="xref py py-obj docutils literal"><span class="pre">linear_coefficients</span></code><a class="headerlink" href="#linear-coefficients" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_linear_coefficients">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_linear_coefficients</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_linear_coefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_linear_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a differential equation with linear coefficients.</p>
<p>The general form of a differential equation with linear coefficients is</p>
<div class="math">
\[y' + F\left(\!\frac{a_1 x + b_1 y + c_1}{a_2 x + b_2 y +
c_2}\!\right) = 0\text{,}\]</div>
<p>where <span class="math">\(a_1\)</span>, <span class="math">\(b_1\)</span>, <span class="math">\(c_1\)</span>, <span class="math">\(a_2\)</span>, <span class="math">\(b_2\)</span>, <span class="math">\(c_2\)</span> are constants and <span class="math">\(a_1 b_2
- a_2 b_1 \ne 0\)</span>.</p>
<p>This can be solved by substituting:</p>
<div class="math">
\[ \begin{align}\begin{aligned}x = x' + \frac{b_2 c_1 - b_1 c_2}{a_2 b_1 - a_1 b_2}\\y = y' + \frac{a_1 c_2 - a_2 c_1}{a_2 b_1 - a_1
    b_2}\text{.}\end{aligned}\end{align} \]</div>
<p>This substitution reduces the equation to a homogeneous differential
equation.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_best"><code class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_best()</span></code></a>, <a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep"><code class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_indep_div_dep()</span></code></a>, <a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep"><code class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_1st_homogeneous_coeff_subs_dep_div_indep()</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">df</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;linear_coefficients&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), -x - sqrt(C1 + 7*x**2) - 1), Eq(f(x), -x + sqrt(C1 + 7*x**2) - 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;linear_coefficients&#39;</span><span class="p">))</span>
<span class="go">                  ___________                     ___________</span>
<span class="go">               /         2                     /         2</span>
<span class="go">[f(x) = -x - \/  C1 + 7*x   - 1, f(x) = -x + \/  C1 + 7*x   - 1]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="separable-reduced">
<h3><code class="xref py py-obj docutils literal"><span class="pre">separable_reduced</span></code><a class="headerlink" href="#separable-reduced" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_separable_reduced">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_separable_reduced</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_separable_reduced"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_separable_reduced" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a differential equation that can be reduced to the separable form.</p>
<p>The general form of this equation is</p>
<div class="math">
\[y' + (y/x) H(x^n y) = 0\text{}.\]</div>
<p>This can be solved by substituting <span class="math">\(u(y) = x^n y\)</span>.  The equation then
reduces to the separable form <span class="math">\(\frac{u'}{u (\mathrm{power} - H(u))} -
\frac{1}{x} = 0\)</span>.</p>
<p>The general solution is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">genform</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">n</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">genform</span><span class="p">)</span>
<span class="go">                 / n     \</span>
<span class="go">d          f(x)*g\x *f(x)/</span>
<span class="go">--(f(x)) + ---------------</span>
<span class="go">dx                x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">genform</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go"> n</span>
<span class="go">x *f(x)</span>
<span class="go">  /</span>
<span class="go"> |</span>
<span class="go"> |         1</span>
<span class="go"> |    ------------ dy = C1 + log(x)</span>
<span class="go"> |    y*(n - g(y))</span>
<span class="go"> |</span>
<span class="go"> /</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.ode.ode_separable" title="sympy.solvers.ode.ode_separable"><code class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.ode_separable()</span></code></a></p>
</div>
<p class="rubric">References</p>
<ul class="simple">
<li>Joel Moses, “Symbolic Integration - The Stormy Decade”, Communications
of the ACM, Volume 14, Number 8, August 1971, pp. 558</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">classify_ode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">)</span>
<span class="go">[Eq(f(x), (-sqrt(C1*x**2 + 1) + 1)/x), Eq(f(x), (sqrt(C1*x**2 + 1) + 1)/x)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;separable_reduced&#39;</span><span class="p">))</span>
<span class="go">             ___________                ___________</span>
<span class="go">            /     2                    /     2</span>
<span class="go">        - \/  C1*x  + 1  + 1         \/  C1*x  + 1  + 1</span>
<span class="go">[f(x) = --------------------, f(x) = ------------------]</span>
<span class="go">                 x                           x</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="lie-group">
<h3><code class="xref py py-obj docutils literal"><span class="pre">lie_group</span></code><a class="headerlink" href="#lie-group" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_lie_group">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_lie_group</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_lie_group"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_lie_group" title="Permalink to this definition">¶</a></dt>
<dd><p>This hint implements the Lie group method of solving first order differential
equations. The aim is to convert the given differential equation from the
given coordinate given system into another coordinate system where it becomes
invariant under the one-parameter Lie group of translations. The converted ODE is
quadrature and can be solved easily. It makes use of the
<a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal"><span class="pre">sympy.solvers.ode.infinitesimals()</span></code></a> function which returns the
infinitesimals of the transformation.</p>
<p>The coordinates <span class="math">\(r\)</span> and <span class="math">\(s\)</span> can be found by solving the following Partial
Differential Equations.</p>
<div class="math">
\[\xi\frac{\partial r}{\partial x} + \eta\frac{\partial r}{\partial y}
= 0\]</div>
<div class="math">
\[\xi\frac{\partial s}{\partial x} + \eta\frac{\partial s}{\partial y}
= 1\]</div>
<p>The differential equation becomes separable in the new coordinate system</p>
<div class="math">
\[\frac{ds}{dr} = \frac{\frac{\partial s}{\partial x} +
h(x, y)\frac{\partial s}{\partial y}}{
\frac{\partial r}{\partial x} + h(x, y)\frac{\partial r}{\partial y}}\]</div>
<p>After finding the solution by integration, it is then converted back to the original
coordinate system by subsituting <span class="math">\(r\)</span> and <span class="math">\(s\)</span> in terms of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> again.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>Solving differential equations by Symmetry Groups,
John Starrett, pp. 1 - pp. 14</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
<span class="gp">... </span><span class="n">hint</span><span class="o">=</span><span class="s1">&#39;lie_group&#39;</span><span class="p">))</span>
<span class="go">       /      2\    2</span>
<span class="go">       |     x |  -x</span>
<span class="go">f(x) = |C1 + --|*e</span>
<span class="go">       \     2 /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="st-power-series">
<h3><code class="xref py py-obj docutils literal"><span class="pre">1st_power_series</span></code><a class="headerlink" href="#st-power-series" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_1st_power_series">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_1st_power_series</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_1st_power_series"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_1st_power_series" title="Permalink to this definition">¶</a></dt>
<dd><p>The power series solution is a method which gives the Taylor series expansion
to the solution of a differential equation.</p>
<p>For a first order differential equation <span class="math">\(\frac{dy}{dx} = h(x, y)\)</span>, a power
series solution exists at a point <span class="math">\(x = x_{0}\)</span> if <span class="math">\(h(x, y)\)</span> is analytic at <span class="math">\(x_{0}\)</span>.
The solution is given by</p>
<div class="math">
\[y(x) = y(x_{0}) + \sum_{n = 1}^{\infty} \frac{F_{n}(x_{0},b)(x - x_{0})^n}{n!},\]</div>
<p>where <span class="math">\(y(x_{0}) = b\)</span> is the value of y at the initial value of <span class="math">\(x_{0}\)</span>.
To compute the values of the <span class="math">\(F_{n}(x_{0},b)\)</span> the following algorithm is
followed, until the required number of terms are generated.</p>
<ol class="arabic simple">
<li><span class="math">\(F_1 = h(x_{0}, b)\)</span></li>
<li><span class="math">\(F_{n+1} = \frac{\partial F_{n}}{\partial x} + \frac{\partial F_{n}}{\partial y}F_{1}\)</span></li>
</ol>
<p class="rubric">References</p>
<ul class="simple">
<li>Travis W. Walker, Analytic power series technique for solving first-order
differential equations, p.p 17, 18</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Function</span><span class="p">,</span> <span class="n">Derivative</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.ode</span> <span class="k">import</span> <span class="n">dsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;1st_power_series&#39;</span><span class="p">))</span>
<span class="go">                       3       4       5</span>
<span class="go">                   C1*x    C1*x    C1*x     / 6\</span>
<span class="go">f(x) = C1 + C1*x - ----- + ----- + ----- + O\x /</span>
<span class="go">                     6       24      60</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nd-power-series-ordinary">
<h3><code class="xref py py-obj docutils literal"><span class="pre">2nd_power_series_ordinary</span></code><a class="headerlink" href="#nd-power-series-ordinary" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_2nd_power_series_ordinary">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_2nd_power_series_ordinary</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_2nd_power_series_ordinary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_2nd_power_series_ordinary" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a power series solution to a second order homogeneous differential
equation with polynomial coefficients at an ordinary point. A homogenous
differential equation is of the form</p>
<div class="math">
\[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) = 0\]</div>
<p>For simplicity it is assumed that <span class="math">\(P(x)\)</span>, <span class="math">\(Q(x)\)</span> and <span class="math">\(R(x)\)</span> are polynomials,
it is sufficient that <span class="math">\(\frac{Q(x)}{P(x)}\)</span> and <span class="math">\(\frac{R(x)}{P(x)}\)</span> exists at
<span class="math">\(x_{0}\)</span>. A recurrence relation is obtained by substituting <span class="math">\(y\)</span> as <span class="math">\(\sum_{n=0}^\infty a_{n}x^{n}\)</span>,
in the differential equation, and equating the nth term. Using this relation
various terms can be generated.</p>
<p class="rubric">References</p>
<ul class="simple">
<li><a class="reference external" href="http://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx">http://tutorial.math.lamar.edu/Classes/DE/SeriesSolutions.aspx</a></li>
<li>George E. Simmons, “Differential Equations with Applications and
Historical Notes”, p.p 176 - 184</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">hint</span><span class="o">=</span><span class="s1">&#39;2nd_power_series_ordinary&#39;</span><span class="p">))</span>
<span class="go">          / 4    2    \        /   2    \</span>
<span class="go">          |x    x     |        |  x     |    / 6\</span>
<span class="go">f(x) = C2*|-- - -- + 1| + C1*x*|- -- + 1| + O\x /</span>
<span class="go">          \24   2     /        \  6     /</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="nd-power-series-regular">
<h3><code class="xref py py-obj docutils literal"><span class="pre">2nd_power_series_regular</span></code><a class="headerlink" href="#nd-power-series-regular" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.ode_2nd_power_series_regular">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">ode_2nd_power_series_regular</code><span class="sig-paren">(</span><em>eq</em>, <em>func</em>, <em>order</em>, <em>match</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#ode_2nd_power_series_regular"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.ode_2nd_power_series_regular" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives a power series solution to a second order homogeneous differential
equation with polynomial coefficients at a regular point. A second order
homogenous differential equation is of the form</p>
<div class="math">
\[P(x)\frac{d^2y}{dx^2} + Q(x)\frac{dy}{dx} + R(x) = 0\]</div>
<p>A point is said to regular singular at <span class="math">\(x0\)</span> if <span class="math">\(x - x0\frac{Q(x)}{P(x)}\)</span>
and <span class="math">\((x - x0)^{2}\frac{R(x)}{P(x)}\)</span> are analytic at <span class="math">\(x0\)</span>. For simplicity
<span class="math">\(P(x)\)</span>, <span class="math">\(Q(x)\)</span> and <span class="math">\(R(x)\)</span> are assumed to be polynomials. The algorithm for
finding the power series solutions is:</p>
<ol class="arabic simple">
<li>Try expressing <span class="math">\((x - x0)P(x)\)</span> and <span class="math">\(((x - x0)^{2})Q(x)\)</span> as power series
solutions about x0. Find <span class="math">\(p0\)</span> and <span class="math">\(q0\)</span> which are the constants of the
power series expansions.</li>
<li>Solve the indicial equation <span class="math">\(f(m) = m(m - 1) + m*p0 + q0\)</span>, to obtain the
roots <span class="math">\(m1\)</span> and <span class="math">\(m2\)</span> of the indicial equation.</li>
<li>If <span class="math">\(m1 - m2\)</span> is a non integer there exists two series solutions. If
<span class="math">\(m1 = m2\)</span>, there exists only one solution. If <span class="math">\(m1 - m2\)</span> is an integer,
then the existence of one solution is confirmed. The other solution may
or may not exist.</li>
</ol>
<p>The power series solution is of the form <span class="math">\(x^{m}\sum_{n=0}^\infty a_{n}x^{n}\)</span>. The
coefficients are determined by the following recurrence relation.
<span class="math">\(a_{n} = -\frac{\sum_{k=0}^{n-1} q_{n-k} + (m + k)p_{n-k}}{f(m + n)}\)</span>. For the case
in which <span class="math">\(m1 - m2\)</span> is an integer, it can be seen from the recurrence relation
that for the lower root <span class="math">\(m\)</span>, when <span class="math">\(n\)</span> equals the difference of both the
roots, the denominator becomes zero. So if the numerator is not equal to zero,
a second series solution exists.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>George E. Simmons, “Differential Equations with Applications and
Historical Notes”, p.p 176 - 184</li>
</ul>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">dsolve</span><span class="p">,</span> <span class="n">Function</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="k">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">dsolve</span><span class="p">(</span><span class="n">eq</span><span class="p">))</span>
<span class="go">                              /    6    4    2    \</span>
<span class="go">                              |   x    x    x     |</span>
<span class="go">          /  4    2    \   C1*|- --- + -- - -- + 1|</span>
<span class="go">          | x    x     |      \  720   24   2     /    / 6\</span>
<span class="go">f(x) = C2*|--- - -- + 1| + ------------------------ + O\x /</span>
<span class="go">          \120   6     /              x</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="lie-heuristics">
<h2>Lie heuristics<a class="headerlink" href="#lie-heuristics" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use of the Lie Group Solver.
Nonetheless, they contain useful information in their docstrings on the algorithms
implemented for the various heuristics.</p>
<div class="section" id="abaco1-simple">
<h3><code class="xref py py-obj docutils literal"><span class="pre">abaco1_simple</span></code><a class="headerlink" href="#abaco1-simple" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_abaco1_simple">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_abaco1_simple</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_abaco1_simple"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_abaco1_simple" title="Permalink to this definition">¶</a></dt>
<dd><p>The first heuristic uses the following four sets of
assumptions on <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span></p>
<div class="math">
\[\xi = 0, \eta = f(x)\]</div>
<div class="math">
\[\xi = 0, \eta = f(y)\]</div>
<div class="math">
\[\xi = f(x), \eta = 0\]</div>
<div class="math">
\[\xi = f(y), \eta = 0\]</div>
<p>The success of this heuristic is determined by algebraic factorisation.
For the first assumption <span class="math">\(\xi = 0\)</span> and <span class="math">\(\eta\)</span> to be a function of <span class="math">\(x\)</span>, the PDE</p>
<div class="math">
\[\frac{\partial \eta}{\partial x} + (\frac{\partial \eta}{\partial y}
- \frac{\partial \xi}{\partial x})*h
- \frac{\partial \xi}{\partial y}*h^{2}
- \xi*\frac{\partial h}{\partial x} - \eta*\frac{\partial h}{\partial y} = 0\]</div>
<p>reduces to <span class="math">\(f'(x) - f\frac{\partial h}{\partial y} = 0\)</span>
If <span class="math">\(\frac{\partial h}{\partial y}\)</span> is a function of <span class="math">\(x\)</span>, then this can usually
be integrated easily. A similar idea is applied to the other 3 assumptions as well.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco1-product">
<h3><code class="xref py py-obj docutils literal"><span class="pre">abaco1_product</span></code><a class="headerlink" href="#abaco1-product" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_abaco1_product">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_abaco1_product</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_abaco1_product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_abaco1_product" title="Permalink to this definition">¶</a></dt>
<dd><p>The second heuristic uses the following two assumptions on <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span></p>
<div class="math">
\[\eta = 0, \xi = f(x)*g(y)\]</div>
<div class="math">
\[\eta = f(x)*g(y), \xi = 0\]</div>
<p>The first assumption of this heuristic holds good if
<span class="math">\(\frac{1}{h^{2}}\frac{\partial^2}{\partial x \partial y}\log(h)\)</span> is
separable in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, then the separated factors containing <span class="math">\(x\)</span>
is <span class="math">\(f(x)\)</span>, and <span class="math">\(g(y)\)</span> is obtained by</p>
<div class="math">
\[e^{\int f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\,dy}\]</div>
<p>provided <span class="math">\(f\frac{\partial}{\partial x}\left(\frac{1}{f*h}\right)\)</span> is a function
of <span class="math">\(y\)</span> only.</p>
<p>The second assumption holds good if <span class="math">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first assumption
satisifes. After obtaining <span class="math">\(f(x)\)</span> and <span class="math">\(g(y)\)</span>, the coordinates are again
interchanged, to get <span class="math">\(\eta\)</span> as <span class="math">\(f(x)*g(y)\)</span></p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</li>
</ul>
</dd></dl>

</div>
<div class="section" id="bivariate">
<h3><code class="xref py py-obj docutils literal"><span class="pre">bivariate</span></code><a class="headerlink" href="#bivariate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_bivariate">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_bivariate</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_bivariate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_bivariate" title="Permalink to this definition">¶</a></dt>
<dd><p>The third heuristic assumes the infinitesimals <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span>
to be bi-variate polynomials in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. The assumption made here
for the logic below is that <span class="math">\(h\)</span> is a rational function in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>
though that may not be necessary for the infinitesimals to be
bivariate polynomials. The coefficients of the infinitesimals
are found out by substituting them in the PDE and grouping similar terms
that are polynomials and since they form a linear system, solve and check
for non trivial solutions. The degree of the assumed bivariates
are increased till a certain maximum value.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>Lie Groups and Differential Equations
pp. 327 - pp. 329</li>
</ul>
</dd></dl>

</div>
<div class="section" id="chi">
<h3><code class="xref py py-obj docutils literal"><span class="pre">chi</span></code><a class="headerlink" href="#chi" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_chi">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_chi</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_chi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_chi" title="Permalink to this definition">¶</a></dt>
<dd><p>The aim of the fourth heuristic is to find the function <span class="math">\(\chi(x, y)\)</span>
that satisifies the PDE <span class="math">\(\frac{d\chi}{dx} + h\frac{d\chi}{dx}
- \frac{\partial h}{\partial y}\chi = 0\)</span>.</p>
<p>This assumes <span class="math">\(\chi\)</span> to be a bivariate polynomial in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. By intution,
<span class="math">\(h\)</span> should be a rational function in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>. The method used here is
to substitute a general binomial for <span class="math">\(\chi\)</span> up to a certain maximum degree
is reached. The coefficients of the polynomials, are calculated by by collecting
terms of the same order in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.</p>
<p>After finding <span class="math">\(\chi\)</span>, the next step is to use <span class="math">\(\eta = \xi*h + \chi\)</span>, to
determine <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span>. This can be done by dividing <span class="math">\(\chi\)</span> by <span class="math">\(h\)</span>
which would give <span class="math">\(-\xi\)</span> as the quotient and <span class="math">\(\eta\)</span> as the remainder.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S Cheb-Terrab, L.G.S Duarte and L.A,C.P da Mota, Computer Algebra
Solving of First Order ODEs Using Symmetry Methods, pp. 8</li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco2-similar">
<h3><code class="xref py py-obj docutils literal"><span class="pre">abaco2_similar</span></code><a class="headerlink" href="#abaco2-similar" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_abaco2_similar">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_abaco2_similar</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_abaco2_similar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_abaco2_similar" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic uses the following two assumptions on <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span></p>
<div class="math">
\[\eta = g(x), \xi = f(x)\]</div>
<div class="math">
\[\eta = f(y), \xi = g(y)\]</div>
<p>For the first assumption,</p>
<ol class="arabic">
<li><p class="first">First <span class="math">\(\frac{\frac{\partial h}{\partial y}}{\frac{\partial^{2} h}{
\partial yy}}\)</span> is calculated. Let us say this value is A</p>
</li>
<li><p class="first">If this is constant, then <span class="math">\(h\)</span> is matched to the form <span class="math">\(A(x) + B(x)e^{
\frac{y}{C}}\)</span> then, <span class="math">\(\frac{e^{\int \frac{A(x)}{C} \,dx}}{B(x)}\)</span> gives <span class="math">\(f(x)\)</span>
and <span class="math">\(A(x)*f(x)\)</span> gives <span class="math">\(g(x)\)</span></p>
</li>
<li><p class="first">Otherwise <span class="math">\(\frac{\frac{\partial A}{\partial X}}{\frac{\partial A}{
\partial Y}} = \gamma\)</span> is calculated. If</p>
<p>a] <span class="math">\(\gamma\)</span> is a function of <span class="math">\(x\)</span> alone</p>
<p>b] <span class="math">\(\frac{\gamma\frac{\partial h}{\partial y} - \gamma'(x) - \frac{
\partial h}{\partial x}}{h + \gamma} = G\)</span> is a function of <span class="math">\(x\)</span> alone.
then, <span class="math">\(e^{\int G \,dx}\)</span> gives <span class="math">\(f(x)\)</span> and <span class="math">\(-\gamma*f(x)\)</span> gives <span class="math">\(g(x)\)</span></p>
</li>
</ol>
<p>The second assumption holds good if <span class="math">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first assumption
satisifes. After obtaining <span class="math">\(f(x)\)</span> and <span class="math">\(g(x)\)</span>, the coordinates are again
interchanged, to get <span class="math">\(\xi\)</span> as <span class="math">\(f(x^*)\)</span> and <span class="math">\(\eta\)</span> as <span class="math">\(g(y^*)\)</span></p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</li>
</ul>
</dd></dl>

</div>
<div class="section" id="function-sum">
<h3><code class="xref py py-obj docutils literal"><span class="pre">function_sum</span></code><a class="headerlink" href="#function-sum" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_function_sum">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_function_sum</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_function_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_function_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic uses the following two assumptions on <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span></p>
<div class="math">
\[\eta = 0, \xi = f(x) + g(y)\]</div>
<div class="math">
\[\eta = f(x) + g(y), \xi = 0\]</div>
<p>The first assumption of this heuristic holds good if</p>
<div class="math">
\[\frac{\partial}{\partial y}[(h\frac{\partial^{2}}{
\partial x^{2}}(h^{-1}))^{-1}]\]</div>
<p>is separable in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>,</p>
<ol class="arabic simple">
<li>The separated factors containing <span class="math">\(y\)</span> is <span class="math">\(\frac{\partial g}{\partial y}\)</span>.
From this <span class="math">\(g(y)\)</span> can be determined.</li>
<li>The separated factors containing <span class="math">\(x\)</span> is <span class="math">\(f''(x)\)</span>.</li>
<li><span class="math">\(h\frac{\partial^{2}}{\partial x^{2}}(h^{-1})\)</span> equals
<span class="math">\(\frac{f''(x)}{f(x) + g(y)}\)</span>. From this <span class="math">\(f(x)\)</span> can be determined.</li>
</ol>
<p>The second assumption holds good if <span class="math">\(\frac{dy}{dx} = h(x, y)\)</span> is rewritten as
<span class="math">\(\frac{dy}{dx} = \frac{1}{h(y, x)}\)</span> and the same properties of the first
assumption satisifes. After obtaining <span class="math">\(f(x)\)</span> and <span class="math">\(g(y)\)</span>, the coordinates
are again interchanged, to get <span class="math">\(\eta\)</span> as <span class="math">\(f(x) + g(y)\)</span>.</p>
<p>For both assumptions, the constant factors are separated among <span class="math">\(g(y)\)</span>
and <span class="math">\(f''(x)\)</span>, such that <span class="math">\(f''(x)\)</span> obtained from 3] is the same as that
obtained from 2]. If not possible, then this heuristic fails.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 7 - pp. 8</li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco2-unique-unknown">
<h3><code class="xref py py-obj docutils literal"><span class="pre">abaco2_unique_unknown</span></code><a class="headerlink" href="#abaco2-unique-unknown" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_abaco2_unique_unknown">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_abaco2_unique_unknown</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_abaco2_unique_unknown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_abaco2_unique_unknown" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic assumes the presence of unknown functions or known functions
with non-integer powers.</p>
<ol class="arabic">
<li><p class="first">A list of all functions and non-integer powers containing x and y</p>
</li>
<li><p class="first">Loop over each element <span class="math">\(f\)</span> in the list, find <span class="math">\(\frac{\frac{\partial f}{\partial x}}{
\frac{\partial f}{\partial x}} = R\)</span></p>
<p>If it is separable in <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, let <span class="math">\(X\)</span> be the factors containing <span class="math">\(x\)</span>. Then</p>
<dl class="docutils">
<dt>a] Check if <span class="math">\(\xi = X\)</span> and <span class="math">\(\eta = -\frac{X}{R}\)</span> satisfy the PDE. If yes, then return</dt>
<dd><p class="first last"><span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span></p>
</dd>
<dt>b] Check if <span class="math">\(\xi = \frac{-R}{X}\)</span> and <span class="math">\(\eta = -\frac{1}{X}\)</span> satisfy the PDE.</dt>
<dd><p class="first last">If yes, then return <span class="math">\(\xi\)</span> and <span class="math">\(\eta\)</span></p>
</dd>
</dl>
<p>If not, then check if</p>
<p>a] <span class="math">\(\xi = -R,\eta = 1\)</span></p>
<p>b] <span class="math">\(\xi = 1, \eta = -\frac{1}{R}\)</span></p>
<p>are solutions.</p>
</li>
</ol>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</li>
</ul>
</dd></dl>

</div>
<div class="section" id="abaco2-unique-general">
<h3><code class="xref py py-obj docutils literal"><span class="pre">abaco2_unique_general</span></code><a class="headerlink" href="#abaco2-unique-general" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_abaco2_unique_general">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_abaco2_unique_general</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_abaco2_unique_general"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_abaco2_unique_general" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic finds if infinitesimals of the form <span class="math">\(\eta = f(x)\)</span>, <span class="math">\(\xi = g(y)\)</span>
without making any assumptions on <span class="math">\(h\)</span>.</p>
<p>The complete sequence of steps is given in the paper mentioned below.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</li>
</ul>
</dd></dl>

</div>
<div class="section" id="linear">
<h3><code class="xref py py-obj docutils literal"><span class="pre">linear</span></code><a class="headerlink" href="#linear" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode.lie_heuristic_linear">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">lie_heuristic_linear</code><span class="sig-paren">(</span><em>match</em>, <em>comp=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#lie_heuristic_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode.lie_heuristic_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic assumes</p>
<ol class="arabic simple">
<li><span class="math">\(\xi = ax + by + c\)</span> and</li>
<li><span class="math">\(\eta = fx + gy + h\)</span></li>
</ol>
<p>After substituting the following assumptions in the determining PDE, it
reduces to</p>
<div class="math">
\[f + (g - a)h - bh^{2} - (ax + by + c)\frac{\partial h}{\partial x}
- (fx + gy + c)\frac{\partial h}{\partial y}\]</div>
<p>Solving the reduced PDE obtained, using the method of characteristics, becomes
impractical. The method followed is grouping similar terms and solving the system
of linear equations obtained. The difference between the bivariate heuristic is that
<span class="math">\(h\)</span> need not be a rational function in this case.</p>
<p class="rubric">References</p>
<ul class="simple">
<li>E.S. Cheb-Terrab, A.D. Roche, Symmetries and First Order
ODE Patterns, pp. 10 - pp. 12</li>
</ul>
</dd></dl>

</div>
</div>
<div class="section" id="system-of-odes">
<h2>System of ODEs<a class="headerlink" href="#system-of-odes" title="Permalink to this headline">¶</a></h2>
<p>These functions are intended for internal use by
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> for system of differential equations.</p>
<div class="section" id="system-of-odes-linear-2eq-order1-type1">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type1</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order1-type1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order1_type1">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order1_type1</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order1_type1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order1_type1" title="Permalink to this definition">¶</a></dt>
<dd><p>It is classified under system of two linear homogeneous first-order constant-coefficient
ordinary differential equations.</p>
<p>The equations which come under this type are</p>
<div class="math">
\[x' = ax + by,\]</div>
<div class="math">
\[y' = cx + dy\]</div>
<p>The characteristics equation is written as</p>
<div class="math">
\[\lambda^{2} + (a+d) \lambda + ad - bc = 0\]</div>
<p>and its discriminant is <span class="math">\(D = (a-d)^{2} + 4bc\)</span>. There are several cases</p>
<p>1. Case when <span class="math">\(ad - bc \neq 0\)</span>. The origin of coordinates, <span class="math">\(x = y = 0\)</span>,
is the only stationary point; it is
- a node if <span class="math">\(D = 0\)</span>
- a node if <span class="math">\(D &gt; 0\)</span> and <span class="math">\(ad - bc &gt; 0\)</span>
- a saddle if <span class="math">\(D &gt; 0\)</span> and <span class="math">\(ad - bc &lt; 0\)</span>
- a focus if <span class="math">\(D &lt; 0\)</span> and <span class="math">\(a + d \neq 0\)</span>
- a centre if <span class="math">\(D &lt; 0\)</span> and <span class="math">\(a + d \neq 0\)</span>.</p>
<p>1.1. If <span class="math">\(D &gt; 0\)</span>. The characteristic equation has two distinct real roots
<span class="math">\(\lambda_1\)</span> and <span class="math">\(\lambda_ 2\)</span> . The general solution of the system in question is expressed as</p>
<div class="math">
\[x = C_1 b e^{\lambda_1 t} + C_2 b e^{\lambda_2 t}\]</div>
<div class="math">
\[y = C_1 (\lambda_1 - a) e^{\lambda_1 t} + C_2 (\lambda_2 - a) e^{\lambda_2 t}\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> being arbitary constants</p>
<p>1.2. If <span class="math">\(D &lt; 0\)</span>. The characteristics equation has two conjugate
roots, <span class="math">\(\lambda_1 = \sigma + i \beta\)</span> and <span class="math">\(\lambda_2 = \sigma - i \beta\)</span>.
The general solution of the system is given by</p>
<div class="math">
\[x = b e^{\sigma t} (C_1 \sin(\beta t) + C_2 \cos(\beta t))\]</div>
<div class="math">
\[y = e^{\sigma t} ([(\sigma - a) C_1 - \beta C_2] \sin(\beta t) + [\beta C_1 + (\sigma - a) C_2 \cos(\beta t)])\]</div>
<p>1.3. If <span class="math">\(D = 0\)</span> and <span class="math">\(a \neq d\)</span>. The characteristic equation has
two equal roots, <span class="math">\(\lambda_1 = \lambda_2\)</span>. The general solution of the system is written as</p>
<div class="math">
\[x = 2b (C_1 + \frac{C_2}{a-d} + C_2 t) e^{\frac{a+d}{2} t}\]</div>
<div class="math">
\[y = [(d - a) C_1 + C_2 + (d - a) C_2 t] e^{\frac{a+d}{2} t}\]</div>
<p>1.4. If <span class="math">\(D = 0\)</span> and <span class="math">\(a = d \neq 0\)</span> and <span class="math">\(b = 0\)</span></p>
<div class="math">
\[x = C_1 e^{a t} , y = (c C_1 t + C_2) e^{a t}\]</div>
<p>1.5. If <span class="math">\(D = 0\)</span> and <span class="math">\(a = d \neq 0\)</span> and <span class="math">\(c = 0\)</span></p>
<div class="math">
\[x = (b C_1 t + C_2) e^{a t} , y = C_1 e^{a t}\]</div>
<p>2. Case when <span class="math">\(ad - bc = 0\)</span> and <span class="math">\(a^{2} + b^{2} &gt; 0\)</span>. The whole straight
line <span class="math">\(ax + by = 0\)</span> consists of singular points. The orginal system of differential
equaitons can be rewritten as</p>
<div class="math">
\[x' = ax + by , y' = k (ax + by)\]</div>
<p>2.1 If <span class="math">\(a + bk \neq 0\)</span>, solution will be</p>
<div class="math">
\[x = b C_1 + C_2 e^{(a + bk) t} , y = -a C_1 + k C_2 e^{(a + bk) t}\]</div>
<p>2.2 If <span class="math">\(a + bk = 0\)</span>, solution will be</p>
<div class="math">
\[x = C_1 (bk t - 1) + b C_2 t , y = k^{2} b C_1 t + (b k^{2} t + 1) C_2\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order1-type2">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type2</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order1-type2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order1_type2">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order1_type2</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order1_type2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order1_type2" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type are</p>
<div class="math">
\[x' = ax + by + k1 , y' = cx + dy + k2\]</div>
<p>The general solution of this system is given by sum of its particular solution and the
general solution of the corresponding homogeneous system is obtained from type1.</p>
<p>1. When <span class="math">\(ad - bc \neq 0\)</span>. The particular solution will be
<span class="math">\(x = x_0\)</span> and <span class="math">\(y = y_0\)</span> where <span class="math">\(x_0\)</span> and <span class="math">\(y_0\)</span> are determined by solving linear system of equations</p>
<div class="math">
\[a x_0 + b y_0 + k1 = 0 , c x_0 + d y_0 + k2 = 0\]</div>
<ol class="arabic simple" start="2">
<li>When <span class="math">\(ad - bc = 0\)</span> and <span class="math">\(a^{2} + b^{2} &gt; 0\)</span>. In this case, the system of equation becomes</li>
</ol>
<div class="math">
\[x' = ax + by + k_1 , y' = k (ax + by) + k_2\]</div>
<p>2.1 If <span class="math">\(\sigma = a + bk \neq 0\)</span>, particular solution is given by</p>
<div class="math">
\[x = b \sigma^{-1} (c_1 k - c_2) t - \sigma^{-2} (a c_1 + b c_2)\]</div>
<div class="math">
\[y = kx + (c_2 - c_1 k) t\]</div>
<p>2.2 If <span class="math">\(\sigma = a + bk = 0\)</span>, particular solution is given by</p>
<div class="math">
\[x = \frac{1}{2} b (c_2 - c_1 k) t^{2} + c_1 t\]</div>
<div class="math">
\[y = kx + (c_2 - c_1 k) t\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order1-type3">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type3</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order1-type3" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order1_type3">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order1_type3</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order1_type3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order1_type3" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type of ode are</p>
<div class="math">
\[x' = f(t) x + g(t) y\]</div>
<div class="math">
\[y' = g(t) x + f(t) y\]</div>
<p>The solution of such equations is given by</p>
<div class="math">
\[x = e^{F} (C_1 e^{G} + C_2 e^{-G}) , y = e^{F} (C_1 e^{G} - C_2 e^{-G})\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitary constants, and</p>
<div class="math">
\[F = \int f(t) \,dt , G = \int g(t) \,dt\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order1-type4">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type4</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order1-type4" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order1_type4">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order1_type4</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order1_type4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order1_type4" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type of ode are .</p>
<div class="math">
\[x' = f(t) x + g(t) y\]</div>
<div class="math">
\[y' = -g(t) x + f(t) y\]</div>
<p>The solution is given by</p>
<div class="math">
\[x = F (C_1 \cos(G) + C_2 \sin(G)), y = F (-C_1 \sin(G) + C_2 \cos(G))\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitary constants, and</p>
<div class="math">
\[F = \int f(t) \,dt , G = \int g(t) \,dt\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order1-type5">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type5</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order1-type5" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order1_type5">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order1_type5</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order1_type5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order1_type5" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type of ode are .</p>
<div class="math">
\[x' = f(t) x + g(t) y\]</div>
<div class="math">
\[y' = a g(t) x + [f(t) + b g(t)] y\]</div>
<p>The transformation of</p>
<div class="math">
\[x = e^{\int f(t) \,dt} u , y = e^{\int f(t) \,dt} v , T = \int g(t) \,dt\]</div>
<p>leads to a system of constant coefficient linear differential equations</p>
<div class="math">
\[u'(T) = v , v'(T) = au + bv\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order1-type6">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type6</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order1-type6" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order1_type6">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order1_type6</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order1_type6"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order1_type6" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type of ode are .</p>
<div class="math">
\[x' = f(t) x + g(t) y\]</div>
<div class="math">
\[y' = a [f(t) + a h(t)] x + a [g(t) - h(t)] y\]</div>
<p>This is solved by first multiplying the first equation by <span class="math">\(-a\)</span> and adding
it to the second equation to obtain</p>
<div class="math">
\[y' - a x' = -a h(t) (y - a x)\]</div>
<p>Setting <span class="math">\(U = y - ax\)</span> and integrating the equation we arrive at</p>
<div class="math">
\[y - ax = C_1 e^{-a \int h(t) \,dt}\]</div>
<p>and on substituing the value of y in first equation give rise to first order ODEs. After solving for
<span class="math">\(x\)</span>, we can obtain <span class="math">\(y\)</span> by substituting the value of <span class="math">\(x\)</span> in second equation.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order1-type7">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type7</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order1-type7" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order1_type7">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order1_type7</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order1_type7"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order1_type7" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type of ode are .</p>
<div class="math">
\[x' = f(t) x + g(t) y\]</div>
<div class="math">
\[y' = h(t) x + p(t) y\]</div>
<p>Differentiating the first equation and substituting the value of <span class="math">\(y\)</span>
from second equation will give a second-order linear equation</p>
<div class="math">
\[g x'' - (fg + gp + g') x' + (fgp - g^{2} h + f g' - f' g) x = 0\]</div>
<p>This above equation can be easily integrated if following conditions are satisfied.</p>
<ol class="arabic simple">
<li><span class="math">\(fgp - g^{2} h + f g' - f' g = 0\)</span></li>
<li><span class="math">\(fgp - g^{2} h + f g' - f' g = ag, fg + gp + g' = bg\)</span></li>
</ol>
<p>If first condition is satisfied then it is solved by current dsolve solver and in second case it becomes
a constant cofficient differential equation which is also solved by current solver.</p>
<p>Otherwise if the above condition fails then,
a particular solution is assumed as <span class="math">\(x = x_0(t)\)</span> and <span class="math">\(y = y_0(t)\)</span>
Then the general solution is expressed as</p>
<div class="math">
\[x = C_1 x_0(t) + C_2 x_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt\]</div>
<div class="math">
\[y = C_1 y_0(t) + C_2 [\frac{F(t) P(t)}{x_0(t)} + y_0(t) \int \frac{g(t) F(t) P(t)}{x_0^{2}(t)} \,dt]\]</div>
<p>where C1 and C2 are arbitary constants and</p>
<div class="math">
\[F(t) = e^{\int f(t) \,dt} , P(t) = e^{\int p(t) \,dt}\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type1">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type1</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type1">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type1</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type1" title="Permalink to this definition">¶</a></dt>
<dd><p>System of two constant-coefficient second-order linear homogeneous differential equations</p>
<div class="math">
\[x'' = ax + by\]</div>
<div class="math">
\[y'' = cx + dy\]</div>
<p>The charecteristic equation for above equations</p>
<div class="math">
\[\lambda^4 - (a + d) \lambda^2 + ad - bc = 0\]</div>
<p>whose discriminant is <span class="math">\(D = (a - d)^2 + 4bc \neq 0\)</span></p>
<ol class="arabic simple">
<li>When <span class="math">\(ad - bc \neq 0\)</span></li>
</ol>
<p>1.1. If <span class="math">\(D \neq 0\)</span>. The characteristic equation has four distict roots, <span class="math">\(\lambda_1, \lambda_2, \lambda_3, \lambda_4\)</span>.
The general solution of the system is</p>
<div class="math">
\[x = C_1 b e^{\lambda_1 t} + C_2 b e^{\lambda_2 t} + C_3 b e^{\lambda_3 t} + C_4 b e^{\lambda_4 t}\]</div>
<div class="math">
\[y = C_1 (\lambda_1^{2} - a) e^{\lambda_1 t} + C_2 (\lambda_2^{2} - a) e^{\lambda_2 t} + C_3 (\lambda_3^{2} - a) e^{\lambda_3 t} + C_4 (\lambda_4^{2} - a) e^{\lambda_4 t}\]</div>
<p>where <span class="math">\(C_1,..., C_4\)</span> are arbitary constants.</p>
<p>1.2. If <span class="math">\(D = 0\)</span> and <span class="math">\(a \neq d\)</span>:</p>
<div class="math">
\[x = 2 C_1 (bt + \frac{2bk}{a - d}) e^{\frac{kt}{2}} + 2 C_2 (bt + \frac{2bk}{a - d}) e^{\frac{-kt}{2}} + 2b C_3 t e^{\frac{kt}{2}} + 2b C_4 t e^{\frac{-kt}{2}}\]</div>
<div class="math">
\[y = C_1 (d - a) t e^{\frac{kt}{2}} + C_2 (d - a) t e^{\frac{-kt}{2}} + C_3 [(d - a) t + 2k] e^{\frac{kt}{2}} + C_4 [(d - a) t - 2k] e^{\frac{-kt}{2}}\]</div>
<p>where <span class="math">\(C_1,..., C_4\)</span> are arbitary constants and <span class="math">\(k = \sqrt{2 (a + d)}\)</span></p>
<p>1.3. If <span class="math">\(D = 0\)</span> and <span class="math">\(a = d \neq 0\)</span> and <span class="math">\(b = 0\)</span>:</p>
<div class="math">
\[x = 2 \sqrt{a} C_1 e^{\sqrt{a} t} + 2 \sqrt{a} C_2 e^{-\sqrt{a} t}\]</div>
<div class="math">
\[y = c C_1 t e^{\sqrt{a} t} - c C_2 t e^{-\sqrt{a} t} + C_3 e^{\sqrt{a} t} + C_4 e^{-\sqrt{a} t}\]</div>
<p>1.4. If <span class="math">\(D = 0\)</span> and <span class="math">\(a = d \neq 0\)</span> and <span class="math">\(c = 0\)</span>:</p>
<div class="math">
\[x = b C_1 t e^{\sqrt{a} t} - b C_2 t e^{-\sqrt{a} t} + C_3 e^{\sqrt{a} t} + C_4 e^{-\sqrt{a} t}\]</div>
<div class="math">
\[y = 2 \sqrt{a} C_1 e^{\sqrt{a} t} + 2 \sqrt{a} C_2 e^{-\sqrt{a} t}\]</div>
<ol class="arabic simple" start="2">
<li>When <span class="math">\(ad - bc = 0\)</span> and <span class="math">\(a^2 + b^2 &gt; 0\)</span>. Then the original system becomes</li>
</ol>
<div class="math">
\[x'' = ax + by\]</div>
<div class="math">
\[y'' = k (ax + by)\]</div>
<p>2.1. If <span class="math">\(a + bk \neq 0\)</span>:</p>
<div class="math">
\[x = C_1 e^{t \sqrt{a + bk}} + C_2 e^{-t \sqrt{a + bk}} + C_3 bt + C_4 b\]</div>
<div class="math">
\[y = C_1 k e^{t \sqrt{a + bk}} + C_2 k e^{-t \sqrt{a + bk}} - C_3 at - C_4 a\]</div>
<p>2.2. If <span class="math">\(a + bk = 0\)</span>:</p>
<div class="math">
\[x = C_1 b t^3 + C_2 b t^2 + C_3 t + C_4\]</div>
<div class="math">
\[y = kx + 6 C_1 t + 2 C_2\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type2">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type2</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type2">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type2</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type2" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations in this type are</p>
<div class="math">
\[x'' = a_1 x + b_1 y + c_1\]</div>
<div class="math">
\[y'' = a_2 x + b_2 y + c_2\]</div>
<p>The general solution of this system is given by the sum of its particular solution
and the general solution of the homogeneous system. The general solution is given
by the linear system of 2 equation of order 2 and type 1</p>
<p>1. If <span class="math">\(a_1 b_2 - a_2 b_1 \neq 0\)</span>. A particular solution will be <span class="math">\(x = x_0\)</span> and <span class="math">\(y = y_0\)</span>
where the constants <span class="math">\(x_0\)</span> and <span class="math">\(y_0\)</span> are determined by solving the linear algebraic system</p>
<div class="math">
\[a_1 x_0 + b_1 y_0 + c_1 = 0, a_2 x_0 + b_2 y_0 + c_2 = 0\]</div>
<ol class="arabic simple" start="2">
<li>If <span class="math">\(a_1 b_2 - a_2 b_1 = 0\)</span> and <span class="math">\(a_1^2 + b_1^2 &gt; 0\)</span>. In this case, the system in question becomes</li>
</ol>
<div class="math">
\[x'' = ax + by + c_1, y'' = k (ax + by) + c_2\]</div>
<p>2.1. If <span class="math">\(\sigma = a + bk \neq 0\)</span>, the particular solution will be</p>
<div class="math">
\[x = \frac{1}{2} b \sigma^{-1} (c_1 k - c_2) t^2 - \sigma^{-2} (a c_1 + b c_2)\]</div>
<div class="math">
\[y = kx + \frac{1}{2} (c_2 - c_1 k) t^2\]</div>
<p>2.2. If <span class="math">\(\sigma = a + bk = 0\)</span>, the particular solution will be</p>
<div class="math">
\[x = \frac{1}{24} b (c_2 - c_1 k) t^4 + \frac{1}{2} c_1 t^2\]</div>
<div class="math">
\[y = kx + \frac{1}{2} (c_2 - c_1 k) t^2\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type3">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type3</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type3" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type3">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type3</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type3" title="Permalink to this definition">¶</a></dt>
<dd><p>These type of equation is used for describing the horizontal motion of a pendulum
taking into account the Earth rotation.
The solution is given with <span class="math">\(a^2 + 4b &gt; 0\)</span>:</p>
<div class="math">
\[x = C_1 \cos(\alpha t) + C_2 \sin(\alpha t) + C_3 \cos(\beta t) + C_4 \sin(\beta t)\]</div>
<div class="math">
\[y = -C_1 \sin(\alpha t) + C_2 \cos(\alpha t) - C_3 \sin(\beta t) + C_4 \cos(\beta t)\]</div>
<p>where <span class="math">\(C_1,...,C_4\)</span> and</p>
<div class="math">
\[\alpha = \frac{1}{2} a + \frac{1}{2} \sqrt{a^2 + 4b}, \beta = \frac{1}{2} a - \frac{1}{2} \sqrt{a^2 + 4b}\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type4">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type4</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type4" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type4">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type4</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type4" title="Permalink to this definition">¶</a></dt>
<dd><p>These equations are found in the theory of oscillations</p>
<div class="math">
\[x'' + a_1 x' + b_1 y' + c_1 x + d_1 y = k_1 e^{i \omega t}\]</div>
<div class="math">
\[y'' + a_2 x' + b_2 y' + c_2 x + d_2 y = k_2 e^{i \omega t}\]</div>
<p>The general solution of this linear nonhomogeneous system of constant-coefficient
differential equations is given by the sum of its particular solution and the
general solution of the corresponding homogeneous system (with <span class="math">\(k_1 = k_2 = 0\)</span>)</p>
<ol class="arabic simple">
<li>A particular solution is obtained by the method of undetermined coefficients:</li>
</ol>
<div class="math">
\[x = A_* e^{i \omega t}, y = B_* e^{i \omega t}\]</div>
<p>On substituting these expressions into the original system of differential equations,
one arrive at a linear nonhomogeneous system of algebraic equations for the
coefficients <span class="math">\(A\)</span> and <span class="math">\(B\)</span>.</p>
<p>2. The general solution of the homogeneous system of differential equations is determined
by a linear combination of linearly independent particular solutions determined by
the method of undetermined coefficients in the form of exponentials:</p>
<div class="math">
\[x = A e^{\lambda t}, y = B e^{\lambda t}\]</div>
<p>On substituting these expressions into the original system and colleting the
coefficients of the unknown <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, one obtains</p>
<div class="math">
\[(\lambda^{2} + a_1 \lambda + c_1) A + (b_1 \lambda + d_1) B = 0\]</div>
<div class="math">
\[(a_2 \lambda + c_2) A + (\lambda^{2} + b_2 \lambda + d_2) B = 0\]</div>
<p>The determinant of this system must vanish for nontrivial solutions A, B to exist.
This requirement results in the following characteristic equation for <span class="math">\(\lambda\)</span></p>
<div class="math">
\[(\lambda^2 + a_1 \lambda + c_1) (\lambda^2 + b_2 \lambda + d_2) - (b_1 \lambda + d_1) (a_2 \lambda + c_2) = 0\]</div>
<p>If all roots <span class="math">\(k_1,...,k_4\)</span> of this equation are distict, the general solution of the original
system of the differential equations has the form</p>
<div class="math">
\[x = C_1 (b_1 \lambda_1 + d_1) e^{\lambda_1 t} - C_2 (b_1 \lambda_2 + d_1) e^{\lambda_2 t} - C_3 (b_1 \lambda_3 + d_1) e^{\lambda_3 t} - C_4 (b_1 \lambda_4 + d_1) e^{\lambda_4 t}\]</div>
<div class="math">
\[y = C_1 (\lambda_1^{2} + a_1 \lambda_1 + c_1) e^{\lambda_1 t} + C_2 (\lambda_2^{2} + a_1 \lambda_2 + c_1) e^{\lambda_2 t} + C_3 (\lambda_3^{2} + a_1 \lambda_3 + c_1) e^{\lambda_3 t} + C_4 (\lambda_4^{2} + a_1 \lambda_4 + c_1) e^{\lambda_4 t}\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type5">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type5</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type5" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type5">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type5</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type5" title="Permalink to this definition">¶</a></dt>
<dd><p>The equation which come under this catagory are</p>
<div class="math">
\[x'' = a (t y' - y)\]</div>
<div class="math">
\[y'' = b (t x' - x)\]</div>
<p>The transformation</p>
<div class="math">
\[u = t x' - x, b = t y' - y\]</div>
<p>leads to the first-order system</p>
<div class="math">
\[u' = atv, v' = btu\]</div>
<p>The general solution of this system is given by</p>
<p>If <span class="math">\(ab &gt; 0\)</span>:</p>
<div class="math">
\[u = C_1 a e^{\frac{1}{2} \sqrt{ab} t^2} + C_2 a e^{-\frac{1}{2} \sqrt{ab} t^2}\]</div>
<div class="math">
\[v = C_1 \sqrt{ab} e^{\frac{1}{2} \sqrt{ab} t^2} - C_2 \sqrt{ab} e^{-\frac{1}{2} \sqrt{ab} t^2}\]</div>
<p>If <span class="math">\(ab &lt; 0\)</span>:</p>
<div class="math">
\[u = C_1 a \cos(\frac{1}{2} \sqrt{\left|ab\right|} t^2) + C_2 a \sin(-\frac{1}{2} \sqrt{\left|ab\right|} t^2)\]</div>
<div class="math">
\[v = C_1 \sqrt{\left|ab\right|} \sin(\frac{1}{2} \sqrt{\left|ab\right|} t^2) + C_2 \sqrt{\left|ab\right|} \cos(-\frac{1}{2} \sqrt{\left|ab\right|} t^2)\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitary constants. On substituting the value of <span class="math">\(u\)</span> and <span class="math">\(v\)</span>
in above equations and integrating the resulting expressions, the general solution will become</p>
<div class="math">
\[x = C_3 t + t \int \frac{u}{t^2} \,dt, y = C_4 t + t \int \frac{u}{t^2} \,dt\]</div>
<p>where <span class="math">\(C_3\)</span> and <span class="math">\(C_4\)</span> are arbitrary constants.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type6">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type6</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type6" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type6">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type6</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type6"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type6" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations are</p>
<div class="math">
\[x'' = f(t) (a_1 x + b_1 y)\]</div>
<div class="math">
\[y'' = f(t) (a_2 x + b_2 y)\]</div>
<p>If <span class="math">\(k_1\)</span> and <span class="math">\(k_2\)</span> are roots of the quadratic equation</p>
<div class="math">
\[k^2 - (a_1 + b_2) k + a_1 b_2 - a_2 b_1 = 0\]</div>
<p>Then by multiplying appropriate constants and adding together original equations
we obtain two independent equations:</p>
<div class="math">
\[z_1'' = k_1 f(t) z_1, z_1 = a_2 x + (k_1 - a_1) y\]</div>
<div class="math">
\[z_2'' = k_2 f(t) z_2, z_2 = a_2 x + (k_2 - a_1) y\]</div>
<p>Solving the equations will give the values of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> after obtaining the value
of <span class="math">\(z_1\)</span> and <span class="math">\(z_2\)</span> by solving the differential equation and substuting the result.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type7">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type7</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type7" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type7">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type7</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type7"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type7" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations are given as</p>
<div class="math">
\[x'' = f(t) (a_1 x' + b_1 y')\]</div>
<div class="math">
\[y'' = f(t) (a_2 x' + b_2 y')\]</div>
<p>If <span class="math">\(k_1\)</span> and ‘k_2` are roots of the quadratic equation</p>
<div class="math">
\[k^2 - (a_1 + b_2) k + a_1 b_2 - a_2 b_1 = 0\]</div>
<p>Then the system can be reduced by adding together the two equations multiplied
by appropriate constants give following two independent equations:</p>
<div class="math">
\[z_1'' = k_1 f(t) z_1', z_1 = a_2 x + (k_1 - a_1) y\]</div>
<div class="math">
\[z_2'' = k_2 f(t) z_2', z_2 = a_2 x + (k_2 - a_1) y\]</div>
<p>Integrating these and returning to the original variables, one arrives at a linear
algebraic system for the unknowns <span class="math">\(x\)</span> and <span class="math">\(y\)</span>:</p>
<div class="math">
\[a_2 x + (k_1 - a_1) y = C_1 \int e^{k_1 F(t)} \,dt + C_2\]</div>
<div class="math">
\[a_2 x + (k_2 - a_1) y = C_3 \int e^{k_2 F(t)} \,dt + C_4\]</div>
<p>where <span class="math">\(C_1,...,C_4\)</span> are arbitrary constants and <span class="math">\(F(t) = \int f(t) \,dt\)</span></p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type8">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type8</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type8" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type8">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type8</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type8"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type8" title="Permalink to this definition">¶</a></dt>
<dd><p>The equation of this catagory are</p>
<div class="math">
\[x'' = a f(t) (t y' - y)\]</div>
<div class="math">
\[y'' = b f(t) (t x' - x)\]</div>
<p>The transformation</p>
<div class="math">
\[u = t x' - x, v = t y' - y\]</div>
<p>leads to the system of first-order equations</p>
<div class="math">
\[u' = a t f(t) v, v' = b t f(t) u\]</div>
<p>The general solution of this system has the form</p>
<p>If <span class="math">\(ab &gt; 0\)</span>:</p>
<div class="math">
\[u = C_1 a e^{\sqrt{ab} \int t f(t) \,dt} + C_2 a e^{-\sqrt{ab} \int t f(t) \,dt}\]</div>
<div class="math">
\[v = C_1 \sqrt{ab} e^{\sqrt{ab} \int t f(t) \,dt} - C_2 \sqrt{ab} e^{-\sqrt{ab} \int t f(t) \,dt}\]</div>
<p>If <span class="math">\(ab &lt; 0\)</span>:</p>
<div class="math">
\[u = C_1 a \cos(\sqrt{\left|ab\right|} \int t f(t) \,dt) + C_2 a \sin(-\sqrt{\left|ab\right|} \int t f(t) \,dt)\]</div>
<div class="math">
\[v = C_1 \sqrt{\left|ab\right|} \sin(\sqrt{\left|ab\right|} \int t f(t) \,dt) + C_2 \sqrt{\left|ab\right|} \cos(-\sqrt{\left|ab\right|} \int t f(t) \,dt)\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitary constants. On substituting the value of <span class="math">\(u\)</span> and <span class="math">\(v\)</span>
in above equations and integrating the resulting expressions, the general solution will become</p>
<div class="math">
\[x = C_3 t + t \int \frac{u}{t^2} \,dt, y = C_4 t + t \int \frac{u}{t^2} \,dt\]</div>
<p>where <span class="math">\(C_3\)</span> and <span class="math">\(C_4\)</span> are arbitrary constants.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type9">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type9</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type9" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type9">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type9</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type9"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type9" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[t^2 x'' + a_1 t x' + b_1 t y' + c_1 x + d_1 y = 0\]</div>
<div class="math">
\[t^2 y'' + a_2 t x' + b_2 t y' + c_2 x + d_2 y = 0\]</div>
<p>These system of equations are euler type.</p>
<p>The substitution of <span class="math">\(t = \sigma e^{\tau} (\sigma \neq 0)\)</span> leads to the system of constant
coefficient linear differential equations</p>
<div class="math">
\[x'' + (a_1 - 1) x' + b_1 y' + c_1 x + d_1 y = 0\]</div>
<div class="math">
\[y'' + a_2 x' + (b_2 - 1) y' + c_2 x + d_2 y = 0\]</div>
<p>The general solution of the homogeneous system of differential equations is determined
by a linear combination of linearly independent particular solutions determined by
the method of undetermined coefficients in the form of exponentials</p>
<div class="math">
\[x = A e^{\lambda t}, y = B e^{\lambda t}\]</div>
<p>On substituting these expressions into the original system and colleting the
coefficients of the unknown <span class="math">\(A\)</span> and <span class="math">\(B\)</span>, one obtains</p>
<div class="math">
\[(\lambda^{2} + (a_1 - 1) \lambda + c_1) A + (b_1 \lambda + d_1) B = 0\]</div>
<div class="math">
\[(a_2 \lambda + c_2) A + (\lambda^{2} + (b_2 - 1) \lambda + d_2) B = 0\]</div>
<p>The determinant of this system must vanish for nontrivial solutions A, B to exist.
This requirement results in the following characteristic equation for <span class="math">\(\lambda\)</span></p>
<div class="math">
\[(\lambda^2 + (a_1 - 1) \lambda + c_1) (\lambda^2 + (b_2 - 1) \lambda + d_2) - (b_1 \lambda + d_1) (a_2 \lambda + c_2) = 0\]</div>
<p>If all roots <span class="math">\(k_1,...,k_4\)</span> of this equation are distict, the general solution of the original
system of the differential equations has the form</p>
<div class="math">
\[x = C_1 (b_1 \lambda_1 + d_1) e^{\lambda_1 t} - C_2 (b_1 \lambda_2 + d_1) e^{\lambda_2 t} - C_3 (b_1 \lambda_3 + d_1) e^{\lambda_3 t} - C_4 (b_1 \lambda_4 + d_1) e^{\lambda_4 t}\]</div>
<div class="math">
\[y = C_1 (\lambda_1^{2} + (a_1 - 1) \lambda_1 + c_1) e^{\lambda_1 t} + C_2 (\lambda_2^{2} + (a_1 - 1) \lambda_2 + c_1) e^{\lambda_2 t} + C_3 (\lambda_3^{2} + (a_1 - 1) \lambda_3 + c_1) e^{\lambda_3 t} + C_4 (\lambda_4^{2} + (a_1 - 1) \lambda_4 + c_1) e^{\lambda_4 t}\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type10">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type10</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type10" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type10">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type10</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type10"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type10" title="Permalink to this definition">¶</a></dt>
<dd><p>The equation of this catagory are</p>
<div class="math">
\[(\alpha t^2 + \beta t + \gamma)^{2} x'' = ax + by\]</div>
<div class="math">
\[(\alpha t^2 + \beta t + \gamma)^{2} y'' = cx + dy\]</div>
<p>The transformation</p>
<div class="math">
\[\tau = \int \frac{1}{\alpha t^2 + \beta t + \gamma} \,dt , u = \frac{x}{\sqrt{\left|\alpha t^2 + \beta t + \gamma\right|}} , v = \frac{y}{\sqrt{\left|\alpha t^2 + \beta t + \gamma\right|}}\]</div>
<p>leads to a constant coefficient linear system of equations</p>
<div class="math">
\[u'' = (a - \alpha \gamma + \frac{1}{4} \beta^{2}) u + b v\]</div>
<div class="math">
\[v'' = c u + (d - \alpha \gamma + \frac{1}{4} \beta^{2}) v\]</div>
<p>These system of equations obtained can be solved by type1 of System of two
constant-coefficient second-order linear homogeneous differential equations.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-2eq-order2-type11">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type11</span></code><a class="headerlink" href="#system-of-odes-linear-2eq-order2-type11" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_2eq_order2_type11">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_2eq_order2_type11</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_2eq_order2_type11"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_2eq_order2_type11" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations which comes under this type are</p>
<div class="math">
\[x'' = f(t) (t x' - x) + g(t) (t y' - y)\]</div>
<div class="math">
\[y'' = h(t) (t x' - x) + p(t) (t y' - y)\]</div>
<p>The transformation</p>
<div class="math">
\[u = t x' - x, v = t y' - y\]</div>
<p>leads to the linear system of first-order equations</p>
<div class="math">
\[u' = t f(t) u + t g(t) v, v' = t h(t) u + t p(t) v\]</div>
<p>On substituting the value of <span class="math">\(u\)</span> and <span class="math">\(v\)</span> in transformed equation gives value of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> as</p>
<div class="math">
\[x = C_3 t + t \int \frac{u}{t^2} \,dt , y = C_4 t + t \int \frac{v}{t^2} \,dt.\]</div>
<p>where <span class="math">\(C_3\)</span> and <span class="math">\(C_4\)</span> are arbitrary constants.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-3eq-order1-type1">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_3eq_order1_type1</span></code><a class="headerlink" href="#system-of-odes-linear-3eq-order1-type1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_3eq_order1_type1">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_3eq_order1_type1</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_3eq_order1_type1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_3eq_order1_type1" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[x' = ax\]</div>
<div class="math">
\[y' = bx + cy\]</div>
<div class="math">
\[z' = dx + ky + pz\]</div>
<p>Solution of such equations are forward substitution. Solving first equations
gives the value of <span class="math">\(x\)</span>, substituting it in second and third equation and
solving second equation gives <span class="math">\(y\)</span> and similarly substituting <span class="math">\(y\)</span> in third
equation give <span class="math">\(z\)</span>.</p>
<div class="math">
\[x = C_1 e^{at}\]</div>
<div class="math">
\[y = \frac{b C_1}{a - c} e^{at} + C_2 e^{ct}\]</div>
<div class="math">
\[z = \frac{C_1}{a - p} (d + \frac{bk}{a - c}) e^{at} + \frac{k C_2}{c - p} e^{ct} + C_3 e^{pt}\]</div>
<p>where <span class="math">\(C_1, C_2\)</span> and <span class="math">\(C_3\)</span> are arbitrary constants.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-3eq-order1-type2">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_3eq_order1_type2</span></code><a class="headerlink" href="#system-of-odes-linear-3eq-order1-type2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_3eq_order1_type2">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_3eq_order1_type2</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_3eq_order1_type2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_3eq_order1_type2" title="Permalink to this definition">¶</a></dt>
<dd><p>The equations of this type are</p>
<div class="math">
\[x' = cy - bz\]</div>
<div class="math">
\[y' = az - cx\]</div>
<div class="math">
\[z' = bx - ay\]</div>
<ol class="arabic simple">
<li>First integral:</li>
</ol>
<div class="math">
\[ax + by + cz = A             \qquad - (1)\]</div>
<div class="math">
\[x^2 + y^2 + z^2 = B^2        \qquad - (2)\]</div>
<p>where <span class="math">\(A\)</span> and <span class="math">\(B\)</span> are arbitrary constants. It follows from these integrals
that the integral lines are circles formed by the intersection of the planes
<span class="math">\((1)\)</span> and sphere <span class="math">\((2)\)</span></p>
<ol class="arabic simple" start="2">
<li>Solution:</li>
</ol>
<div class="math">
\[x = a C_0 + k C_1 \cos(kt) + (c C_2 - b C_3) \sin(kt)\]</div>
<div class="math">
\[y = b C_0 + k C_2 \cos(kt) + (a C_2 - c C_3) \sin(kt)\]</div>
<div class="math">
\[z = c C_0 + k C_3 \cos(kt) + (b C_2 - a C_3) \sin(kt)\]</div>
<p>where <span class="math">\(k = \sqrt{a^2 + b^2 + c^2}\)</span> and the four constants of integration,
<span class="math">\(C_1,...,C_4\)</span> are constrained by a single relation,</p>
<div class="math">
\[a C_1 + b C_2 + c C_3 = 0\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-3eq-order1-type3">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_3eq_order1_type3</span></code><a class="headerlink" href="#system-of-odes-linear-3eq-order1-type3" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_3eq_order1_type3">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_3eq_order1_type3</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_3eq_order1_type3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_3eq_order1_type3" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations of this system of ODEs</p>
<div class="math">
\[a x' = bc (y - z)\]</div>
<div class="math">
\[b y' = ac (z - x)\]</div>
<div class="math">
\[c z' = ab (x - y)\]</div>
<ol class="arabic simple">
<li>First integral:</li>
</ol>
<div class="math">
\[a^2 x + b^2 y + c^2 z = A\]</div>
<p>where A is an arbitary constant. It follows that the integral lines are plane curves.</p>
<ol class="arabic simple" start="2">
<li>Solution:</li>
</ol>
<div class="math">
\[x = C_0 + k C_1 \cos(kt) + a^{-1} bc (C_2 - C_3) \sin(kt)\]</div>
<div class="math">
\[y = C_0 + k C_2 \cos(kt) + a b^{-1} c (C_3 - C_1) \sin(kt)\]</div>
<div class="math">
\[z = C_0 + k C_3 \cos(kt) + ab c^{-1} (C_1 - C_2) \sin(kt)\]</div>
<p>where <span class="math">\(k = \sqrt{a^2 + b^2 + c^2}\)</span> and the four constants of integration,
<span class="math">\(C_1,...,C_4\)</span> are constrained by a single relation</p>
<div class="math">
\[a^2 C_1 + b^2 C_2 + c^2 C_3 = 0\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-3eq-order1-type4">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_3eq_order1_type4</span></code><a class="headerlink" href="#system-of-odes-linear-3eq-order1-type4" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_3eq_order1_type4">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_3eq_order1_type4</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, <em>r</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_3eq_order1_type4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_3eq_order1_type4" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math">
\[x' = (a_1 f(t) + g(t)) x + a_2 f(t) y + a_3 f(t) z\]</div>
<div class="math">
\[y' = b_1 f(t) x + (b_2 f(t) + g(t)) y + b_3 f(t) z\]</div>
<div class="math">
\[z' = c_1 f(t) x + c_2 f(t) y + (c_3 f(t) + g(t)) z\]</div>
<p>The transformation</p>
<div class="math">
\[x = e^{\int g(t) \,dt} u, y = e^{\int g(t) \,dt} v, z = e^{\int g(t) \,dt} w, \tau = \int f(t) \,dt\]</div>
<p>leads to the system of constant coefficient linear differential equations</p>
<div class="math">
\[u' = a_1 u + a_2 v + a_3 w\]</div>
<div class="math">
\[v' = b_1 u + b_2 v + b_3 w\]</div>
<div class="math">
\[w' = c_1 u + c_2 v + c_3 w\]</div>
<p>These system of equations are solved by homogeneous linear system of constant
coefficients of <span class="math">\(n\)</span> equations of first order. Then substituting the value of
<span class="math">\(u, v\)</span> and <span class="math">\(w\)</span> in transformed equation gives value of <span class="math">\(x, y\)</span> and <span class="math">\(z\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-linear-neq-order1-type1">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_linear_neq_order1_type1</span></code><a class="headerlink" href="#system-of-odes-linear-neq-order1-type1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._linear_neq_order1_type1">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_linear_neq_order1_type1</code><span class="sig-paren">(</span><em>match_</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_linear_neq_order1_type1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._linear_neq_order1_type1" title="Permalink to this definition">¶</a></dt>
<dd><p>System of n first-order constant-coefficient linear nonhomogeneous differential equation</p>
<div class="math">
\[y'_k = a_{k1} y_1 + a_{k2} y_2 +...+ a_{kn} y_n; k = 1,2,...,n\]</div>
<p>or that can be written as <span class="math">\(\vec{y'} = A . \vec{y}\)</span>
where <span class="math">\(\vec{y}\)</span> is matrix of <span class="math">\(y_k\)</span> for <span class="math">\(k = 1,2,...n\)</span> and <span class="math">\(A\)</span> is a <span class="math">\(n \times n\)</span> matrix.</p>
<p>Since these equations are equivalent to a first order homogeneous linear
differential equation. So the general solution will contain <span class="math">\(n\)</span> linearly
independent parts and solution will consist some type of exponential
functions. Assuming <span class="math">\(y = \vec{v} e^{rt}\)</span> is a solution of the system where
<span class="math">\(\vec{v}\)</span> is a vector of coefficients of <span class="math">\(y_1,...,y_n\)</span>. Substituting <span class="math">\(y\)</span> and
<span class="math">\(y' = r v e^{r t}\)</span> into the equation <span class="math">\(\vec{y'} = A . \vec{y}\)</span>, we get</p>
<div class="math">
\[r \vec{v} e^{rt} = A \vec{v} e^{rt}\]</div>
<div class="math">
\[r \vec{v} = A \vec{v}\]</div>
<p>where <span class="math">\(r\)</span> comes out to be eigenvalue of <span class="math">\(A\)</span> and vector <span class="math">\(\vec{v}\)</span> is the eigenvector
of <span class="math">\(A\)</span> corresponding to <span class="math">\(r\)</span>. There are three possiblities of eigenvalues of <span class="math">\(A\)</span></p>
<ul class="simple">
<li><span class="math">\(n\)</span> distinct real eigenvalues</li>
<li>complex conjugate eigenvalues</li>
<li>eigenvalues with multiplicity <span class="math">\(k\)</span></li>
</ul>
<p>1. When all eigenvalues <span class="math">\(r_1,..,r_n\)</span> are distinct with <span class="math">\(n\)</span> different eigenvectors
<span class="math">\(v_1,...v_n\)</span> then the solution is given by</p>
<div class="math">
\[\vec{y} = C_1 e^{r_1 t} \vec{v_1} + C_2 e^{r_2 t} \vec{v_2} +...+ C_n e^{r_n t} \vec{v_n}\]</div>
<p>where <span class="math">\(C_1,C_2,...,C_n\)</span> are arbitrary constants.</p>
<p>2. When some eigenvalues are complex then in order to make the solution real,
we take a llinear combination: if <span class="math">\(r = a + bi\)</span> has an eigenvector
<span class="math">\(\vec{v} = \vec{w_1} + i \vec{w_2}\)</span> then to obtain real-valued solutions to
the system, replace the complex-valued solutions <span class="math">\(e^{rx} \vec{v}\)</span>
with real-valued solution <span class="math">\(e^{ax} (\vec{w_1} \cos(bx) - \vec{w_2} \sin(bx))\)</span>
and for <span class="math">\(r = a - bi\)</span> replace the solution <span class="math">\(e^{-r x} \vec{v}\)</span> with
<span class="math">\(e^{ax} (\vec{w_1} \sin(bx) + \vec{w_2} \cos(bx))\)</span></p>
<p>3. If some eigenvalues are repeated. Then we get fewer than <span class="math">\(n\)</span> linearly
independent eigenvectors, we miss some of the solutions and need to
construct the missing ones. We do this via generalized eigenvectors, vectors
which are not eigenvectors but are close enough that we can use to write
down the remaining solutions. For a eigenvalue <span class="math">\(r\)</span> with eigenvector <span class="math">\(\vec{w}\)</span>
we obtain <span class="math">\(\vec{w_2},...,\vec{w_k}\)</span> using</p>
<div class="math">
\[(A - r I) . \vec{w_2} = \vec{w}\]</div>
<div class="math">
\[(A - r I) . \vec{w_3} = \vec{w_2}\]</div>
<div class="math">
\[\vdots\]</div>
<div class="math">
\[(A - r I) . \vec{w_k} = \vec{w_{k-1}}\]</div>
<p>Then the solutions to the system for the eigenspace are <span class="math">\(e^{rt} [\vec{w}],
e^{rt} [t \vec{w} + \vec{w_2}], e^{rt} [\frac{t^2}{2} \vec{w} + t \vec{w_2} + \vec{w_3}],
...,e^{rt} [\frac{t^{k-1}}{(k-1)!} \vec{w} + \frac{t^{k-2}}{(k-2)!} \vec{w_2} +...+ t \vec{w_{k-1}}
+ \vec{w_k}]\)</span></p>
<p>So, If <span class="math">\(\vec{y_1},...,\vec{y_n}\)</span> are <span class="math">\(n\)</span> solution of obtained from three
categories of <span class="math">\(A\)</span>, then general solution to the system <span class="math">\(\vec{y'} = A . \vec{y}\)</span></p>
<div class="math">
\[\vec{y} = C_1 \vec{y_1} + C_2 \vec{y_2} + \cdots + C_n \vec{y_n}\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-2eq-order1-type1">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type1</span></code><a class="headerlink" href="#system-of-odes-nonlinear-2eq-order1-type1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_2eq_order1_type1">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_2eq_order1_type1</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_2eq_order1_type1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_2eq_order1_type1" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math">
\[x' = x^n F(x,y)\]</div>
<div class="math">
\[y' = g(y) F(x,y)\]</div>
<p>Solution:</p>
<div class="math">
\[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]</div>
<p>where</p>
<p>if <span class="math">\(n \neq 1\)</span></p>
<div class="math">
\[\varphi = [C_1 + (1-n) \int \frac{1}{g(y)} \,dy]^{\frac{1}{1-n}}\]</div>
<p>if <span class="math">\(n = 1\)</span></p>
<div class="math">
\[\varphi = C_1 e^{\int \frac{1}{g(y)} \,dy}\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitrary constants.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-2eq-order1-type2">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type2</span></code><a class="headerlink" href="#system-of-odes-nonlinear-2eq-order1-type2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_2eq_order1_type2">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_2eq_order1_type2</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_2eq_order1_type2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_2eq_order1_type2" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math">
\[x' = e^{\lambda x} F(x,y)\]</div>
<div class="math">
\[y' = g(y) F(x,y)\]</div>
<p>Solution:</p>
<div class="math">
\[x = \varphi(y), \int \frac{1}{g(y) F(\varphi(y),y)} \,dy = t + C_2\]</div>
<p>where</p>
<p>if <span class="math">\(\lambda \neq 0\)</span></p>
<div class="math">
\[\varphi = -\frac{1}{\lambda} log(C_1 - \lambda \int \frac{1}{g(y)} \,dy)\]</div>
<p>if <span class="math">\(\lambda = 0\)</span></p>
<div class="math">
\[\varphi = C_1 + \int \frac{1}{g(y)} \,dy\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitrary constants.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-2eq-order1-type3">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type3</span></code><a class="headerlink" href="#system-of-odes-nonlinear-2eq-order1-type3" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_2eq_order1_type3">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_2eq_order1_type3</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_2eq_order1_type3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_2eq_order1_type3" title="Permalink to this definition">¶</a></dt>
<dd><p>Autonomous system of general form</p>
<div class="math">
\[x' = F(x,y)\]</div>
<div class="math">
\[y' = G(x,y)\]</div>
<p>Assuming <span class="math">\(y = y(x, C_1)\)</span> where <span class="math">\(C_1\)</span> is an arbitrary constant is the general
solution of the first-order equation</p>
<div class="math">
\[F(x,y) y'_x = G(x,y)\]</div>
<p>Then the general solution of the original system of equations has the form</p>
<div class="math">
\[\int \frac{1}{F(x,y(x,C_1))} \,dx = t + C_1\]</div>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-2eq-order1-type4">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type4</span></code><a class="headerlink" href="#system-of-odes-nonlinear-2eq-order1-type4" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_2eq_order1_type4">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_2eq_order1_type4</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_2eq_order1_type4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_2eq_order1_type4" title="Permalink to this definition">¶</a></dt>
<dd><p>Equation:</p>
<div class="math">
\[x' = f_1(x) g_1(y) \phi(x,y,t)\]</div>
<div class="math">
\[y' = f_2(x) g_2(y) \phi(x,y,t)\]</div>
<p>First integral:</p>
<div class="math">
\[\int \frac{f_2(x)}{f_1(x)} \,dx - \int \frac{g_1(y)}{g_2(y)} \,dy = C\]</div>
<p>where <span class="math">\(C\)</span> is an arbitrary constant.</p>
<p>On solving the first integral for <span class="math">\(x\)</span> (resp., <span class="math">\(y\)</span> ) and on substituting the
resulting expression into either equation of the original solution, one
arrives at a firs-order equation for determining <span class="math">\(y\)</span> (resp., <span class="math">\(x\)</span> ).</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-2eq-order1-type5">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type5</span></code><a class="headerlink" href="#system-of-odes-nonlinear-2eq-order1-type5" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_2eq_order1_type5">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_2eq_order1_type5</code><span class="sig-paren">(</span><em>func</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_2eq_order1_type5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_2eq_order1_type5" title="Permalink to this definition">¶</a></dt>
<dd><p>Clairaut system of ODEs</p>
<div class="math">
\[x = t x' + F(x',y')\]</div>
<div class="math">
\[y = t y' + G(x',y')\]</div>
<p>The following are solutions of the system</p>
<p><span class="math">\((i)\)</span> straight lines:</p>
<div class="math">
\[x = C_1 t + F(C_1, C_2), y = C_2 t + G(C_1, C_2)\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitrary constants;</p>
<p><span class="math">\((ii)\)</span> envelopes of the above lines;</p>
<p><span class="math">\((iii)\)</span> continuously differentiable lines made up from segments of the lines
<span class="math">\((i)\)</span> and <span class="math">\((ii)\)</span>.</p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-3eq-order1-type1">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type1</span></code><a class="headerlink" href="#system-of-odes-nonlinear-3eq-order1-type1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_3eq_order1_type1">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_3eq_order1_type1</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_3eq_order1_type1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_3eq_order1_type1" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math">
\[a x' = (b - c) y z, \enspace b y' = (c - a) z x, \enspace c z' = (a - b) x y\]</div>
<p>First Integrals:</p>
<div class="math">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
<div class="math">
\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2} = C_2\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitrary constants. On solving the integrals for <span class="math">\(y\)</span> and
<span class="math">\(z\)</span> and on substituting the resulting expressions into the first equation of the
system, we arrives at a separable first-order equation on <span class="math">\(x\)</span>. Similarly doing that
for other two equations, we will arrive at first order equation on <span class="math">\(y\)</span> and <span class="math">\(z\)</span> too.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0401.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-3eq-order1-type2">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type2</span></code><a class="headerlink" href="#system-of-odes-nonlinear-3eq-order1-type2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_3eq_order1_type2">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_3eq_order1_type2</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_3eq_order1_type2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_3eq_order1_type2" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math">
\[a x' = (b - c) y z f(x, y, z, t)\]</div>
<div class="math">
\[b y' = (c - a) z x f(x, y, z, t)\]</div>
<div class="math">
\[c z' = (a - b) x y f(x, y, z, t)\]</div>
<p>First Integrals:</p>
<div class="math">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
<div class="math">
\[a^{2} x^{2} + b^{2} y^{2} + c^{2} z^{2} = C_2\]</div>
<p>where <span class="math">\(C_1\)</span> and <span class="math">\(C_2\)</span> are arbitrary constants. On solving the integrals for <span class="math">\(y\)</span> and
<span class="math">\(z\)</span> and on substituting the resulting expressions into the first equation of the
system, we arrives at a first-order differential equations on <span class="math">\(x\)</span>. Similarly doing
that for other two equations we will arrive at first order equation on <span class="math">\(y\)</span> and <span class="math">\(z\)</span>.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0402.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-3eq-order1-type3">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type3</span></code><a class="headerlink" href="#system-of-odes-nonlinear-3eq-order1-type3" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_3eq_order1_type3">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_3eq_order1_type3</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_3eq_order1_type3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_3eq_order1_type3" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math">
\[x' = c F_2 - b F_3, \enspace y' = a F_3 - c F_1, \enspace z' = b F_1 - a F_2\]</div>
<p>where <span class="math">\(F_n = F_n(x, y, z, t)\)</span>.</p>
<ol class="arabic simple">
<li>First Integral:</li>
</ol>
<div class="math">
\[a x + b y + c z = C_1,\]</div>
<p>where C is an arbitrary constant.</p>
<p>2. If we assume function <span class="math">\(F_n\)</span> to be independent of <span class="math">\(t\)</span>,i.e, <span class="math">\(F_n\)</span> = <span class="math">\(F_n (x, y, z)\)</span>
Then, on eliminating <span class="math">\(t\)</span> and <span class="math">\(z\)</span> from the first two equation of the system, one
arrives at the first-order equation</p>
<div class="math">
\[\frac{dy}{dx} = \frac{a F_3 (x, y, z) - c F_1 (x, y, z)}{c F_2 (x, y, z) -
b F_3 (x, y, z)}\]</div>
<p>where <span class="math">\(z = \frac{1}{c} (C_1 - a x - b y)\)</span></p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0404.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-3eq-order1-type4">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type4</span></code><a class="headerlink" href="#system-of-odes-nonlinear-3eq-order1-type4" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_3eq_order1_type4">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_3eq_order1_type4</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_3eq_order1_type4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_3eq_order1_type4" title="Permalink to this definition">¶</a></dt>
<dd><p>Equations:</p>
<div class="math">
\[x' = c z F_2 - b y F_3, \enspace y' = a x F_3 - c z F_1, \enspace z' = b y F_1 - a x F_2\]</div>
<p>where <span class="math">\(F_n = F_n (x, y, z, t)\)</span></p>
<ol class="arabic simple">
<li>First integral:</li>
</ol>
<div class="math">
\[a x^{2} + b y^{2} + c z^{2} = C_1\]</div>
<p>where <span class="math">\(C\)</span> is an arbitrary constant.</p>
<p>2. Assuming the function <span class="math">\(F_n\)</span> is independent of <span class="math">\(t\)</span>: <span class="math">\(F_n = F_n (x, y, z)\)</span>. Then on
eliminating <span class="math">\(t\)</span> and <span class="math">\(z\)</span> from the first two equations of the system, one arrives at
the first-order equation</p>
<div class="math">
\[\frac{dy}{dx} = \frac{a x F_3 (x, y, z) - c z F_1 (x, y, z)}
{c z F_2 (x, y, z) - b y F_3 (x, y, z)}\]</div>
<p>where <span class="math">\(z = \pm \sqrt{\frac{1}{c} (C_1 - a x^{2} - b y^{2})}\)</span></p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0405.pdf</a></p>
</dd></dl>

</div>
<div class="section" id="system-of-odes-nonlinear-3eq-order1-type5">
<h3><code class="xref py py-obj docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type5</span></code><a class="headerlink" href="#system-of-odes-nonlinear-3eq-order1-type5" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="sympy.solvers.ode._nonlinear_3eq_order1_type5">
<code class="descclassname">sympy.solvers.ode.</code><code class="descname">_nonlinear_3eq_order1_type5</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>t</em>, <em>eq</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/ode.html#_nonlinear_3eq_order1_type5"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.ode._nonlinear_3eq_order1_type5" title="Permalink to this definition">¶</a></dt>
<dd><div class="math">
\[x' = x (c F_2 - b F_3), \enspace y' = y (a F_3 - c F_1), \enspace z' = z (b F_1 - a F_2)\]</div>
<p>where <span class="math">\(F_n = F_n (x, y, z, t)\)</span> and are arbitrary functions.</p>
<p>First Integral:</p>
<div class="math">
\[\left|x\right|^{a} \left|y\right|^{b} \left|z\right|^{c} = C_1\]</div>
<p>where <span class="math">\(C\)</span> is an arbitrary constant. If the function <span class="math">\(F_n\)</span> is independent of <span class="math">\(t\)</span>,
then, by eliminating <span class="math">\(t\)</span> and <span class="math">\(z\)</span> from the first two equations of the system, one
arrives at a first-order equation.</p>
<p class="rubric">References</p>
<p>-<a class="reference external" href="http://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf">http://eqworld.ipmnet.ru/en/solutions/sysode/sode0406.pdf</a></p>
</dd></dl>

</div>
</div>
<div class="section" id="module-sympy.solvers.ode">
<span id="information-on-the-ode-module"></span><h2>Information on the ode module<a class="headerlink" href="#module-sympy.solvers.ode" title="Permalink to this headline">¶</a></h2>
<p>This module contains <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> and different helper
functions that it uses.</p>
<p><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> solves ordinary differential equations.
See the docstring on the various functions for their uses.  Note that partial
differential equations support is in <code class="docutils literal"><span class="pre">pde.py</span></code>.  Note that hint functions
have docstrings describing their various methods, but they are intended for
internal use.  Use <code class="docutils literal"><span class="pre">dsolve(ode,</span> <span class="pre">func,</span> <span class="pre">hint=hint)</span></code> to solve an ODE using a
specific hint.  See also the docstring on
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>.</p>
<p><strong>Functions in this module</strong></p>
<blockquote>
<div><p>These are the user functions in this module:</p>
<ul class="simple">
<li><a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> - Solves ODEs.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> - Classifies ODEs into
possible hints for <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><code class="xref py py-meth docutils literal"><span class="pre">checkodesol()</span></code></a> - Checks if an equation is the
solution to an ODE.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.homogeneous_order" title="sympy.solvers.ode.homogeneous_order"><code class="xref py py-meth docutils literal"><span class="pre">homogeneous_order()</span></code></a> - Returns the
homogeneous order of an expression.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.infinitesimals" title="sympy.solvers.ode.infinitesimals"><code class="xref py py-meth docutils literal"><span class="pre">infinitesimals()</span></code></a> - Returns the infinitesimals
of the Lie group of point transformations of an ODE, such that it is
invariant.</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">ode_checkinfsol()</span></code> - Checks if the given infinitesimals
are the actual infinitesimals of a first order ODE.</li>
</ul>
<p>These are the non-solver helper functions that are for internal use.  The
user should use the various options to
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> to obtain the functionality provided
by these functions:</p>
<ul class="simple">
<li><a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a> - Does all forms of ODE
simplification.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.ode_sol_simplicity" title="sympy.solvers.ode.ode_sol_simplicity"><code class="xref py py-meth docutils literal"><span class="pre">ode_sol_simplicity()</span></code></a> - A key function for
comparing solutions by simplicity.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal"><span class="pre">constantsimp()</span></code></a> - Simplifies arbitrary
constants.</li>
<li><a class="reference internal" href="#sympy.solvers.ode.constant_renumber" title="sympy.solvers.ode.constant_renumber"><code class="xref py py-meth docutils literal"><span class="pre">constant_renumber()</span></code></a> - Renumber arbitrary
constants.</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">_handle_Integral()</span></code> - Evaluate unevaluated
Integrals.</li>
</ul>
<p>See also the docstrings of these functions.</p>
</div></blockquote>
<p><strong>Currently implemented solver methods</strong></p>
<p>The following methods are implemented for solving ordinary differential
equations.  See the docstrings of the various hint functions for more
information on each (run <code class="docutils literal"><span class="pre">help(ode)</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li>1st order separable differential equations.</li>
<li>1st order differential equations whose coefficients or <span class="math">\(dx\)</span> and <span class="math">\(dy\)</span> are
functions homogeneous of the same order.</li>
<li>1st order exact differential equations.</li>
<li>1st order linear differential equations.</li>
<li>1st order Bernoulli differential equations.</li>
<li>Power series solutions for first order differential equations.</li>
<li>Lie Group method of solving first order differential equations.</li>
<li>2nd order Liouville differential equations.</li>
<li>Power series solutions for second order differential equations
at ordinary and regular singular points.</li>
<li><span class="math">\(n\)</span>th order linear homogeneous differential equation with constant
coefficients.</li>
<li><span class="math">\(n\)</span>th order linear inhomogeneous differential equation with constant
coefficients using the method of undetermined coefficients.</li>
<li><span class="math">\(n\)</span>th order linear inhomogeneous differential equation with constant
coefficients using the method of variation of parameters.</li>
</ul>
</div></blockquote>
<p><strong>Philosophy behind this module</strong></p>
<p>This module is designed to make it easy to add new ODE solving methods without
having to mess with the solving code for other methods.  The idea is that
there is a <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> function, which takes in
an ODE and tells you what hints, if any, will solve the ODE.  It does this
without attempting to solve the ODE, so it is fast.  Each solving method is a
hint, and it has its own function, named <code class="docutils literal"><span class="pre">ode_&lt;hint&gt;</span></code>.  That function takes
in the ODE and any match expression gathered by
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> and returns a solved result.  If
this result has any integrals in it, the hint function will return an
unevaluated <a class="reference internal" href="../integrals/integrals.html#sympy.integrals.Integral" title="sympy.integrals.Integral"><code class="xref py py-class docutils literal"><span class="pre">Integral</span></code></a> class.
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>, which is the user wrapper function
around all of this, will then call <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a> on
the result, which, among other things, will attempt to solve the equation for
the dependent variable (the function we are solving for), simplify the
arbitrary constants in the expression, and evaluate any integrals, if the hint
allows it.</p>
<p><strong>How to add new solution methods</strong></p>
<p>If you have an ODE that you want <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> to be
able to solve, try to avoid adding special case code here.  Instead, try
finding a general method that will solve your ODE, as well as others.  This
way, the <a class="reference internal" href="#module-sympy.solvers.ode" title="sympy.solvers.ode"><code class="xref py py-mod docutils literal"><span class="pre">ode</span></code></a> module will become more robust, and
unhindered by special case hacks.  WolphramAlpha and Maple’s
DETools[odeadvisor] function are two resources you can use to classify a
specific ODE.  It is also better for a method to work with an <span class="math">\(n\)</span>th order ODE
instead of only with specific orders, if possible.</p>
<p>To add a new method, there are a few things that you need to do.  First, you
need a hint name for your method.  Try to name your hint so that it is
unambiguous with all other methods, including ones that may not be implemented
yet.  If your method uses integrals, also include a <code class="docutils literal"><span class="pre">hint_Integral</span></code> hint.
If there is more than one way to solve ODEs with your method, include a hint
for each one, as well as a <code class="docutils literal"><span class="pre">&lt;hint&gt;_best</span></code> hint.  Your <code class="docutils literal"><span class="pre">ode_&lt;hint&gt;_best()</span></code>
function should choose the best using min with <code class="docutils literal"><span class="pre">ode_sol_simplicity</span></code> as the
key argument.  See
<a class="reference internal" href="#sympy.solvers.ode.ode_1st_homogeneous_coeff_best" title="sympy.solvers.ode.ode_1st_homogeneous_coeff_best"><code class="xref py py-meth docutils literal"><span class="pre">ode_1st_homogeneous_coeff_best()</span></code></a>, for example.
The function that uses your method will be called <code class="docutils literal"><span class="pre">ode_&lt;hint&gt;()</span></code>, so the
hint must only use characters that are allowed in a Python function name
(alphanumeric characters and the underscore ‘<code class="docutils literal"><span class="pre">_</span></code>’ character).  Include a
function for every hint, except for <code class="docutils literal"><span class="pre">_Integral</span></code> hints
(<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> takes care of those automatically).
Hint names should be all lowercase, unless a word is commonly capitalized
(such as Integral or Bernoulli).  If you have a hint that you do not want to
run with <code class="docutils literal"><span class="pre">all_Integral</span></code> that doesn’t have an <code class="docutils literal"><span class="pre">_Integral</span></code> counterpart (such
as a best hint that would defeat the purpose of <code class="docutils literal"><span class="pre">all_Integral</span></code>), you will
need to remove it manually in the <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> code.
See also the <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> docstring for
guidelines on writing a hint name.</p>
<p>Determine <em>in general</em> how the solutions returned by your method compare with
other methods that can potentially solve the same ODEs.  Then, put your hints
in the <a class="reference internal" href="#sympy.solvers.ode.allhints" title="sympy.solvers.ode.allhints"><code class="xref py py-data docutils literal"><span class="pre">allhints</span></code></a> tuple in the order that they
should be called.  The ordering of this tuple determines which hints are
default.  Note that exceptions are ok, because it is easy for the user to
choose individual hints with <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>.  In
general, <code class="docutils literal"><span class="pre">_Integral</span></code> variants should go at the end of the list, and
<code class="docutils literal"><span class="pre">_best</span></code> variants should go before the various hints they apply to.  For
example, the <code class="docutils literal"><span class="pre">undetermined_coefficients</span></code> hint comes before the
<code class="docutils literal"><span class="pre">variation_of_parameters</span></code> hint because, even though variation of parameters
is more general than undetermined coefficients, undetermined coefficients
generally returns cleaner results for the ODEs that it can solve than
variation of parameters does, and it does not require integration, so it is
much faster.</p>
<p>Next, you need to have a match expression or a function that matches the type
of the ODE, which you should put in <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a>
(if the match function is more than just a few lines, like
<code class="xref py py-meth docutils literal"><span class="pre">_undetermined_coefficients_match()</span></code>, it should go
outside of <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a>).  It should match the
ODE without solving for it as much as possible, so that
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> remains fast and is not hindered by
bugs in solving code.  Be sure to consider corner cases.  For example, if your
solution method involves dividing by something, make sure you exclude the case
where that division will be 0.</p>
<p>In most cases, the matching of the ODE will also give you the various parts
that you need to solve it.  You should put that in a dictionary (<code class="docutils literal"><span class="pre">.match()</span></code>
will do this for you), and add that as <code class="docutils literal"><span class="pre">matching_hints['hint']</span> <span class="pre">=</span> <span class="pre">matchdict</span></code>
in the relevant part of <a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a>.
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> will then send this to
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>, which will send it to your function as
the <code class="docutils literal"><span class="pre">match</span></code> argument.  Your function should be named <code class="docutils literal"><span class="pre">ode_&lt;hint&gt;(eq,</span> <span class="pre">func,</span>
<span class="pre">order,</span> <span class="pre">match)`.</span>&#160; <span class="pre">If</span> <span class="pre">you</span> <span class="pre">need</span> <span class="pre">to</span> <span class="pre">send</span> <span class="pre">more</span> <span class="pre">information,</span> <span class="pre">put</span> <span class="pre">it</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">``match</span></code>
dictionary.  For example, if you had to substitute in a dummy variable in
<a class="reference internal" href="#sympy.solvers.ode.classify_ode" title="sympy.solvers.ode.classify_ode"><code class="xref py py-meth docutils literal"><span class="pre">classify_ode()</span></code></a> to match the ODE, you will need to
pass it to your function using the <span class="math">\(match\)</span> dict to access it.  You can access
the independent variable using <code class="docutils literal"><span class="pre">func.args[0]</span></code>, and the dependent variable
(the function you are trying to solve for) as <code class="docutils literal"><span class="pre">func.func</span></code>.  If, while trying
to solve the ODE, you find that you cannot, raise <code class="docutils literal"><span class="pre">NotImplementedError</span></code>.
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a> will catch this error with the <code class="docutils literal"><span class="pre">all</span></code>
meta-hint, rather than causing the whole routine to fail.</p>
<p>Add a docstring to your function that describes the method employed.  Like
with anything else in SymPy, you will need to add a doctest to the docstring,
in addition to real tests in <code class="docutils literal"><span class="pre">test_ode.py</span></code>.  Try to maintain consistency
with the other hint functions’ docstrings.  Add your method to the list at the
top of this docstring.  Also, add your method to <code class="docutils literal"><span class="pre">ode.rst</span></code> in the
<code class="docutils literal"><span class="pre">docs/src</span></code> directory, so that the Sphinx docs will pull its docstring into
the main SymPy documentation.  Be sure to make the Sphinx documentation by
running <code class="docutils literal"><span class="pre">make</span> <span class="pre">html</span></code> from within the doc directory to verify that the
docstring formats correctly.</p>
<p>If your solution method involves integrating, use <code class="xref py py-meth docutils literal"><span class="pre">Integral()</span></code> instead of
<a class="reference internal" href="../core.html#sympy.core.expr.Expr.integrate" title="sympy.core.expr.Expr.integrate"><code class="xref py py-meth docutils literal"><span class="pre">integrate()</span></code></a>.  This allows the user to bypass
hard/slow integration by using the <code class="docutils literal"><span class="pre">_Integral</span></code> variant of your hint.  In
most cases, calling <a class="reference internal" href="../core.html#sympy.core.basic.Basic.doit" title="sympy.core.basic.Basic.doit"><code class="xref py py-meth docutils literal"><span class="pre">sympy.core.basic.Basic.doit()</span></code></a> will integrate your
solution.  If this is not the case, you will need to write special code in
<code class="xref py py-meth docutils literal"><span class="pre">_handle_Integral()</span></code>.  Arbitrary constants should be
symbols named <code class="docutils literal"><span class="pre">C1</span></code>, <code class="docutils literal"><span class="pre">C2</span></code>, and so on.  All solution methods should return
an equality instance.  If you need an arbitrary number of arbitrary constants,
you can use <code class="docutils literal"><span class="pre">constants</span> <span class="pre">=</span> <span class="pre">numbered_symbols(prefix='C',</span> <span class="pre">cls=Symbol,</span> <span class="pre">start=1)</span></code>.
If it is possible to solve for the dependent function in a general way, do so.
Otherwise, do as best as you can, but do not call solve in your
<code class="docutils literal"><span class="pre">ode_&lt;hint&gt;()</span></code> function.  <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a> will attempt
to solve the solution for you, so you do not need to do that.  Lastly, if your
ODE has a common simplification that can be applied to your solutions, you can
add a special case in <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a> for it.  For
example, solutions returned from the <code class="docutils literal"><span class="pre">1st_homogeneous_coeff</span></code> hints often
have many <code class="xref py py-meth docutils literal"><span class="pre">log()</span></code> terms, so
<a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a> calls
<a class="reference internal" href="../simplify/simplify.html#sympy.simplify.simplify.logcombine" title="sympy.simplify.simplify.logcombine"><code class="xref py py-meth docutils literal"><span class="pre">logcombine()</span></code></a> on them (it also helps to write
the arbitrary constant as <code class="docutils literal"><span class="pre">log(C1)</span></code> instead of <code class="docutils literal"><span class="pre">C1</span></code> in this case).  Also
consider common ways that you can rearrange your solution to have
<a class="reference internal" href="#sympy.solvers.ode.constantsimp" title="sympy.solvers.ode.constantsimp"><code class="xref py py-meth docutils literal"><span class="pre">constantsimp()</span></code></a> take better advantage of it.  It is
better to put simplification in <a class="reference internal" href="#sympy.solvers.ode.odesimp" title="sympy.solvers.ode.odesimp"><code class="xref py py-meth docutils literal"><span class="pre">odesimp()</span></code></a> than in
your method, because it can then be turned off with the simplify flag in
<a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>.  If you have any extraneous
simplification in your function, be sure to only run it using <code class="docutils literal"><span class="pre">if</span>
<span class="pre">match.get('simplify',</span> <span class="pre">True):</span></code>, especially if it can be slow or if it can
reduce the domain of the solution.</p>
<p>Finally, as with every contribution to SymPy, your method will need to be
tested.  Add a test for each method in <code class="docutils literal"><span class="pre">test_ode.py</span></code>.  Follow the
conventions there, i.e., test the solver using <code class="docutils literal"><span class="pre">dsolve(eq,</span> <span class="pre">f(x),</span>
<span class="pre">hint=your_hint)</span></code>, and also test the solution using
<a class="reference internal" href="#sympy.solvers.ode.checkodesol" title="sympy.solvers.ode.checkodesol"><code class="xref py py-meth docutils literal"><span class="pre">checkodesol()</span></code></a> (you can put these in a separate
tests and skip/XFAIL if it runs too slow/doesn’t work).  Be sure to call your
hint specifically in <a class="reference internal" href="#sympy.solvers.ode.dsolve" title="sympy.solvers.ode.dsolve"><code class="xref py py-meth docutils literal"><span class="pre">dsolve()</span></code></a>, that way the test
won’t be broken simply by the introduction of another matching hint.  If your
method works for higher order (&gt;1) ODEs, you will need to run <code class="docutils literal"><span class="pre">sol</span> <span class="pre">=</span>
<span class="pre">constant_renumber(sol,</span> <span class="pre">'C',</span> <span class="pre">1,</span> <span class="pre">order)</span></code> for each solution, where <code class="docutils literal"><span class="pre">order</span></code> is
the order of the ODE.  This is because <code class="docutils literal"><span class="pre">constant_renumber</span></code> renumbers the
arbitrary constants by printing order, which is platform dependent.  Try to
test every corner case of your solver, including a range of orders if it is a
<span class="math">\(n\)</span>th order solver, but if your solver is slow, such as if it involves hard
integration, try to keep the test run time down.</p>
<p>Feel free to refactor existing hints to avoid duplicating code or creating
inconsistencies.  If you can show that your method exactly duplicates an
existing method, including in the simplicity and speed of obtaining the
solutions, then you can remove the old, less general method.  The existing
code is tested extensively in <code class="docutils literal"><span class="pre">test_ode.py</span></code>, so if anything is broken, one
of those tests will surely fail.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ODE</a><ul>
<li><a class="reference internal" href="#user-functions">User Functions</a><ul>
<li><a class="reference internal" href="#dsolve"><code class="docutils literal"><span class="pre">dsolve()</span></code></a></li>
<li><a class="reference internal" href="#classify-ode"><code class="docutils literal"><span class="pre">classify_ode()</span></code></a></li>
<li><a class="reference internal" href="#checkodesol"><code class="docutils literal"><span class="pre">checkodesol()</span></code></a></li>
<li><a class="reference internal" href="#homogeneous-order"><code class="docutils literal"><span class="pre">homogeneous_order()</span></code></a></li>
<li><a class="reference internal" href="#infinitesimals"><code class="docutils literal"><span class="pre">infinitesimals()</span></code></a></li>
<li><a class="reference internal" href="#checkinfsol"><code class="docutils literal"><span class="pre">checkinfsol()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#hint-functions">Hint Functions</a><ul>
<li><a class="reference internal" href="#allhints"><code class="docutils literal"><span class="pre">allhints</span></code></a></li>
<li><a class="reference internal" href="#odesimp"><code class="docutils literal"><span class="pre">odesimp</span></code></a></li>
<li><a class="reference internal" href="#constant-renumber"><code class="docutils literal"><span class="pre">constant_renumber</span></code></a></li>
<li><a class="reference internal" href="#constantsimp"><code class="docutils literal"><span class="pre">constantsimp</span></code></a></li>
<li><a class="reference internal" href="#sol-simplicity"><code class="docutils literal"><span class="pre">sol_simplicity</span></code></a></li>
<li><a class="reference internal" href="#st-exact"><code class="docutils literal"><span class="pre">1st_exact</span></code></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-best"><code class="docutils literal"><span class="pre">1st_homogeneous_coeff_best</span></code></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-subs-dep-div-indep"><code class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_dep_div_indep</span></code></a></li>
<li><a class="reference internal" href="#st-homogeneous-coeff-subs-indep-div-dep"><code class="docutils literal"><span class="pre">1st_homogeneous_coeff_subs_indep_div_dep</span></code></a></li>
<li><a class="reference internal" href="#st-linear"><code class="docutils literal"><span class="pre">1st_linear</span></code></a></li>
<li><a class="reference internal" href="#bernoulli"><code class="docutils literal"><span class="pre">Bernoulli</span></code></a></li>
<li><a class="reference internal" href="#liouville"><code class="docutils literal"><span class="pre">Liouville</span></code></a></li>
<li><a class="reference internal" href="#riccati-special-minus2"><code class="docutils literal"><span class="pre">Riccati_special_minus2</span></code></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-homogeneous"><code class="docutils literal"><span class="pre">nth_linear_constant_coeff_homogeneous</span></code></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-undetermined-coefficients"><code class="docutils literal"><span class="pre">nth_linear_constant_coeff_undetermined_coefficients</span></code></a></li>
<li><a class="reference internal" href="#nth-linear-constant-coeff-variation-of-parameters"><code class="docutils literal"><span class="pre">nth_linear_constant_coeff_variation_of_parameters</span></code></a></li>
<li><a class="reference internal" href="#separable"><code class="docutils literal"><span class="pre">separable</span></code></a></li>
<li><a class="reference internal" href="#almost-linear"><code class="docutils literal"><span class="pre">almost_linear</span></code></a></li>
<li><a class="reference internal" href="#linear-coefficients"><code class="docutils literal"><span class="pre">linear_coefficients</span></code></a></li>
<li><a class="reference internal" href="#separable-reduced"><code class="docutils literal"><span class="pre">separable_reduced</span></code></a></li>
<li><a class="reference internal" href="#lie-group"><code class="docutils literal"><span class="pre">lie_group</span></code></a></li>
<li><a class="reference internal" href="#st-power-series"><code class="docutils literal"><span class="pre">1st_power_series</span></code></a></li>
<li><a class="reference internal" href="#nd-power-series-ordinary"><code class="docutils literal"><span class="pre">2nd_power_series_ordinary</span></code></a></li>
<li><a class="reference internal" href="#nd-power-series-regular"><code class="docutils literal"><span class="pre">2nd_power_series_regular</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#lie-heuristics">Lie heuristics</a><ul>
<li><a class="reference internal" href="#abaco1-simple"><code class="docutils literal"><span class="pre">abaco1_simple</span></code></a></li>
<li><a class="reference internal" href="#abaco1-product"><code class="docutils literal"><span class="pre">abaco1_product</span></code></a></li>
<li><a class="reference internal" href="#bivariate"><code class="docutils literal"><span class="pre">bivariate</span></code></a></li>
<li><a class="reference internal" href="#chi"><code class="docutils literal"><span class="pre">chi</span></code></a></li>
<li><a class="reference internal" href="#abaco2-similar"><code class="docutils literal"><span class="pre">abaco2_similar</span></code></a></li>
<li><a class="reference internal" href="#function-sum"><code class="docutils literal"><span class="pre">function_sum</span></code></a></li>
<li><a class="reference internal" href="#abaco2-unique-unknown"><code class="docutils literal"><span class="pre">abaco2_unique_unknown</span></code></a></li>
<li><a class="reference internal" href="#abaco2-unique-general"><code class="docutils literal"><span class="pre">abaco2_unique_general</span></code></a></li>
<li><a class="reference internal" href="#linear"><code class="docutils literal"><span class="pre">linear</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#system-of-odes">System of ODEs</a><ul>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order1-type1"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type1</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order1-type2"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type2</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order1-type3"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type3</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order1-type4"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type4</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order1-type5"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type5</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order1-type6"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type6</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order1-type7"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order1_type7</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type1"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type1</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type2"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type2</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type3"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type3</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type4"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type4</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type5"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type5</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type6"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type6</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type7"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type7</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type8"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type8</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type9"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type9</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type10"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type10</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-2eq-order2-type11"><code class="docutils literal"><span class="pre">system_of_odes_linear_2eq_order2_type11</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-3eq-order1-type1"><code class="docutils literal"><span class="pre">system_of_odes_linear_3eq_order1_type1</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-3eq-order1-type2"><code class="docutils literal"><span class="pre">system_of_odes_linear_3eq_order1_type2</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-3eq-order1-type3"><code class="docutils literal"><span class="pre">system_of_odes_linear_3eq_order1_type3</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-3eq-order1-type4"><code class="docutils literal"><span class="pre">system_of_odes_linear_3eq_order1_type4</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-linear-neq-order1-type1"><code class="docutils literal"><span class="pre">system_of_odes_linear_neq_order1_type1</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-2eq-order1-type1"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type1</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-2eq-order1-type2"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type2</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-2eq-order1-type3"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type3</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-2eq-order1-type4"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type4</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-2eq-order1-type5"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_2eq_order1_type5</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-3eq-order1-type1"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type1</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-3eq-order1-type2"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type2</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-3eq-order1-type3"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type3</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-3eq-order1-type4"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type4</span></code></a></li>
<li><a class="reference internal" href="#system-of-odes-nonlinear-3eq-order1-type5"><code class="docutils literal"><span class="pre">system_of_odes_nonlinear_3eq_order1_type5</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-sympy.solvers.ode">Information on the ode module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../stats.html"
                        title="previous chapter">Stats</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pde.html"
                        title="next chapter">PDE</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/solvers/ode.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pde.html" title="PDE"
             >next</a> |</li>
        <li class="right" >
          <a href="../stats.html" title="Stats"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">SymPy 1.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >SymPy Modules Reference</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017 SymPy Development Team.
      Last updated on Jul 27, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.
    </div>
  </body>
</html>