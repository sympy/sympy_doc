<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Solveset &mdash; SymPy 0.7.7.dev documentation</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-core.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-autocomplete.css" type="text/css" />
    <link rel="stylesheet" href="http://live.sympy.org/static/live-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.7.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/utilities.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/external/classy.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-core.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-autocomplete.js"></script>
    <script type="text/javascript" src="http://live.sympy.org/static/live-sphinx.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML-full"></script>
    <link rel="shortcut icon" href="../../_static/sympy-notailtext-favicon.ico"/>
    <link rel="top" title="SymPy 0.7.7.dev documentation" href="../../index.html" />
    <link rel="up" title="SymPy Modules Reference" href="../index.html" />
    <link rel="next" title="Tensor Module" href="../tensor/index.html" />
    <link rel="prev" title="Inequality Solvers" href="inequalities.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../tensor/index.html" title="Tensor Module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="inequalities.html" title="Inequality Solvers"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">SymPy 0.7.7.dev documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-sympy.solvers.solveset">
<span id="solveset"></span><h1>Solveset<a class="headerlink" href="#module-sympy.solvers.solveset" title="Permalink to this headline">¶</a></h1>
<p>This is the official documentation of the <code class="docutils literal"><span class="pre">solveset</span></code> module in solvers.
It contains the frequently asked questions about our new module to solve
equations.</p>
<div class="section" id="what-s-wrong-with-solve">
<h2>What&#8217;s wrong with solve():<a class="headerlink" href="#what-s-wrong-with-solve" title="Permalink to this headline">¶</a></h2>
<p>SymPy already has a pretty powerful <code class="docutils literal"><span class="pre">solve</span></code> function. But it has a lot of major
issues</p>
<ol class="arabic simple">
<li>It doesn&#8217;t have a consistent output for various types of solutions
It needs to return a lot of types of solutions consistently:<ul>
<li>Single solution : <span class="math">\(x = 1\)</span></li>
<li>Multiple solutions: <span class="math">\(x^2 = 1\)</span></li>
<li>No Solution: <span class="math">\(x^2 + 1 = 0 ; x \in \mathbb{R}\)</span></li>
<li>Interval of solution: <span class="math">\(\lfloor x \rfloor = 0\)</span></li>
<li>Infinitely many solutions: <span class="math">\(sin(x) = 0\)</span></li>
<li>Multivariate functions with point solutions: <span class="math">\(x^2 + y^2 = 0\)</span></li>
<li>Multivariate functions with non-point solution: <span class="math">\(x^2 + y^2 = 1\)</span></li>
<li>System of equations: <span class="math">\(x + y = 1\)</span> and <span class="math">\(x - y = 0\)</span></li>
<li>Relational: <span class="math">\(x &gt; 0\)</span></li>
<li>And the most important case &#8220;We don&#8217;t Know&#8221;</li>
</ul>
</li>
<li>The input API is also a mess, there are a lot of parameters. Many of them
are not needed and they make it hard for the user and the developers to
work on solvers.</li>
<li>There are cases like finding the maxima and minima of function using
critical points where it is important to know if it has returned all the
solutions. <code class="docutils literal"><span class="pre">solve</span></code> does not guarantee this.</li>
</ol>
</div>
<div class="section" id="why-solveset">
<h2>Why Solveset?<a class="headerlink" href="#why-solveset" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">solveset</span></code> has a cleaner input and output interface: <code class="docutils literal"><span class="pre">solveset</span></code> returns
a set object and a set object takes care of all types of output. For
cases where it doesn&#8217;t &#8220;know&#8221; all the solutions a <code class="docutils literal"><span class="pre">ConditionSet</span></code> with partial
solution is returned. For input it only takes the equation, the variables
to solve for and the optional argument <code class="docutils literal"><span class="pre">domain</span></code> in which the equations has to
be solved.</li>
<li><code class="docutils literal"><span class="pre">solveset</span></code> can return infinitely many solutions. For example solving for
<span class="math">\(\sin{(x)} = 0\)</span> returns <span class="math">\(\{2 n \pi | n \in \mathbb{Z}\} \cup \{2 n \pi + \pi | n \in \mathbb{Z}\}\)</span>,
whereas <code class="docutils literal"><span class="pre">solve</span></code> only returns <span class="math">\([0, \pi]\)</span>.</li>
<li>There is a clear code level and interface level separation between solvers
for equations in the complex domain and the real domain. For example
solving <span class="math">\(exp(x) = 1\)</span> when <span class="math">\(x\)</span> is to be solved in the complex domain, returns
the set of all solutions, that is <span class="math">\(\{2 n i \pi | n \in \mathbb{Z}\}\)</span>, whereas
if <span class="math">\(x\)</span> is to be solved in the real domain then only <span class="math">\(\{0\}\)</span> is returned.</li>
</ul>
</div>
<div class="section" id="why-do-we-use-sets-as-an-output-type">
<h2>Why do we use Sets as an output type?<a class="headerlink" href="#why-do-we-use-sets-as-an-output-type" title="Permalink to this headline">¶</a></h2>
<p>SymPy has a well developed sets module, which can represent most of the set
containers in Mathematics such as:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal"><span class="pre">FiniteSet</span></code></p>
<p>Represents a finite set of discrete numbers.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Interval</span></code></p>
<p>Represents a real interval as a set.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ProductSet</span></code></p>
<p>Represents a Cartesian product of sets.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ImageSet</span></code></p>
<p>Represents the image of a set under a mathematical function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ImageSet</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Lambda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squares</span> <span class="o">=</span> <span class="n">ImageSet</span><span class="p">(</span><span class="n">Lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Naturals</span><span class="p">)</span>  <span class="c"># {x**2 for x in N}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">4</span> <span class="ow">in</span> <span class="n">squares</span>
<span class="go">True</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ComplexRegion</span></code></p>
<p>Represents the set of all complex numbers in a region in the Argand plane.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ConditionSet</span></code></p>
<p>Represents the set of elements, which satisfies a given condition.</p>
</li>
</ul>
</div></blockquote>
<p>Also, the predefined set classes such as:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="docutils literal"><span class="pre">Naturals</span></code> <span class="math">\(\mathbb{N}\)</span></p>
<p>Represents the natural numbers (or counting numbers), which are all
positive integers starting from 1.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Naturals0</span></code> <span class="math">\(\mathbb{N_0}\)</span></p>
<p>Represents the whole numbers, which are all the non-negative integers,
inclusive of 0.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Integers</span></code> <span class="math">\(\mathbb{Z}\)</span></p>
<p>Represents all integers: positive, negative and zero.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Reals</span></code> <span class="math">\(\mathbb{R}\)</span></p>
<p>Represents the set of all real numbers.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">Complexes</span></code> <span class="math">\(\mathbb{C}\)</span></p>
<p>Represents the set of all complex numbers.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">EmptySet</span></code> <span class="math">\(\phi\)</span></p>
<p>Represents the empty set.</p>
</li>
</ul>
<p>The above six sets are available as Singletons, like say <code class="docutils literal"><span class="pre">S.Integers</span></code>.</p>
</div></blockquote>
<p>It is capable of most of the set operations in mathematics:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">Union</span></code></li>
<li><code class="docutils literal"><span class="pre">Intersection</span></code></li>
<li><code class="docutils literal"><span class="pre">Complement</span></code></li>
<li><code class="docutils literal"><span class="pre">SymmetricDifference</span></code></li>
</ul>
</div></blockquote>
<p>The main reason for using sets as output to solvers is that it can consistently
represent many types of solutions. For the single variable case it can represent:</p>
<blockquote>
<div><ul class="simple">
<li>No solution (by the empty set).</li>
<li>Finitely many solutions (by <code class="docutils literal"><span class="pre">FiniteSet</span></code>).</li>
<li>Infinitely many solutions, both countably and uncountably infinite solutions
(using the <code class="docutils literal"><span class="pre">ImageSet</span></code> module) .</li>
<li><code class="docutils literal"><span class="pre">Interval</span></code></li>
<li>There can also be bizarre solutions to equations like set of rational
numbers.</li>
</ul>
</div></blockquote>
<p>No other programmer&#8217;s object (list, dictionary, generator, python sets)
provides the flexibility of mathematical sets which our sets module try to
emulate. The second reason to use sets is that they are close to the entities
which mathematician&#8217;s deals with and it makes it easier to reason about them.
Set objects conform to Pythonic conventions when possible, i.e., <code class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">A</span></code> and
<code class="docutils literal"><span class="pre">for</span> <span class="pre">i</span> <span class="pre">in</span> <span class="pre">A</span></code> both work when they can be computed. Another advantage of using
objects closer to mathematical entities is that the user won&#8217;t have to &#8220;learn&#8221;
our representation and she can have her expectations transferred from her
mathematical experience.</p>
<p>For the multivariate case we represent solutions as a set of points in a
n-dimensional space and a point is represented by a FiniteSet of ordered
tuples, which is a point in <span class="math">\(\mathbb{R}^n\)</span> or mathbb{C}^n.</p>
<p>Please note that, the general <code class="docutils literal"><span class="pre">FiniteSet</span></code> is unordered, but a <code class="docutils literal"><span class="pre">FiniteSet</span></code>
with a tuple as it&#8217;s only argument becomes ordered, Since a tuple is ordered.
So the order in the tuple is mapped to a pre-defined order of variables,
while returning solutions.</p>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">FiniteSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FiniteSet</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>   <span class="c"># Unordered</span>
<span class="go">{1, 2, 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">FiniteSet</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c"># Ordered</span>
<span class="go">{(1, 2, 3)}</span>
</pre></div>
</div>
<p>Why not use dicts as output?</p>
<blockquote>
<div><p>Dictionary are easy to deal with programatically but mathematically they are
not very precise and use of them can quickly lead to inconsistency and a lot
of confusion. For example:</p>
<ul>
<li><p class="first">There are a lot of cases where we don&#8217;t know the complete solution and we
may like to output a partial solution, consider the equation <span class="math">\(fg = 0\)</span>. The
solution of this equation is the union of the solution of the following
two equations: <span class="math">\(f = 0\)</span>, <span class="math">\(g = 0\)</span>. Let&#8217;s say that we are able to solve
<span class="math">\(f = 0\)</span> but solving <span class="math">\(g = 0\)</span> isn&#8217;t supported yet. In this case we cannot
represent partial solution of the given equation <span class="math">\(fg = 0\)</span> using dicts.
This problem is solved with sets using <code class="docutils literal"><span class="pre">ConditionSet</span></code> object:</p>
<p><span class="math">\(sol_f\)</span> U <span class="math">\(\{x | x ∊ \mathbb{R} ∧ g = 0\}\)</span>, where <span class="math">\(sol_f\)</span> is the solution
of the equation <span class="math">\(f = 0\)</span>.</p>
</li>
<li><p class="first">Using dict may lead to surprising results like:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">solve(Eq(x**2,</span> <span class="pre">1),</span> <span class="pre">x)</span> <span class="pre">!=</span> <span class="pre">solve(Eq(y**2,</span> <span class="pre">1),</span> <span class="pre">y)</span></code>
Though, mathematically, it doesn&#8217;t make sense. Using <code class="docutils literal"><span class="pre">FiniteSet</span></code> here
solves the problem.</li>
</ul>
</li>
<li><p class="first">It can also not represent solutions for Equations like <span class="math">\(|x| &lt; 1\)</span>, which
is a disk of radius 1 in the Argand Plane. This problem is solved using
complex sets implemented as <code class="docutils literal"><span class="pre">ComplexRegion</span></code>.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="input-api-of-solveset">
<h2>Input API of <code class="docutils literal"><span class="pre">solveset</span></code><a class="headerlink" href="#input-api-of-solveset" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">solveset</span></code> has a cleaner input API, unlike <code class="docutils literal"><span class="pre">solve</span></code>. It takes a maximum
of three arguments:</p>
<p><code class="docutils literal"><span class="pre">solveset(equation,</span> <span class="pre">variable=None,</span> <span class="pre">domain=S.Complexes)</span></code></p>
<ul>
<li><p class="first">Equation(s)</p>
<p>The equation(s) to solve.</p>
</li>
<li><p class="first">Variable(s)</p>
<p>The variable(s) for which the equation is to be solved.</p>
</li>
<li><p class="first">Domain</p>
<p>The domain in which the equation is to be solved.</p>
</li>
</ul>
<blockquote>
<div><code class="docutils literal"><span class="pre">solveset</span></code> removes the <code class="docutils literal"><span class="pre">flags</span></code> argument of <code class="docutils literal"><span class="pre">solve</span></code>, which had made
the input API messy and output API inconsistent.</div></blockquote>
</div>
<div class="section" id="what-is-this-domain-argument-about">
<h2>What is this domain argument about?<a class="headerlink" href="#what-is-this-domain-argument-about" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset is designed to be independent of the assumptions on the
variable being solved for and instead, uses the <code class="docutils literal"><span class="pre">domain</span></code> argument to
decide the solver to dispatch the equation to, namely <code class="docutils literal"><span class="pre">solveset_real</span></code>
or <code class="docutils literal"><span class="pre">solveset_complex</span></code>. It&#8217;s unlike the old <code class="docutils literal"><span class="pre">solve</span></code> which considers the
assumption on the variable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solveset</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c"># domain=S.Complexes is default</span>
<span class="go">{-I, I}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">EmptySet()</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="what-are-the-general-methods-employed-by-solveset-to-solve-an-equation">
<h2>What are the general methods employed by solveset to solve an equation?<a class="headerlink" href="#what-are-the-general-methods-employed-by-solveset-to-solve-an-equation" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset uses various methods to solve an equation, here is a brief overview
of the methodology:</p>
<ul class="simple">
<li>The <code class="docutils literal"><span class="pre">domain</span></code> argument is first considered to know the domain in which
the user is interested to get the solution.</li>
<li>If the given function is a relational (<code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>), and
the domain is real, then <code class="docutils literal"><span class="pre">solve_univariate_inequality</span></code> and solutions are
returned. Solving for complex solutions of inequalities, like <span class="math">\(x^2 &lt; 0\)</span>
is not yet supported.&#8221;.</li>
<li>Based on the <code class="docutils literal"><span class="pre">domain</span></code>, the equation is dispatched to one of the two
functions <code class="docutils literal"><span class="pre">solveset_real</span></code> or <code class="docutils literal"><span class="pre">solveset_complex</span></code>, which solves the
given equation in the complex or real domain, respectively.</li>
<li>If the given expression is a product of two or more functions,
like say <span class="math">\(gh = 0\)</span>, then the solution to the given equation is the Union
of the solution of the equations <span class="math">\(g = 0\)</span> and <span class="math">\(h = 0\)</span>, if and only if both
<span class="math">\(g\)</span> and <span class="math">\(h\)</span> are finite for a finite input. So, the solution is built up
recursively.</li>
<li>The function class is now checked if it&#8217;s trigonometric or hyperbolic, then
the function <code class="docutils literal"><span class="pre">_solve_real_trig</span></code> is called, which solves it by converting
it to complex exponential form.</li>
<li>The function is now checked if there is any instance of a <code class="docutils literal"><span class="pre">Piecewise</span></code>
expression, if it is, then it&#8217;s converted to explict expression and
set pairs and then solved recursively.</li>
<li>The respective solver now tries to invert the equation using the routines
<code class="docutils literal"><span class="pre">invert_real</span></code> and <code class="docutils literal"><span class="pre">invert_complex</span></code>. These routines are based on the
concept of mathematical inverse (though not exactly). It reduces the
real/complex valued equation <code class="docutils literal"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">y</span></code> to a set of equations:
<code class="docutils literal"><span class="pre">{g(x)</span>&nbsp; <span class="pre">=</span> <span class="pre">h_1(y),</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_n(y)</span> <span class="pre">}</span></code> where <code class="docutils literal"><span class="pre">g(x)</span></code> is a
simpler function than <code class="docutils literal"><span class="pre">f(x)</span></code>. There is some work needed to be done in
this to find invert of more complex expressions.</li>
<li>After the invert, the equations are checked for radical or Abs (Modulus),
then the method <code class="docutils literal"><span class="pre">_solve_radical</span></code> tries to simplify the radical, by
removing it using techniques like squarring, cubing etc, and <code class="docutils literal"><span class="pre">_solve_abs</span></code>
solves nested Modulus by considering the positive and negative variants,
iteratively.</li>
<li>If none of the above method is successful, then methods of polynomial is
used as follows:<ul>
<li>The method to solve the rational function is called:
<code class="docutils literal"><span class="pre">_solve_as_rational(f,</span> <span class="pre">symbol,</span> <span class="pre">solveset_solver,</span> <span class="pre">as_poly_solver)</span></code>
its third argument is the <code class="docutils literal"><span class="pre">solveset_solver</span></code> which can either be
<code class="docutils literal"><span class="pre">solveset_real</span></code> or <code class="docutils literal"><span class="pre">solveset_complex</span></code> based on these, respective
poly solvers <code class="docutils literal"><span class="pre">_solve_as_poly_real</span></code> or <code class="docutils literal"><span class="pre">_solve_as_poly_complex</span></code>
is called to solve as polynomial.</li>
<li>The underlying method <code class="docutils literal"><span class="pre">_solve_as_poly</span></code> solves the equation using
polynomial techniques if its already a polynomial equation or, with
a change of variables, can be made so.</li>
</ul>
</li>
<li>The final solution set obtained is taken intersection with the input
domain, and the resulting solution is returned.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-do-we-manipulate-and-return-an-infinite-solution">
<h2>How do we manipulate and return an infinite solution?<a class="headerlink" href="#how-do-we-manipulate-and-return-an-infinite-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul>
<li><p class="first">In the real domain, we use our <code class="docutils literal"><span class="pre">ImageSet</span></code> class in the sets module to
return infinite solutions. <code class="docutils literal"><span class="pre">ImageSet</span></code> is an image of a set under
a mathematical function. For example, to represent the solution
of the equation <span class="math">\(\sin{(x)} = 0\)</span>, we can use the <code class="docutils literal"><span class="pre">ImageSet</span></code> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ImageSet</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Dummy</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">Dummy</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ImageSet</span><span class="p">(</span><span class="n">Lambda</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="n">S</span><span class="o">.</span><span class="n">Integers</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{2⋅n⋅π | n ∊ ℤ}</span>
</pre></div>
</div>
<p>Where <code class="docutils literal"><span class="pre">n</span></code> is a dummy variable. It is basically the image of the
set of integers under the function <span class="math">\(2\pi n\)</span>.</p>
</li>
<li><p class="first">In the complex domain, we use complex sets, which are implemented as the
<code class="docutils literal"><span class="pre">ComplexRegion</span></code> class in the sets module, to represent infinite
solution in the Argand plane. For example to represent the solution
of the equation <span class="math">\(|z| = 1\)</span>, which is a unit circle, we can use
the <code class="docutils literal"><span class="pre">ComplexRegion</span></code> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ComplexRegion</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ComplexRegion</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">),</span> <span class="n">polar</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{r⋅(ⅈ⋅sin(θ) + cos(θ)) | r, θ ∊ {1} × [0, 2⋅π)}</span>
</pre></div>
</div>
<p>Where the <code class="docutils literal"><span class="pre">FiniteSet</span></code> in the <code class="docutils literal"><span class="pre">ProductSet</span></code> is the range of the value
of <span class="math">\(r\)</span>, which is the radius of the circle and the <code class="docutils literal"><span class="pre">Interval</span></code> is the range
of <span class="math">\(\theta\)</span>, the angle from the <span class="math">\(x\)</span> axis representing a unit circle in the
Argand plane.</p>
<p>Note: We also have non-polar form notation for representing solution
in rectangular form. For example, to represent first two quadrants in the
Argand plane, we can write the <code class="docutils literal"><span class="pre">ComplexRegion</span></code> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">ComplexRegion</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">oo</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">ComplexRegion</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="o">-</span><span class="n">oo</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span><span class="o">*</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">oo</span><span class="p">)),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">{x + y⋅ⅈ | x, y ∊ (-∞, ∞) × [0, ∞)}</span>
</pre></div>
</div>
<p>where the Intervals are the range of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> for the set of complex
numbers <span class="math">\(x + iy\)</span>.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution">
<h2>How does <code class="docutils literal"><span class="pre">solveset</span></code> ensure that it is not returning any wrong solution?<a class="headerlink" href="#how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solvers in a Computer Algebra System are based on heuristic algorithms,
so it&#8217;s usually very hard to ensure 100% percent correctness, in every
possible case. However there are still a lot of cases where we can ensure
correctness. Solveset tries to verify correctness wherever it can. For
example:</p>
<p>Consider the equation <span class="math">\(|x| = n\)</span>. A naive method to solve this equation
would return <code class="docutils literal"><span class="pre">{-n,</span> <span class="pre">n}</span></code> as its solution, which is not correct since
<code class="docutils literal"><span class="pre">{-n,</span> <span class="pre">n}</span></code> can be its solution if and only if <code class="docutils literal"><span class="pre">n</span></code> is positive.
Solveset returns this information as well to ensure correctness.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x, n&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">([0, ∞) ∩ {n}) ∪ ((-∞, 0] ∩ {-n})</span>
</pre></div>
</div>
<p>Though, there still a lot of work needs to be done in this regard.</p>
</div></blockquote>
</div>
<div class="section" id="search-based-solver-and-step-by-step-solution">
<h2>Search based solver and step-by-step solution<a class="headerlink" href="#search-based-solver-and-step-by-step-solution" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Note: This is under Development.</p>
<p>After the introduction of <code class="xref py py-class docutils literal"><span class="pre">ConditionSet</span></code>, the
solving of equations can be seen as set transformations. Here is an abstract
view of the things we can do to solve equations.</p>
<ul class="simple">
<li>Apply various set transformations on the given set.</li>
<li>Define a metric of the usability of solutions, or a notion of some
solutions being better than others.</li>
<li>Different transformations would be the nodes of a tree.</li>
<li>Suitable searching techniques could be applied to get the best solution.</li>
</ul>
<p><code class="docutils literal"><span class="pre">ConditionSet</span></code> gives us the ability to represent unevaluated equations and
inequalities in forms like <span class="math">\(\{x|f(x)=0; x \in S\}\)</span> and <span class="math">\(\{x|f(x)&gt;0; x \in S\}\)</span>
but a more powerful thing about <code class="docutils literal"><span class="pre">ConditionSet</span></code> is that it allows us to write
the intermediate steps as set to set transformation. Some of the transformations
are:</p>
<ul>
<li><p class="first">Composition: <span class="math">\(\{x|f(g(x))=0;x \in S\} \Rightarrow \{x|g(x)=y; x \in S, y \in \{z|f(z)=0; z \in S\}\}\)</span></p>
</li>
<li><dl class="first docutils">
<dt>Polynomial Solver: <span class="math">\(\{x | P(x) = 0;x \in S\} \Rightarrow  \{x_1,x_2, ... ,x_n\} ∩ S\)</span></dt>
<dd><p class="first last"><span class="math">\(\text{ where } `x_i\)</span> <span class="math">\(\text{ are roots of } P(x)\)</span></p>
</dd>
</dl>
</li>
<li><p class="first">Invert solver: <span class="math">\(\{x|f(x)=0;x \in S\} \Rightarrow  \{g(0)| \text{ all g such that } f(g(x)) = x\}\)</span></p>
</li>
<li><dl class="first docutils">
<dt>logcombine: <span class="math">\(\{x| log(f(x)) + log(g(x));x \in S\}\)</span></dt>
<dd><p class="first last"><span class="math">\(\Rightarrow  \{x| log(f(x).g(x)); x \in S\} \text{ if } f(x) &gt; 0 \text{ and } g(x) &gt; 0\)</span>
<span class="math">\(\Rightarrow  \{x| log(f(x)) + log(g(x));x \in S\} \text{ otherwise}\)</span></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>product solve: <span class="math">\(\{x|f(x)*g(x)=0; x \in S\}\)</span></dt>
<dd><p class="first last"><span class="math">\(\Rightarrow  \{x|f(x)=0; x \in S\} U \{x|g(x)=0; x \in S\}\)</span>
<span class="math">\(\text{ given } f(x) \text{ and } g(x) \text{ are bounded.}\)</span>
<span class="math">\(\Rightarrow  \{x|f(x)*g(x)=0; x \in S\}, \text{ otherwise}\)</span></p>
</dd>
</dl>
</li>
</ul>
<p>Since the output type is same as the input type any composition of these
transformations is also a valid transformation. And our aim is to find
the right sequence of compositions (given the atoms) which transforms
the given condition set to a set which is not a condition set i.e.,
FiniteSet, Interval, Set of Integers and their Union, Intersection,
Complement or ImageSet. We can assign a cost function to each set,
such that, the more desirable that form of set is to us, the less the value
of the cost function. This way our problem is now reduced to finding the path
from the initial ConditionSet to the lowest valued set on a graph where
the atomic transformations forms the edges.</p>
</div></blockquote>
</div>
<div class="section" id="how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known">
<h2>How do we deal with cases where only some of the solutions are known?<a class="headerlink" href="#how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Creating a universal equation solver, which can solve each and every
equation we encounter in mathematics is an ideal case for solvers in
a Computer Algebra System. We always have some cases, which are not
solved, or solved with incomplete solutions, so it&#8217;s very important
to represent that situation. For this type of situation we use
<span class="math">\(ConditionSet\)</span> class in the sets module, which acts as an unevaluated
solveset object.</p>
<p>See <a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">Richardson&#8217;s theorem</a>.</p>
<p><code class="docutils literal"><span class="pre">ConditionSet</span></code> is basically a Set of elements which satisfy a given
condition. For example, to represent the solutions of the equation in
the real domain:</p>
<div class="math">
\[(x^2 - 4)*(\sin(x) + x)\]</div>
<p>We can represent it as:</p>
<p><span class="math">\(\{-2, 2\} ∪ \{x | x \in \mathbb{R} ∧ x + \sin(x) = 0\}\)</span></p>
</div></blockquote>
</div>
<div class="section" id="what-will-you-do-with-the-old-solve">
<h2>What will you do with the old solve?<a class="headerlink" href="#what-will-you-do-with-the-old-solve" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>There are still a few things <code class="docutils literal"><span class="pre">solveset</span></code> can&#8217;t do, which the old <code class="docutils literal"><span class="pre">solve</span></code>
can, such as solving non linear multivariate &amp; LambertW type equations.
Hence, it&#8217;s not yet a perfect replacement for old <code class="docutils literal"><span class="pre">solve</span></code>. The ultimate
goal is to:</p>
<ul class="simple">
<li>Replace <code class="docutils literal"><span class="pre">solve</span></code> with <code class="docutils literal"><span class="pre">solveset</span></code>, by the time solveset is
at least powerful as <code class="docutils literal"><span class="pre">solve</span></code>, i.e. <code class="docutils literal"><span class="pre">solveset</span></code> does everything
that <code class="docutils literal"><span class="pre">solve</span></code> can do currently, and</li>
<li>Eventually rename <code class="docutils literal"><span class="pre">solveset</span></code> to <code class="docutils literal"><span class="pre">solve</span></code>.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="how-are-symbolic-parameters-handled-in-solveset">
<h2>How are symbolic parameters handled in solveset?<a class="headerlink" href="#how-are-symbolic-parameters-handled-in-solveset" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Solveset is in its initial phase of development as of now, so the
symbolic parameters aren&#8217;t handled well for all the cases, but some
work has been done in this regard to depict our ideology towards
symbolic parameters. As an example the solving of <span class="math">\(|x| = n\)</span> for <span class="math">\(x\)</span>
where <span class="math">\(n\)</span> is a symbolic parameter. Solveset returns the value of <span class="math">\(x\)</span>
considering the domain of the symbolic parameter <span class="math">\(n\)</span> as well, i.e. :</p>
<p><span class="math">\(([0, \infty) ∩ \{n\}) ∪ ((-\infty, 0] ∩ \{-n\})\)</span>.</p>
<p>It simply means <span class="math">\(n\)</span> is the solution only when it belongs to the <code class="docutils literal"><span class="pre">Interval</span></code>
<span class="math">\([0, \infty)\)</span> and <span class="math">\(-n\)</span> is the solution only when <span class="math">\(n\)</span> belongs to the <code class="docutils literal"><span class="pre">Interval</span></code>
<span class="math">\((- \infty, 0]\)</span>.</p>
<p>There are various other cases as well which needs to be addressed, like
say, solving of <span class="math">\(2^x + (a - 2)\)</span> for <span class="math">\(x\)</span> where <span class="math">\(a\)</span> is a symbolic parameter.
As of now, It returns the solution as an intersection with <span class="math">\(\mathbb{R}\)</span>, which
is trivial, as it doesn&#8217;t reveal the domain of <span class="math">\(a\)</span> in the solution.</p>
<p>Recently, we have also implemented a function to find the domain of the
expression in a FiniteSet (Intersection with the interval) in which it is
not-empty. It is a useful addition for dealing with symbolic parameters.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">FiniteSet</span><span class="p">,</span> <span class="n">Interval</span><span class="p">,</span> <span class="n">not_empty_in</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_empty_in</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[0, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">not_empty_in</span><span class="p">(</span><span class="n">FiniteSet</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">[-sqrt(2), -1] U [1, 2]</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2015-Ideas#solvers">https://github.com/sympy/sympy/wiki/GSoC-2015-Ideas#solvers</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers">https://github.com/sympy/sympy/wiki/GSoC-2014-Application-Harsh-Gupta:-Solvers</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2015-Application-AMiT-Kumar--Solvers-:-Extending-Solveset">https://github.com/sympy/sympy/wiki/GSoC-2015-Application-AMiT-Kumar&#8211;Solvers-:-Extending-Solveset</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><a class="reference external" href="http://iamit.in/blog/">http://iamit.in/blog/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/2948">https://github.com/sympy/sympy/pull/2948</a> : Action Plan for improving solvers.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[7]</td><td><a class="reference external" href="https://github.com/sympy/sympy/issues/6659">https://github.com/sympy/sympy/issues/6659</a> : <code class="docutils literal"><span class="pre">solve()</span></code> is a giant mess</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/7523">https://github.com/sympy/sympy/pull/7523</a> : <code class="docutils literal"><span class="pre">solveset</span></code> PR</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td><a class="reference external" href="https://groups.google.com/forum/#!topic/sympy/-SIbX0AFL3Q">https://groups.google.com/forum/#!topic/sympy/-SIbX0AFL3Q</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td><a class="reference external" href="https://github.com/sympy/sympy/pull/9696">https://github.com/sympy/sympy/pull/9696</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%27s_theorem">https://en.wikipedia.org/wiki/Richardson%27s_theorem</a></td></tr>
</tbody>
</table>
</div></blockquote>
</div>
<div class="section" id="solveset-module-reference">
<h2>Solveset Module Reference<a class="headerlink" href="#solveset-module-reference" title="Permalink to this headline">¶</a></h2>
<p>Use <a class="reference internal" href="#sympy.solvers.solveset.solveset" title="sympy.solvers.solveset.solveset"><code class="xref py py-func docutils literal"><span class="pre">solveset()</span></code></a> to solve equations or expressions (assumed to be equal to 0) for a single variable.
Solving an equation like <span class="math">\(x^2 == 1\)</span> can be done as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-1, 1}</span>
</pre></div>
</div>
<p>Or one may manually rewrite the equation as an expression equal to 0:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-1, 1}</span>
</pre></div>
</div>
<p>The first argument for <a class="reference internal" href="#sympy.solvers.solveset.solveset" title="sympy.solvers.solveset.solveset"><code class="xref py py-func docutils literal"><span class="pre">solveset()</span></code></a> is an expression (equal to zero) or an equation and the second argument
is the symbol that we want to solve the equation for.</p>
<dl class="function">
<dt id="sympy.solvers.solveset.solveset">
<code class="descclassname">sympy.solvers.solveset.</code><code class="descname">solveset</code><span class="sig-paren">(</span><em>f</em>, <em>symbol=None</em>, <em>domain=Complexes(Lambda((_x</em>, <em>_y)</em>, <em>_x + _y*I)</em>, <em>(-oo</em>, <em>oo) x (-oo</em>, <em>oo))</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#solveset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a given inequality or equation with set as output</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : Expr or a relational.</p>
<blockquote>
<div><p>The target equation or inequality</p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable for which the equation is solved</p>
</div></blockquote>
<p><strong>domain</strong> : Set</p>
<blockquote>
<div><p>The domain over which the equation is solved</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Set</p>
<blockquote>
<div><p>A set of values for <span class="math">\(symbol\)</span> for which <span class="math">\(f\)</span> is True or is equal to
zero. An <span class="math">\(EmptySet\)</span> is returned if no solution is found.
A <span class="math">\(ConditionSet\)</span> is returned as unsolved object if algorithms
to evaluatee complete solution are not yet implemented.</p>
</div></blockquote>
<p><span class="math">\(solveset\)</span> claims to be complete in the solution set that it returns.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>The algorithms to solve inequalities in complex domain  are
not yet implemented.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote>
<div><p>The input is not valid.</p>
</div></blockquote>
<p><strong>RuntimeError</strong></p>
<blockquote>
<div><p>It is a bug, please report to the github issue tracker.</p>
</div></blockquote>
<p><strong>`solveset` uses two underlying functions `solveset_real` and</strong></p>
<p><strong>`solveset_complex` to solve equations. They are the solvers for real and</strong></p>
<p><strong>complex domain respectively. `solveset` ignores the assumptions on the</strong></p>
<p><strong>variable being solved for and instead, uses the `domain` parameter to</strong></p>
<p class="last"><strong>decide which solver to use.</strong></p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sympy.solvers.solveset.solveset_real" title="sympy.solvers.solveset.solveset_real"><code class="xref py py-obj docutils literal"><span class="pre">solveset_real</span></code></a></dt>
<dd>solver for real domain</dd>
<dt><a class="reference internal" href="#sympy.solvers.solveset.solveset_complex" title="sympy.solvers.solveset.solveset_complex"><code class="xref py py-obj docutils literal"><span class="pre">solveset_complex</span></code></a></dt>
<dd>solver for complex domain</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">solveset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
</pre></div>
</div>
<ul class="simple">
<li>The default domain is complex. Not specifying a domain will lead to the
solving of the equation in the complex domain.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">{2*n*I*pi | n in Integers()}</span>
</pre></div>
</div>
<ul class="simple">
<li>If you want to solve equation in real domain by the <span class="math">\(solveset\)</span>
interface, then specify that the domain is real. Alternatively use
<span class="math">\(solveset\_real\)</span>.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">{0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">Eq</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">{0}</span>
</pre></div>
</div>
<ul class="simple">
<li>Inequalities can be solved over the real domain only. Use of a complex
domain leads to a NotImplementedError.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Reals</span><span class="p">)</span>
<span class="go">(0, oo)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.solveset_real">
<code class="descclassname">sympy.solvers.solveset.</code><code class="descname">solveset_real</code><span class="sig-paren">(</span><em>f</em>, <em>symbol</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#solveset_real"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves a real valued equation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : Expr</p>
<blockquote>
<div><p>The target equation</p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable for which the equation is solved</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Set</p>
<blockquote>
<div><p>A set of values for <span class="math">\(symbol\)</span> for which <span class="math">\(f\)</span> is equal to
zero. An <span class="math">\(EmptySet\)</span> is returned if no solution is found.
A <span class="math">\(ConditionSet\)</span> is returned as unsolved object if algorithms
to evaluate complete solutions are not yet implemented.</p>
</div></blockquote>
<p><span class="math">\(solveset_real\)</span> claims to be complete in the set of the solution it</p>
<p>returns.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>Algorithms to solve inequalities in complex domain are
not yet implemented.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote>
<div><p>The input is not valid.</p>
</div></blockquote>
<p><strong>RuntimeError</strong></p>
<blockquote>
<div><p>It is a bug, please report to the github issue tracker.</p>
</div></blockquote>
<p><strong>See Also</strong></p>
<p><strong>=======</strong></p>
<p class="last"><strong>solveset_complex</strong> : solver for complex domain</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">I</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">solveset_real</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">finite</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-1, 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-1, 2}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">I</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">EmptySet()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{a}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{log(a)}</span>
</pre></div>
</div>
<ul class="simple">
<li>In case the equation has infinitely many solutions an infinitely indexed
<span class="math">\(ImageSet\)</span> is returned.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">ImageSet(Lambda(_n, 2*_n*pi + pi/2), Integers())</span>
</pre></div>
</div>
<ul class="simple">
<li>If the equation is true for any arbitrary value of the symbol a <span class="math">\(S.Reals\)</span>
set is returned.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_real</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(-oo, oo)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.solveset_complex">
<code class="descclassname">sympy.solvers.solveset.</code><code class="descname">solveset_complex</code><span class="sig-paren">(</span><em>f</em>, <em>symbol</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#solveset_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.solveset_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve a complex valued equation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : Expr</p>
<blockquote>
<div><p>The target equation</p>
</div></blockquote>
<p><strong>symbol</strong> : Symbol</p>
<blockquote>
<div><p>The variable for which the equation is solved</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Set</p>
<blockquote>
<div><p>A set of values for <span class="math">\(symbol\)</span> for which <span class="math">\(f\)</span> equal to
zero. An <span class="math">\(EmptySet\)</span> is returned if no solution is found.
A <span class="math">\(ConditionSet\)</span> is returned as an unsolved object if algorithms
to evaluate complete solutions are not yet implemented.</p>
</div></blockquote>
<p><span class="math">\(solveset_complex\)</span> claims to be complete in the solution set that</p>
<p>it returns.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>NotImplementedError</strong></p>
<blockquote>
<div><p>The algorithms to solve inequalities in complex domain  are
not yet implemented.</p>
</div></blockquote>
<p><strong>ValueError</strong></p>
<blockquote>
<div><p>The input is not valid.</p>
</div></blockquote>
<p><strong>RuntimeError</strong></p>
<blockquote class="last">
<div><p>It is a bug, please report to the github issue tracker.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#sympy.solvers.solveset.solveset_real" title="sympy.solvers.solveset.solveset_real"><code class="xref py py-obj docutils literal"><span class="pre">solveset_real</span></code></a></dt>
<dd>solver for real domain</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">solveset_complex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_complex</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">{-b/(2*a) - sqrt(-4*a*c + b**2)/(2*a), -b/(2*a) + sqrt(-4*a*c + b**2)/(2*a)}</span>
</pre></div>
</div>
<ul class="simple">
<li>Due to the fact that complex extension of my real valued functions are
multivariate even some simple equations can have infinitely many
solution.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">solveset_complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">ImageSet(Lambda(_n, 2*_n*I*pi), Integers())</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.invert_real">
<code class="descclassname">sympy.solvers.solveset.</code><code class="descname">invert_real</code><span class="sig-paren">(</span><em>f_x</em>, <em>y</em>, <em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#invert_real"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.invert_real" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts a real valued function</p>
<p>Reduces the real valued equation <code class="docutils literal"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">y</span></code> to a set of equations <code class="docutils literal"><span class="pre">{g(x)</span>
<span class="pre">=</span> <span class="pre">h_1(y),</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_n(y)</span> <span class="pre">}</span></code> where <code class="docutils literal"><span class="pre">g(x)</span></code> is a simpler
function than <code class="docutils literal"><span class="pre">f(x)</span></code>.  The return value is a tuple <code class="docutils literal"><span class="pre">(g(x),</span> <span class="pre">set_h)</span></code>,
where <code class="docutils literal"><span class="pre">g(x)</span></code> is a function of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">set_h</span></code> is the set of
functions <code class="docutils literal"><span class="pre">{h_1(y),</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">h_n(y)}</span></code>.
Here, <code class="docutils literal"><span class="pre">y</span></code> is not necessarily a symbol.</p>
<p>The <code class="docutils literal"><span class="pre">set_h</span></code> contains the functions along with the information about their
domain in which they are valid, through set operations. For instance, if
<code class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">Abs(x)</span> <span class="pre">-</span> <span class="pre">n</span></code>, is inverted, then, the <code class="docutils literal"><span class="pre">set_h</span></code> doesn&#8217;t simply
return <span class="math">\({-n, n}\)</span>, as it doesn&#8217;t explicitly mentions about the nature of
<span class="math">\(n\)</span> rather it will return:
<span class="math">\(Intersection([0, oo) {n}) U Intersection((-oo, 0], {-n})\)</span></p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.solveset.invert_complex" title="sympy.solvers.solveset.invert_complex"><code class="xref py py-obj docutils literal"><span class="pre">invert_complex</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">invert_real</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">tan</span><span class="p">,</span> <span class="n">Abs</span><span class="p">,</span> <span class="n">exp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, {0})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">tan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, ImageSet(Lambda(_n, _n*pi + atan(y)), Integers()))</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">set_h</span></code> containing information about the domain</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">31</span> <span class="o">+</span> <span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x**31 + x, Intersection([0, oo), {y}) U Intersection((-oo, 0], {-y}))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_real</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">Abs</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, Intersection([0, oo), {log(y)}) U Intersection((-oo, 0], {-log(y)}))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.invert_complex">
<code class="descclassname">sympy.solvers.solveset.</code><code class="descname">invert_complex</code><span class="sig-paren">(</span><em>f_x</em>, <em>y</em>, <em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#invert_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.invert_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts a complex valued function.</p>
<p>Reduces the complex valued equation <code class="docutils literal"><span class="pre">f(x)</span> <span class="pre">=</span> <span class="pre">y</span></code> to a set of equations
<code class="docutils literal"><span class="pre">{g(x)</span> <span class="pre">=</span> <span class="pre">h_1(y),</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">g(x)</span> <span class="pre">=</span> <span class="pre">h_n(y)</span> <span class="pre">}</span></code> where <code class="docutils literal"><span class="pre">g(x)</span></code> is
a simpler function than <code class="docutils literal"><span class="pre">f(x)</span></code>.  The return value is a tuple <code class="docutils literal"><span class="pre">(g(x),</span>
<span class="pre">set_h)</span></code>, where <code class="docutils literal"><span class="pre">g(x)</span></code> is a function of <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">set_h</span></code> is
the set of function <code class="docutils literal"><span class="pre">{h_1(y),</span> <span class="pre">h_2(y),</span> <span class="pre">...,</span> <span class="pre">h_n(y)}</span></code>.
Here, <code class="docutils literal"><span class="pre">y</span></code> is not necessarily a symbol.</p>
<p>Note that <span class="math">\(invert\_complex\)</span> and <span class="math">\(invert\_real\)</span> don&#8217;t always produce the
same result even for a seemingly simple function like <code class="docutils literal"><span class="pre">exp(x)</span></code> because
the complex extension of real valued <code class="docutils literal"><span class="pre">log</span></code> is multivariate in the complex
system and has infinitely many branches. If you are working with real
values only or you are not sure with function to use you should use
<span class="math">\(invert\_real\)</span>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#sympy.solvers.solveset.invert_real" title="sympy.solvers.solveset.invert_real"><code class="xref py py-obj docutils literal"><span class="pre">invert_real</span></code></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">invert_complex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">exp</span><span class="p">,</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, {exp(y)})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>  <span class="c"># Second parameter is not a symbol</span>
<span class="go">(x, {1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert_complex</span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="go">(x, ImageSet(Lambda(_n, I*(2*_n*pi + arg(y)) + log(Abs(y))), Integers()))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="sympy.solvers.solveset.domain_check">
<code class="descclassname">sympy.solvers.solveset.</code><code class="descname">domain_check</code><span class="sig-paren">(</span><em>f</em>, <em>symbol</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#domain_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.domain_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns False if point p is infinite or any subexpression of f
is infinite or becomes so after replacing symbol with p. If none of
these conditions is met then True will be returned.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Mul</span><span class="p">,</span> <span class="n">oo</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">domain_check</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">oo</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<ul class="simple">
<li>The function relies on the assumption that the original form
of the equation has not been changed by automatic simplification.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c"># x/x is automatically simplified to 1</span>
<span class="go">True</span>
</pre></div>
</div>
<ul class="simple">
<li>To deal with automatic evaluations use evaluate=False:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">domain_check</span><span class="p">(</span><span class="n">Mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">x</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="linear-eq-to-matrix">
<h2>linear_eq_to_matrix<a class="headerlink" href="#linear-eq-to-matrix" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sympy.solvers.solveset.linear_eq_to_matrix">
<code class="descclassname">sympy.solvers.solveset.</code><code class="descname">linear_eq_to_matrix</code><span class="sig-paren">(</span><em>equations</em>, <em>*symbols</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#linear_eq_to_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.linear_eq_to_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a given System of Equations into Matrix form.
Here <span class="math">\(equations\)</span> must be a linear system of equations in
<span class="math">\(symbols\)</span>. The order of symbols in input <span class="math">\(symbols\)</span> will
determine the order of coefficients in the returned
Matrix.</p>
<p>The Matrix form corresponds to the augmented matrix form.
For example:</p>
<div class="math">
\[4x + 2y + 3z  = 1\]</div>
<div class="math">
\[3x +  y +  z  = -6\]</div>
<div class="math">
\[2x + 4y + 9z  = 2\]</div>
<p>This system would return <span class="math">\(A\)</span> &amp; <span class="math">\(b\)</span> as given below:</p>
<div class="highlight-python"><div class="highlight"><pre>    [ 4  2  3 ]          [ 1 ]
A = [ 3  1  1 ]   b  =   [-6 ]
    [ 2  4  9 ]          [ 2 ]
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">linear_eq_to_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x, y, z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="n">z</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1, 2, 3],</span>
<span class="go">[3, 1, 1],</span>
<span class="go">[2, 4, 9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[ 1],</span>
<span class="go">[-6],</span>
<span class="go">[ 2]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1,  0, 1],</span>
<span class="go">[0,  1, 1],</span>
<span class="go">[1, -1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[1],</span>
<span class="go">[0],</span>
<span class="go">[0]])</span>
</pre></div>
</div>
<ul class="simple">
<li>Symbolic coefficients are also supported</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a, b, c, d, e, f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">f</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">linear_eq_to_matrix</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[a, b],</span>
<span class="go">[d, e]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>
<span class="go">Matrix([</span>
<span class="go">[c],</span>
<span class="go">[f]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="linsolve">
<h2>linsolve<a class="headerlink" href="#linsolve" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="sympy.solvers.solveset.linsolve">
<code class="descclassname">sympy.solvers.solveset.</code><code class="descname">linsolve</code><span class="sig-paren">(</span><em>system</em>, <em>*symbols</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sympy/solvers/solveset.html#linsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.solvers.solveset.linsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve system of N linear equations with M variables, which
means both under - and overdetermined systems are supported.
The possible number of solutions is zero, one or infinite.
Zero solutions throws a ValueError, where as infinite
solutions are represented parametrically in terms of given
symbols. For unique solution a FiniteSet of ordered tuple
is returned.</p>
<p>All Standard input formats are supported:
For the given set of Equations, the respective input types
are given below:</p>
<div class="math">
\[3x + 2y -   z = 1\]</div>
<div class="math">
\[2x - 2y + 4z = -2\]</div>
<div class="math">
\[2x -   y + 2z = 0\]</div>
<ul class="simple">
<li>Augmented Matrix Form, <span class="math">\(system\)</span> given below:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>         [3   2  -1  1]
system = [2  -2   4 -2]
         [2  -1   2  0]
</pre></div>
</div>
<ul class="simple">
<li>List Of Equations Form</li>
</ul>
<p><span class="math">\(system  =  [3x + 2y - z - 1, 2x - 2y + 4z + 2, 2x - y + 2z]\)</span></p>
<ul class="simple">
<li>Input A &amp; b Matrix Form (from Ax = b) are given as below:</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre>    [3   2  -1 ]         [  1 ]
A = [2  -2   4 ]    b =  [ -2 ]
    [2  -1   2 ]         [  0 ]
</pre></div>
</div>
<p><span class="math">\(system = (A, b)\)</span></p>
<p>Symbols to solve for should be given as input in all the
cases either in an iterable or as comma separated arguments.
This is done to maintain consistency in returning solutions
in the form of variable input by the user.</p>
<p>The algorithm used here is Gauss-Jordan elimination, which
results, after elimination, in an row echelon form matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A FiniteSet of ordered tuple of values of <span class="math">\(symbols\)</span> for which</p>
<p>the <span class="math">\(system\)</span> has solution.</p>
<p>Please note that general FiniteSet is unordered, the solution</p>
<p>returned here is not simply a FiniteSet of solutions, rather</p>
<p>it is a FiniteSet of ordered tuple, i.e. the first &amp; only</p>
<p>argument to FiniteSet is a tuple of solutions, which is ordered,</p>
<p>&amp; hence the returned solution is ordered.</p>
<p>Also note that solution could also have been returned as an</p>
<p>ordered tuple, FiniteSet is just a wrapper <span class="math">\({}\)</span> around</p>
<p>the tuple. It has no other significance except for</p>
<p>the fact it is just used to maintain a consistent output</p>
<p>format throughout the solveset.</p>
<p>Returns EmptySet(), if the linear system is inconsistent.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong></p>
<blockquote class="last">
<div><p>The input is not valid.
The symbols are not given.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.solvers.solveset</span> <span class="kn">import</span> <span class="n">linsolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&quot;x, y, z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">Matrix([</span>
<span class="go">[1, 2,  3],</span>
<span class="go">[4, 5,  6],</span>
<span class="go">[7, 8, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">Matrix([</span>
<span class="go">[3],</span>
<span class="go">[6],</span>
<span class="go">[9]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{(-1, 2, 0)}</span>
</pre></div>
</div>
<ul class="simple">
<li>Parametric Solution: In case the system is under determined, the function
will return parametric solution in terms of the given symbols.
Free symbols in the system are returned as it is. For e.g. in the system
below, <span class="math">\(z\)</span> is returned as the solution for variable z, which means z is a
free symbol, i.e. it can take arbitrary values.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">{(z - 1, -2*z + 2, z)}</span>
</pre></div>
</div>
<ul class="simple">
<li>List of Equations as input</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Eqns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">z</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">Eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{(1, -2, -2)}</span>
</pre></div>
</div>
<ul class="simple">
<li>Augmented Matrix as input</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span>
<span class="go">Matrix([</span>
<span class="go">[2, 1,  3, 1],</span>
<span class="go">[2, 6,  8, 3],</span>
<span class="go">[6, 8, 18, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">{(3/10, 2/5, 0)}</span>
</pre></div>
</div>
<ul class="simple">
<li>Solve for symbolic coefficients</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;a, b, c, d, e, f&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eqns</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">e</span><span class="o">*</span><span class="n">y</span> <span class="o">-</span> <span class="n">f</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">eqns</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{(-b*(f - c*d/a)/(a*(e - b*d/a)) + c/a, (f - c*d/a)/(e - b*d/a))}</span>
</pre></div>
</div>
<ul class="simple">
<li>A degenerate system returns solution as set of given
symbols.</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">system</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">(([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">linsolve</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{(x, y)}</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="diophantine-equations-des">
<h2>Diophantine Equations (DEs)<a class="headerlink" href="#diophantine-equations-des" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="diophantine.html#diophantine-docs"><em>Diophantine</em></a></p>
</div>
<div class="section" id="inequalities">
<h2>Inequalities<a class="headerlink" href="#inequalities" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="inequalities.html#inequality-docs"><em>Inequality Solvers</em></a></p>
</div>
<div class="section" id="ordinary-differential-equations-odes">
<h2>Ordinary Differential equations (ODEs)<a class="headerlink" href="#ordinary-differential-equations-odes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="ode.html#ode-docs"><em>ODE</em></a>.</p>
</div>
<div class="section" id="partial-differential-equations-pdes">
<h2>Partial Differential Equations (PDEs)<a class="headerlink" href="#partial-differential-equations-pdes" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="pde.html#pde-docs"><em>PDE</em></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solveset</a><ul>
<li><a class="reference internal" href="#what-s-wrong-with-solve">What&#8217;s wrong with solve():</a></li>
<li><a class="reference internal" href="#why-solveset">Why Solveset?</a></li>
<li><a class="reference internal" href="#why-do-we-use-sets-as-an-output-type">Why do we use Sets as an output type?</a></li>
<li><a class="reference internal" href="#input-api-of-solveset">Input API of <code class="docutils literal"><span class="pre">solveset</span></code></a></li>
<li><a class="reference internal" href="#what-is-this-domain-argument-about">What is this domain argument about?</a></li>
<li><a class="reference internal" href="#what-are-the-general-methods-employed-by-solveset-to-solve-an-equation">What are the general methods employed by solveset to solve an equation?</a></li>
<li><a class="reference internal" href="#how-do-we-manipulate-and-return-an-infinite-solution">How do we manipulate and return an infinite solution?</a></li>
<li><a class="reference internal" href="#how-does-solveset-ensure-that-it-is-not-returning-any-wrong-solution">How does <code class="docutils literal"><span class="pre">solveset</span></code> ensure that it is not returning any wrong solution?</a></li>
<li><a class="reference internal" href="#search-based-solver-and-step-by-step-solution">Search based solver and step-by-step solution</a></li>
<li><a class="reference internal" href="#how-do-we-deal-with-cases-where-only-some-of-the-solutions-are-known">How do we deal with cases where only some of the solutions are known?</a></li>
<li><a class="reference internal" href="#what-will-you-do-with-the-old-solve">What will you do with the old solve?</a></li>
<li><a class="reference internal" href="#how-are-symbolic-parameters-handled-in-solveset">How are symbolic parameters handled in solveset?</a></li>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#solveset-module-reference">Solveset Module Reference</a></li>
<li><a class="reference internal" href="#linear-eq-to-matrix">linear_eq_to_matrix</a></li>
<li><a class="reference internal" href="#linsolve">linsolve</a></li>
<li><a class="reference internal" href="#diophantine-equations-des">Diophantine Equations (DEs)</a></li>
<li><a class="reference internal" href="#inequalities">Inequalities</a></li>
<li><a class="reference internal" href="#ordinary-differential-equations-odes">Ordinary Differential equations (ODEs)</a></li>
<li><a class="reference internal" href="#partial-differential-equations-pdes">Partial Differential Equations (PDEs)</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="inequalities.html"
                        title="previous chapter">Inequality Solvers</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../tensor/index.html"
                        title="next chapter">Tensor Module</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/solvers/solveset.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../tensor/index.html" title="Tensor Module"
             >next</a> |</li>
        <li class="right" >
          <a href="inequalities.html" title="Inequality Solvers"
             >previous</a> |</li>
        <li><a href="../../index.html">SymPy 0.7.7.dev documentation</a> &raquo;</li>
          <li><a href="../index.html" >SymPy Modules Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015 SymPy Development Team.
      Last updated on Feb 11, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3b2.
    </div>
  </body>
</html>