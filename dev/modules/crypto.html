
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cryptography &#8212; SymPy 1.7.dev documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-core.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-autocomplete.css" />
    <link rel="stylesheet" type="text/css" href="https://live.sympy.org/static/live-sphinx.css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="https://live.sympy.org/static/utilities.js"></script>
    <script src="https://live.sympy.org/static/external/classy.js"></script>
    <script src="https://live.sympy.org/static/live-core.js"></script>
    <script src="https://live.sympy.org/static/live-autocomplete.js"></script>
    <script src="https://live.sympy.org/static/live-sphinx.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML-full"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    
    <link rel="shortcut icon" href="../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/crypto.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Differential Geometry" href="diffgeom.html" />
    <link rel="prev" title="Core" href="core.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="diffgeom.html" title="Differential Geometry"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="core.html" title="Core"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">SymPy Modules Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Cryptography</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="cryptography">
<h1>Cryptography<a class="headerlink" href="#cryptography" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This module is intended for educational purposes only. Do not use the
functions in this module for real cryptographic applications. If you wish
to encrypt real data, we recommend using something like the <a class="reference external" href="https://cryptography.io/en/latest/">cryptography</a> module.</p>
</div>
<p>Encryption is the process of hiding a message and a cipher is a
means of doing so. Included in this module are both block and stream
ciphers:</p>
<blockquote>
<div><ul class="simple">
<li><p>Shift cipher</p></li>
<li><p>Affine cipher</p></li>
<li><p>substitution ciphers</p></li>
<li><p>Vigenere’s cipher</p></li>
<li><p>Hill’s cipher</p></li>
<li><p>Bifid ciphers</p></li>
<li><p>RSA</p></li>
<li><p>Kid RSA</p></li>
<li><p>linear-feedback shift registers (for stream ciphers)</p></li>
<li><p>ElGamal encryption</p></li>
</ul>
</div></blockquote>
<p>In a <em>substitution cipher</em> “units” (not necessarily single characters)
of plaintext are replaced with ciphertext according to a regular system.</p>
<p>A <em>transposition cipher</em> is a method of encryption by which
the positions held by “units” of plaintext are replaced by a
permutation of the plaintext. That is, the order of the units is
changed using a bijective function on the position of the characters
to perform the encryption.</p>
<p>A <em>monoalphabetic cipher</em> uses fixed substitution over the entire
message, whereas a <em>polyalphabetic cipher</em> uses a number of
substitutions at different times in the message.</p>
<span class="target" id="module-sympy.crypto.crypto"></span><dl class="py function">
<dt id="sympy.crypto.crypto.AZ">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">AZ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L46-L75"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.AZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the letters of <code class="docutils literal notranslate"><span class="pre">s</span></code> in uppercase. In case more than
one string is passed, each of them will be processed and a list
of upper case strings will be returned.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">AZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AZ</span><span class="p">(</span><span class="s1">&#39;Hello, world!&#39;</span><span class="p">)</span>
<span class="go">&#39;HELLOWORLD&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">AZ</span><span class="p">(</span><span class="s1">&#39;Hello, world!&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">[&#39;HELLO&#39;, &#39;WORLD&#39;]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.check_and_join" title="sympy.crypto.crypto.check_and_join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_and_join</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.padded_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">padded_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L82-L112"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.padded_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string of the distinct characters of <code class="docutils literal notranslate"><span class="pre">symbols</span></code> with
those of <code class="docutils literal notranslate"><span class="pre">key</span></code> appearing first. A ValueError is raised if
a) there are duplicate characters in <code class="docutils literal notranslate"><span class="pre">symbols</span></code> or
b) there are characters in <code class="docutils literal notranslate"><span class="pre">key</span></code> that are  not in <code class="docutils literal notranslate"><span class="pre">symbols</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">padded_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">padded_key</span><span class="p">(</span><span class="s1">&#39;PUPPY&#39;</span><span class="p">,</span> <span class="s1">&#39;OPQRSTUVWXY&#39;</span><span class="p">)</span>
<span class="go">&#39;PUYOQRSTVWX&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">padded_key</span><span class="p">(</span><span class="s1">&#39;RSA&#39;</span><span class="p">,</span> <span class="s1">&#39;ARTIST&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">duplicate characters in symbols: T</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.check_and_join">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">check_and_join</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">phrase</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">filter</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L115-L156"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.check_and_join" title="Permalink to this definition">¶</a></dt>
<dd><p>Joins characters of <code class="docutils literal notranslate"><span class="pre">phrase</span></code> and if <code class="docutils literal notranslate"><span class="pre">symbols</span></code> is given, raises
an error if any character in <code class="docutils literal notranslate"><span class="pre">phrase</span></code> is not in <code class="docutils literal notranslate"><span class="pre">symbols</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>phrase</strong></p>
<blockquote>
<div><p>String or list of strings to be returned as a string.</p>
</div></blockquote>
<p><strong>symbols</strong></p>
<blockquote>
<div><p>Iterable of characters allowed in <code class="docutils literal notranslate"><span class="pre">phrase</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">symbols</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, no checking is performed.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">check_and_join</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_and_join</span><span class="p">(</span><span class="s1">&#39;a phrase&#39;</span><span class="p">)</span>
<span class="go">&#39;a phrase&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_and_join</span><span class="p">(</span><span class="s1">&#39;a phrase&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
<span class="go">&#39;APHRASE&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_and_join</span><span class="p">(</span><span class="s1">&#39;a phrase!&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="s1">&#39;ARE&#39;</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;ARAE&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">check_and_join</span><span class="p">(</span><span class="s1">&#39;a phrase!&#39;</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="s1">&#39;ARE&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">characters in phrase but not symbols: &quot;!HPS&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.cycle_list">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">cycle_list</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">k</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L174-L188"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.cycle_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the elements of the list <code class="docutils literal notranslate"><span class="pre">range(n)</span></code> shifted to the
left by <code class="docutils literal notranslate"><span class="pre">k</span></code> (so the list starts with <code class="docutils literal notranslate"><span class="pre">k</span></code> (mod <code class="docutils literal notranslate"><span class="pre">n</span></code>)).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">cycle_list</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cycle_list</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">[3, 4, 5, 6, 7, 8, 9, 0, 1, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_shift">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L194-L268"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs shift cipher encryption on plaintext msg, and returns the
ciphertext.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> : int</p>
<blockquote>
<div><p>The secret key.</p>
</div></blockquote>
<p><strong>msg</strong> : str</p>
<blockquote>
<div><p>Plaintext of upper-case letters.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>str</p>
<blockquote>
<div><p>Ciphertext of upper-case letters.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_shift</span><span class="p">,</span> <span class="n">decipher_shift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;GONAVYBEATARMY&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">encipher_shift</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="n">ct</span>
<span class="go">&#39;HPOBWZCFBUBSNZ&#39;</span>
</pre></div>
</div>
<p>To decipher the shifted text, change the sign of the key:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_shift</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;GONAVYBEATARMY&#39;</span>
</pre></div>
</div>
<p>There is also a convenience function that does this with the
original key:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_shift</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;GONAVYBEATARMY&#39;</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>ALGORITHM:</p>
<blockquote>
<div><dl class="simple">
<dt>STEPS:</dt><dd><ol class="arabic simple" start="0">
<li><p>Number the letters of the alphabet from 0, …, N</p></li>
<li><p>Compute from the string <code class="docutils literal notranslate"><span class="pre">msg</span></code> a list <code class="docutils literal notranslate"><span class="pre">L1</span></code> of
corresponding integers.</p></li>
<li><p>Compute from the list <code class="docutils literal notranslate"><span class="pre">L1</span></code> a new list <code class="docutils literal notranslate"><span class="pre">L2</span></code>, given by
adding <code class="docutils literal notranslate"><span class="pre">(k</span> <span class="pre">mod</span> <span class="pre">26)</span></code> to each element in <code class="docutils literal notranslate"><span class="pre">L1</span></code>.</p></li>
<li><p>Compute from the list <code class="docutils literal notranslate"><span class="pre">L2</span></code> a string <code class="docutils literal notranslate"><span class="pre">ct</span></code> of
corresponding letters.</p></li>
</ol>
</dd>
</dl>
</div></blockquote>
<p>The shift cipher is also called the Caesar cipher, after
Julius Caesar, who, according to Suetonius, used it with a
shift of three to protect messages of military significance.
Caesar’s nephew Augustus reportedly used a similar cipher, but
with a right shift of 1.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.decipher_shift" title="sympy.crypto.crypto.decipher_shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_shift</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r118"><span class="brackets"><a class="fn-backref" href="#id2">R118</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Caesar_cipher">https://en.wikipedia.org/wiki/Caesar_cipher</a></p>
</dd>
<dt class="label" id="r119"><span class="brackets"><a class="fn-backref" href="#id3">R119</a></span></dt>
<dd><p><a class="reference external" href="http://mathworld.wolfram.com/CaesarsMethod.html">http://mathworld.wolfram.com/CaesarsMethod.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_shift">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L271-L295"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the text by shifting the characters of <code class="docutils literal notranslate"><span class="pre">msg</span></code> to the
left by the amount given by <code class="docutils literal notranslate"><span class="pre">key</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_shift</span><span class="p">,</span> <span class="n">decipher_shift</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;GONAVYBEATARMY&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">encipher_shift</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="n">ct</span>
<span class="go">&#39;HPOBWZCFBUBSNZ&#39;</span>
</pre></div>
</div>
<p>To decipher the shifted text, change the sign of the key:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_shift</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;GONAVYBEATARMY&#39;</span>
</pre></div>
</div>
<p>Or use this function with the original key:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_shift</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;GONAVYBEATARMY&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_rot13">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_rot13</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L297-L323"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_rot13" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the ROT13 encryption on a given plaintext <code class="docutils literal notranslate"><span class="pre">msg</span></code>.</p>
<p class="rubric">Notes</p>
<p>ROT13 is a substitution cipher which substitutes each letter
in the plaintext message for the letter furthest away from it
in the English alphabet.</p>
<p>Equivalently, it is just a Caeser (shift) cipher with a shift
key of 13 (midway point of the alphabet).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.decipher_rot13" title="sympy.crypto.crypto.decipher_rot13"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_rot13</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.encipher_shift" title="sympy.crypto.crypto.encipher_shift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_shift</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r120"><span class="brackets"><a class="fn-backref" href="#id4">R120</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/ROT13">https://en.wikipedia.org/wiki/ROT13</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_rot13">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_rot13</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L325-L353"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_rot13" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the ROT13 decryption on a given plaintext <code class="docutils literal notranslate"><span class="pre">msg</span></code>.</p>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">decipher_rot13</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">encipher_rot13</span></code> as both
<code class="docutils literal notranslate"><span class="pre">decipher_shift</span></code> with a key of 13 and <code class="docutils literal notranslate"><span class="pre">encipher_shift</span></code> key with a
key of 13 will return the same results. Nonetheless,
<code class="docutils literal notranslate"><span class="pre">decipher_rot13</span></code> has nonetheless been explicitly defined here for
consistency.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_rot13</span><span class="p">,</span> <span class="n">decipher_rot13</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;GONAVYBEATARMY&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encipher_rot13</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span><span class="n">ciphertext</span>
<span class="go">&#39;TBANILORNGNEZL&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_rot13</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span>
<span class="go">&#39;GONAVYBEATARMY&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_rot13</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="n">decipher_rot13</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">==</span> <span class="n">decipher_rot13</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_affine">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_affine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">_inverse</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L358-L431"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the affine cipher encryption on plaintext <code class="docutils literal notranslate"><span class="pre">msg</span></code>, and
returns the ciphertext.</p>
<p>Encryption is based on the map <span class="math notranslate nohighlight">\(x \rightarrow ax+b\)</span> (mod <span class="math notranslate nohighlight">\(N\)</span>)
where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of characters in the alphabet.
Decryption is based on the map <span class="math notranslate nohighlight">\(x \rightarrow cx+d\)</span> (mod <span class="math notranslate nohighlight">\(N\)</span>),
where <span class="math notranslate nohighlight">\(c = a^{-1}\)</span> (mod <span class="math notranslate nohighlight">\(N\)</span>) and <span class="math notranslate nohighlight">\(d = -a^{-1}b\)</span> (mod <span class="math notranslate nohighlight">\(N\)</span>).
In particular, for the map to be invertible, we need
<span class="math notranslate nohighlight">\(\mathrm{gcd}(a, N) = 1\)</span> and an error will be raised if this is
not true.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong> : str</p>
<blockquote>
<div><p>Characters that appear in <code class="docutils literal notranslate"><span class="pre">symbols</span></code>.</p>
</div></blockquote>
<p><strong>a, b</strong> : int, int</p>
<blockquote>
<div><p>A pair integers, with <code class="docutils literal notranslate"><span class="pre">gcd(a,</span> <span class="pre">N)</span> <span class="pre">=</span> <span class="pre">1</span></code> (the secret key).</p>
</div></blockquote>
<p><strong>symbols</strong></p>
<blockquote>
<div><p>String of characters (default = uppercase letters).</p>
<p>When no symbols are given, <code class="docutils literal notranslate"><span class="pre">msg</span></code> is converted to upper case
letters and all other characters are ignored.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ct</p>
<blockquote>
<div><p>String of characters (the ciphertext message)</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>ALGORITHM:</p>
<blockquote>
<div><dl class="simple">
<dt>STEPS:</dt><dd><ol class="arabic simple" start="0">
<li><p>Number the letters of the alphabet from 0, …, N</p></li>
<li><p>Compute from the string <code class="docutils literal notranslate"><span class="pre">msg</span></code> a list <code class="docutils literal notranslate"><span class="pre">L1</span></code> of
corresponding integers.</p></li>
<li><p>Compute from the list <code class="docutils literal notranslate"><span class="pre">L1</span></code> a new list <code class="docutils literal notranslate"><span class="pre">L2</span></code>, given by
replacing <code class="docutils literal notranslate"><span class="pre">x</span></code> by <code class="docutils literal notranslate"><span class="pre">a*x</span> <span class="pre">+</span> <span class="pre">b</span> <span class="pre">(mod</span> <span class="pre">N)</span></code>, for each element
<code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">L1</span></code>.</p></li>
<li><p>Compute from the list <code class="docutils literal notranslate"><span class="pre">L2</span></code> a string <code class="docutils literal notranslate"><span class="pre">ct</span></code> of
corresponding letters.</p></li>
</ol>
</dd>
</dl>
</div></blockquote>
<p>This is a straightforward generalization of the shift cipher with
the added complexity of requiring 2 characters to be deciphered in
order to recover the key.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.decipher_affine" title="sympy.crypto.crypto.decipher_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_affine</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r121"><span class="brackets"><a class="fn-backref" href="#id5">R121</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Affine_cipher">https://en.wikipedia.org/wiki/Affine_cipher</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_affine">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_affine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L434-L459"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the deciphered text that was made from the mapping,
<span class="math notranslate nohighlight">\(x \rightarrow ax+b\)</span> (mod <span class="math notranslate nohighlight">\(N\)</span>), where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the
number of characters in the alphabet. Deciphering is done by
reciphering with a new key: <span class="math notranslate nohighlight">\(x \rightarrow cx+d\)</span> (mod <span class="math notranslate nohighlight">\(N\)</span>),
where <span class="math notranslate nohighlight">\(c = a^{-1}\)</span> (mod <span class="math notranslate nohighlight">\(N\)</span>) and <span class="math notranslate nohighlight">\(d = -a^{-1}b\)</span> (mod <span class="math notranslate nohighlight">\(N\)</span>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_affine</span><span class="p">,</span> <span class="n">decipher_affine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;GO NAVY BEAT ARMY&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_affine</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;TROBMVENBGBALV&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_affine</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;GONAVYBEATARMY&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.encipher_affine" title="sympy.crypto.crypto.encipher_affine"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_affine</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_atbash">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_atbash</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L462-L482"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_atbash" title="Permalink to this definition">¶</a></dt>
<dd><p>Enciphers a given <code class="docutils literal notranslate"><span class="pre">msg</span></code> into its Atbash ciphertext and returns it.</p>
<p class="rubric">Notes</p>
<p>Atbash is a substitution cipher originally used to encrypt the Hebrew
alphabet. Atbash works on the principle of mapping each alphabet to its
reverse / counterpart (i.e. a would map to z, b to y etc.)</p>
<p>Atbash is functionally equivalent to the affine cipher with <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">25</span></code>
and <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">25</span></code></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.decipher_atbash" title="sympy.crypto.crypto.decipher_atbash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_atbash</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_atbash">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_atbash</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L485-L521"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_atbash" title="Permalink to this definition">¶</a></dt>
<dd><p>Deciphers a given <code class="docutils literal notranslate"><span class="pre">msg</span></code> using Atbash cipher and returns it.</p>
<p class="rubric">Notes</p>
<p><code class="docutils literal notranslate"><span class="pre">decipher_atbash</span></code> is functionally equivalent to <code class="docutils literal notranslate"><span class="pre">encipher_atbash</span></code>.
However, it has still been added as a separate function to maintain
consistency.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_atbash</span><span class="p">,</span> <span class="n">decipher_atbash</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;GONAVYBEATARMY&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_atbash</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">&#39;TLMZEBYVZGZINB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_atbash</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">&#39;TLMZEBYVZGZINB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_atbash</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">==</span> <span class="n">decipher_atbash</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">==</span> <span class="n">encipher_atbash</span><span class="p">(</span><span class="n">encipher_atbash</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.encipher_atbash" title="sympy.crypto.crypto.encipher_atbash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_atbash</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r122"><span class="brackets"><a class="fn-backref" href="#id6">R122</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Atbash">https://en.wikipedia.org/wiki/Atbash</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_substitution">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_substitution</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">old</span></em>, <em class="sig-param"><span class="n">new</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L526-L582"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_substitution" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ciphertext obtained by replacing each character that
appears in <code class="docutils literal notranslate"><span class="pre">old</span></code> with the corresponding character in <code class="docutils literal notranslate"><span class="pre">new</span></code>.
If <code class="docutils literal notranslate"><span class="pre">old</span></code> is a mapping, then new is ignored and the replacements
defined by <code class="docutils literal notranslate"><span class="pre">old</span></code> are used.</p>
<p class="rubric">Notes</p>
<p>This is a more general than the affine cipher in that the key can
only be recovered by determining the mapping for each symbol.
Though in practice, once a few symbols are recognized the mappings
for other characters can be quickly guessed.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_substitution</span><span class="p">,</span> <span class="n">AZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">old</span> <span class="o">=</span> <span class="s1">&#39;OEYAG&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new</span> <span class="o">=</span> <span class="s1">&#39;034^6&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">(</span><span class="s2">&quot;go navy! beat army!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">encipher_substitution</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span> <span class="n">ct</span>
<span class="go">&#39;60N^V4B3^T^RM4&#39;</span>
</pre></div>
</div>
<p>To decrypt a substitution, reverse the last two arguments:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_substitution</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>
<span class="go">&#39;GONAVYBEATARMY&#39;</span>
</pre></div>
</div>
<p>In the special case where <code class="docutils literal notranslate"><span class="pre">old</span></code> and <code class="docutils literal notranslate"><span class="pre">new</span></code> are a permutation of
order 2 (representing a transposition of characters) their order
is immaterial:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">old</span> <span class="o">=</span> <span class="s1">&#39;NAVY&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new</span> <span class="o">=</span> <span class="s1">&#39;ANYV&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">encipher_substitution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher</span><span class="p">(</span><span class="s1">&#39;NAVY&#39;</span><span class="p">)</span>
<span class="go">&#39;ANYV&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">&#39;NAVY&#39;</span>
</pre></div>
</div>
<p>The substitution cipher, in general, is a method
whereby “units” (not necessarily single characters) of plaintext
are replaced with ciphertext according to a regular system.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;</span><span class="se">\\</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="s1">&#39;abc&#39;</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">encipher_substitution</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="n">ords</span><span class="p">))</span>
<span class="go">\97\98\99</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r123"><span class="brackets"><a class="fn-backref" href="#id7">R123</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Substitution_cipher">https://en.wikipedia.org/wiki/Substitution_cipher</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_vigenere">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_vigenere</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L589-L754"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_vigenere" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the Vigenere cipher encryption on plaintext <code class="docutils literal notranslate"><span class="pre">msg</span></code>, and
returns the ciphertext.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_vigenere</span><span class="p">,</span> <span class="n">AZ</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;encrypt&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;meet me on monday&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_vigenere</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;QRGKKTHRZQEBPR&#39;</span>
</pre></div>
</div>
<p>Section 1 of the Kryptos sculpture at the CIA headquarters
uses this cipher and also changes the order of the the
alphabet <a class="reference internal" href="#r125" id="id8"><span>[R125]</span></a>. Here is the first line of that section of
the sculpture:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">decipher_vigenere</span><span class="p">,</span> <span class="n">padded_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alp</span> <span class="o">=</span> <span class="n">padded_key</span><span class="p">(</span><span class="s1">&#39;KRYPTOS&#39;</span><span class="p">,</span> <span class="n">AZ</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;PALIMPSEST&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;EMUFPHZLRFAXYUSDJKZLDKRNSHGNFIVJ&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_vigenere</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
<span class="go">&#39;BETWEENSUBTLESHADINGANDTHEABSENC&#39;</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The Vigenere cipher is named after Blaise de Vigenere, a sixteenth
century diplomat and cryptographer, by a historical accident.
Vigenere actually invented a different and more complicated cipher.
The so-called <em>Vigenere cipher</em> was actually invented
by Giovan Batista Belaso in 1553.</p>
<p>This cipher was used in the 1800’s, for example, during the American
Civil War. The Confederacy used a brass cipher disk to implement the
Vigenere cipher (now on display in the NSA Museum in Fort
Meade) <a class="reference internal" href="#r124" id="id9"><span>[R124]</span></a>.</p>
<p>The Vigenere cipher is a generalization of the shift cipher.
Whereas the shift cipher shifts each letter by the same amount
(that amount being the key of the shift cipher) the Vigenere
cipher shifts a letter by an amount determined by the key (which is
a word or phrase known only to the sender and receiver).</p>
<p>For example, if the key was a single letter, such as “C”, then the
so-called Vigenere cipher is actually a shift cipher with a
shift of <span class="math notranslate nohighlight">\(2\)</span> (since “C” is the 2nd letter of the alphabet, if
you start counting at <span class="math notranslate nohighlight">\(0\)</span>). If the key was a word with two
letters, such as “CA”, then the so-called Vigenere cipher will
shift letters in even positions by <span class="math notranslate nohighlight">\(2\)</span> and letters in odd positions
are left alone (shifted by <span class="math notranslate nohighlight">\(0\)</span>, since “A” is the 0th letter, if
you start counting at <span class="math notranslate nohighlight">\(0\)</span>).</p>
<p>ALGORITHM:</p>
<blockquote>
<div><p>INPUT:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">msg</span></code>: string of characters that appear in <code class="docutils literal notranslate"><span class="pre">symbols</span></code>
(the plaintext)</p>
<p><code class="docutils literal notranslate"><span class="pre">key</span></code>: a string of characters that appear in <code class="docutils literal notranslate"><span class="pre">symbols</span></code>
(the secret key)</p>
<p><code class="docutils literal notranslate"><span class="pre">symbols</span></code>: a string of letters defining the alphabet</p>
</div></blockquote>
<p>OUTPUT:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">ct</span></code>: string of characters (the ciphertext message)</p>
</div></blockquote>
<dl class="simple">
<dt>STEPS:</dt><dd><ol class="arabic simple" start="0">
<li><p>Number the letters of the alphabet from 0, …, N</p></li>
<li><p>Compute from the string <code class="docutils literal notranslate"><span class="pre">key</span></code> a list <code class="docutils literal notranslate"><span class="pre">L1</span></code> of
corresponding integers. Let <code class="docutils literal notranslate"><span class="pre">n1</span> <span class="pre">=</span> <span class="pre">len(L1)</span></code>.</p></li>
<li><p>Compute from the string <code class="docutils literal notranslate"><span class="pre">msg</span></code> a list <code class="docutils literal notranslate"><span class="pre">L2</span></code> of
corresponding integers. Let <code class="docutils literal notranslate"><span class="pre">n2</span> <span class="pre">=</span> <span class="pre">len(L2)</span></code>.</p></li>
<li><p>Break <code class="docutils literal notranslate"><span class="pre">L2</span></code> up sequentially into sublists of size
<code class="docutils literal notranslate"><span class="pre">n1</span></code>; the last sublist may be smaller than <code class="docutils literal notranslate"><span class="pre">n1</span></code></p></li>
<li><p>For each of these sublists <code class="docutils literal notranslate"><span class="pre">L</span></code> of <code class="docutils literal notranslate"><span class="pre">L2</span></code>, compute a
new list <code class="docutils literal notranslate"><span class="pre">C</span></code> given by <code class="docutils literal notranslate"><span class="pre">C[i]</span> <span class="pre">=</span> <span class="pre">L[i]</span> <span class="pre">+</span> <span class="pre">L1[i]</span> <span class="pre">(mod</span> <span class="pre">N)</span></code>
to the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th element in the sublist, for each <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>Assemble these lists <code class="docutils literal notranslate"><span class="pre">C</span></code> by concatenation into a new
list of length <code class="docutils literal notranslate"><span class="pre">n2</span></code>.</p></li>
<li><p>Compute from the new list a string <code class="docutils literal notranslate"><span class="pre">ct</span></code> of
corresponding letters.</p></li>
</ol>
</dd>
</dl>
</div></blockquote>
<p>Once it is known that the key is, say, <span class="math notranslate nohighlight">\(n\)</span> characters long,
frequency analysis can be applied to every <span class="math notranslate nohighlight">\(n\)</span>-th letter of
the ciphertext to determine the plaintext. This method is
called <em>Kasiski examination</em> (although it was first discovered
by Babbage). If they key is as long as the message and is
comprised of randomly selected characters – a one-time pad – the
message is theoretically unbreakable.</p>
<p>The cipher Vigenere actually discovered is an “auto-key” cipher
described as follows.</p>
<p>ALGORITHM:</p>
<blockquote>
<div><p>INPUT:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">key</span></code>: a string of letters (the secret key)</p>
<p><code class="docutils literal notranslate"><span class="pre">msg</span></code>: string of letters (the plaintext message)</p>
</div></blockquote>
<p>OUTPUT:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">ct</span></code>: string of upper-case letters (the ciphertext message)</p>
</div></blockquote>
<dl class="simple">
<dt>STEPS:</dt><dd><ol class="arabic simple" start="0">
<li><p>Number the letters of the alphabet from 0, …, N</p></li>
<li><p>Compute from the string <code class="docutils literal notranslate"><span class="pre">msg</span></code> a list <code class="docutils literal notranslate"><span class="pre">L2</span></code> of
corresponding integers. Let <code class="docutils literal notranslate"><span class="pre">n2</span> <span class="pre">=</span> <span class="pre">len(L2)</span></code>.</p></li>
<li><p>Let <code class="docutils literal notranslate"><span class="pre">n1</span></code> be the length of the key. Append to the
string <code class="docutils literal notranslate"><span class="pre">key</span></code> the first <code class="docutils literal notranslate"><span class="pre">n2</span> <span class="pre">-</span> <span class="pre">n1</span></code> characters of
the plaintext message. Compute from this string (also of
length <code class="docutils literal notranslate"><span class="pre">n2</span></code>) a list <code class="docutils literal notranslate"><span class="pre">L1</span></code> of integers corresponding
to the letter numbers in the first step.</p></li>
<li><p>Compute a new list <code class="docutils literal notranslate"><span class="pre">C</span></code> given by
<code class="docutils literal notranslate"><span class="pre">C[i]</span> <span class="pre">=</span> <span class="pre">L1[i]</span> <span class="pre">+</span> <span class="pre">L2[i]</span> <span class="pre">(mod</span> <span class="pre">N)</span></code>.</p></li>
<li><p>Compute from the new list a string <code class="docutils literal notranslate"><span class="pre">ct</span></code> of letters
corresponding to the new integers.</p></li>
</ol>
</dd>
</dl>
</div></blockquote>
<p>To decipher the auto-key ciphertext, the key is used to decipher
the first <code class="docutils literal notranslate"><span class="pre">n1</span></code> characters and then those characters become the
key to  decipher the next <code class="docutils literal notranslate"><span class="pre">n1</span></code> characters, etc…:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">(</span><span class="s1">&#39;go navy, beat army! yes you can&#39;</span><span class="p">);</span> <span class="n">m</span>
<span class="go">&#39;GONAVYBEATARMYYESYOUCAN&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">(</span><span class="s1">&#39;gold bug&#39;</span><span class="p">);</span> <span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">);</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">auto_key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="n">m</span><span class="p">[:</span><span class="n">n2</span> <span class="o">-</span> <span class="n">n1</span><span class="p">];</span> <span class="n">auto_key</span>
<span class="go">&#39;GOLDBUGGONAVYBEATARMYYE&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">encipher_vigenere</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">auto_key</span><span class="p">);</span> <span class="n">ct</span>
<span class="go">&#39;MCYDWSHKOGAMKZCELYFGAYR&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pt</span> <span class="o">=</span> <span class="p">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="n">ct</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">part</span><span class="p">,</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">ct</span><span class="p">[:</span><span class="n">n1</span><span class="p">],</span> <span class="n">ct</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="n">pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decipher_vigenere</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">key</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="o">==</span> <span class="n">m</span>
<span class="go">True</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r124"><span class="brackets">R124</span><span class="fn-backref">(<a href="#id9">1</a>,<a href="#id10">2</a>)</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Vigenere_cipher">https://en.wikipedia.org/wiki/Vigenere_cipher</a></p>
</dd>
<dt class="label" id="r125"><span class="brackets">R125</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p><a class="reference external" href="http://web.archive.org/web/20071116100808/">http://web.archive.org/web/20071116100808/</a></p>
</dd>
<dt class="label" id="r126"><span class="brackets"><a class="fn-backref" href="#id12">R126</a></span></dt>
<dd><p><a class="reference external" href="http://filebox.vt.edu/users/batman/kryptos.html">http://filebox.vt.edu/users/batman/kryptos.html</a>
(short URL: <a class="reference external" href="https://goo.gl/ijr22d">https://goo.gl/ijr22d</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_vigenere">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_vigenere</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L757-L778"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_vigenere" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode using the Vigenere cipher.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">decipher_vigenere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;encrypt&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="s2">&quot;QRGK kt HRZQE BPR&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_vigenere</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;MEETMEONMONDAY&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_hill">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_hill</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pad</span><span class="o">=</span><span class="default_value">'Q'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L784-L876"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_hill" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Hill cipher encryption of <code class="docutils literal notranslate"><span class="pre">msg</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong></p>
<blockquote>
<div><p>Plaintext message of <span class="math notranslate nohighlight">\(n\)</span> upper-case letters.</p>
</div></blockquote>
<p><strong>key</strong></p>
<blockquote>
<div><p>A <span class="math notranslate nohighlight">\(k \times k\)</span> invertible matrix <span class="math notranslate nohighlight">\(K\)</span>, all of whose entries are
in <span class="math notranslate nohighlight">\(Z_{26}\)</span> (or whatever number of symbols are being used).</p>
</div></blockquote>
<p><strong>pad</strong></p>
<blockquote>
<div><p>Character (default “Q”) to use to make length of text be a
multiple of <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ct</p>
<blockquote>
<div><p>Ciphertext of upper-case letters.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>ALGORITHM:</p>
<blockquote>
<div><dl class="simple">
<dt>STEPS:</dt><dd><ol class="arabic simple" start="0">
<li><p>Number the letters of the alphabet from 0, …, N</p></li>
<li><p>Compute from the string <code class="docutils literal notranslate"><span class="pre">msg</span></code> a list <code class="docutils literal notranslate"><span class="pre">L</span></code> of
corresponding integers. Let <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">len(L)</span></code>.</p></li>
<li><p>Break the list <code class="docutils literal notranslate"><span class="pre">L</span></code> up into <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">ceiling(n/k)</span></code>
sublists <code class="docutils literal notranslate"><span class="pre">L_1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">L_t</span></code> of size <code class="docutils literal notranslate"><span class="pre">k</span></code> (with
the last list “padded” to ensure its size is
<code class="docutils literal notranslate"><span class="pre">k</span></code>).</p></li>
<li><p>Compute new list <code class="docutils literal notranslate"><span class="pre">C_1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">C_t</span></code> given by
<code class="docutils literal notranslate"><span class="pre">C[i]</span> <span class="pre">=</span> <span class="pre">K*L_i</span></code> (arithmetic is done mod N), for each
<code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>Concatenate these into a list <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">C_1</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">C_t</span></code>.</p></li>
<li><p>Compute from <code class="docutils literal notranslate"><span class="pre">C</span></code> a string <code class="docutils literal notranslate"><span class="pre">ct</span></code> of corresponding
letters. This has length <code class="docutils literal notranslate"><span class="pre">k*t</span></code>.</p></li>
</ol>
</dd>
</dl>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.decipher_hill" title="sympy.crypto.crypto.decipher_hill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_hill</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r127"><span class="brackets"><a class="fn-backref" href="#id13">R127</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Hill_cipher">https://en.wikipedia.org/wiki/Hill_cipher</a></p>
</dd>
<dt class="label" id="r128"><span class="brackets"><a class="fn-backref" href="#id14">R128</a></span></dt>
<dd><p>Lester S. Hill, Cryptography in an Algebraic Alphabet,
The American Mathematical Monthly Vol.36, June-July 1929,
pp.306-312.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_hill">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_hill</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L879-L945"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_hill" title="Permalink to this definition">¶</a></dt>
<dd><p>Deciphering is the same as enciphering but using the inverse of the
key matrix.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_hill</span><span class="p">,</span> <span class="n">decipher_hill</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Matrix</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_hill</span><span class="p">(</span><span class="s2">&quot;meet me on monday&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;UEQDUEODOCTCWQ&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_hill</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;MEETMEONMONDAY&#39;</span>
</pre></div>
</div>
<p>When the length of the plaintext (stripped of invalid characters)
is not a multiple of the key dimension, extra characters will
appear at the end of the enciphered and deciphered text. In order to
decipher the text, those characters must be included in the text to
be deciphered. In the following, the key has a dimension of 4 but
the text is 2 short of being a multiple of 4 so two characters will
be added.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;ST&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_hill</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;HJEB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_hill</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;STQQ&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_hill</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>
<span class="go">&#39;ISPK&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_hill</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;STZZ&#39;</span>
</pre></div>
</div>
<p>If the last two characters of the ciphertext were ignored in
either case, the wrong plaintext would be recovered:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_hill</span><span class="p">(</span><span class="s2">&quot;HD&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;ORMV&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_hill</span><span class="p">(</span><span class="s2">&quot;IS&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;UIKY&#39;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.encipher_hill" title="sympy.crypto.crypto.encipher_hill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_hill</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_bifid">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_bifid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L951-L1010"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_bifid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the Bifid cipher encryption on plaintext <code class="docutils literal notranslate"><span class="pre">msg</span></code>, and
returns the ciphertext.</p>
<p>This is the version of the Bifid cipher that uses an <span class="math notranslate nohighlight">\(n \times n\)</span>
Polybius square.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong></p>
<blockquote>
<div><p>Plaintext string.</p>
</div></blockquote>
<p><strong>key</strong></p>
<blockquote>
<div><p>Short string for key.</p>
<p>Duplicate characters are ignored and then it is padded with the
characters in <code class="docutils literal notranslate"><span class="pre">symbols</span></code> that were not in the short key.</p>
</div></blockquote>
<p><strong>symbols</strong></p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(n \times n\)</span> characters defining the alphabet.</p>
<p>(default is string.printable)</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ciphertext</p>
<blockquote>
<div><p>Ciphertext using Bifid5 cipher without spaces.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.decipher_bifid" title="sympy.crypto.crypto.decipher_bifid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_bifid</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.encipher_bifid5" title="sympy.crypto.crypto.encipher_bifid5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_bifid5</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.encipher_bifid6" title="sympy.crypto.crypto.encipher_bifid6"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_bifid6</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r129"><span class="brackets"><a class="fn-backref" href="#id15">R129</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Bifid_cipher">https://en.wikipedia.org/wiki/Bifid_cipher</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_bifid">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_bifid</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">symbols</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1013-L1110"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_bifid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the Bifid cipher decryption on ciphertext <code class="docutils literal notranslate"><span class="pre">msg</span></code>, and
returns the plaintext.</p>
<p>This is the version of the Bifid cipher that uses the <span class="math notranslate nohighlight">\(n \times n\)</span>
Polybius square.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong></p>
<blockquote>
<div><p>Ciphertext string.</p>
</div></blockquote>
<p><strong>key</strong></p>
<blockquote>
<div><p>Short string for key.</p>
<p>Duplicate characters are ignored and then it is padded with the
characters in symbols that were not in the short key.</p>
</div></blockquote>
<p><strong>symbols</strong></p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(n \times n\)</span> characters defining the alphabet.</p>
<p>(default=string.printable, a <span class="math notranslate nohighlight">\(10 \times 10\)</span> matrix)</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>deciphered</p>
<blockquote>
<div><p>Deciphered text.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">encipher_bifid</span><span class="p">,</span> <span class="n">decipher_bifid</span><span class="p">,</span> <span class="n">AZ</span><span class="p">)</span>
</pre></div>
</div>
<p>Do an encryption using the bifid5 alphabet:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alp</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">(</span><span class="s2">&quot;meet me on monday!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">AZ</span><span class="p">(</span><span class="s2">&quot;gold bug&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_bifid</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
<span class="go">&#39;IEILHHFSTSFQYE&#39;</span>
</pre></div>
</div>
<p>When entering the text or ciphertext, spaces are ignored so it
can be formatted as desired. Re-entering the ciphertext from the
preceding, putting 4 characters per line and padding with an extra
J, does not cause problems for the deciphering:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_bifid</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="gp">... </span><span class="s1">IEILH</span>
<span class="gp">... </span><span class="s1">HFSTS</span>
<span class="gp">... </span><span class="s1">FQYEJ&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
<span class="go">&#39;MEETMEONMONDAY&#39;</span>
</pre></div>
</div>
<p>When no alphabet is given, all 100 printable characters will be
used:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_bifid</span><span class="p">(</span><span class="s1">&#39;hello world!&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;bmtwmg-bIo*w&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_bifid</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;hello world!&#39;</span>
</pre></div>
</div>
<p>If the key is changed, a different encryption is obtained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;gold bug&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_bifid</span><span class="p">(</span><span class="s1">&#39;hello world!&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_bug&#39;</span><span class="p">)</span>
<span class="go">&#39;hg2sfuei7t}w&#39;</span>
</pre></div>
</div>
<p>And if the key used to decrypt the message is not exact, the
original text will not be perfectly obtained:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_bifid</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="s1">&#39;gold pug&#39;</span><span class="p">)</span>
<span class="go">&#39;heldo~wor6d!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.bifid5_square">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">bifid5_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1302-L1326"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.bifid5_square" title="Permalink to this definition">¶</a></dt>
<dd><p>5x5 Polybius square.</p>
<p>Produce the Polybius square for the <span class="math notranslate nohighlight">\(5 \times 5\)</span> Bifid cipher.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">bifid5_square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bifid5_square</span><span class="p">(</span><span class="s2">&quot;gold bug&quot;</span><span class="p">)</span>
<span class="go">Matrix([</span>
<span class="go">[G, O, L, D, B],</span>
<span class="go">[U, A, C, E, F],</span>
<span class="go">[H, I, K, M, N],</span>
<span class="go">[P, Q, R, S, T],</span>
<span class="go">[V, W, X, Y, Z]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_bifid5">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_bifid5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1154-L1255"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_bifid5" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the Bifid cipher encryption on plaintext <code class="docutils literal notranslate"><span class="pre">msg</span></code>, and
returns the ciphertext.</p>
<p>This is the version of the Bifid cipher that uses the <span class="math notranslate nohighlight">\(5 \times 5\)</span>
Polybius square. The letter “J” is ignored so it must be replaced
with something else (traditionally an “I”) before encryption.</p>
<p>ALGORITHM: (5x5 case)</p>
<blockquote>
<div><dl>
<dt>STEPS:</dt><dd><ol class="arabic" start="0">
<li><p>Create the <span class="math notranslate nohighlight">\(5 \times 5\)</span> Polybius square <code class="docutils literal notranslate"><span class="pre">S</span></code> associated
to <code class="docutils literal notranslate"><span class="pre">key</span></code> as follows:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li><p>moving from left-to-right, top-to-bottom,
place the letters of the key into a <span class="math notranslate nohighlight">\(5 \times 5\)</span>
matrix,</p></li>
<li><p>if the key has less than 25 letters, add the
letters of the alphabet not in the key until the
<span class="math notranslate nohighlight">\(5 \times 5\)</span> square is filled.</p></li>
</ol>
</div></blockquote>
</li>
<li><p>Create a list <code class="docutils literal notranslate"><span class="pre">P</span></code> of pairs of numbers which are the
coordinates in the Polybius square of the letters in
<code class="docutils literal notranslate"><span class="pre">msg</span></code>.</p></li>
<li><p>Let <code class="docutils literal notranslate"><span class="pre">L1</span></code> be the list of all first coordinates of <code class="docutils literal notranslate"><span class="pre">P</span></code>
(length of <code class="docutils literal notranslate"><span class="pre">L1</span> <span class="pre">=</span> <span class="pre">n</span></code>), let <code class="docutils literal notranslate"><span class="pre">L2</span></code> be the list of all
second coordinates of <code class="docutils literal notranslate"><span class="pre">P</span></code> (so the length of <code class="docutils literal notranslate"><span class="pre">L2</span></code>
is also <code class="docutils literal notranslate"><span class="pre">n</span></code>).</p></li>
<li><p>Let <code class="docutils literal notranslate"><span class="pre">L</span></code> be the concatenation of <code class="docutils literal notranslate"><span class="pre">L1</span></code> and <code class="docutils literal notranslate"><span class="pre">L2</span></code>
(length <code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">=</span> <span class="pre">2*n</span></code>), except that consecutive numbers
are paired <code class="docutils literal notranslate"><span class="pre">(L[2*i],</span> <span class="pre">L[2*i</span> <span class="pre">+</span> <span class="pre">1])</span></code>. You can regard
<code class="docutils literal notranslate"><span class="pre">L</span></code> as a list of pairs of length <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
<li><p>Let <code class="docutils literal notranslate"><span class="pre">C</span></code> be the list of all letters which are of the
form <code class="docutils literal notranslate"><span class="pre">S[i,</span> <span class="pre">j]</span></code>, for all <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> in <code class="docutils literal notranslate"><span class="pre">L</span></code>. As a
string, this is the ciphertext of <code class="docutils literal notranslate"><span class="pre">msg</span></code>.</p></li>
</ol>
</dd>
</dl>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong> : str</p>
<blockquote>
<div><p>Plaintext string.</p>
<p>Converted to upper case and filtered of anything but all letters
except J.</p>
</div></blockquote>
<p><strong>key</strong></p>
<blockquote>
<div><p>Short string for key; non-alphabetic letters, J and duplicated
characters are ignored and then, if the length is less than 25
characters, it is padded with other letters of the alphabet
(in alphabetical order).</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ct</p>
<blockquote>
<div><p>Ciphertext (all caps, no spaces).</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">encipher_bifid5</span><span class="p">,</span> <span class="n">decipher_bifid5</span><span class="p">)</span>
</pre></div>
</div>
<p>“J” will be omitted unless it is replaced with something else:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">round_trip</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> \
<span class="gp">... </span>    <span class="n">decipher_bifid5</span><span class="p">(</span><span class="n">encipher_bifid5</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;JOSIE&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">round_trip</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;OSIE&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">round_trip</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;IOSIE&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span> <span class="o">=</span> <span class="s2">&quot;QIQ&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">round_trip</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">)</span>
<span class="go">&#39;JOSIE&#39;</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The Bifid cipher was invented around 1901 by Felix Delastelle.
It is a <em>fractional substitution</em> cipher, where letters are
replaced by pairs of symbols from a smaller alphabet. The
cipher uses a <span class="math notranslate nohighlight">\(5 \times 5\)</span> square filled with some ordering of the
alphabet, except that “J” is replaced with “I” (this is a so-called
Polybius square; there is a <span class="math notranslate nohighlight">\(6 \times 6\)</span> analog if you add back in
“J” and also append onto the usual 26 letter alphabet, the digits
0, 1, …, 9).
According to Helen Gaines’ book <em>Cryptanalysis</em>, this type of cipher
was used in the field by the German Army during World War I.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.decipher_bifid5" title="sympy.crypto.crypto.decipher_bifid5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_bifid5</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.encipher_bifid" title="sympy.crypto.crypto.encipher_bifid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_bifid</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_bifid5">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_bifid5</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1258-L1299"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_bifid5" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Bifid cipher decryption of <code class="docutils literal notranslate"><span class="pre">msg</span></code>.</p>
<p>This is the version of the Bifid cipher that uses the <span class="math notranslate nohighlight">\(5 \times 5\)</span>
Polybius square; the letter “J” is ignored unless a <code class="docutils literal notranslate"><span class="pre">key</span></code> of
length 25 is used.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong></p>
<blockquote>
<div><p>Ciphertext string.</p>
</div></blockquote>
<p><strong>key</strong></p>
<blockquote>
<div><p>Short string for key; duplicated characters are ignored and if
the length is less then 25 characters, it will be padded with
other letters from the alphabet omitting “J”.
Non-alphabetic characters are ignored.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>plaintext</p>
<blockquote>
<div><p>Plaintext from Bifid5 cipher (all caps, no spaces).</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_bifid5</span><span class="p">,</span> <span class="n">decipher_bifid5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;gold bug&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_bifid5</span><span class="p">(</span><span class="s1">&#39;meet me on friday&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;IEILEHFSTSFXEE&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_bifid5</span><span class="p">(</span><span class="s1">&#39;meet me on monday&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;IEILHHFSTSFQYE&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_bifid5</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;MEETMEONMONDAY&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_bifid6">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_bifid6</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1329-L1363"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_bifid6" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the Bifid cipher encryption on plaintext <code class="docutils literal notranslate"><span class="pre">msg</span></code>, and
returns the ciphertext.</p>
<p>This is the version of the Bifid cipher that uses the <span class="math notranslate nohighlight">\(6 \times 6\)</span>
Polybius square.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong></p>
<blockquote>
<div><p>Plaintext string (digits okay).</p>
</div></blockquote>
<p><strong>key</strong></p>
<blockquote>
<div><p>Short string for key (digits okay).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">key</span></code> is less than 36 characters long, the square will be
filled with letters A through Z and digits 0 through 9.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ciphertext</p>
<blockquote>
<div><p>Ciphertext from Bifid cipher (all caps, no spaces).</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.decipher_bifid6" title="sympy.crypto.crypto.decipher_bifid6"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_bifid6</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.encipher_bifid" title="sympy.crypto.crypto.encipher_bifid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_bifid</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_bifid6">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_bifid6</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1366-L1406"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_bifid6" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the Bifid cipher decryption on ciphertext <code class="docutils literal notranslate"><span class="pre">msg</span></code>, and
returns the plaintext.</p>
<p>This is the version of the Bifid cipher that uses the <span class="math notranslate nohighlight">\(6 \times 6\)</span>
Polybius square.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong></p>
<blockquote>
<div><p>Ciphertext string (digits okay); converted to upper case</p>
</div></blockquote>
<p><strong>key</strong></p>
<blockquote>
<div><p>Short string for key (digits okay).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">key</span></code> is less than 36 characters long, the square will be
filled with letters A through Z and digits 0 through 9.
All letters are converted to uppercase.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>plaintext</p>
<blockquote>
<div><p>Plaintext from Bifid cipher (all caps, no spaces).</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_bifid6</span><span class="p">,</span> <span class="n">decipher_bifid6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;gold bug&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_bifid6</span><span class="p">(</span><span class="s1">&#39;meet me on monday at 8am&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;KFKLJJHF5MMMKTFRGPL&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_bifid6</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">&#39;MEETMEONMONDAYAT8AM&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.bifid6_square">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">bifid6_square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1409-L1436"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.bifid6_square" title="Permalink to this definition">¶</a></dt>
<dd><p>6x6 Polybius square.</p>
<p>Produces the Polybius square for the <span class="math notranslate nohighlight">\(6 \times 6\)</span> Bifid cipher.
Assumes alphabet of symbols is “A”, …, “Z”, “0”, …, “9”.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">bifid6_square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;gold bug&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bifid6_square</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="go">Matrix([</span>
<span class="go">[G, O, L, D, B, U],</span>
<span class="go">[A, C, E, F, H, I],</span>
<span class="go">[J, K, M, N, P, Q],</span>
<span class="go">[R, S, T, V, W, X],</span>
<span class="go">[Y, Z, 0, 1, 2, 3],</span>
<span class="go">[4, 5, 6, 7, 8, 9]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.rsa_public_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">rsa_public_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1571-L1740"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.rsa_public_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RSA <em>public key</em> pair, <span class="math notranslate nohighlight">\((n, e)\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> : naturals</p>
<blockquote>
<div><p>If specified as <span class="math notranslate nohighlight">\(p, q, e\)</span> where <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> are distinct primes
and <span class="math notranslate nohighlight">\(e\)</span> is a desired public exponent of the RSA, <span class="math notranslate nohighlight">\(n = p q\)</span> and
<span class="math notranslate nohighlight">\(e\)</span> will be verified against the totient
<span class="math notranslate nohighlight">\(\phi(n)\)</span> (Euler totient) or <span class="math notranslate nohighlight">\(\lambda(n)\)</span> (Carmichael totient)
to be <span class="math notranslate nohighlight">\(\gcd(e, \phi(n)) = 1\)</span> or <span class="math notranslate nohighlight">\(\gcd(e, \lambda(n)) = 1\)</span>.</p>
<p>If specified as <span class="math notranslate nohighlight">\(p_1, p_2, ..., p_n, e\)</span> where
<span class="math notranslate nohighlight">\(p_1, p_2, ..., p_n\)</span> are specified as primes,
and <span class="math notranslate nohighlight">\(e\)</span> is specified as a desired public exponent of the RSA,
it will be able to form a multi-prime RSA, which is a more
generalized form of the popular 2-prime RSA.</p>
<p>It can also be possible to form a single-prime RSA by specifying
the argument as <span class="math notranslate nohighlight">\(p, e\)</span>, which can be considered a trivial case
of a multiprime RSA.</p>
<p>Furthermore, it can be possible to form a multi-power RSA by
specifying two or more pairs of the primes to be same.
However, unlike the two-distinct prime RSA or multi-prime
RSA, not every numbers in the complete residue system
(<span class="math notranslate nohighlight">\(\mathbb{Z}_n\)</span>) will be decryptable since the mapping
<span class="math notranslate nohighlight">\(\mathbb{Z}_{n} \rightarrow \mathbb{Z}_{n}\)</span>
will not be bijective.
(Only except for the trivial case when
<span class="math notranslate nohighlight">\(e = 1\)</span>
or more generally,</p>
<div class="math notranslate nohighlight">
\[e \in \left \{ 1 + k \lambda(n)
\mid k \in \mathbb{Z} \land k \geq 0 \right \}\]</div>
<p>when RSA reduces to the identity.)
However, the RSA can still be decryptable for the numbers in the
reduced residue system (<span class="math notranslate nohighlight">\(\mathbb{Z}_n^{\times}\)</span>), since the
mapping
<span class="math notranslate nohighlight">\(\mathbb{Z}_{n}^{\times} \rightarrow \mathbb{Z}_{n}^{\times}\)</span>
can still be bijective.</p>
<p>If you pass a non-prime integer to the arguments
<span class="math notranslate nohighlight">\(p_1, p_2, ..., p_n\)</span>, the particular number will be
prime-factored and it will become either a multi-prime RSA or a
multi-power RSA in its canonical form, depending on whether the
product equals its radical or not.
<span class="math notranslate nohighlight">\(p_1 p_2 ... p_n = \text{rad}(p_1 p_2 ... p_n)\)</span></p>
</div></blockquote>
<p><strong>totient</strong> : bool, optional</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">'Euler'</span></code>, it uses Euler’s totient <span class="math notranslate nohighlight">\(\phi(n)\)</span> which is
<a class="reference internal" href="ntheory.html#sympy.ntheory.factor_.totient" title="sympy.ntheory.factor_.totient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.ntheory.factor_.totient()</span></code></a> in SymPy.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">'Carmichael'</span></code>, it uses Carmichael’s totient <span class="math notranslate nohighlight">\(\lambda(n)\)</span>
which is <a class="reference internal" href="ntheory.html#sympy.ntheory.factor_.reduced_totient" title="sympy.ntheory.factor_.reduced_totient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.ntheory.factor_.reduced_totient()</span></code></a> in SymPy.</p>
<p>Unlike private key generation, this is a trivial keyword for
public key generation because
<span class="math notranslate nohighlight">\(\gcd(e, \phi(n)) = 1 \iff \gcd(e, \lambda(n)) = 1\)</span>.</p>
</div></blockquote>
<p><strong>index</strong> : nonnegative integer, optional</p>
<blockquote>
<div><p>Returns an arbitrary solution of a RSA public key at the index
specified at <span class="math notranslate nohighlight">\(0, 1, 2, ...\)</span>. This parameter needs to be
specified along with <code class="docutils literal notranslate"><span class="pre">totient='Carmichael'</span></code>.</p>
<p>Similarly to the non-uniquenss of a RSA private key as described
in the <code class="docutils literal notranslate"><span class="pre">index</span></code> parameter documentation in
<a class="reference internal" href="#sympy.crypto.crypto.rsa_private_key" title="sympy.crypto.crypto.rsa_private_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rsa_private_key()</span></code></a>, RSA public key is also not unique and
there is an infinite number of RSA public exponents which
can behave in the same manner.</p>
<p>From any given RSA public exponent <span class="math notranslate nohighlight">\(e\)</span>, there are can be an
another RSA public exponent <span class="math notranslate nohighlight">\(e + k \lambda(n)\)</span> where <span class="math notranslate nohighlight">\(k\)</span> is an
integer, <span class="math notranslate nohighlight">\(\lambda\)</span> is a Carmichael’s totient function.</p>
<p>However, considering only the positive cases, there can be
a principal solution of a RSA public exponent <span class="math notranslate nohighlight">\(e_0\)</span> in
<span class="math notranslate nohighlight">\(0 &lt; e_0 &lt; \lambda(n)\)</span>, and all the other solutions
can be canonicalzed in a form of <span class="math notranslate nohighlight">\(e_0 + k \lambda(n)\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">index</span></code> specifies the <span class="math notranslate nohighlight">\(k\)</span> notation to yield any possible value
an RSA public key can have.</p>
<p>An example of computing any arbitrary RSA public key:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">rsa_public_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_public_key</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="n">totient</span><span class="o">=</span><span class="s1">&#39;Carmichael&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(3233, 17)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_public_key</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="n">totient</span><span class="o">=</span><span class="s1">&#39;Carmichael&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(3233, 797)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_public_key</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="n">totient</span><span class="o">=</span><span class="s1">&#39;Carmichael&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(3233, 1577)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>multipower</strong> : bool, optional</p>
<blockquote>
<div><p>Any pair of non-distinct primes found in the RSA specification
will restrict the domain of the cryptosystem, as noted in the
explaination of the parameter <code class="docutils literal notranslate"><span class="pre">args</span></code>.</p>
<p>SymPy RSA key generator may give a warning before dispatching it
as a multi-power RSA, however, you can disable the warning if
you pass <code class="docutils literal notranslate"><span class="pre">True</span></code> to this keyword.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>(n, e)</strong> : int, int</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(n\)</span> is a product of any arbitrary number of primes given as
the argument.</p>
<p><span class="math notranslate nohighlight">\(e\)</span> is relatively prime (coprime) to the Euler totient
<span class="math notranslate nohighlight">\(\phi(n)\)</span>.</p>
</div></blockquote>
<p>False</p>
<blockquote>
<div><p>Returned if less than two arguments are given, or <span class="math notranslate nohighlight">\(e\)</span> is
not relatively prime to the modulus.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">rsa_public_key</span>
</pre></div>
</div>
<p>A public key of a two-prime RSA:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_public_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="go">(15, 7)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_public_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A public key of a multiprime RSA:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">primes</span> <span class="o">+</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_public_key</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="go">(30030, 7)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>Although the RSA can be generalized over any modulus <span class="math notranslate nohighlight">\(n\)</span>, using
two large primes had became the most popular specification because a
product of two large primes is usually the hardest to factor
relatively to the digits of <span class="math notranslate nohighlight">\(n\)</span> can have.</p>
<p>However, it may need further understanding of the time complexities
of each prime-factoring algorithms to verify the claim.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.rsa_private_key" title="sympy.crypto.crypto.rsa_private_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsa_private_key</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.encipher_rsa" title="sympy.crypto.crypto.encipher_rsa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_rsa</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.decipher_rsa" title="sympy.crypto.crypto.decipher_rsa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_rsa</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r130"><span class="brackets"><a class="fn-backref" href="#id16">R130</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29</a></p>
</dd>
<dt class="label" id="r131"><span class="brackets"><a class="fn-backref" href="#id17">R131</a></span></dt>
<dd><p><a class="reference external" href="http://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf">http://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf</a></p>
</dd>
<dt class="label" id="r132"><span class="brackets"><a class="fn-backref" href="#id18">R132</a></span></dt>
<dd><p><a class="reference external" href="https://link.springer.com/content/pdf/10.1007%2FBFb0055738.pdf">https://link.springer.com/content/pdf/10.1007%2FBFb0055738.pdf</a></p>
</dd>
<dt class="label" id="r133"><span class="brackets"><a class="fn-backref" href="#id19">R133</a></span></dt>
<dd><p><a class="reference external" href="http://www.itiis.org/digital-library/manuscript/1381">http://www.itiis.org/digital-library/manuscript/1381</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.rsa_private_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">rsa_private_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1743-L1862"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.rsa_private_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the RSA <em>private key</em> pair, <span class="math notranslate nohighlight">\((n, d)\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>args</strong> : naturals</p>
<blockquote>
<div><p>The keyword is identical to the <code class="docutils literal notranslate"><span class="pre">args</span></code> in
<a class="reference internal" href="#sympy.crypto.crypto.rsa_public_key" title="sympy.crypto.crypto.rsa_public_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rsa_public_key()</span></code></a>.</p>
</div></blockquote>
<p><strong>totient</strong> : bool, optional</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">'Euler'</span></code>, it uses Euler’s totient convention <span class="math notranslate nohighlight">\(\phi(n)\)</span>
which is <a class="reference internal" href="ntheory.html#sympy.ntheory.factor_.totient" title="sympy.ntheory.factor_.totient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.ntheory.factor_.totient()</span></code></a> in SymPy.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">'Carmichael'</span></code>, it uses Carmichael’s totient convention
<span class="math notranslate nohighlight">\(\lambda(n)\)</span> which is
<a class="reference internal" href="ntheory.html#sympy.ntheory.factor_.reduced_totient" title="sympy.ntheory.factor_.reduced_totient"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.ntheory.factor_.reduced_totient()</span></code></a> in SymPy.</p>
<p>There can be some output differences for private key generation
as examples below.</p>
<p>Example using Euler’s totient:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">rsa_private_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_private_key</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="n">totient</span><span class="o">=</span><span class="s1">&#39;Euler&#39;</span><span class="p">)</span>
<span class="go">(3233, 2753)</span>
</pre></div>
</div>
<p>Example using Carmichael’s totient:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">rsa_private_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_private_key</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="n">totient</span><span class="o">=</span><span class="s1">&#39;Carmichael&#39;</span><span class="p">)</span>
<span class="go">(3233, 413)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>index</strong> : nonnegative integer, optional</p>
<blockquote>
<div><p>Returns an arbitrary solution of a RSA private key at the index
specified at <span class="math notranslate nohighlight">\(0, 1, 2, ...\)</span>. This parameter needs to be
specified along with <code class="docutils literal notranslate"><span class="pre">totient='Carmichael'</span></code>.</p>
<p>RSA private exponent is a non-unique solution of
<span class="math notranslate nohighlight">\(e d \mod \lambda(n) = 1\)</span> and it is possible in any form of
<span class="math notranslate nohighlight">\(d + k \lambda(n)\)</span>, where <span class="math notranslate nohighlight">\(d\)</span> is an another
already-computed private exponent, and <span class="math notranslate nohighlight">\(\lambda\)</span> is a
Carmichael’s totient function, and <span class="math notranslate nohighlight">\(k\)</span> is any integer.</p>
<p>However, considering only the positive cases, there can be
a principal solution of a RSA private exponent <span class="math notranslate nohighlight">\(d_0\)</span> in
<span class="math notranslate nohighlight">\(0 &lt; d_0 &lt; \lambda(n)\)</span>, and all the other solutions
can be canonicalzed in a form of <span class="math notranslate nohighlight">\(d_0 + k \lambda(n)\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">index</span></code> specifies the <span class="math notranslate nohighlight">\(k\)</span> notation to yield any possible value
an RSA private key can have.</p>
<p>An example of computing any arbitrary RSA private key:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">rsa_private_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_private_key</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="n">totient</span><span class="o">=</span><span class="s1">&#39;Carmichael&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(3233, 413)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_private_key</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="n">totient</span><span class="o">=</span><span class="s1">&#39;Carmichael&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(3233, 1193)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_private_key</span><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="n">totient</span><span class="o">=</span><span class="s1">&#39;Carmichael&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(3233, 1973)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>multipower</strong> : bool, optional</p>
<blockquote>
<div><p>The keyword is identical to the <code class="docutils literal notranslate"><span class="pre">multipower</span></code> in
<a class="reference internal" href="#sympy.crypto.crypto.rsa_public_key" title="sympy.crypto.crypto.rsa_public_key"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rsa_public_key()</span></code></a>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>(n, d)</strong> : int, int</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(n\)</span> is a product of any arbitrary number of primes given as
the argument.</p>
<p><span class="math notranslate nohighlight">\(d\)</span> is the inverse of <span class="math notranslate nohighlight">\(e\)</span> (mod <span class="math notranslate nohighlight">\(\phi(n)\)</span>) where <span class="math notranslate nohighlight">\(e\)</span> is the
exponent given, and <span class="math notranslate nohighlight">\(\phi\)</span> is a Euler totient.</p>
</div></blockquote>
<p>False</p>
<blockquote>
<div><p>Returned if less than two arguments are given, or <span class="math notranslate nohighlight">\(e\)</span> is
not relatively prime to the totient of the modulus.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">rsa_private_key</span>
</pre></div>
</div>
<p>A private key of a two-prime RSA:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_private_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="go">(15, 7)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_private_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>A private key of a multiprime RSA:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="n">primes</span> <span class="o">+</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rsa_private_key</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="go">(30030, 823)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.crypto.crypto.rsa_public_key" title="sympy.crypto.crypto.rsa_public_key"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsa_public_key</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.encipher_rsa" title="sympy.crypto.crypto.encipher_rsa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">encipher_rsa</span></code></a>, <a class="reference internal" href="#sympy.crypto.crypto.decipher_rsa" title="sympy.crypto.crypto.decipher_rsa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decipher_rsa</span></code></a></p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r134"><span class="brackets"><a class="fn-backref" href="#id20">R134</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29</a></p>
</dd>
<dt class="label" id="r135"><span class="brackets"><a class="fn-backref" href="#id21">R135</a></span></dt>
<dd><p><a class="reference external" href="http://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf">http://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf</a></p>
</dd>
<dt class="label" id="r136"><span class="brackets"><a class="fn-backref" href="#id22">R136</a></span></dt>
<dd><p><a class="reference external" href="https://link.springer.com/content/pdf/10.1007%2FBFb0055738.pdf">https://link.springer.com/content/pdf/10.1007%2FBFb0055738.pdf</a></p>
</dd>
<dt class="label" id="r137"><span class="brackets"><a class="fn-backref" href="#id23">R137</a></span></dt>
<dd><p><a class="reference external" href="http://www.itiis.org/digital-library/manuscript/1381">http://www.itiis.org/digital-library/manuscript/1381</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_rsa">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_rsa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">factors</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1885-L1951"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_rsa" title="Permalink to this definition">¶</a></dt>
<dd><p>Encrypt the plaintext with RSA.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> : integer</p>
<blockquote>
<div><p>The plaintext to be encrypted for.</p>
</div></blockquote>
<p><strong>key</strong> : (n, e) where n, e are integers</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(n\)</span> is the modulus of the key and <span class="math notranslate nohighlight">\(e\)</span> is the exponent of the
key. The encryption is computed by <span class="math notranslate nohighlight">\(i^e \bmod n\)</span>.</p>
<p>The key can either be a public key or a private key, however,
the message encrypted by a public key can only be decrypted by
a private key, and vice versa, as RSA is an asymmetric
cryptography system.</p>
</div></blockquote>
<p><strong>factors</strong> : list of coprime integers</p>
<blockquote>
<div><p>This is identical to the keyword <code class="docutils literal notranslate"><span class="pre">factors</span></code> in
<a class="reference internal" href="#sympy.crypto.crypto.decipher_rsa" title="sympy.crypto.crypto.decipher_rsa"><code class="xref py py-meth docutils literal notranslate"><span class="pre">decipher_rsa()</span></code></a>.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Some specifications may make the RSA not cryptographically
meaningful.</p>
<p>For example, <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span> will remain always same after taking any
number of exponentiation, thus, should be avoided.</p>
<p>Furthermore, if <span class="math notranslate nohighlight">\(i^e &lt; n\)</span>, <span class="math notranslate nohighlight">\(i\)</span> may easily be figured out by taking
<span class="math notranslate nohighlight">\(e\)</span> th root.</p>
<p>And also, specifying the exponent as <span class="math notranslate nohighlight">\(1\)</span> or in more generalized form
as <span class="math notranslate nohighlight">\(1 + k \lambda(n)\)</span> where <span class="math notranslate nohighlight">\(k\)</span> is an nonnegative integer,
<span class="math notranslate nohighlight">\(\lambda\)</span> is a carmichael totient, the RSA becomes an identity
mapping.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_rsa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">rsa_public_key</span><span class="p">,</span> <span class="n">rsa_private_key</span>
</pre></div>
</div>
<p>Public Key Encryption:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">puk</span> <span class="o">=</span> <span class="n">rsa_public_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">puk</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Private Key Encryption:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prk</span> <span class="o">=</span> <span class="n">rsa_private_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">prk</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Encryption using chinese remainder theorem:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">prk</span><span class="p">,</span> <span class="n">factors</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">])</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_rsa">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_rsa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">factors</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L1954-L2045"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_rsa" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrypt the ciphertext with RSA.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> : integer</p>
<blockquote>
<div><p>The ciphertext to be decrypted for.</p>
</div></blockquote>
<p><strong>key</strong> : (n, d) where n, d are integers</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(n\)</span> is the modulus of the key and <span class="math notranslate nohighlight">\(d\)</span> is the exponent of the
key. The decryption is computed by <span class="math notranslate nohighlight">\(i^d \bmod n\)</span>.</p>
<p>The key can either be a public key or a private key, however,
the message encrypted by a public key can only be decrypted by
a private key, and vice versa, as RSA is an asymmetric
cryptography system.</p>
</div></blockquote>
<p><strong>factors</strong> : list of coprime integers</p>
<blockquote>
<div><p>As the modulus <span class="math notranslate nohighlight">\(n\)</span> created from RSA key generation is composed
of arbitrary prime factors
<span class="math notranslate nohighlight">\(n = {p_1}^{k_1}{p_2}^{k_2}...{p_n}^{k_n}\)</span> where
<span class="math notranslate nohighlight">\(p_1, p_2, ..., p_n\)</span> are distinct primes and
<span class="math notranslate nohighlight">\(k_1, k_2, ..., k_n\)</span> are positive integers, chinese remainder
theorem can be used to compute <span class="math notranslate nohighlight">\(i^d \bmod n\)</span> from the
fragmented modulo operations like</p>
<div class="math notranslate nohighlight">
\[i^d \bmod {p_1}^{k_1}, i^d \bmod {p_2}^{k_2}, ... ,
i^d \bmod {p_n}^{k_n}\]</div>
<p>or like</p>
<div class="math notranslate nohighlight">
\[i^d \bmod {p_1}^{k_1}{p_2}^{k_2},
i^d \bmod {p_3}^{k_3}, ... ,
i^d \bmod {p_n}^{k_n}\]</div>
<p>as long as every moduli does not share any common divisor each
other.</p>
<p>The raw primes used in generating the RSA key pair can be a good
option.</p>
<p>Note that the speed advantage of using this is only viable for
very large cases (Like 2048-bit RSA keys) since the
overhead of using pure python implementation of
<a class="reference internal" href="ntheory.html#sympy.ntheory.modular.crt" title="sympy.ntheory.modular.crt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sympy.ntheory.modular.crt()</span></code></a> may overcompensate the
theoritical speed advantage.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See the <code class="docutils literal notranslate"><span class="pre">Notes</span></code> section in the documentation of
<a class="reference internal" href="#sympy.crypto.crypto.encipher_rsa" title="sympy.crypto.crypto.encipher_rsa"><code class="xref py py-meth docutils literal notranslate"><span class="pre">encipher_rsa()</span></code></a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">decipher_rsa</span><span class="p">,</span> <span class="n">encipher_rsa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">rsa_public_key</span><span class="p">,</span> <span class="n">rsa_private_key</span>
</pre></div>
</div>
<p>Public Key Encryption and Decryption:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prk</span> <span class="o">=</span> <span class="n">rsa_private_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">puk</span> <span class="o">=</span> <span class="n">rsa_public_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_msg</span> <span class="o">=</span> <span class="n">encipher_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">prk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_msg</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_rsa</span><span class="p">(</span><span class="n">new_msg</span><span class="p">,</span> <span class="n">puk</span><span class="p">)</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Private Key Encryption and Decryption:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prk</span> <span class="o">=</span> <span class="n">rsa_private_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">puk</span> <span class="o">=</span> <span class="n">rsa_public_key</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="mi">12</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_msg</span> <span class="o">=</span> <span class="n">encipher_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">puk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_msg</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_rsa</span><span class="p">(</span><span class="n">new_msg</span><span class="p">,</span> <span class="n">prk</span><span class="p">)</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Decryption using chinese remainder theorem:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_rsa</span><span class="p">(</span><span class="n">new_msg</span><span class="p">,</span> <span class="n">prk</span><span class="p">,</span> <span class="n">factors</span><span class="o">=</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">])</span>
<span class="go">12</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.kid_rsa_public_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">kid_rsa_public_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2051-L2084"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.kid_rsa_public_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Kid RSA is a version of RSA useful to teach grade school children
since it does not involve exponentiation.</p>
<p>Alice wants to talk to Bob. Bob generates keys as follows.
Key generation:</p>
<ul class="simple">
<li><p>Select positive integers <span class="math notranslate nohighlight">\(a, b, A, B\)</span> at random.</p></li>
<li><p>Compute <span class="math notranslate nohighlight">\(M = a b - 1\)</span>, <span class="math notranslate nohighlight">\(e = A M + a\)</span>, <span class="math notranslate nohighlight">\(d = B M + b\)</span>,
<span class="math notranslate nohighlight">\(n = (e d - 1)//M\)</span>.</p></li>
<li><p>The <em>public key</em> is <span class="math notranslate nohighlight">\((n, e)\)</span>. Bob sends these to Alice.</p></li>
<li><p>The <em>private key</em> is <span class="math notranslate nohighlight">\((n, d)\)</span>, which Bob keeps secret.</p></li>
</ul>
<p>Encryption: If <span class="math notranslate nohighlight">\(p\)</span> is the plaintext message then the
ciphertext is <span class="math notranslate nohighlight">\(c = p e \pmod n\)</span>.</p>
<p>Decryption: If <span class="math notranslate nohighlight">\(c\)</span> is the ciphertext message then the
plaintext is <span class="math notranslate nohighlight">\(p = c d \pmod n\)</span>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">kid_rsa_public_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kid_rsa_public_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="go">(369, 58)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.kid_rsa_private_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">kid_rsa_private_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">A</span></em>, <em class="sig-param"><span class="n">B</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2087-L2106"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.kid_rsa_private_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <span class="math notranslate nohighlight">\(M = a b - 1\)</span>, <span class="math notranslate nohighlight">\(e = A M + a\)</span>, <span class="math notranslate nohighlight">\(d = B M + b\)</span>,
<span class="math notranslate nohighlight">\(n = (e d - 1) / M\)</span>. The <em>private key</em> is <span class="math notranslate nohighlight">\(d\)</span>, which Bob
keeps secret.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">kid_rsa_private_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kid_rsa_private_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="go">(369, 70)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_kid_rsa">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_kid_rsa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2109-L2126"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_kid_rsa" title="Permalink to this definition">¶</a></dt>
<dd><p>Here <code class="docutils literal notranslate"><span class="pre">msg</span></code> is the plaintext and <code class="docutils literal notranslate"><span class="pre">key</span></code> is the public key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">encipher_kid_rsa</span><span class="p">,</span> <span class="n">kid_rsa_public_key</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="mi">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">kid_rsa_public_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_kid_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
<span class="go">161</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_kid_rsa">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_kid_rsa</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2129-L2150"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_kid_rsa" title="Permalink to this definition">¶</a></dt>
<dd><p>Here <code class="docutils literal notranslate"><span class="pre">msg</span></code> is the plaintext and <code class="docutils literal notranslate"><span class="pre">key</span></code> is the private key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">kid_rsa_public_key</span><span class="p">,</span> <span class="n">kid_rsa_private_key</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">decipher_kid_rsa</span><span class="p">,</span> <span class="n">encipher_kid_rsa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">kid_rsa_private_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="mi">200</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span> <span class="o">=</span> <span class="n">kid_rsa_public_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pri</span> <span class="o">=</span> <span class="n">kid_rsa_private_key</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">encipher_kid_rsa</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">pub</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_kid_rsa</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">pri</span><span class="p">)</span>
<span class="go">200</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encode_morse">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encode_morse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">'|'</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2185-L2229"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encode_morse" title="Permalink to this definition">¶</a></dt>
<dd><p>Encodes a plaintext into popular Morse Code with letters
separated by <span class="math notranslate nohighlight">\(sep\)</span> and words by a double <span class="math notranslate nohighlight">\(sep\)</span>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encode_morse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;ATTACK RIGHT FLANK&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encode_morse</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="go">&#39;.-|-|-|.-|-.-.|-.-||.-.|..|--.|....|-||..-.|.-..|.-|-.|-.-&#39;</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r138"><span class="brackets"><a class="fn-backref" href="#id24">R138</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Morse_code">https://en.wikipedia.org/wiki/Morse_code</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decode_morse">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decode_morse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">'|'</span></em>, <em class="sig-param"><span class="n">mapping</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2232-L2263"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decode_morse" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a Morse Code with letters separated by <span class="math notranslate nohighlight">\(sep\)</span>
(default is ‘|’) and words by <span class="math notranslate nohighlight">\(word_sep\)</span> (default is ‘||)
into plaintext.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">decode_morse</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="s1">&#39;--|---|...-|.||.|.-|...|-&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decode_morse</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span>
<span class="go">&#39;MOVE EAST&#39;</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r139"><span class="brackets"><a class="fn-backref" href="#id25">R139</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Morse_code">https://en.wikipedia.org/wiki/Morse_code</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.lfsr_sequence">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">lfsr_sequence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">fill</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2269-L2369"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.lfsr_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates an LFSR sequence.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> : list</p>
<blockquote>
<div><p>A list of finite field elements, <span class="math notranslate nohighlight">\([c_0, c_1, \ldots, c_k].\)</span></p>
</div></blockquote>
<p><strong>fill</strong> : list</p>
<blockquote>
<div><p>The list of the initial terms of the LFSR sequence,
<span class="math notranslate nohighlight">\([x_0, x_1, \ldots, x_k].\)</span></p>
</div></blockquote>
<p><strong>n</strong></p>
<blockquote>
<div><p>Number of terms of the sequence that the function returns.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>L</p>
<blockquote>
<div><p>The LFSR sequence defined by
<span class="math notranslate nohighlight">\(x_{n+1} = c_k x_n + \ldots + c_0 x_{n-k}\)</span>, for
<span class="math notranslate nohighlight">\(n \leq k\)</span>.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>S. Golomb <a class="reference internal" href="#g139" id="id26"><span>[G139]</span></a> gives a list of three statistical properties a
sequence of numbers <span class="math notranslate nohighlight">\(a = \{a_n\}_{n=1}^\infty\)</span>,
<span class="math notranslate nohighlight">\(a_n \in \{0,1\}\)</span>, should display to be considered
“random”. Define the autocorrelation of <span class="math notranslate nohighlight">\(a\)</span> to be</p>
<div class="math notranslate nohighlight">
\[C(k) = C(k,a) = \lim_{N\rightarrow \infty} {1\over N}\sum_{n=1}^N (-1)^{a_n + a_{n+k}}.\]</div>
<p>In the case where <span class="math notranslate nohighlight">\(a\)</span> is periodic with period
<span class="math notranslate nohighlight">\(P\)</span> then this reduces to</p>
<div class="math notranslate nohighlight">
\[C(k) = {1\over P}\sum_{n=1}^P (-1)^{a_n + a_{n+k}}.\]</div>
<p>Assume <span class="math notranslate nohighlight">\(a\)</span> is periodic with period <span class="math notranslate nohighlight">\(P\)</span>.</p>
<ul>
<li><p>balance:</p>
<div class="math notranslate nohighlight">
\[\left|\sum_{n=1}^P(-1)^{a_n}\right| \leq 1.\]</div>
</li>
<li><p>low autocorrelation:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}C(k) = \left\{ \begin{array}{cc} 1,&amp; k = 0,\\ \epsilon, &amp; k \ne 0. \end{array} \right.\end{split}\]</div>
</div></blockquote>
<p>(For sequences satisfying these first two properties, it is known
that <span class="math notranslate nohighlight">\(\epsilon = -1/P\)</span> must hold.)</p>
</li>
<li><p>proportional runs property: In each period, half the runs have
length <span class="math notranslate nohighlight">\(1\)</span>, one-fourth have length <span class="math notranslate nohighlight">\(2\)</span>, etc.
Moreover, there are as many runs of <span class="math notranslate nohighlight">\(1\)</span>’s as there are of
<span class="math notranslate nohighlight">\(0\)</span>’s.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">lfsr_sequence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.polys.domains</span> <span class="kn">import</span> <span class="n">FF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">FF</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lfsr_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">[1 mod 2, 1 mod 2, 0 mod 2, 1 mod 2, 0 mod 2,</span>
<span class="go">1 mod 2, 1 mod 2, 0 mod 2, 0 mod 2, 1 mod 2]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="g139"><span class="brackets">G139</span><span class="fn-backref">(<a href="#id26">1</a>,<a href="#id27">2</a>)</span></dt>
<dd><p>Solomon Golomb, Shift register sequences, Aegean Park Press,
Laguna Hills, Ca, 1967</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.lfsr_autocorrelation">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">lfsr_autocorrelation</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">L</span></em>, <em class="sig-param"><span class="n">P</span></em>, <em class="sig-param"><span class="n">k</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2372-L2419"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.lfsr_autocorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the LFSR autocorrelation function.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>L</strong></p>
<blockquote>
<div><p>A periodic sequence of elements of <span class="math notranslate nohighlight">\(GF(2)\)</span>.
L must have length larger than P.</p>
</div></blockquote>
<p><strong>P</strong></p>
<blockquote>
<div><p>The period of L.</p>
</div></blockquote>
<p><strong>k</strong> : int</p>
<blockquote>
<div><p>An integer <span class="math notranslate nohighlight">\(k\)</span> (<span class="math notranslate nohighlight">\(0 &lt; k &lt; P\)</span>).</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>autocorrelation</p>
<blockquote>
<div><p>The k-th value of the autocorrelation of the LFSR L.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">lfsr_sequence</span><span class="p">,</span> <span class="n">lfsr_autocorrelation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.polys.domains</span> <span class="kn">import</span> <span class="n">FF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">FF</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">lfsr_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lfsr_autocorrelation</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">-1/15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lfsr_autocorrelation</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.lfsr_connection_polynomial">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">lfsr_connection_polynomial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2422-L2516"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.lfsr_connection_polynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the LFSR connection polynomial.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>s</strong></p>
<blockquote>
<div><p>A sequence of elements of even length, with entries in a finite
field.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>C(x)</p>
<blockquote>
<div><p>The connection polynomial of a minimal LFSR yielding s.</p>
<p>This implements the algorithm in section 3 of J. L. Massey’s
article <a class="reference internal" href="#m140" id="id28"><span>[M140]</span></a>.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">lfsr_sequence</span><span class="p">,</span> <span class="n">lfsr_connection_polynomial</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.polys.domains</span> <span class="kn">import</span> <span class="n">FF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">FF</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">lfsr_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lfsr_connection_polynomial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">x**4 + x + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">lfsr_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lfsr_connection_polynomial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">x**3 + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">lfsr_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lfsr_connection_polynomial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">x**3 + x**2 + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fill</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">F</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">lfsr_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lfsr_connection_polynomial</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">x**3 + x + 1</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="m140"><span class="brackets">M140</span><span class="fn-backref">(<a href="#id28">1</a>,<a href="#id29">2</a>)</span></dt>
<dd><p>James L. Massey, “Shift-Register Synthesis and BCH Decoding.”
IEEE Trans. on Information Theory, vol. 15(1), pp. 122-127,
Jan 1969.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.elgamal_public_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">elgamal_public_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2574-L2601"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.elgamal_public_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return three number tuple as public key.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> : (p, r, e)</p>
<blockquote>
<div><p>Tuple generated by <code class="docutils literal notranslate"><span class="pre">elgamal_private_key</span></code>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tuple</strong> : (p, r, e)</p>
<blockquote>
<div><p><span class="math notranslate nohighlight">\(e = r**d \bmod p\)</span></p>
<p><span class="math notranslate nohighlight">\(d\)</span> is a random number in private key.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">elgamal_public_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">elgamal_public_key</span><span class="p">((</span><span class="mi">1031</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">636</span><span class="p">))</span>
<span class="go">(1031, 14, 212)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.elgamal_private_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">elgamal_private_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">digit</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2522-L2571"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.elgamal_private_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return three number tuple as private key.</p>
<p>Elgamal encryption is based on the mathmatical problem
called the Discrete Logarithm Problem (DLP). For example,</p>
<p><span class="math notranslate nohighlight">\(a^{b} \equiv c \pmod p\)</span></p>
<p>In general, if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are known, <code class="docutils literal notranslate"><span class="pre">ct</span></code> is easily
calculated. If <code class="docutils literal notranslate"><span class="pre">b</span></code> is unknown, it is hard to use
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">ct</span></code> to get <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>digit</strong> : int</p>
<blockquote>
<div><p>Minimum number of binary digits for key.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tuple</strong> : (p, r, d)</p>
<blockquote>
<div><p>p = prime number.</p>
<p>r = primitive root.</p>
<p>d = random number.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For testing purposes, the <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter may be set to control
the output of this routine. See sympy.testing.randtest._randrange.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">elgamal_private_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">is_primitive_root</span><span class="p">,</span> <span class="n">isprime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">elgamal_private_key</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isprime</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_primitive_root</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_elgamal">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_elgamal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2604-L2658"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_elgamal" title="Permalink to this definition">¶</a></dt>
<dd><p>Encrypt message with public key</p>
<p><code class="docutils literal notranslate"><span class="pre">i</span></code> is a plaintext message expressed as an integer.
<code class="docutils literal notranslate"><span class="pre">key</span></code> is public key (p, r, e). In order to encrypt
a message, a random number <code class="docutils literal notranslate"><span class="pre">a</span></code> in <code class="docutils literal notranslate"><span class="pre">range(2,</span> <span class="pre">p)</span></code>
is generated and the encryped message is returned as
<span class="math notranslate nohighlight">\(c_{1}\)</span> and <span class="math notranslate nohighlight">\(c_{2}\)</span> where:</p>
<p><span class="math notranslate nohighlight">\(c_{1} \equiv r^{a} \pmod p\)</span></p>
<p><span class="math notranslate nohighlight">\(c_{2} \equiv m e^{a} \pmod p\)</span></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>msg</strong></p>
<blockquote>
<div><p>int of encoded message.</p>
</div></blockquote>
<p><strong>key</strong></p>
<blockquote>
<div><p>Public key.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tuple</strong> : (c1, c2)</p>
<blockquote>
<div><p>Encipher into two number.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For testing purposes, the <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter may be set to control
the output of this routine. See sympy.testing.randtest._randrange.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_elgamal</span><span class="p">,</span> <span class="n">elgamal_private_key</span><span class="p">,</span> <span class="n">elgamal_public_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pri</span> <span class="o">=</span> <span class="n">elgamal_private_key</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span> <span class="n">pri</span>
<span class="go">(37, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span> <span class="o">=</span> <span class="n">elgamal_public_key</span><span class="p">(</span><span class="n">pri</span><span class="p">);</span> <span class="n">pub</span>
<span class="go">(37, 2, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="mi">36</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_elgamal</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">pub</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="go">(8, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_elgamal">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_elgamal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">msg</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2661-L2697"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_elgamal" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrypt message with private key</p>
<p><span class="math notranslate nohighlight">\(msg = (c_{1}, c_{2})\)</span></p>
<p><span class="math notranslate nohighlight">\(key = (p, r, d)\)</span></p>
<p>According to extended Eucliden theorem,
<span class="math notranslate nohighlight">\(u c_{1}^{d} + p n = 1\)</span></p>
<p><span class="math notranslate nohighlight">\(u \equiv 1/{{c_{1}}^d} \pmod p\)</span></p>
<p><span class="math notranslate nohighlight">\(u c_{2} \equiv \frac{1}{c_{1}^d} c_{2} \equiv \frac{1}{r^{ad}} c_{2} \pmod p\)</span></p>
<p><span class="math notranslate nohighlight">\(\frac{1}{r^{ad}} m e^a \equiv \frac{1}{r^{ad}} m {r^{d a}} \equiv m \pmod p\)</span></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">decipher_elgamal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_elgamal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">elgamal_private_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">elgamal_public_key</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pri</span> <span class="o">=</span> <span class="n">elgamal_private_key</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pub</span> <span class="o">=</span> <span class="n">elgamal_public_key</span><span class="p">(</span><span class="n">pri</span><span class="p">);</span> <span class="n">pub</span>
<span class="go">(37, 2, 8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msg</span> <span class="o">=</span> <span class="mi">17</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_elgamal</span><span class="p">(</span><span class="n">encipher_elgamal</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">pub</span><span class="p">),</span> <span class="n">pri</span><span class="p">)</span> <span class="o">==</span> <span class="n">msg</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.dh_public_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">dh_public_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2768-L2800"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.dh_public_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return three number tuple as public key.</p>
<p>This is the tuple that Alice sends to Bob.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> : (p, g, a)</p>
<blockquote>
<div><p>A tuple generated by <code class="docutils literal notranslate"><span class="pre">dh_private_key</span></code>.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tuple</strong> : int, int, int</p>
<blockquote>
<div><p>A tuple of <span class="math notranslate nohighlight">\((p, g, g^a \mod p)\)</span> with <span class="math notranslate nohighlight">\(p\)</span>, <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(a\)</span> given as
parameters.s</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">dh_private_key</span><span class="p">,</span> <span class="n">dh_public_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">dh_private_key</span><span class="p">();</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_p</span><span class="p">,</span> <span class="n">_g</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">dh_public_key</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">==</span> <span class="n">_p</span> <span class="ow">and</span> <span class="n">g</span> <span class="o">==</span> <span class="n">_g</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">pow</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.dh_private_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">dh_private_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">digit</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2702-L2765"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.dh_private_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return three integer tuple as private key.</p>
<p>Diffie-Hellman key exchange is based on the mathematical problem
called the Discrete Logarithm Problem (see ElGamal).</p>
<p>Diffie-Hellman key exchange is divided into the following steps:</p>
<ul class="simple">
<li><p>Alice and Bob agree on a base that consist of a prime <code class="docutils literal notranslate"><span class="pre">p</span></code>
and a primitive root of <code class="docutils literal notranslate"><span class="pre">p</span></code> called <code class="docutils literal notranslate"><span class="pre">g</span></code></p></li>
<li><p>Alice choses a number <code class="docutils literal notranslate"><span class="pre">a</span></code> and Bob choses a number <code class="docutils literal notranslate"><span class="pre">b</span></code> where
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are random numbers in range <span class="math notranslate nohighlight">\([2, p)\)</span>. These are
their private keys.</p></li>
<li><p>Alice then publicly sends Bob <span class="math notranslate nohighlight">\(g^{a} \pmod p\)</span> while Bob sends
Alice <span class="math notranslate nohighlight">\(g^{b} \pmod p\)</span></p></li>
<li><p>They both raise the received value to their secretly chosen
number (<code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>) and now have both as their shared key
<span class="math notranslate nohighlight">\(g^{ab} \pmod p\)</span></p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>digit</strong></p>
<blockquote>
<div><p>Minimum number of binary digits required in key.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tuple</strong> : (p, g, a)</p>
<blockquote>
<div><p>p = prime number.</p>
<p>g = primitive root of p.</p>
<p>a = random number from 2 through p - 1.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For testing purposes, the <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter may be set to control
the output of this routine. See sympy.testing.randtest._randrange.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">dh_private_key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.ntheory</span> <span class="kn">import</span> <span class="n">isprime</span><span class="p">,</span> <span class="n">is_primitive_root</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dh_private_key</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_primitive_root</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dh_private_key</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isprime</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_primitive_root</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.dh_shared_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">dh_shared_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">b</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2803-L2844"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.dh_shared_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an integer that is the shared key.</p>
<p>This is what Bob and Alice can both calculate using the public
keys they received from each other and their private keys.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>key</strong> : (p, g, x)</p>
<blockquote>
<div><p>Tuple <span class="math notranslate nohighlight">\((p, g, x)\)</span> generated by <code class="docutils literal notranslate"><span class="pre">dh_public_key</span></code>.</p>
</div></blockquote>
<p><strong>b</strong></p>
<blockquote>
<div><p>Random number in the range of <span class="math notranslate nohighlight">\(2\)</span> to <span class="math notranslate nohighlight">\(p - 1\)</span>
(Chosen by second key exchange member (Bob)).</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>int</p>
<blockquote>
<div><p>A shared key.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">dh_private_key</span><span class="p">,</span> <span class="n">dh_public_key</span><span class="p">,</span> <span class="n">dh_shared_key</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prk</span> <span class="o">=</span> <span class="n">dh_private_key</span><span class="p">();</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">dh_public_key</span><span class="p">(</span><span class="n">prk</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sk</span> <span class="o">=</span> <span class="n">dh_shared_key</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sk</span> <span class="o">==</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.gm_public_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">gm_public_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">a</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2964-L2999"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.gm_public_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute public keys for p and q.
Note that in Goldwasser-Micali Encryption,
public keys are randomly selected.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p, q, a</strong> : int, int, int</p>
<blockquote>
<div><p>Initialization variables.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tuple</strong> : (a, N)</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">a</span></code> is the input <code class="docutils literal notranslate"><span class="pre">a</span></code> if it is not <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise
some random integer coprime to <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">N</span></code> is the product of <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.gm_private_key">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">gm_private_key</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">a</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L2892-L2961"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.gm_private_key" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> can be used as private keys for
the Goldwasser-Micali encryption. The method works
roughly as follows.</p>
<p><span class="math notranslate nohighlight">\(\cdot\)</span> Pick two large primes <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\cdot\)</span> Call their product <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p><span class="math notranslate nohighlight">\(\cdot\)</span> Given a message as an integer <span class="math notranslate nohighlight">\(i\)</span>, write <span class="math notranslate nohighlight">\(i\)</span> in its
bit representation <span class="math notranslate nohighlight">\(b_0\)</span> , <span class="math notranslate nohighlight">\(\dotsc\)</span> , <span class="math notranslate nohighlight">\(b_n\)</span> .</p>
<p><span class="math notranslate nohighlight">\(\cdot\)</span> For each <span class="math notranslate nohighlight">\(k\)</span> ,</p>
<blockquote>
<div><dl class="simple">
<dt>if <span class="math notranslate nohighlight">\(b_k\)</span> = 0:</dt><dd><p>let <span class="math notranslate nohighlight">\(a_k\)</span> be a random square
(quadratic residue) modulo <span class="math notranslate nohighlight">\(p q\)</span>
such that <span class="math notranslate nohighlight">\(jacobi \_symbol(a, p q) = 1\)</span></p>
</dd>
<dt>if <span class="math notranslate nohighlight">\(b_k\)</span> = 1:</dt><dd><p>let <span class="math notranslate nohighlight">\(a_k\)</span> be a random non-square
(non-quadratic residue) modulo <span class="math notranslate nohighlight">\(p q\)</span>
such that <span class="math notranslate nohighlight">\(jacobi \_ symbol(a, p q) = 1\)</span></p>
</dd>
</dl>
</div></blockquote>
<p>returns [<span class="math notranslate nohighlight">\(a_1\)</span> , <span class="math notranslate nohighlight">\(a_2\)</span> , <span class="math notranslate nohighlight">\(\dotsc\)</span> ]</p>
<p><span class="math notranslate nohighlight">\(b_k\)</span> can be recovered by checking whether or not
<span class="math notranslate nohighlight">\(a_k\)</span> is a residue. And from the <span class="math notranslate nohighlight">\(b_k\)</span> ‘s, the message
can be reconstructed.</p>
<p>The idea is that, while <span class="math notranslate nohighlight">\(jacobi \_ symbol(a, p q)\)</span>
can be easily computed (and when it is equal to <span class="math notranslate nohighlight">\(-1\)</span> will
tell you that <span class="math notranslate nohighlight">\(a\)</span> is not a square mod <span class="math notranslate nohighlight">\(p q\)</span> ), quadratic
residuosity modulo a composite number is hard to compute
without knowing its factorization.</p>
<p>Moreover, approximately half the numbers coprime to <span class="math notranslate nohighlight">\(p q\)</span> have
<span class="math notranslate nohighlight">\(jacobi \_ symbol\)</span> equal to <span class="math notranslate nohighlight">\(1\)</span> . And among those, approximately half
are residues and approximately half are not. This maximizes the
entropy of the code.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>p, q, a</strong></p>
<blockquote>
<div><p>Initialization variables.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tuple</strong> : (p, q)</p>
<blockquote>
<div><p>The input value <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>.</p>
</div></blockquote>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong></p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code> are not distinct odd primes.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_gm">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_gm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">seed</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L3002-L3036"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_gm" title="Permalink to this definition">¶</a></dt>
<dd><p>Encrypt integer ‘i’ using public_key ‘key’
Note that gm uses random encryption.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>i</strong> : int</p>
<blockquote>
<div><p>The message to encrypt.</p>
</div></blockquote>
<p><strong>key</strong> : (a, N)</p>
<blockquote>
<div><p>The public key.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>list</strong> : list of int</p>
<blockquote>
<div><p>The randomized encrypted message.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_gm">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_gm</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">message</span></em>, <em class="sig-param"><span class="n">key</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L3040-L3067"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_gm" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrypt message ‘message’ using public_key ‘key’.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>message</strong> : list of int</p>
<blockquote>
<div><p>The randomized encrypted message.</p>
</div></blockquote>
<p><strong>key</strong> : (p, q)</p>
<blockquote>
<div><p>The private key.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>int</p>
<blockquote>
<div><p>The encrypted message.</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.encipher_railfence">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">encipher_railfence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">message</span></em>, <em class="sig-param"><span class="n">rails</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L3073-L3103"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.encipher_railfence" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs Railfence Encryption on plaintext and returns ciphertext</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>message</strong> : string, the message to encrypt.</p>
<p><strong>rails</strong> : int, the number of rails.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Encrypted string message.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">encipher_railfence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">message</span> <span class="o">=</span> <span class="s2">&quot;hello world&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">encipher_railfence</span><span class="p">(</span><span class="n">message</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;horel ollwd&#39;</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r142"><span class="brackets"><a class="fn-backref" href="#id30">R142</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Rail_fence_cipher">https://en.wikipedia.org/wiki/Rail_fence_cipher</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="sympy.crypto.crypto.decipher_railfence">
<code class="sig-prename descclassname">sympy.crypto.crypto.</code><code class="sig-name descname">decipher_railfence</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ciphertext</span></em>, <em class="sig-param"><span class="n">rails</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/fc2006887d1f78540cbbf07bac32c12d20225c0a/sympy/crypto/crypto.py#L3106-L3136"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#sympy.crypto.crypto.decipher_railfence" title="Permalink to this definition">¶</a></dt>
<dd><p>Decrypt the message using the given rails</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>message</strong> : string, the message to encrypt.</p>
<p><strong>rails</strong> : int, the number of rails.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Decrypted string message.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.crypto.crypto</span> <span class="kn">import</span> <span class="n">decipher_railfence</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decipher_railfence</span><span class="p">(</span><span class="s2">&quot;horel ollwd&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;hello world&#39;</span>
</pre></div>
</div>
</dd></dl>

</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/sympylogo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="core.html"
                        title="previous chapter">Core</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="diffgeom.html"
                        title="next chapter">Differential Geometry</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/modules/crypto.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="diffgeom.html" title="Differential Geometry"
             >next</a> |</li>
        <li class="right" >
          <a href="core.html" title="Core"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">SymPy 1.7.dev documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >SymPy Modules Reference</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Cryptography</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020 SymPy Development Team.
      Last updated on Oct 01, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>